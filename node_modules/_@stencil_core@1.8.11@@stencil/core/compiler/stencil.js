var stencil = (function (exports) {
	'use strict';

	if (typeof globalThis === 'undefined') {
	  if (typeof self !== 'undefined') {
	    self.globalThis = self;
	  } else if (typeof window !== 'undefined') {
	    window.globalThis = window;
	  } else if (typeof global !== 'undefined') {
	    global.globalThis = global;
	  }
	}

	(gbl => {
	  if (!gbl.Buffer) {
	    gbl.Buffer = {};
	  }
	  gbl.Buffer.__browser = true;

	  const process = gbl.process = (gbl.process || {});
	  process.__browser = true;

	  if (!process.argv) {
	    process.argv = ['browser'];
	  }
	  if (!process.binding) {
	    process.binding = () => ({ __browser: true });
	  }
	  if (!process.cwd) {
	    process.cwd = () => '/';
	  }
	  if (!process.env) {
	    process.env = () => ({ __browser: true });
	  }
	  if (!process.nextTick) {
	    process.nextTick = (cb) => Promise.resolve().then(cb);
	  }
	  if (!process.platform) {
	    process.platform = () => 'browser';
	  }
	  if (!process.version) {
	    process.version = () => '0.0.0';
	  }

	  if (!gbl.__dirname) {
	    gbl.__dirname = '/';
	  }

	  if (!gbl.__filename) {
	    gbl.__filename = location.pathname;
	    if (gbl.__filename === '/') {
	      gbl.__filename = gbl.__dirname + 'index.js';
	    }
	  }

	})(globalThis);


	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var pathBrowserify = createCommonjsModule(function (module, exports) {
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	});
	var pathBrowserify_1 = pathBrowserify.resolve;
	var pathBrowserify_2 = pathBrowserify.normalize;
	var pathBrowserify_3 = pathBrowserify.isAbsolute;
	var pathBrowserify_4 = pathBrowserify.join;
	var pathBrowserify_5 = pathBrowserify.relative;
	var pathBrowserify_6 = pathBrowserify.sep;
	var pathBrowserify_7 = pathBrowserify.delimiter;
	var pathBrowserify_8 = pathBrowserify.dirname;
	var pathBrowserify_9 = pathBrowserify.basename;
	var pathBrowserify_10 = pathBrowserify.extname;

	/**
	 * Default style mode id
	 */
	const DEFAULT_STYLE_MODE = '$';

	const normalizePath = (str) => {
	    // Convert Windows backslash paths to slash paths: foo\\bar âž” foo/bar
	    // https://github.com/sindresorhus/slash MIT
	    // By Sindre Sorhus
	    if (typeof str !== 'string') {
	        throw new Error(`invalid path to normalize`);
	    }
	    str = str.trim();
	    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(str)) {
	        return str;
	    }
	    str = str.replace(SLASH_REGEX, '/');
	    // always remove the trailing /
	    // this makes our file cache look ups consistent
	    if (str.charAt(str.length - 1) === '/') {
	        const colonIndex = str.indexOf(':');
	        if (colonIndex > -1) {
	            if (colonIndex < str.length - 2) {
	                str = str.substring(0, str.length - 1);
	            }
	        }
	        else if (str.length > 1) {
	            str = str.substring(0, str.length - 1);
	        }
	    }
	    return str;
	};
	const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
	const NON_ASCII_REGEX = /[^\x00-\x80]+/;
	const SLASH_REGEX = /\\/g;

	const toLowerCase = (str) => str.toLowerCase();
	const toDashCase = (str) => toLowerCase(str.replace(/([A-Z0-9])/g, g => ' ' + g[0]).trim().replace(/ /g, '-'));
	const dashToPascalCase = (str) => toLowerCase(str).split('-').map(segment => segment.charAt(0).toUpperCase() + segment.slice(1)).join('');
	const noop = () => { };
	const sortBy = (array, prop) => {
	    return array.slice().sort((a, b) => {
	        const nameA = prop(a);
	        const nameB = prop(b);
	        if (nameA < nameB)
	            return -1;
	        if (nameA > nameB)
	            return 1;
	        return 0;
	    });
	};
	const flatOne = (array) => {
	    if (array.flat) {
	        return array.flat(1);
	    }
	    return array.reduce((result, item) => {
	        result.push(...item);
	        return result;
	    }, []);
	};
	const unique = (array, predicate = (i) => i) => {
	    const set = new Set();
	    return array.filter(item => {
	        const key = predicate(item);
	        if (key == null) {
	            return true;
	        }
	        if (set.has(key)) {
	            return false;
	        }
	        set.add(key);
	        return true;
	    });
	};

	class InMemoryFileSystem {
	    constructor(disk, path) {
	        this.disk = disk;
	        this.path = path;
	        this.items = new Map();
	    }
	    async accessData(filePath) {
	        const item = this.getItem(filePath);
	        if (typeof item.exists === 'boolean') {
	            return {
	                exists: item.exists,
	                isDirectory: item.isDirectory,
	                isFile: item.isFile
	            };
	        }
	        const data = {
	            exists: false,
	            isDirectory: false,
	            isFile: false
	        };
	        try {
	            const s = await this.stat(filePath);
	            item.exists = true;
	            item.isDirectory = s.isDirectory;
	            item.isFile = s.isFile;
	            data.exists = item.exists;
	            data.isDirectory = item.isDirectory;
	            data.isFile = item.isFile;
	        }
	        catch (e) {
	            item.exists = false;
	        }
	        return data;
	    }
	    async access(filePath) {
	        const data = await this.accessData(filePath);
	        return data.exists;
	    }
	    /**
	     * Synchronous!!! Do not use!!!
	     * (Only typescript transpiling is allowed to use)
	     * @param filePath
	     */
	    accessSync(filePath) {
	        const item = this.getItem(filePath);
	        if (typeof item.exists === 'boolean') {
	            return item.exists;
	        }
	        let hasAccess = false;
	        try {
	            const s = this.statSync(filePath);
	            item.exists = true;
	            item.isDirectory = s.isDirectory;
	            item.isFile = s.isFile;
	            hasAccess = true;
	        }
	        catch (e) {
	            item.exists = false;
	        }
	        return hasAccess;
	    }
	    async copyFile(src, dest) {
	        const item = this.getItem(src);
	        item.queueCopyFileToDest = dest;
	    }
	    async emptyDir(dirPath) {
	        const item = this.getItem(dirPath);
	        await this.removeDir(dirPath);
	        item.isFile = false;
	        item.isDirectory = true;
	        item.queueWriteToDisk = true;
	        item.queueDeleteFromDisk = false;
	    }
	    async readdir(dirPath, opts = {}) {
	        dirPath = normalizePath(dirPath);
	        const collectedPaths = [];
	        if (opts.inMemoryOnly === true) {
	            let inMemoryDir = dirPath;
	            if (!inMemoryDir.endsWith('/')) {
	                inMemoryDir += '/';
	            }
	            const inMemoryDirs = dirPath.split('/');
	            this.items.forEach((d, filePath) => {
	                if (!filePath.startsWith(dirPath)) {
	                    return;
	                }
	                const parts = filePath.split('/');
	                if (parts.length === inMemoryDirs.length + 1 || (opts.recursive && parts.length > inMemoryDirs.length)) {
	                    if (d.exists) {
	                        const item = {
	                            absPath: filePath,
	                            relPath: parts[inMemoryDirs.length],
	                            isDirectory: d.isDirectory,
	                            isFile: d.isFile
	                        };
	                        collectedPaths.push(item);
	                    }
	                }
	            });
	        }
	        else {
	            // always a disk read
	            await this.readDirectory(dirPath, dirPath, opts, collectedPaths);
	        }
	        return collectedPaths.sort((a, b) => {
	            if (a.absPath < b.absPath)
	                return -1;
	            if (a.absPath > b.absPath)
	                return 1;
	            return 0;
	        });
	    }
	    async readDirectory(initPath, dirPath, opts, collectedPaths) {
	        // used internally only so we could easily recursively drill down
	        // loop through this directory and sub directories
	        // always a disk read!!
	        const dirItems = await this.disk.readdir(dirPath);
	        // cache some facts about this path
	        const item = this.getItem(dirPath);
	        item.exists = true;
	        item.isFile = false;
	        item.isDirectory = true;
	        await Promise.all(dirItems.map(async (dirItem) => {
	            // let's loop through each of the files we've found so far
	            // create an absolute path of the item inside of this directory
	            const absPath = normalizePath(this.path.join(dirPath, dirItem));
	            const relPath = normalizePath(this.path.relative(initPath, absPath));
	            // get the fs stats for the item, could be either a file or directory
	            const stats = await this.stat(absPath);
	            // cache some stats about this path
	            const subItem = this.getItem(absPath);
	            subItem.exists = true;
	            subItem.isDirectory = stats.isDirectory;
	            subItem.isFile = stats.isFile;
	            collectedPaths.push({
	                absPath: absPath,
	                relPath: relPath,
	                isDirectory: stats.isDirectory,
	                isFile: stats.isFile
	            });
	            if (opts.recursive === true && stats.isDirectory === true) {
	                // looks like it's yet another directory
	                // let's keep drilling down
	                await this.readDirectory(initPath, absPath, opts, collectedPaths);
	            }
	        }));
	    }
	    async readFile(filePath, opts) {
	        if (opts == null || (opts.useCache === true || opts.useCache === undefined)) {
	            const item = this.getItem(filePath);
	            if (item.exists && typeof item.fileText === 'string') {
	                return item.fileText;
	            }
	        }
	        const fileContent = await this.disk.readFile(filePath);
	        const item = this.getItem(filePath);
	        if (fileContent.length < MAX_TEXT_CACHE) {
	            item.exists = true;
	            item.isFile = true;
	            item.isDirectory = false;
	            item.fileText = fileContent;
	        }
	        return fileContent;
	    }
	    /**
	     * Synchronous!!! Do not use!!!
	     * (Only typescript transpiling is allowed to use)
	     * @param filePath
	     */
	    readFileSync(filePath, opts) {
	        if (opts == null || (opts.useCache === true || opts.useCache === undefined)) {
	            const item = this.getItem(filePath);
	            if (item.exists && typeof item.fileText === 'string') {
	                return item.fileText;
	            }
	        }
	        const fileContent = this.disk.readFileSync(filePath);
	        const item = this.getItem(filePath);
	        if (fileContent.length < MAX_TEXT_CACHE) {
	            item.exists = true;
	            item.isFile = true;
	            item.isDirectory = false;
	            item.fileText = fileContent;
	        }
	        return fileContent;
	    }
	    async remove(itemPath) {
	        const stats = await this.stat(itemPath);
	        if (stats.isDirectory === true) {
	            await this.removeDir(itemPath);
	        }
	        else if (stats.isFile === true) {
	            await this.removeItem(itemPath);
	        }
	    }
	    async removeDir(dirPath) {
	        const item = this.getItem(dirPath);
	        item.isFile = false;
	        item.isDirectory = true;
	        if (!item.queueWriteToDisk) {
	            item.queueDeleteFromDisk = true;
	        }
	        try {
	            const dirItems = await this.readdir(dirPath, { recursive: true });
	            await Promise.all(dirItems.map(item => this.removeItem(item.absPath)));
	        }
	        catch (e) {
	            // do not throw error if the directory never existed
	        }
	    }
	    async removeItem(filePath) {
	        const item = this.getItem(filePath);
	        if (!item.queueWriteToDisk) {
	            item.queueDeleteFromDisk = true;
	        }
	    }
	    async stat(itemPath) {
	        const item = this.getItem(itemPath);
	        if (typeof item.isDirectory !== 'boolean' || typeof item.isFile !== 'boolean') {
	            const s = await this.disk.stat(itemPath);
	            item.exists = true;
	            item.isDirectory = s.isDirectory();
	            item.isFile = s.isFile();
	            item.size = s.size;
	        }
	        return {
	            exists: !!item.exists,
	            isFile: !!item.isFile,
	            isDirectory: !!item.isDirectory,
	            size: typeof item.size === 'number' ? item.size : 0
	        };
	    }
	    /**
	     * Synchronous!!! Do not use!!!
	     * (Only typescript transpiling is allowed to use)
	     * @param itemPath
	     */
	    statSync(itemPath) {
	        const item = this.getItem(itemPath);
	        if (typeof item.isDirectory !== 'boolean' || typeof item.isFile !== 'boolean') {
	            const s = this.disk.statSync(itemPath);
	            item.exists = true;
	            item.isDirectory = s.isDirectory();
	            item.isFile = s.isFile();
	        }
	        return {
	            isFile: item.isFile,
	            isDirectory: item.isDirectory
	        };
	    }
	    async writeFile(filePath, content, opts) {
	        if (typeof filePath !== 'string') {
	            throw new Error(`writeFile, invalid filePath: ${filePath}`);
	        }
	        if (typeof content !== 'string') {
	            throw new Error(`writeFile, invalid content: ${filePath}`);
	        }
	        const results = {
	            ignored: false,
	            changedContent: false,
	            queuedWrite: false
	        };
	        if (shouldIgnore(filePath) === true) {
	            results.ignored = true;
	            return results;
	        }
	        const item = this.getItem(filePath);
	        item.exists = true;
	        item.isFile = true;
	        item.isDirectory = false;
	        item.queueDeleteFromDisk = false;
	        results.changedContent = (item.fileText !== content);
	        results.queuedWrite = false;
	        item.fileText = content;
	        if (opts != null && opts.useCache === false) {
	            item.useCache = false;
	        }
	        if (opts != null && opts.inMemoryOnly === true) {
	            // we don't want to actually write this to disk
	            // just keep it in memory
	            if (item.queueWriteToDisk) {
	                // we already queued this file to write to disk
	                // in that case we still need to do it
	                results.queuedWrite = true;
	            }
	            else {
	                // we only want this in memory and
	                // it wasn't already queued to be written
	                item.queueWriteToDisk = false;
	            }
	        }
	        else if (opts != null && opts.immediateWrite === true) {
	            // If this is an immediate write then write the file
	            // and do not add it to the queue
	            await this.ensureDir(filePath);
	            await this.disk.writeFile(filePath, item.fileText);
	        }
	        else {
	            // we want to write this to disk (eventually)
	            // but only if the content is different
	            // from our existing cached content
	            if (!item.queueWriteToDisk && results.changedContent === true) {
	                // not already queued to be written
	                // and the content is different
	                item.queueWriteToDisk = true;
	                results.queuedWrite = true;
	            }
	        }
	        return results;
	    }
	    writeFiles(files, opts) {
	        return Promise.all(Object.keys(files).map(filePath => {
	            return this.writeFile(filePath, files[filePath], opts);
	        }));
	    }
	    async commit() {
	        const instructions = getCommitInstructions(this.path, this.items);
	        // ensure directories we need exist
	        const dirsAdded = await this.commitEnsureDirs(instructions.dirsToEnsure);
	        // write all queued the files
	        const filesWritten = await this.commitWriteFiles(instructions.filesToWrite);
	        // write all queued the files to copy
	        const filesCopied = await this.commitCopyFiles(instructions.filesToCopy);
	        // remove all the queued files to be deleted
	        const filesDeleted = await this.commitDeleteFiles(instructions.filesToDelete);
	        // remove all the queued dirs to be deleted
	        const dirsDeleted = await this.commitDeleteDirs(instructions.dirsToDelete);
	        instructions.filesToDelete.forEach(fileToDelete => {
	            this.clearFileCache(fileToDelete);
	        });
	        instructions.dirsToDelete.forEach(dirToDelete => {
	            this.clearDirCache(dirToDelete);
	        });
	        // return only the files that were
	        return {
	            filesCopied,
	            filesWritten,
	            filesDeleted,
	            dirsDeleted,
	            dirsAdded
	        };
	    }
	    async ensureDir(p) {
	        const allDirs = [];
	        while (true) {
	            p = this.path.dirname(p);
	            if (typeof p === 'string' && p.length > 0 && p !== '/' && p.endsWith(':/') === false && p.endsWith(':\\') === false) {
	                allDirs.push(p);
	            }
	            else {
	                break;
	            }
	        }
	        allDirs.reverse();
	        await this.commitEnsureDirs(allDirs);
	    }
	    async commitEnsureDirs(dirsToEnsure) {
	        const dirsAdded = [];
	        for (const dirPath of dirsToEnsure) {
	            const item = this.getItem(dirPath);
	            if (item.exists === true && item.isDirectory === true) {
	                // already cached that this path is indeed an existing directory
	                continue;
	            }
	            try {
	                // cache that we know this is a directory on disk
	                item.exists = true;
	                item.isDirectory = true;
	                item.isFile = false;
	                await this.disk.mkdir(dirPath);
	                dirsAdded.push(dirPath);
	            }
	            catch (e) { }
	        }
	        return dirsAdded;
	    }
	    commitCopyFiles(filesToCopy) {
	        const copiedFiles = Promise.all(filesToCopy.map(async (data) => {
	            const src = data[0];
	            const dest = data[1];
	            await this.disk.copyFile(src, dest);
	            return [src, dest];
	        }));
	        return copiedFiles;
	    }
	    commitWriteFiles(filesToWrite) {
	        const writtenFiles = Promise.all(filesToWrite.map(async (filePath) => {
	            if (typeof filePath !== 'string') {
	                throw new Error(`unable to writeFile without filePath`);
	            }
	            return this.commitWriteFile(filePath);
	        }));
	        return writtenFiles;
	    }
	    async commitWriteFile(filePath) {
	        const item = this.getItem(filePath);
	        if (item.fileText == null) {
	            throw new Error(`unable to find item fileText to write: ${filePath}`);
	        }
	        await this.disk.writeFile(filePath, item.fileText);
	        if (item.useCache === false) {
	            this.clearFileCache(filePath);
	        }
	        return filePath;
	    }
	    async commitDeleteFiles(filesToDelete) {
	        const deletedFiles = await Promise.all(filesToDelete.map(async (filePath) => {
	            if (typeof filePath !== 'string') {
	                throw new Error(`unable to unlink without filePath`);
	            }
	            await this.disk.unlink(filePath);
	            return filePath;
	        }));
	        return deletedFiles;
	    }
	    async commitDeleteDirs(dirsToDelete) {
	        const dirsDeleted = [];
	        for (const dirPath of dirsToDelete) {
	            try {
	                await this.disk.rmdir(dirPath);
	            }
	            catch (e) { }
	            dirsDeleted.push(dirPath);
	        }
	        return dirsDeleted;
	    }
	    clearDirCache(dirPath) {
	        dirPath = normalizePath(dirPath);
	        this.items.forEach((_, f) => {
	            const filePath = this.path.relative(dirPath, f).split('/')[0];
	            if (!filePath.startsWith('.') && !filePath.startsWith('/')) {
	                this.clearFileCache(f);
	            }
	        });
	    }
	    clearFileCache(filePath) {
	        filePath = normalizePath(filePath);
	        const item = this.items.get(filePath);
	        if (item != null && !item.queueWriteToDisk) {
	            this.items.delete(filePath);
	        }
	    }
	    cancelDeleteFilesFromDisk(filePaths) {
	        filePaths.forEach(filePath => {
	            const item = this.getItem(filePath);
	            if (item.isFile === true && item.queueDeleteFromDisk === true) {
	                item.queueDeleteFromDisk = false;
	            }
	        });
	    }
	    cancelDeleteDirectoriesFromDisk(dirPaths) {
	        dirPaths.forEach(dirPath => {
	            const item = this.getItem(dirPath);
	            if (item.queueDeleteFromDisk === true) {
	                item.queueDeleteFromDisk = false;
	            }
	        });
	    }
	    getItem(itemPath) {
	        itemPath = normalizePath(itemPath);
	        let item = this.items.get(itemPath);
	        if (item != null) {
	            return item;
	        }
	        this.items.set(itemPath, item = {
	            exists: null,
	            fileText: null,
	            size: null,
	            mtimeMs: null,
	            isDirectory: null,
	            isFile: null,
	            queueCopyFileToDest: null,
	            queueDeleteFromDisk: null,
	            queueWriteToDisk: null,
	            useCache: null
	        });
	        return item;
	    }
	    clearCache() {
	        this.items.clear();
	    }
	    get keys() {
	        return Array.from(this.items.keys()).sort();
	    }
	    getMemoryStats() {
	        return `data length: ${this.items.size}`;
	    }
	}
	const getCommitInstructions = (path, d) => {
	    const instructions = {
	        filesToDelete: [],
	        filesToWrite: [],
	        filesToCopy: [],
	        dirsToDelete: [],
	        dirsToEnsure: []
	    };
	    d.forEach((item, itemPath) => {
	        if (item.queueWriteToDisk === true) {
	            if (item.isFile === true) {
	                instructions.filesToWrite.push(itemPath);
	                const dir = normalizePath(path.dirname(itemPath));
	                if (!instructions.dirsToEnsure.includes(dir)) {
	                    instructions.dirsToEnsure.push(dir);
	                }
	                const dirDeleteIndex = instructions.dirsToDelete.indexOf(dir);
	                if (dirDeleteIndex > -1) {
	                    instructions.dirsToDelete.splice(dirDeleteIndex, 1);
	                }
	                const fileDeleteIndex = instructions.filesToDelete.indexOf(itemPath);
	                if (fileDeleteIndex > -1) {
	                    instructions.filesToDelete.splice(fileDeleteIndex, 1);
	                }
	            }
	            else if (item.isDirectory === true) {
	                if (!instructions.dirsToEnsure.includes(itemPath)) {
	                    instructions.dirsToEnsure.push(itemPath);
	                }
	                const dirDeleteIndex = instructions.dirsToDelete.indexOf(itemPath);
	                if (dirDeleteIndex > -1) {
	                    instructions.dirsToDelete.splice(dirDeleteIndex, 1);
	                }
	            }
	        }
	        else if (item.queueDeleteFromDisk === true) {
	            if (item.isDirectory && !instructions.dirsToEnsure.includes(itemPath)) {
	                instructions.dirsToDelete.push(itemPath);
	            }
	            else if (item.isFile && !instructions.filesToWrite.includes(itemPath)) {
	                instructions.filesToDelete.push(itemPath);
	            }
	        }
	        else if (typeof item.queueCopyFileToDest === 'string') {
	            const src = itemPath;
	            const dest = item.queueCopyFileToDest;
	            instructions.filesToCopy.push([src, dest]);
	            const dir = normalizePath(path.dirname(dest));
	            if (!instructions.dirsToEnsure.includes(dir)) {
	                instructions.dirsToEnsure.push(dir);
	            }
	            const dirDeleteIndex = instructions.dirsToDelete.indexOf(dir);
	            if (dirDeleteIndex > -1) {
	                instructions.dirsToDelete.splice(dirDeleteIndex, 1);
	            }
	            const fileDeleteIndex = instructions.filesToDelete.indexOf(dest);
	            if (fileDeleteIndex > -1) {
	                instructions.filesToDelete.splice(fileDeleteIndex, 1);
	            }
	        }
	        item.queueDeleteFromDisk = false;
	        item.queueWriteToDisk = false;
	    });
	    // add all the ancestor directories for each directory too
	    for (let i = 0, ilen = instructions.dirsToEnsure.length; i < ilen; i++) {
	        const segments = instructions.dirsToEnsure[i].split('/');
	        for (let j = 2; j < segments.length; j++) {
	            const dir = segments.slice(0, j).join('/');
	            if (instructions.dirsToEnsure.includes(dir) === false) {
	                instructions.dirsToEnsure.push(dir);
	            }
	        }
	    }
	    // sort directories so shortest paths are ensured first
	    instructions.dirsToEnsure.sort((a, b) => {
	        const segmentsA = a.split('/').length;
	        const segmentsB = b.split('/').length;
	        if (segmentsA < segmentsB)
	            return -1;
	        if (segmentsA > segmentsB)
	            return 1;
	        if (a.length < b.length)
	            return -1;
	        if (a.length > b.length)
	            return 1;
	        return 0;
	    });
	    // sort directories so longest paths are removed first
	    instructions.dirsToDelete.sort((a, b) => {
	        const segmentsA = a.split('/').length;
	        const segmentsB = b.split('/').length;
	        if (segmentsA < segmentsB)
	            return 1;
	        if (segmentsA > segmentsB)
	            return -1;
	        if (a.length < b.length)
	            return 1;
	        if (a.length > b.length)
	            return -1;
	        return 0;
	    });
	    instructions.dirsToEnsure.forEach(dirToEnsure => {
	        const i = instructions.dirsToDelete.indexOf(dirToEnsure);
	        if (i > -1) {
	            instructions.dirsToDelete.splice(i, 1);
	        }
	    });
	    instructions.dirsToDelete = instructions.dirsToDelete.filter(dir => {
	        if (dir === '/' || dir.endsWith(':/') === true) {
	            return false;
	        }
	        return true;
	    });
	    instructions.dirsToEnsure = instructions.dirsToEnsure.filter(dir => {
	        const item = d.get(dir);
	        if (item != null && item.exists === true && item.isDirectory === true) {
	            return false;
	        }
	        if (dir === '/' || dir.endsWith(':/')) {
	            return false;
	        }
	        return true;
	    });
	    return instructions;
	};
	const shouldIgnore = (filePath) => {
	    filePath = filePath.trim().toLowerCase();
	    return IGNORE.some(ignoreFile => filePath.endsWith(ignoreFile));
	};
	const IGNORE = [
	    '.ds_store',
	    '.gitignore',
	    'desktop.ini',
	    'thumbs.db'
	];
	// only cache if it's less than 5MB-ish (using .length as a rough guess)
	// why 5MB? idk, seems like a good number for source text
	// it's pretty darn large to cover almost ALL legitimate source files
	// and anything larger is probably a REALLY large file and a rare case
	// which we don't need to eat up memory for
	const MAX_TEXT_CACHE = 5242880;

	const splitLineBreaks = (sourceText) => {
	    if (typeof sourceText !== 'string')
	        return [];
	    sourceText = sourceText.replace(/\\r/g, '\n');
	    return sourceText.split('\n');
	};

	const buildError = (diagnostics) => {
	    const diagnostic = {
	        level: 'error',
	        type: 'build',
	        header: 'Build Error',
	        messageText: 'build error',
	        relFilePath: null,
	        absFilePath: null,
	        lines: []
	    };
	    diagnostics.push(diagnostic);
	    return diagnostic;
	};
	const buildWarn = (diagnostics) => {
	    const diagnostic = {
	        level: 'warn',
	        type: 'build',
	        header: 'Build Warn',
	        messageText: 'build warn',
	        relFilePath: null,
	        absFilePath: null,
	        lines: []
	    };
	    diagnostics.push(diagnostic);
	    return diagnostic;
	};
	const catchError = (diagnostics, err, msg) => {
	    const diagnostic = {
	        level: 'error',
	        type: 'build',
	        header: 'Build Error',
	        messageText: 'build error',
	        relFilePath: null,
	        absFilePath: null,
	        lines: []
	    };
	    if (typeof msg === 'string') {
	        diagnostic.messageText = msg;
	    }
	    else if (err != null) {
	        if (err.stack != null) {
	            diagnostic.messageText = err.stack.toString();
	        }
	        else {
	            if (err.message != null) {
	                diagnostic.messageText = err.message.toString();
	            }
	            else {
	                diagnostic.messageText = err.toString();
	            }
	        }
	    }
	    if (diagnostics != null && !shouldIgnoreError(diagnostic.messageText)) {
	        diagnostics.push(diagnostic);
	    }
	    return diagnostic;
	};
	const hasError = (diagnostics) => {
	    if (diagnostics == null || diagnostics.length === 0) {
	        return false;
	    }
	    return diagnostics.some(d => d.level === 'error' && d.type !== 'runtime');
	};
	const hasWarning = (diagnostics) => {
	    if (diagnostics == null || diagnostics.length === 0) {
	        return false;
	    }
	    return diagnostics.some(d => d.level === 'warn');
	};
	const shouldIgnoreError = (msg) => {
	    return (msg === TASK_CANCELED_MSG);
	};
	const TASK_CANCELED_MSG = `task canceled`;

	const augmentDiagnosticWithNode = (config, d, node) => {
	    if (!node) {
	        return d;
	    }
	    const sourceFile = node.getSourceFile();
	    if (!sourceFile) {
	        return d;
	    }
	    d.absFilePath = normalizePath(sourceFile.fileName);
	    d.relFilePath = normalizePath(config.sys.path.relative(config.rootDir, sourceFile.fileName));
	    const sourceText = sourceFile.text;
	    const srcLines = splitLineBreaks(sourceText);
	    const start = node.getStart();
	    const end = node.getEnd();
	    const posStart = sourceFile.getLineAndCharacterOfPosition(start);
	    const errorLine = {
	        lineIndex: posStart.line,
	        lineNumber: posStart.line + 1,
	        text: srcLines[posStart.line],
	        errorCharStart: posStart.character,
	        errorLength: Math.max(end - start, 1)
	    };
	    d.lineNumber = errorLine.lineNumber;
	    d.columnNumber = errorLine.errorCharStart + 1;
	    d.lines.push(errorLine);
	    if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
	        errorLine.errorLength = 1;
	        errorLine.errorCharStart--;
	    }
	    if (errorLine.lineIndex > 0) {
	        const previousLine = {
	            lineIndex: errorLine.lineIndex - 1,
	            lineNumber: errorLine.lineNumber - 1,
	            text: srcLines[errorLine.lineIndex - 1],
	            errorCharStart: -1,
	            errorLength: -1
	        };
	        d.lines.unshift(previousLine);
	    }
	    if (errorLine.lineIndex + 1 < srcLines.length) {
	        const nextLine = {
	            lineIndex: errorLine.lineIndex + 1,
	            lineNumber: errorLine.lineNumber + 1,
	            text: srcLines[errorLine.lineIndex + 1],
	            errorCharStart: -1,
	            errorLength: -1
	        };
	        d.lines.push(nextLine);
	    }
	    return d;
	};
	/**
	 * Ok, so formatting overkill, we know. But whatever, it makes for great
	 * error reporting within a terminal. So, yeah, let's code it up, shall we?
	 */
	const loadTypeScriptDiagnostics = (tsDiagnostics) => {
	    const diagnostics = [];
	    const maxErrors = Math.min(tsDiagnostics.length, 50);
	    for (let i = 0; i < maxErrors; i++) {
	        diagnostics.push(loadTypeScriptDiagnostic(tsDiagnostics[i]));
	    }
	    return diagnostics;
	};
	const loadTypeScriptDiagnostic = (tsDiagnostic) => {
	    const d = {
	        level: 'warn',
	        type: 'typescript',
	        language: 'typescript',
	        header: 'TypeScript',
	        code: tsDiagnostic.code.toString(),
	        messageText: flattenDiagnosticMessageText(tsDiagnostic, tsDiagnostic.messageText),
	        relFilePath: null,
	        absFilePath: null,
	        lines: []
	    };
	    if (tsDiagnostic.category === 1) {
	        d.level = 'error';
	    }
	    if (tsDiagnostic.file) {
	        d.absFilePath = tsDiagnostic.file.fileName;
	        const sourceText = tsDiagnostic.file.text;
	        const srcLines = splitLineBreaks(sourceText);
	        const posData = tsDiagnostic.file.getLineAndCharacterOfPosition(tsDiagnostic.start);
	        const errorLine = {
	            lineIndex: posData.line,
	            lineNumber: posData.line + 1,
	            text: srcLines[posData.line],
	            errorCharStart: posData.character,
	            errorLength: Math.max(tsDiagnostic.length, 1)
	        };
	        d.lineNumber = errorLine.lineNumber;
	        d.columnNumber = errorLine.errorCharStart + 1;
	        d.lines.push(errorLine);
	        if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
	            errorLine.errorLength = 1;
	            errorLine.errorCharStart--;
	        }
	        if (errorLine.lineIndex > 0) {
	            const previousLine = {
	                lineIndex: errorLine.lineIndex - 1,
	                lineNumber: errorLine.lineNumber - 1,
	                text: srcLines[errorLine.lineIndex - 1],
	                errorCharStart: -1,
	                errorLength: -1
	            };
	            d.lines.unshift(previousLine);
	        }
	        if (errorLine.lineIndex + 1 < srcLines.length) {
	            const nextLine = {
	                lineIndex: errorLine.lineIndex + 1,
	                lineNumber: errorLine.lineNumber + 1,
	                text: srcLines[errorLine.lineIndex + 1],
	                errorCharStart: -1,
	                errorLength: -1
	            };
	            d.lines.push(nextLine);
	        }
	    }
	    return d;
	};
	const flattenDiagnosticMessageText = (tsDiagnostic, diag) => {
	    if (typeof diag === 'string') {
	        return diag;
	    }
	    else if (diag === undefined) {
	        return '';
	    }
	    const ignoreCodes = [];
	    const isStencilConfig = tsDiagnostic.file.fileName.includes('stencil.config');
	    if (isStencilConfig) {
	        ignoreCodes.push(2322);
	    }
	    let result = '';
	    if (!ignoreCodes.includes(diag.code)) {
	        result = diag.messageText;
	        if (diag.next) {
	            for (const kid of diag.next) {
	                result += flattenDiagnosticMessageText(tsDiagnostic, kid);
	            }
	        }
	    }
	    if (isStencilConfig) {
	        result = result.replace(`type 'StencilConfig'`, `Stencil Config`);
	        result = result.replace(`Object literal may only specify known properties, but `, ``);
	        result = result.replace(`Object literal may only specify known properties, and `, ``);
	    }
	    return result.trim();
	};

	const getFileExt = (fileName) => {
	    if (typeof fileName === 'string') {
	        const parts = fileName.split('.');
	        if (parts.length > 1) {
	            return parts[parts.length - 1].toLowerCase();
	        }
	    }
	    return null;
	};

	const validateComponentTag = (tag) => {
	    if (tag !== tag.trim()) {
	        return `Tag can not contain white spaces`;
	    }
	    if (tag !== tag.toLowerCase()) {
	        return `Tag can not contain upper case characters`;
	    }
	    if (typeof tag !== 'string') {
	        return `Tag "${tag}" must be a string type`;
	    }
	    if (tag.length === 0) {
	        return `Received empty tag value`;
	    }
	    if (tag.indexOf(' ') > -1) {
	        return `"${tag}" tag cannot contain a space`;
	    }
	    if (tag.indexOf(',') > -1) {
	        return `"${tag}" tag cannot be used for multiple tags`;
	    }
	    const invalidChars = tag.replace(/\w|-/g, '');
	    if (invalidChars !== '') {
	        return `"${tag}" tag contains invalid characters: ${invalidChars}`;
	    }
	    if (tag.indexOf('-') === -1) {
	        return `"${tag}" tag must contain a dash (-) to work as a valid web component`;
	    }
	    if (tag.indexOf('--') > -1) {
	        return `"${tag}" tag cannot contain multiple dashes (--) next to each other`;
	    }
	    if (tag.indexOf('-') === 0) {
	        return `"${tag}" tag cannot start with a dash (-)`;
	    }
	    if (tag.lastIndexOf('-') === tag.length - 1) {
	        return `"${tag}" tag cannot end with a dash (-)`;
	    }
	    return undefined;
	};

	const getTerserOptions = (sourceTarget, isDebug) => {
	    const opts = {
	        safari10: true,
	        output: {},
	    };
	    if (sourceTarget === 'es5') {
	        opts.ecma = opts.output.ecma = 5;
	        opts.compress = false;
	        opts.mangle = true;
	    }
	    else {
	        opts.mangle = {
	            properties: {
	                regex: '^\\$.+\\$$'
	            }
	        };
	        opts.compress = {
	            pure_getters: true,
	            keep_fargs: false,
	            passes: 2,
	        };
	        opts.ecma = opts.output.ecma = opts.compress.ecma = 7;
	        opts.toplevel = true;
	        opts.module = true;
	        opts.compress.toplevel = true;
	        opts.mangle.toplevel = true;
	        opts.compress.arrows = true;
	        opts.compress.module = true;
	    }
	    if (isDebug) {
	        opts.mangle = { keep_fnames: true };
	        opts.compress = {};
	        opts.compress.drop_console = false;
	        opts.compress.drop_debugger = false;
	        opts.compress.pure_funcs = [];
	        opts.output.beautify = true;
	        opts.output.indent_level = 2;
	        opts.output.comments = 'all';
	    }
	    return opts;
	};

	const ts = {};
	const initTypescript = () => {
	    if (!ts.transform) {
	        if (globalThis.ts) {
	            // doing this so we can lazy load "ts"
	            Object.assign(ts, globalThis.ts);
	        }
	        else {
	            throw new Error(`typescript: missing global "ts" variable`);
	        }
	    }
	    if (!ts.sys) {
	        ts.sys = {
	            args: [],
	            newLine: '\n',
	            useCaseSensitiveFileNames: false,
	            write(s) {
	                console.log(s);
	            },
	            readFile(_p, _encoding) {
	                throw new Error('ts.sys.readFile not implemented');
	            },
	            writeFile(_p, _data, _writeByteOrderMark) {
	                throw new Error('ts.sys.writeFile not implemented');
	            },
	            resolvePath(p) {
	                return pathBrowserify.resolve(p);
	            },
	            fileExists(_p) {
	                throw new Error('ts.sys.fileExists not implemented');
	            },
	            directoryExists(_p) {
	                throw new Error('ts.sys.directoryExists not implemented');
	            },
	            createDirectory(_p) {
	                throw new Error('ts.sys.createDirectory not implemented');
	            },
	            getExecutingFilePath() {
	                return location.href;
	            },
	            getCurrentDirectory() {
	                return '/';
	            },
	            getDirectories(_path) {
	                return [];
	            },
	            readDirectory(_path, _extensions, _exclude, _include, _depth) {
	                return [];
	            },
	            exit(exitCode) {
	                console.log('typescript exit:', exitCode);
	            }
	        };
	    }
	};

	const getCompileOptions = (input, filePath) => {
	    const rtn = {
	        componentExport: getConfig(input.componentExport, VALID_EXPORT, 'customelement'),
	        componentMetadata: getConfig(input.componentMetadata, VALID_METADATA, null),
	        proxy: getConfig(input.proxy, VALID_PROXY, 'defineproperty'),
	        module: getConfig(input.module, VALID_MODULE, 'esm'),
	        script: getConfig(input.script, VALID_SCRIPT, 'es2017'),
	        style: getConfig(input.style, VALID_STYLE, 'static'),
	        data: input.data ? Object.assign({}, input.data) : null,
	        type: input.type
	    };
	    if (rtn.type == null) {
	        const fileName = pathBrowserify.basename(filePath).trim().toLowerCase();
	        if (fileName.endsWith('.d.ts')) {
	            rtn.type = 'dts';
	        }
	        else if (fileName.endsWith('.tsx')) {
	            rtn.type = 'tsx';
	        }
	        else if (fileName.endsWith('.ts')) {
	            rtn.type = 'ts';
	        }
	        else if (fileName.endsWith('.jsx')) {
	            rtn.type = 'jsx';
	        }
	        else if (fileName.endsWith('.js') || fileName.endsWith('.mjs')) {
	            rtn.type = 'js';
	        }
	        else if (fileName.endsWith('.css') && rtn.data != null) {
	            rtn.type = 'css';
	        }
	    }
	    return rtn;
	};
	const getConfig = (value, validValues, defaultValue) => {
	    if (value === 'null') {
	        return null;
	    }
	    value = (typeof value === 'string' ? value.toLowerCase().trim() : null);
	    if (validValues.has(value)) {
	        return value;
	    }
	    return defaultValue;
	};
	const VALID_PROXY = new Set(['defineproperty', null]);
	const VALID_METADATA = new Set(['compilerstatic', null]);
	const VALID_EXPORT = new Set(['customelement', 'module']);
	const VALID_MODULE = new Set(['esm', 'cjs']);
	const VALID_SCRIPT = new Set(['latest', 'esnext', 'es2017', 'es2015', 'es5']);
	const VALID_STYLE = new Set(['static']);
	const getTransformOptions = (compilerOpts) => {
	    const transformOpts = {
	        // best we always set this to true
	        allowSyntheticDefaultImports: true,
	        // best we always set this to true
	        esModuleInterop: true,
	        // always get source maps
	        sourceMap: true,
	        // isolated per file transpiling
	        isolatedModules: true,
	        // transpileModule does not write anything to disk so there is no need to verify that there are no conflicts between input and output paths.
	        suppressOutputPathCheck: true,
	        // Filename can be non-ts file.
	        allowNonTsExtensions: true,
	        // We are not returning a sourceFile for lib file when asked by the program,
	        // so pass --noLib to avoid reporting a file not found error.
	        noLib: true,
	        noResolve: true,
	        coreImportPath: '@stencil/core/internal/client',
	        componentExport: null,
	        componentMetadata: compilerOpts.componentMetadata,
	        proxy: compilerOpts.proxy,
	        style: compilerOpts.style
	    };
	    if (compilerOpts.module === 'cjs' || compilerOpts.module === 'commonjs') {
	        compilerOpts.module = 'cjs';
	        transformOpts.module = ts.ModuleKind.CommonJS;
	    }
	    else {
	        compilerOpts.module = 'esm';
	        transformOpts.module = ts.ModuleKind.ESNext;
	    }
	    if (compilerOpts.script === 'esnext') {
	        transformOpts.target = ts.ScriptTarget.ESNext;
	    }
	    else if (compilerOpts.script === 'latest') {
	        transformOpts.target = ts.ScriptTarget.Latest;
	    }
	    else if (compilerOpts.script === 'es2015') {
	        transformOpts.target = ts.ScriptTarget.ES2015;
	    }
	    else if (compilerOpts.script === 'es5') {
	        transformOpts.target = ts.ScriptTarget.ES5;
	    }
	    else {
	        transformOpts.target = ts.ScriptTarget.ES2017;
	        compilerOpts.script = 'es2017';
	    }
	    if (compilerOpts.componentExport === 'lazy') {
	        transformOpts.componentExport = 'lazy';
	    }
	    else if (compilerOpts.componentExport === 'module') {
	        transformOpts.componentExport = 'native';
	    }
	    else {
	        transformOpts.componentExport = 'customelement';
	    }
	    return transformOpts;
	};
	const getCompilerConfig = () => {
	    const config = {
	        cwd: '/',
	        rootDir: '/',
	        srcDir: '/',
	        devMode: true,
	        _isTesting: true,
	        validateTypes: false,
	        enableCache: false,
	        sys: {
	            path: pathBrowserify
	        }
	    };
	    return config;
	};
	const getMinifyScriptOptions = (opts = {}) => {
	    const sourceTarget = (opts.script === 'es5') ? 'es5' : 'es2017';
	    const isPretty = !!opts.pretty;
	    return {
	        options: getTerserOptions(sourceTarget, isPretty),
	        minifier: {
	            name: 'terser',
	            version: '4.6.3',
	            url: 'https://cdn.jsdelivr.net/npm/terser@4.6.3/dist/bundle.js'
	        }
	    };
	};

	const getDeclarationParameters = (decorator) => {
	    if (!ts.isCallExpression(decorator.expression)) {
	        return [];
	    }
	    return decorator.expression.arguments.map(getDeclarationParameter);
	};
	const getDeclarationParameter = (arg) => {
	    if (ts.isObjectLiteralExpression(arg)) {
	        return objectLiteralToObjectMap(arg);
	    }
	    else if (ts.isStringLiteral(arg)) {
	        return arg.text;
	    }
	    throw new Error(`invalid decorator argument: ${arg.getText()}`);
	};
	const isDecoratorNamed = (propName) => {
	    return (dec) => {
	        return (ts.isCallExpression(dec.expression) && dec.expression.expression.getText() === propName);
	    };
	};
	const CLASS_DECORATORS_TO_REMOVE = new Set([
	    'Component'
	]);
	const MEMBER_DECORATORS_TO_REMOVE = new Set([
	    'Element',
	    'Event',
	    'Listen',
	    'Method',
	    'Prop',
	    'PropDidChange',
	    'PropWillChange',
	    'State',
	    'Watch'
	]);

	const isMemberPrivate = (member) => {
	    if (member.modifiers && member.modifiers.some(m => m.kind === ts.SyntaxKind.PrivateKeyword || m.kind === ts.SyntaxKind.ProtectedKeyword)) {
	        return true;
	    }
	    return false;
	};
	const convertValueToLiteral = (val, refs = null) => {
	    if (refs == null) {
	        refs = new WeakSet();
	    }
	    if (val === String) {
	        return ts.createIdentifier('String');
	    }
	    if (val === Number) {
	        return ts.createIdentifier('Number');
	    }
	    if (val === Boolean) {
	        return ts.createIdentifier('Boolean');
	    }
	    if (val === undefined) {
	        return ts.createIdentifier('undefined');
	    }
	    if (val === null) {
	        return ts.createIdentifier('null');
	    }
	    if (Array.isArray(val)) {
	        return arrayToArrayLiteral(val, refs);
	    }
	    if (typeof val === 'object') {
	        if (val.__identifier && val.__escapedText) {
	            return ts.createLiteral(val.__escapedText);
	        }
	        return objectToObjectLiteral(val, refs);
	    }
	    return ts.createLiteral(val);
	};
	const arrayToArrayLiteral = (list, refs) => {
	    const newList = list.map(l => {
	        return convertValueToLiteral(l, refs);
	    });
	    return ts.createArrayLiteral(newList);
	};
	const objectToObjectLiteral = (obj, refs) => {
	    if (refs.has(obj)) {
	        return ts.createIdentifier('undefined');
	    }
	    refs.add(obj);
	    const newProperties = Object.keys(obj).map(key => {
	        const prop = ts.createPropertyAssignment(ts.createLiteral(key), convertValueToLiteral(obj[key], refs));
	        return prop;
	    });
	    return ts.createObjectLiteral(newProperties, true);
	};
	const createStaticGetter = (propName, returnExpression) => {
	    return ts.createGetAccessor(undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], propName, undefined, undefined, ts.createBlock([
	        ts.createReturn(returnExpression)
	    ]));
	};
	const removeDecorators = (node, decoratorNames) => {
	    if (node.decorators) {
	        const updatedDecoratorList = node.decorators.filter(dec => {
	            const name = (ts.isCallExpression(dec.expression) &&
	                ts.isIdentifier(dec.expression.expression) &&
	                dec.expression.expression.text);
	            return !decoratorNames.has(name);
	        });
	        if (updatedDecoratorList.length === 0) {
	            node.decorators = undefined;
	        }
	        else if (updatedDecoratorList.length !== node.decorators.length) {
	            node.decorators = ts.createNodeArray(updatedDecoratorList);
	        }
	    }
	};
	const getStaticValue = (staticMembers, staticName) => {
	    const staticMember = staticMembers.find(member => member.name.escapedText === staticName);
	    if (!staticMember || !staticMember.body || !staticMember.body.statements) {
	        return null;
	    }
	    const rtnStatement = staticMember.body.statements.find(s => s.kind === ts.SyntaxKind.ReturnStatement);
	    if (!rtnStatement || !rtnStatement.expression) {
	        return null;
	    }
	    if (rtnStatement.expression.kind === ts.SyntaxKind.StringLiteral) {
	        return rtnStatement.expression.text;
	    }
	    if (rtnStatement.expression.kind === ts.SyntaxKind.TrueKeyword) {
	        return true;
	    }
	    if (rtnStatement.expression.kind === ts.SyntaxKind.FalseKeyword) {
	        return false;
	    }
	    if (rtnStatement.expression.kind === ts.SyntaxKind.ObjectLiteralExpression) {
	        return objectLiteralToObjectMap(rtnStatement.expression);
	    }
	    if (rtnStatement.expression.kind === ts.SyntaxKind.ArrayLiteralExpression && rtnStatement.expression.elements) {
	        return arrayLiteralToArray(rtnStatement.expression);
	    }
	    if (rtnStatement.expression.kind === ts.SyntaxKind.Identifier) {
	        return {
	            __identifier: true,
	            __escapedText: rtnStatement.expression.escapedText
	        };
	    }
	    return null;
	};
	const arrayLiteralToArray = (arr) => {
	    return arr.elements.map(element => {
	        let val;
	        switch (element.kind) {
	            case ts.SyntaxKind.ObjectLiteralExpression:
	                val = objectLiteralToObjectMap(element);
	                break;
	            case ts.SyntaxKind.StringLiteral:
	                val = element.text;
	                break;
	            case ts.SyntaxKind.TrueKeyword:
	                val = true;
	                break;
	            case ts.SyntaxKind.FalseKeyword:
	                val = false;
	                break;
	            case ts.SyntaxKind.Identifier:
	                const escapedText = element.escapedText;
	                if (escapedText === 'String') {
	                    val = String;
	                }
	                else if (escapedText === 'Number') {
	                    val = Number;
	                }
	                else if (escapedText === 'Boolean') {
	                    val = Boolean;
	                }
	                break;
	            case ts.SyntaxKind.PropertyAccessExpression:
	            default:
	                val = element;
	        }
	        return val;
	    });
	};
	const objectLiteralToObjectMap = (objectLiteral) => {
	    const attrs = objectLiteral.properties;
	    return attrs.reduce((final, attr) => {
	        const attrName = getTextOfPropertyName(attr.name);
	        let val;
	        switch (attr.initializer.kind) {
	            case ts.SyntaxKind.ArrayLiteralExpression:
	                val = arrayLiteralToArray(attr.initializer);
	                break;
	            case ts.SyntaxKind.ObjectLiteralExpression:
	                val = objectLiteralToObjectMap(attr.initializer);
	                break;
	            case ts.SyntaxKind.StringLiteral:
	                val = attr.initializer.text;
	                break;
	            case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
	                val = attr.initializer.text;
	                break;
	            case ts.SyntaxKind.TrueKeyword:
	                val = true;
	                break;
	            case ts.SyntaxKind.FalseKeyword:
	                val = false;
	                break;
	            case ts.SyntaxKind.Identifier:
	                const escapedText = attr.initializer.escapedText;
	                if (escapedText === 'String') {
	                    val = String;
	                }
	                else if (escapedText === 'Number') {
	                    val = Number;
	                }
	                else if (escapedText === 'Boolean') {
	                    val = Boolean;
	                }
	                else if (escapedText === 'undefined') {
	                    val = undefined;
	                }
	                else if (escapedText === 'null') {
	                    val = null;
	                }
	                else {
	                    val = getIdentifierValue(attr.initializer);
	                }
	                break;
	            case ts.SyntaxKind.PropertyAccessExpression:
	            default:
	                val = attr.initializer;
	        }
	        final[attrName] = val;
	        return final;
	    }, {});
	};
	const getIdentifierValue = (initializer) => {
	    const escapedText = initializer.escapedText;
	    const identifier = {
	        __identifier: true,
	        __escapedText: escapedText
	    };
	    return identifier;
	};
	const getTextOfPropertyName = (propName) => {
	    switch (propName.kind) {
	        case ts.SyntaxKind.Identifier:
	            return propName.text;
	        case ts.SyntaxKind.StringLiteral:
	        case ts.SyntaxKind.NumericLiteral:
	            return propName.text;
	        case ts.SyntaxKind.ComputedPropertyName:
	            const expression = propName.expression;
	            if (ts.isStringLiteral(expression) || ts.isNumericLiteral(expression)) {
	                return propName.expression.text;
	            }
	    }
	    return undefined;
	};
	const getAttributeTypeInfo = (baseNode, sourceFile) => {
	    const allReferences = {};
	    getAllTypeReferences(baseNode).forEach(rt => {
	        allReferences[rt] = getTypeReferenceLocation(rt, sourceFile);
	    });
	    return allReferences;
	};
	const getEntityName = (entity) => {
	    if (ts.isIdentifier(entity)) {
	        return entity.escapedText.toString();
	    }
	    else {
	        return getEntityName(entity.left);
	    }
	};
	const getAllTypeReferences = (node) => {
	    const referencedTypes = [];
	    const visit = (node) => {
	        if (ts.isTypeReferenceNode(node)) {
	            referencedTypes.push(getEntityName(node.typeName));
	            if (node.typeArguments) {
	                node.typeArguments
	                    .filter(ta => ts.isTypeReferenceNode(ta))
	                    .forEach((tr) => {
	                    const typeName = tr.typeName;
	                    referencedTypes.push(typeName.escapedText.toString());
	                });
	            }
	        }
	        return ts.forEachChild(node, visit);
	    };
	    visit(node);
	    return referencedTypes;
	};
	const validateReferences = (config, diagnostics, references, node) => {
	    Object.keys(references).forEach(refName => {
	        const ref = references[refName];
	        if (ref.path === '@stencil/core' && MEMBER_DECORATORS_TO_REMOVE.has(refName)) {
	            const err = buildError(diagnostics);
	            augmentDiagnosticWithNode(config, err, node);
	        }
	    });
	};
	const getTypeReferenceLocation = (typeName, sourceFile) => {
	    const sourceFileObj = sourceFile.getSourceFile();
	    // Loop through all top level imports to find any reference to the type for 'import' reference location
	    const importTypeDeclaration = sourceFileObj.statements.find(st => {
	        const statement = ts.isImportDeclaration(st) &&
	            st.importClause &&
	            ts.isImportClause(st.importClause) &&
	            st.importClause.namedBindings &&
	            ts.isNamedImports(st.importClause.namedBindings) &&
	            Array.isArray(st.importClause.namedBindings.elements) &&
	            st.importClause.namedBindings.elements.find(nbe => nbe.name.getText() === typeName);
	        if (!statement) {
	            return false;
	        }
	        return true;
	    });
	    if (importTypeDeclaration) {
	        const localImportPath = importTypeDeclaration.moduleSpecifier.text;
	        return {
	            location: 'import',
	            path: localImportPath
	        };
	    }
	    // Loop through all top level exports to find if any reference to the type for 'local' reference location
	    const isExported = sourceFileObj.statements.some(st => {
	        // Is the interface defined in the file and exported
	        const isInterfaceDeclarationExported = ((ts.isInterfaceDeclaration(st) &&
	            st.name.getText() === typeName) &&
	            Array.isArray(st.modifiers) &&
	            st.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword));
	        const isTypeAliasDeclarationExported = ((ts.isTypeAliasDeclaration(st) &&
	            st.name.getText() === typeName) &&
	            Array.isArray(st.modifiers) &&
	            st.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword));
	        // Is the interface exported through a named export
	        const isTypeInExportDeclaration = ts.isExportDeclaration(st) &&
	            ts.isNamedExports(st.exportClause) &&
	            st.exportClause.elements.some(nee => nee.name.getText() === typeName);
	        return isInterfaceDeclarationExported || isTypeAliasDeclarationExported || isTypeInExportDeclaration;
	    });
	    if (isExported) {
	        return {
	            location: 'local'
	        };
	    }
	    // This is most likely a global type, if it is a local that is not exported then typescript will inform the dev
	    return {
	        location: 'global',
	    };
	};
	const resolveType = (checker, type) => {
	    const set = new Set();
	    parseDocsType(checker, type, set);
	    // normalize booleans
	    const hasTrue = set.delete('true');
	    const hasFalse = set.delete('false');
	    if (hasTrue || hasFalse) {
	        set.add('boolean');
	    }
	    let parts = Array.from(set.keys()).sort();
	    if (parts.length > 1) {
	        parts = parts.map(p => (p.indexOf('=>') >= 0) ? `(${p})` : p);
	    }
	    if (parts.length > 20) {
	        return typeToString(checker, type);
	    }
	    else {
	        return parts.join(' | ');
	    }
	};
	const typeToString = (checker, type) => {
	    const TYPE_FORMAT_FLAGS = ts.TypeFormatFlags.NoTruncation |
	        ts.TypeFormatFlags.InTypeAlias |
	        ts.TypeFormatFlags.InElementType;
	    return checker.typeToString(type, undefined, TYPE_FORMAT_FLAGS);
	};
	const parseDocsType = (checker, type, parts) => {
	    if (type.isUnion()) {
	        type.types.forEach(t => {
	            parseDocsType(checker, t, parts);
	        });
	    }
	    else {
	        const text = typeToString(checker, type);
	        parts.add(text);
	    }
	};
	const getModuleFromSourceFile = (compilerCtx, tsSourceFile) => {
	    const sourceFilePath = normalizePath(tsSourceFile.fileName);
	    const moduleFile = compilerCtx.moduleMap.get(sourceFilePath);
	    if (moduleFile != null) {
	        return moduleFile;
	    }
	    const moduleFiles = Array.from(compilerCtx.moduleMap.values());
	    return moduleFiles.find(m => m.jsFilePath === sourceFilePath);
	};
	const getComponentMeta = (compilerCtx, tsSourceFile, node) => {
	    const meta = compilerCtx.nodeMap.get(node);
	    if (meta) {
	        return meta;
	    }
	    const moduleFile = getModuleFromSourceFile(compilerCtx, tsSourceFile);
	    if (moduleFile != null && node.members != null) {
	        const staticMembers = node.members.filter(isStaticGetter);
	        const tagName = getComponentTagName(staticMembers);
	        if (typeof tagName === 'string') {
	            return moduleFile.cmps.find(cmp => cmp.tagName === tagName);
	        }
	    }
	    return undefined;
	};
	const getComponentTagName = (staticMembers) => {
	    if (staticMembers.length > 0) {
	        const tagName = getStaticValue(staticMembers, 'is');
	        if (typeof tagName === 'string' && tagName.includes('-')) {
	            return tagName;
	        }
	    }
	    return null;
	};
	const isStaticGetter = (member) => {
	    return (member.kind === ts.SyntaxKind.GetAccessor &&
	        member.modifiers && member.modifiers.some(({ kind }) => kind === ts.SyntaxKind.StaticKeyword));
	};
	const serializeSymbol = (checker, symbol) => {
	    return {
	        tags: symbol.getJsDocTags().map(tag => ({ text: tag.text, name: tag.name })),
	        text: ts.displayPartsToString(symbol.getDocumentationComment(checker)),
	    };
	};
	const isInternal = (jsDocs) => {
	    return jsDocs && jsDocs.tags.some((s) => s.name === 'internal');
	};
	const isMethod = (member, methodName) => {
	    return ts.isMethodDeclaration(member) && member.name && member.name.escapedText === methodName;
	};

	const addComponentMetaStatic = (cmpNode, cmpMeta) => {
	    const publicCompilerMeta = getPublicCompilerMeta(cmpMeta);
	    const cmpMetaStaticProp = createStaticGetter('COMPILER_META', convertValueToLiteral(publicCompilerMeta));
	    const classMembers = [...cmpNode.members, cmpMetaStaticProp];
	    return ts.updateClassDeclaration(cmpNode, cmpNode.decorators, cmpNode.modifiers, cmpNode.name, cmpNode.typeParameters, cmpNode.heritageClauses, classMembers);
	};
	const getPublicCompilerMeta = (cmpMeta) => {
	    const publicCompilerMeta = Object.assign({}, cmpMeta);
	    // no need to copy all compiler meta data
	    delete publicCompilerMeta.assetsDirs;
	    delete publicCompilerMeta.dependencies;
	    delete publicCompilerMeta.excludeFromCollection;
	    delete publicCompilerMeta.isCollectionDependency;
	    delete publicCompilerMeta.docs;
	    delete publicCompilerMeta.jsFilePath;
	    delete publicCompilerMeta.potentialCmpRefs;
	    delete publicCompilerMeta.styleDocs;
	    delete publicCompilerMeta.sourceFilePath;
	    return publicCompilerMeta;
	};

	const createStencilImportPath = (type, tagName, encapsulation, modeName, importPath) => {
	    const pathData = serializeStencilImportPath(type, tagName, encapsulation, modeName);
	    return `${pathData}!${importPath}`;
	};
	const serializeStencilImportPath = (type, tagName, encapsulation, modeName) => {
	    const data = {
	        tag: tagName,
	    };
	    if (modeName && modeName !== DEFAULT_STYLE_MODE) {
	        data.mode = modeName;
	    }
	    if (encapsulation !== 'none') {
	        data.encapsulation = encapsulation;
	    }
	    const params = new URLSearchParams(Object.entries(data));
	    params.set('type', type);
	    return STENCIL_IMPORT_PREFIX + params.toString();
	};
	const parseStencilImportPath = (importee, importer) => {
	    if (typeof importee === 'string' && typeof importee === 'string') {
	        if (importee.startsWith(STENCIL_IMPORT_PREFIX) && importee.includes('!')) {
	            const importeeParts = importee.split('!');
	            const importData = importeeParts[0];
	            const importPath = importeeParts[importeeParts.length - 1];
	            const dataParts = importData.split('?');
	            if (dataParts.length === 2) {
	                const params = dataParts[1];
	                const urlParams = new URLSearchParams(params);
	                const type = urlParams.get('type');
	                const data = {
	                    tag: urlParams.get('tag'),
	                    encapsulation: urlParams.get('encapsulation') || 'none',
	                    mode: urlParams.get('mode') || DEFAULT_STYLE_MODE,
	                };
	                importer = normalizePath(importer);
	                const importerDir = pathBrowserify.dirname(importer);
	                const importerExt = getFileExt(importer.split('?')[0]);
	                const resolvedFilePath = normalizePath(pathBrowserify.resolve(importerDir, importPath));
	                const resolvedFileName = pathBrowserify.basename(resolvedFilePath);
	                const resolvedFileExt = getFileExt(resolvedFileName);
	                let resolvedId = resolvedFilePath;
	                if (data.encapsulation === 'scoped' && data.mode && data.mode !== DEFAULT_STYLE_MODE) {
	                    resolvedId += `?${params}`;
	                }
	                const r = {
	                    type,
	                    resolvedId,
	                    resolvedFilePath,
	                    resolvedFileName,
	                    resolvedFileExt,
	                    params,
	                    data,
	                    importee,
	                    importer,
	                    importerExt,
	                };
	                return r;
	            }
	        }
	    }
	    return null;
	};
	const STENCIL_IMPORT_PREFIX = `\0stencil?`;

	const getScopeId = (tagName, mode) => {
	    return ('sc-' + tagName) + ((mode && mode !== DEFAULT_STYLE_MODE) ? '-' + mode : '');
	};

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 *
	 * This file is a port of shadowCSS from webcomponents.js to TypeScript.
	 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
	 * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts
	 */
	const safeSelector = (selector) => {
	    const placeholders = [];
	    let index = 0;
	    let content;
	    // Replaces attribute selectors with placeholders.
	    // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.
	    selector = selector.replace(/(\[[^\]]*\])/g, (_, keep) => {
	        const replaceBy = `__ph-${index}__`;
	        placeholders.push(keep);
	        index++;
	        return replaceBy;
	    });
	    // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
	    // WS and "+" would otherwise be interpreted as selector separators.
	    content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
	        const replaceBy = `__ph-${index}__`;
	        placeholders.push(exp);
	        index++;
	        return pseudo + replaceBy;
	    });
	    const ss = {
	        content,
	        placeholders,
	    };
	    return ss;
	};
	const restoreSafeSelector = (placeholders, content) => {
	    return content.replace(/__ph-(\d+)__/g, (_, index) => placeholders[+index]);
	};
	const _polyfillHost = '-shadowcsshost';
	const _polyfillSlotted = '-shadowcssslotted';
	// note: :host-context pre-processed to -shadowcsshostcontext.
	const _polyfillHostContext = '-shadowcsscontext';
	const _parenSuffix = ')(?:\\((' +
	    '(?:\\([^)(]*\\)|[^)(]*)+?' +
	    ')\\))?([^,{]*)';
	const _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
	const _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
	const _cssColonSlottedRe = new RegExp('(' + _polyfillSlotted + _parenSuffix, 'gim');
	const _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
	const _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
	const _shadowDOMSelectorsRe = [
	    /::shadow/g,
	    /::content/g
	];
	const _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
	const _polyfillHostRe = /-shadowcsshost/gim;
	const _colonHostRe = /:host/gim;
	const _colonSlottedRe = /::slotted/gim;
	const _colonHostContextRe = /:host-context/gim;
	const _commentRe = /\/\*\s*[\s\S]*?\*\//g;
	const stripComments = (input) => {
	    return input.replace(_commentRe, '');
	};
	const _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
	const extractCommentsWithHash = (input) => {
	    return input.match(_commentWithHashRe) || [];
	};
	const _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
	const _curlyRe = /([{}])/g;
	const OPEN_CURLY = '{';
	const CLOSE_CURLY = '}';
	const BLOCK_PLACEHOLDER = '%BLOCK%';
	const processRules = (input, ruleCallback) => {
	    const inputWithEscapedBlocks = escapeBlocks(input);
	    let nextBlockIndex = 0;
	    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {
	        const selector = m[2];
	        let content = '';
	        let suffix = m[4];
	        let contentPrefix = '';
	        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
	            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
	            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
	            contentPrefix = '{';
	        }
	        const cssRule = {
	            selector,
	            content
	        };
	        const rule = ruleCallback(cssRule);
	        return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
	    });
	};
	const escapeBlocks = (input) => {
	    const inputParts = input.split(_curlyRe);
	    const resultParts = [];
	    const escapedBlocks = [];
	    let bracketCount = 0;
	    let currentBlockParts = [];
	    for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {
	        const part = inputParts[partIndex];
	        if (part === CLOSE_CURLY) {
	            bracketCount--;
	        }
	        if (bracketCount > 0) {
	            currentBlockParts.push(part);
	        }
	        else {
	            if (currentBlockParts.length > 0) {
	                escapedBlocks.push(currentBlockParts.join(''));
	                resultParts.push(BLOCK_PLACEHOLDER);
	                currentBlockParts = [];
	            }
	            resultParts.push(part);
	        }
	        if (part === OPEN_CURLY) {
	            bracketCount++;
	        }
	    }
	    if (currentBlockParts.length > 0) {
	        escapedBlocks.push(currentBlockParts.join(''));
	        resultParts.push(BLOCK_PLACEHOLDER);
	    }
	    const strEscapedBlocks = {
	        escapedString: resultParts.join(''),
	        blocks: escapedBlocks
	    };
	    return strEscapedBlocks;
	};
	const insertPolyfillHostInCssText = (selector) => {
	    selector = selector
	        .replace(_colonHostContextRe, _polyfillHostContext)
	        .replace(_colonHostRe, _polyfillHost)
	        .replace(_colonSlottedRe, _polyfillSlotted);
	    return selector;
	};
	const convertColonRule = (cssText, regExp, partReplacer) => {
	    // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
	    return cssText.replace(regExp, (...m) => {
	        if (m[2]) {
	            const parts = m[2].split(',');
	            const r = [];
	            for (let i = 0; i < parts.length; i++) {
	                const p = parts[i].trim();
	                if (!p)
	                    break;
	                r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
	            }
	            return r.join(',');
	        }
	        else {
	            return _polyfillHostNoCombinator + m[3];
	        }
	    });
	};
	const colonHostPartReplacer = (host, part, suffix) => {
	    return host + part.replace(_polyfillHost, '') + suffix;
	};
	const convertColonHost = (cssText) => {
	    return convertColonRule(cssText, _cssColonHostRe, colonHostPartReplacer);
	};
	const colonHostContextPartReplacer = (host, part, suffix) => {
	    if (part.indexOf(_polyfillHost) > -1) {
	        return colonHostPartReplacer(host, part, suffix);
	    }
	    else {
	        return host + part + suffix + ', ' + part + ' ' + host + suffix;
	    }
	};
	const convertColonSlotted = (cssText, slotScopeId) => {
	    const slotClass = '.' + slotScopeId + ' > ';
	    const selectors = [];
	    cssText = cssText.replace(_cssColonSlottedRe, (...m) => {
	        if (m[2]) {
	            const compound = m[2].trim();
	            const suffix = m[3];
	            const slottedSelector = slotClass + compound + suffix;
	            let prefixSelector = '';
	            for (let i = m[4] - 1; i >= 0; i--) {
	                const char = m[5][i];
	                if (char === '}' || char === ',') {
	                    break;
	                }
	                prefixSelector = char + prefixSelector;
	            }
	            const orgSelector = prefixSelector + slottedSelector;
	            const addedSelector = `${prefixSelector.trimRight()}${slottedSelector.trim()}`;
	            if (orgSelector.trim() !== addedSelector.trim()) {
	                const updatedSelector = `${addedSelector}, ${orgSelector}`;
	                selectors.push({
	                    orgSelector,
	                    updatedSelector,
	                });
	            }
	            return slottedSelector;
	        }
	        else {
	            return _polyfillHostNoCombinator + m[3];
	        }
	    });
	    return {
	        selectors,
	        cssText
	    };
	};
	const convertColonHostContext = (cssText) => {
	    return convertColonRule(cssText, _cssColonHostContextRe, colonHostContextPartReplacer);
	};
	const convertShadowDOMSelectors = (cssText) => {
	    return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);
	};
	const makeScopeMatcher = (scopeSelector) => {
	    const lre = /\[/g;
	    const rre = /\]/g;
	    scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
	    return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
	};
	const selectorNeedsScoping = (selector, scopeSelector) => {
	    const re = makeScopeMatcher(scopeSelector);
	    return !re.test(selector);
	};
	const applySimpleSelectorScope = (selector, scopeSelector, hostSelector) => {
	    // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
	    _polyfillHostRe.lastIndex = 0;
	    if (_polyfillHostRe.test(selector)) {
	        const replaceBy = `.${hostSelector}`;
	        return selector
	            .replace(_polyfillHostNoCombinatorRe, (_, selector) => {
	            return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {
	                return before + replaceBy + colon + after;
	            });
	        })
	            .replace(_polyfillHostRe, replaceBy + ' ');
	    }
	    return scopeSelector + ' ' + selector;
	};
	const applyStrictSelectorScope = (selector, scopeSelector, hostSelector) => {
	    const isRe = /\[is=([^\]]*)\]/g;
	    scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
	    const className = '.' + scopeSelector;
	    const _scopeSelectorPart = (p) => {
	        let scopedP = p.trim();
	        if (!scopedP) {
	            return '';
	        }
	        if (p.indexOf(_polyfillHostNoCombinator) > -1) {
	            scopedP = applySimpleSelectorScope(p, scopeSelector, hostSelector);
	        }
	        else {
	            // remove :host since it should be unnecessary
	            const t = p.replace(_polyfillHostRe, '');
	            if (t.length > 0) {
	                const matches = t.match(/([^:]*)(:*)(.*)/);
	                if (matches) {
	                    scopedP = matches[1] + className + matches[2] + matches[3];
	                }
	            }
	        }
	        return scopedP;
	    };
	    const safeContent = safeSelector(selector);
	    selector = safeContent.content;
	    let scopedSelector = '';
	    let startIndex = 0;
	    let res;
	    const sep = /( |>|\+|~(?!=))\s*/g;
	    // If a selector appears before :host it should not be shimmed as it
	    // matches on ancestor elements and not on elements in the host's shadow
	    // `:host-context(div)` is transformed to
	    // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`
	    // the `div` is not part of the component in the 2nd selectors and should not be scoped.
	    // Historically `component-tag:host` was matching the component so we also want to preserve
	    // this behavior to avoid breaking legacy apps (it should not match).
	    // The behavior should be:
	    // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)
	    // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a
	    //   `:host-context(tag)`)
	    const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;
	    // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present
	    let shouldScope = !hasHost;
	    while ((res = sep.exec(selector)) !== null) {
	        const separator = res[1];
	        const part = selector.slice(startIndex, res.index).trim();
	        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
	        const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;
	        scopedSelector += `${scopedPart} ${separator} `;
	        startIndex = sep.lastIndex;
	    }
	    const part = selector.substring(startIndex);
	    shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
	    scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;
	    // replace the placeholders with their original values
	    return restoreSafeSelector(safeContent.placeholders, scopedSelector);
	};
	const scopeSelector = (selector, scopeSelectorText, hostSelector, slotSelector) => {
	    return selector.split(',')
	        .map(shallowPart => {
	        if (slotSelector && shallowPart.indexOf('.' + slotSelector) > -1) {
	            return shallowPart.trim();
	        }
	        if (selectorNeedsScoping(shallowPart, scopeSelectorText)) {
	            return applyStrictSelectorScope(shallowPart, scopeSelectorText, hostSelector).trim();
	        }
	        else {
	            return shallowPart.trim();
	        }
	    })
	        .join(', ');
	};
	const scopeSelectors = (cssText, scopeSelectorText, hostSelector, slotSelector, commentOriginalSelector) => {
	    return processRules(cssText, (rule) => {
	        let selector = rule.selector;
	        let content = rule.content;
	        if (rule.selector[0] !== '@') {
	            selector = scopeSelector(rule.selector, scopeSelectorText, hostSelector, slotSelector);
	        }
	        else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
	            rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
	            content = scopeSelectors(rule.content, scopeSelectorText, hostSelector, slotSelector);
	        }
	        const cssRule = {
	            selector: selector.replace(/\s{2,}/g, ' ').trim(),
	            content
	        };
	        return cssRule;
	    });
	};
	const scopeCssText = (cssText, scopeId, hostScopeId, slotScopeId, commentOriginalSelector) => {
	    cssText = insertPolyfillHostInCssText(cssText);
	    cssText = convertColonHost(cssText);
	    cssText = convertColonHostContext(cssText);
	    const slotted = convertColonSlotted(cssText, slotScopeId);
	    cssText = slotted.cssText;
	    cssText = convertShadowDOMSelectors(cssText);
	    if (scopeId) {
	        cssText = scopeSelectors(cssText, scopeId, hostScopeId, slotScopeId);
	    }
	    cssText = cssText.replace(/-shadowcsshost-no-combinator/g, `.${hostScopeId}`);
	    cssText = cssText.replace(/>\s*\*\s+([^{, ]+)/gm, ' $1 ');
	    return {
	        cssText: cssText.trim(),
	        slottedSelectors: slotted.selectors,
	    };
	};
	const scopeCss = (cssText, scopeId, commentOriginalSelector) => {
	    const hostScopeId = scopeId + '-h';
	    const slotScopeId = scopeId + '-s';
	    const commentsWithHash = extractCommentsWithHash(cssText);
	    cssText = stripComments(cssText);
	    const orgSelectors = [];
	    if (commentOriginalSelector) {
	        const processCommentedSelector = (rule) => {
	            const placeholder = `/*!@___${orgSelectors.length}___*/`;
	            const comment = `/*!@${rule.selector}*/`;
	            orgSelectors.push({ placeholder, comment });
	            rule.selector = placeholder + rule.selector;
	            return rule;
	        };
	        cssText = processRules(cssText, rule => {
	            if (rule.selector[0] !== '@') {
	                return processCommentedSelector(rule);
	            }
	            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
	                rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
	                rule.content = processRules(rule.content, processCommentedSelector);
	                return rule;
	            }
	            return rule;
	        });
	    }
	    const scoped = scopeCssText(cssText, scopeId, hostScopeId, slotScopeId);
	    cssText = [scoped.cssText, ...commentsWithHash].join('\n');
	    if (commentOriginalSelector) {
	        orgSelectors.forEach(({ placeholder, comment }) => {
	            cssText = cssText.replace(placeholder, comment);
	        });
	    }
	    scoped.slottedSelectors.forEach(slottedSelector => {
	        cssText = cssText.replace(slottedSelector.orgSelector, slottedSelector.updatedSelector);
	    });
	    return cssText;
	};

	const stripComments$1 = (input) => {
	    let isInsideString = null;
	    let currentCharacter = '';
	    let returnValue = '';
	    for (let i = 0; i < input.length; i++) {
	        currentCharacter = input[i];
	        if (input[i - 1] !== '\\') {
	            if (currentCharacter === '"' || currentCharacter === '\'') {
	                if (isInsideString === currentCharacter) {
	                    isInsideString = null;
	                }
	                else if (!isInsideString) {
	                    isInsideString = currentCharacter;
	                }
	            }
	        }
	        // Find beginning of /* type comment
	        if (!isInsideString && currentCharacter === '/' && input[i + 1] === '*') {
	            // Ignore important comment when configured to preserve comments using important syntax: /*!
	            let j = i + 2;
	            // Iterate over comment
	            for (; j < input.length; j++) {
	                // Find end of comment
	                if (input[j] === '*' && input[j + 1] === '/') {
	                    break;
	                }
	            }
	            // Resume iteration over CSS string from the end of the comment
	            i = j + 1;
	            continue;
	        }
	        returnValue += currentCharacter;
	    }
	    return returnValue;
	};

	const transformCssToEsm = (config, cssText, filePath, tagName, encapsulation, modeName) => {
	    if (encapsulation === 'scoped') {
	        const scopeId = getScopeId(tagName, modeName);
	        cssText = scopeCss(cssText, scopeId, false);
	    }
	    const defaultVarName = createVarName(filePath, modeName);
	    const varNames = new Set([defaultVarName]);
	    const esmImports = [];
	    const cssImports = getCssImports(config, varNames, cssText, filePath, modeName);
	    cssImports.forEach(cssImport => {
	        // remove the original css @imports
	        cssText = cssText = cssText.replace(cssImport.srcImportText, '');
	        const importPath = createStencilImportPath('css', tagName, encapsulation, modeName, cssImport.filePath);
	        esmImports.push(`import ${cssImport.varName} from '${importPath}';`);
	    });
	    const output = [
	        esmImports.join('\n')
	    ];
	    output.push(`const ${defaultVarName} = `);
	    cssImports.forEach(cssImport => {
	        output.push(`${cssImport.varName} + `);
	    });
	    output.push(`${JSON.stringify(cssText)};`);
	    output.push(`\nexport default ${defaultVarName};`);
	    return {
	        code: output.join(''),
	        map: null
	    };
	};
	const getCssImports = (config, varNames, cssText, filePath, modeName) => {
	    const cssImports = [];
	    if (!cssText.includes('@import')) {
	        // no @import at all, so don't bother
	        return cssImports;
	    }
	    cssText = stripComments$1(cssText);
	    const dir = pathBrowserify.dirname(filePath);
	    let r;
	    while (r = CSS_IMPORT_RE.exec(cssText)) {
	        const cssImportData = {
	            srcImportText: r[0],
	            url: r[4].replace(/[\"\'\)]/g, ''),
	            filePath: null,
	            varName: null
	        };
	        if (!isLocalCssImport(cssImportData.srcImportText)) {
	            // do nothing for @import url(http://external.css)
	            config.logger.debug(`did not resolve external css @import: ${cssImportData.srcImportText}`);
	            continue;
	        }
	        else if (isCssNodeModule(cssImportData.url)) {
	            // do not resolve this path cuz it starts with node resolve id ~
	            continue;
	        }
	        else if (pathBrowserify.isAbsolute(cssImportData.url)) {
	            // absolute path already
	            cssImportData.filePath = normalizePath(cssImportData.url);
	        }
	        else {
	            // relative path
	            cssImportData.filePath = normalizePath(pathBrowserify.resolve(dir, cssImportData.url));
	        }
	        cssImportData.varName = createVarName(filePath, modeName);
	        if (varNames.has(cssImportData.varName)) {
	            cssImportData.varName += (varNames.size);
	        }
	        varNames.add(cssImportData.varName);
	        cssImports.push(cssImportData);
	    }
	    return cssImports;
	};
	const CSS_IMPORT_RE = /(@import)\s+(url\()?\s?(.*?)\s?\)?([^;]*);?/gi;
	const isCssNodeModule = (url) => {
	    return url.startsWith('~');
	};
	const isLocalCssImport = (srcImport) => {
	    srcImport = srcImport.toLowerCase();
	    if (srcImport.includes('url(')) {
	        srcImport = srcImport.replace(/\"/g, '');
	        srcImport = srcImport.replace(/\'/g, '');
	        srcImport = srcImport.replace(/\s/g, '');
	        if (srcImport.includes('url(http') || srcImport.includes('url(//')) {
	            return false;
	        }
	    }
	    return true;
	};
	const createVarName = (filePath, modeName) => {
	    let varName = pathBrowserify.basename(filePath).toLowerCase();
	    varName = varName.replace(/[|&;$%@"<>()+,.{}_]/g, '-');
	    if (modeName && modeName !== DEFAULT_STYLE_MODE && !varName.includes(modeName)) {
	        varName = modeName + '-' + varName;
	    }
	    varName = dashToPascalCase(varName);
	    return varName.trim();
	};

	/**
	 * A new BuildCtx object is created for every build
	 * and rebuild.
	 */
	class BuildContext {
	    constructor(config, compilerCtx) {
	        this.buildId = -1;
	        this.buildMessages = [];
	        this.buildResults = null;
	        this.bundleBuildCount = 0;
	        this.collections = [];
	        this.completedTasks = [];
	        this.components = [];
	        this.componentGraph = new Map();
	        this.data = {};
	        this.diagnostics = [];
	        this.dirsAdded = [];
	        this.dirsDeleted = [];
	        this.entryModules = [];
	        this.filesAdded = [];
	        this.filesChanged = [];
	        this.filesDeleted = [];
	        this.filesUpdated = [];
	        this.filesWritten = [];
	        this.globalStyle = undefined;
	        this.hasConfigChanges = false;
	        this.hasFinished = false;
	        this.hasHtmlChanges = false;
	        this.hasPrintedResults = false;
	        this.hasServiceWorkerChanges = false;
	        this.hasScriptChanges = true;
	        this.hasStyleChanges = true;
	        this.hydrateAppFilePath = null;
	        this.indexBuildCount = 0;
	        this.indexDoc = undefined;
	        this.isRebuild = false;
	        this.moduleFiles = [];
	        this.packageJson = {};
	        this.packageJsonFilePath = null;
	        this.pendingCopyTasks = [];
	        this.requiresFullBuild = true;
	        this.scriptsAdded = [];
	        this.scriptsDeleted = [];
	        this.startTime = Date.now();
	        this.styleBuildCount = 0;
	        this.stylesPromise = null;
	        this.stylesUpdated = [];
	        this.timeSpan = null;
	        this.transpileBuildCount = 0;
	        this.config = config;
	        this.compilerCtx = compilerCtx;
	        this.buildId = ++this.compilerCtx.activeBuildId;
	    }
	    start() {
	        // get the build id from the incremented activeBuildId
	        // print out a good message
	        const msg = `${this.isRebuild ? 'rebuild' : 'build'}, ${this.config.fsNamespace}, ${this.config.devMode ? 'dev' : 'prod'} mode, started`;
	        const buildLog = {
	            buildId: this.buildId,
	            messages: [],
	            progress: 0
	        };
	        this.compilerCtx.events.emit('buildLog', buildLog);
	        // create a timespan for this build
	        this.timeSpan = this.createTimeSpan(msg);
	        // create a build timestamp for this build
	        this.timestamp = getBuildTimestamp();
	        // debug log our new build
	        this.debug(`start build, ${this.timestamp}`);
	    }
	    createTimeSpan(msg, debug) {
	        if (!this.hasFinished || debug) {
	            if (debug) {
	                if (this.config.watch) {
	                    msg = `${this.config.logger.cyan('[' + this.buildId + ']')} ${msg}`;
	                }
	            }
	            const timeSpan = this.config.logger.createTimeSpan(msg, debug, this.buildMessages);
	            if (!debug && this.compilerCtx.events) {
	                const buildLog = {
	                    buildId: this.buildId,
	                    messages: this.buildMessages,
	                    progress: getProgress(this.completedTasks)
	                };
	                this.compilerCtx.events.emit('buildLog', buildLog);
	            }
	            return {
	                duration: () => {
	                    return timeSpan.duration();
	                },
	                finish: (finishedMsg, color, bold, newLineSuffix) => {
	                    if (!this.hasFinished || debug) {
	                        if (debug) {
	                            if (this.config.watch) {
	                                finishedMsg = `${this.config.logger.cyan('[' + this.buildId + ']')} ${finishedMsg}`;
	                            }
	                        }
	                        timeSpan.finish(finishedMsg, color, bold, newLineSuffix);
	                        if (!debug) {
	                            const buildLog = {
	                                buildId: this.buildId,
	                                messages: this.buildMessages.slice(),
	                                progress: getProgress(this.completedTasks)
	                            };
	                            this.compilerCtx.events.emit('buildLog', buildLog);
	                        }
	                    }
	                    return timeSpan.duration();
	                }
	            };
	        }
	        return {
	            duration() { return 0; },
	            finish() { return 0; }
	        };
	    }
	    debug(msg) {
	        if (this.config.watch) {
	            this.config.logger.debug(`${this.config.logger.cyan('[' + this.buildId + ']')} ${msg}`);
	        }
	        else {
	            this.config.logger.debug(msg);
	        }
	    }
	    get hasError() {
	        return hasError(this.diagnostics);
	    }
	    get hasWarning() {
	        return hasWarning(this.diagnostics);
	    }
	    progress(t) {
	        this.completedTasks.push(t);
	    }
	    async validateTypesBuild() {
	        if (this.hasError) {
	            // no need to wait on this one since
	            // we already aborted this build
	            return;
	        }
	        if (!this.validateTypesPromise) {
	            // there is no pending validate types promise
	            // so it probably already finished
	            // so no need to wait on anything
	            return;
	        }
	        if (!this.config.watch) {
	            // this is not a watch build, so we need to make
	            // sure that the type validation has finished
	            this.debug(`build, non-watch, waiting on validateTypes`);
	            await this.validateTypesPromise;
	            this.debug(`build, non-watch, finished waiting on validateTypes`);
	        }
	    }
	}
	const getBuildTimestamp = () => {
	    const d = new Date();
	    // YYYY-MM-DDThh:mm:ss
	    let timestamp = d.getUTCFullYear() + '-';
	    timestamp += ('0' + (d.getUTCMonth() + 1)).slice(-2) + '-';
	    timestamp += ('0' + d.getUTCDate()).slice(-2) + 'T';
	    timestamp += ('0' + d.getUTCHours()).slice(-2) + ':';
	    timestamp += ('0' + d.getUTCMinutes()).slice(-2) + ':';
	    timestamp += ('0' + d.getUTCSeconds()).slice(-2);
	    return timestamp;
	};
	const getProgress = (completedTasks) => {
	    let progressIndex = 0;
	    const taskKeys = Object.keys(ProgressTask);
	    taskKeys.forEach((taskKey, index) => {
	        if (completedTasks.includes(ProgressTask[taskKey])) {
	            progressIndex = index;
	        }
	    });
	    return (progressIndex + 1) / taskKeys.length;
	};
	const ProgressTask = {
	    emptyOutputTargets: {},
	    transpileApp: {},
	    generateStyles: {},
	    generateOutputTargets: {},
	    validateTypesBuild: {},
	    writeBuildFiles: {},
	};

	class BuildEvents {
	    constructor() {
	        this.evCallbacks = new Map();
	    }
	    subscribe(eventName, cb) {
	        const evName = getEventName(eventName);
	        const callbacks = this.evCallbacks.get(evName);
	        if (callbacks == null) {
	            this.evCallbacks.set(evName, [cb]);
	        }
	        else {
	            callbacks.push(cb);
	        }
	        return () => {
	            this.unsubscribe(evName, cb);
	        };
	    }
	    unsubscribe(eventName, cb) {
	        const callbacks = this.evCallbacks.get(getEventName(eventName));
	        if (callbacks != null) {
	            const index = callbacks.indexOf(cb);
	            if (index > -1) {
	                callbacks.splice(index, 1);
	            }
	        }
	    }
	    unsubscribeAll() {
	        this.evCallbacks.clear();
	    }
	    emit(eventName, ...args) {
	        const callbacks = this.evCallbacks.get(getEventName(eventName));
	        if (callbacks != null) {
	            callbacks.forEach(cb => {
	                try {
	                    cb.apply(this, args);
	                }
	                catch (e) {
	                    console.log(e);
	                }
	            });
	        }
	    }
	}
	const getEventName = (evName) => {
	    return evName.trim().toLowerCase();
	};

	class Cache {
	    constructor(config, cacheFs) {
	        this.config = config;
	        this.cacheFs = cacheFs;
	        this.failed = 0;
	        this.skip = false;
	        this.sys = config.sys;
	        this.path = config.sys.path;
	        this.logger = config.logger;
	    }
	    async initCacheDir() {
	        if (this.config._isTesting) {
	            return;
	        }
	        if (!this.config.enableCache) {
	            this.config.logger.info(`cache optimizations disabled`);
	            this.clearDiskCache();
	            return;
	        }
	        this.config.logger.debug(`cache enabled, cacheDir: ${this.config.cacheDir}`);
	        try {
	            const readmeFilePath = this.path.join(this.config.cacheDir, '_README.log');
	            await this.cacheFs.writeFile(readmeFilePath, CACHE_DIR_README);
	        }
	        catch (e) {
	            this.logger.error(`Cache, initCacheDir: ${e}`);
	            this.config.enableCache = false;
	        }
	    }
	    async get(key) {
	        if (!this.config.enableCache || this.skip) {
	            return null;
	        }
	        if (this.failed >= MAX_FAILED) {
	            if (!this.skip) {
	                this.skip = true;
	                this.logger.debug(`cache had ${this.failed} failed ops, skip disk ops for remander of build`);
	            }
	            return null;
	        }
	        let result;
	        try {
	            result = await this.cacheFs.readFile(this.getCacheFilePath(key));
	            this.failed = 0;
	            this.skip = false;
	        }
	        catch (e) {
	            this.failed++;
	            result = null;
	        }
	        return result;
	    }
	    async put(key, value) {
	        if (!this.config.enableCache) {
	            return false;
	        }
	        let result;
	        try {
	            await this.cacheFs.writeFile(this.getCacheFilePath(key), value);
	            result = true;
	        }
	        catch (e) {
	            this.failed++;
	            result = false;
	        }
	        return result;
	    }
	    async has(key) {
	        const val = await this.get(key);
	        return (typeof val === 'string');
	    }
	    async createKey(domain, ...args) {
	        if (!this.config.enableCache) {
	            return domain + (Math.random() * 9999999);
	        }
	        const hash = await this.sys.generateContentHash(JSON.stringify(args), 32);
	        return domain + '_' + hash;
	    }
	    async commit() {
	        if (this.config.enableCache) {
	            this.skip = false;
	            this.failed = 0;
	            await this.cacheFs.commit();
	            await this.clearExpiredCache();
	        }
	    }
	    clear() {
	        if (this.cacheFs != null) {
	            this.cacheFs.clearCache();
	        }
	    }
	    async clearExpiredCache() {
	        if (this.cacheFs == null || this.sys.storage == null) {
	            return;
	        }
	        const now = Date.now();
	        const lastClear = await this.sys.storage.get(EXP_STORAGE_KEY);
	        if (lastClear != null) {
	            const diff = now - lastClear;
	            if (diff < ONE_DAY) {
	                return;
	            }
	            const fs = this.cacheFs.disk;
	            const cachedFileNames = await fs.readdir(this.config.cacheDir);
	            const cachedFilePaths = cachedFileNames.map(f => this.path.join(this.config.cacheDir, f));
	            let totalCleared = 0;
	            const promises = cachedFilePaths.map(async (filePath) => {
	                const stat = await fs.stat(filePath);
	                const lastModified = stat.mtime.getTime();
	                const diff = now - lastModified;
	                if (diff > ONE_WEEK) {
	                    await fs.unlink(filePath);
	                    totalCleared++;
	                }
	            });
	            await Promise.all(promises);
	            this.logger.debug(`clearExpiredCache, cachedFileNames: ${cachedFileNames.length}, totalCleared: ${totalCleared}`);
	        }
	        this.logger.debug(`clearExpiredCache, set last clear`);
	        await this.sys.storage.set(EXP_STORAGE_KEY, now);
	    }
	    async clearDiskCache() {
	        if (this.cacheFs != null) {
	            const hasAccess = await this.cacheFs.access(this.config.cacheDir);
	            if (hasAccess) {
	                await this.cacheFs.remove(this.config.cacheDir);
	                await this.cacheFs.commit();
	            }
	        }
	    }
	    getCacheFilePath(key) {
	        return this.path.join(this.config.cacheDir, key) + '.log';
	    }
	    getMemoryStats() {
	        if (this.cacheFs != null) {
	            return this.cacheFs.getMemoryStats();
	        }
	        return null;
	    }
	}
	const MAX_FAILED = 100;
	const ONE_DAY = 1000 * 60 * 60 * 24;
	const ONE_WEEK = ONE_DAY * 7;
	const EXP_STORAGE_KEY = `last_clear_expired_cache`;
	const CACHE_DIR_README = `# Stencil Cache Directory

This directory contains files which the compiler has
cached for faster builds. To disable caching, please set
"enableCache: false" within the stencil config.

To change the cache directory, please update the
"cacheDir" property within the stencil config.
`;

	/**
	 * The CompilerCtx is a persistent object that's reused throughout
	 * all builds and rebuilds. The data within this object is used
	 * for in-memory caching, and can be reset, but the object itself
	 * is always the same.
	 */
	class CompilerContext {
	    constructor(config) {
	        this.activeBuildId = -1;
	        this.activeFilesAdded = [];
	        this.activeFilesDeleted = [];
	        this.activeFilesUpdated = [];
	        this.activeDirsAdded = [];
	        this.activeDirsDeleted = [];
	        this.cachedStyleMeta = new Map();
	        this.collections = [];
	        this.compilerOptions = null;
	        this.events = new BuildEvents();
	        this.fsWatcher = null;
	        this.hasFsWatcherEvents = false;
	        this.hasLoggedServerUrl = false;
	        this.hasSuccessfulBuild = false;
	        this.isActivelyBuilding = false;
	        this.lastBuildResults = null;
	        this.lastBuildStyles = new Map();
	        this.lastComponentStyleInput = new Map();
	        this.moduleMap = new Map();
	        this.nodeMap = new WeakMap();
	        this.resolvedCollections = new Set();
	        this.rollupCacheHydrate = null;
	        this.rollupCacheLazy = null;
	        this.rollupCacheNative = null;
	        this.rootTsFiles = [];
	        this.tsService = null;
	        this.styleModeNames = new Set();
	        const cacheFs = (config.enableCache && config.sys.fs != null) ? new InMemoryFileSystem(config.sys.fs, config.sys.path) : null;
	        this.cache = new Cache(config, cacheFs);
	        this.cache.initCacheDir();
	        this.fs = (config.sys.fs != null ? new InMemoryFileSystem(config.sys.fs, config.sys.path) : null);
	    }
	    reset() {
	        this.cache.clear();
	        this.cachedStyleMeta.clear();
	        this.cachedGlobalStyle = null;
	        this.collections.length = 0;
	        this.compilerOptions = null;
	        this.lastComponentStyleInput.clear();
	        this.rollupCacheHydrate = null;
	        this.rollupCacheLazy = null;
	        this.rollupCacheNative = null;
	        this.moduleMap.clear();
	        this.resolvedCollections.clear();
	        this.rootTsFiles.length = 0;
	        this.tsService = null;
	        if (this.fs != null) {
	            this.fs.clearCache();
	        }
	    }
	}
	const getModule = (config, compilerCtx, sourceFilePath) => {
	    sourceFilePath = normalizePath(sourceFilePath);
	    const moduleFile = compilerCtx.moduleMap.get(sourceFilePath);
	    if (moduleFile != null) {
	        return moduleFile;
	    }
	    else {
	        const sourceFileDir = config.sys.path.dirname(sourceFilePath);
	        const sourceFileExt = config.sys.path.extname(sourceFilePath);
	        const sourceFileName = config.sys.path.basename(sourceFilePath, sourceFileExt);
	        const jsFilePath = config.sys.path.join(sourceFileDir, sourceFileName + '.js');
	        const moduleFile = {
	            sourceFilePath: sourceFilePath,
	            jsFilePath: jsFilePath,
	            cmps: [],
	            coreRuntimeApis: [],
	            collectionName: null,
	            dtsFilePath: null,
	            excludeFromCollection: false,
	            externalImports: [],
	            hasVdomAttribute: false,
	            hasVdomXlink: false,
	            hasVdomClass: false,
	            hasVdomFunctional: false,
	            hasVdomKey: false,
	            hasVdomListener: false,
	            hasVdomPropOrAttr: false,
	            hasVdomRef: false,
	            hasVdomRender: false,
	            hasVdomStyle: false,
	            hasVdomText: false,
	            htmlAttrNames: [],
	            htmlTagNames: [],
	            isCollectionDependency: false,
	            isLegacy: false,
	            localImports: [],
	            originalCollectionComponentPath: null,
	            originalImports: [],
	            potentialCmpRefs: []
	        };
	        compilerCtx.moduleMap.set(sourceFilePath, moduleFile);
	        return moduleFile;
	    }
	};
	const resetModule = (moduleFile) => {
	    moduleFile.cmps.length = 0;
	    moduleFile.coreRuntimeApis.length = 0;
	    moduleFile.collectionName = null;
	    moduleFile.dtsFilePath = null;
	    moduleFile.excludeFromCollection = false;
	    moduleFile.externalImports.length = 0;
	    moduleFile.isCollectionDependency = false;
	    moduleFile.localImports.length = 0;
	    moduleFile.originalCollectionComponentPath = null;
	    moduleFile.originalImports.length = 0;
	    moduleFile.hasVdomXlink = false;
	    moduleFile.hasVdomAttribute = false;
	    moduleFile.hasVdomClass = false;
	    moduleFile.hasVdomFunctional = false;
	    moduleFile.hasVdomKey = false;
	    moduleFile.hasVdomListener = false;
	    moduleFile.hasVdomRef = false;
	    moduleFile.hasVdomRender = false;
	    moduleFile.hasVdomStyle = false;
	    moduleFile.hasVdomText = false;
	    moduleFile.htmlAttrNames.length = 0;
	    moduleFile.htmlTagNames.length = 0;
	    moduleFile.potentialCmpRefs.length = 0;
	};

	const styleToStatic = (config, newMembers, componentOptions) => {
	    const defaultModeStyles = [];
	    if (componentOptions.styleUrls) {
	        if (Array.isArray(componentOptions.styleUrls)) {
	            defaultModeStyles.push(...normalizeStyleUrl(componentOptions.styleUrls));
	        }
	        else {
	            defaultModeStyles.push(...normalizeStyleUrl(componentOptions.styleUrls[DEFAULT_STYLE_MODE]));
	        }
	    }
	    if (componentOptions.styleUrl) {
	        defaultModeStyles.push(...normalizeStyleUrl(componentOptions.styleUrl));
	    }
	    let styleUrls = {};
	    if (componentOptions.styleUrls && !Array.isArray(componentOptions.styleUrls)) {
	        styleUrls = normalizeStyleUrls(componentOptions.styleUrls);
	    }
	    if (defaultModeStyles.length > 0) {
	        styleUrls[DEFAULT_STYLE_MODE] = defaultModeStyles;
	    }
	    if (Object.keys(styleUrls).length > 0) {
	        const originalStyleUrls = convertValueToLiteral(styleUrls);
	        newMembers.push(createStaticGetter('originalStyleUrls', originalStyleUrls));
	        const norlizedStyleExt = normalizeExtension(config, styleUrls);
	        const normalizedStyleExp = convertValueToLiteral(norlizedStyleExt);
	        newMembers.push(createStaticGetter('styleUrls', normalizedStyleExp));
	    }
	    if (typeof componentOptions.styles === 'string') {
	        const styles = componentOptions.styles.trim();
	        if (styles.length > 0) {
	            newMembers.push(createStaticGetter('styles', ts.createLiteral(styles)));
	        }
	    }
	    else if (componentOptions.styles) {
	        const convertIdentifier = componentOptions.styles;
	        if (convertIdentifier.__identifier) {
	            newMembers.push(createStaticGetter('styles', ts.createIdentifier(convertIdentifier.__escapedText)));
	        }
	    }
	};
	const normalizeExtension = (config, styleUrls) => {
	    const compilerStyleUrls = {};
	    Object.keys(styleUrls).forEach(key => {
	        compilerStyleUrls[key] = styleUrls[key].map(s => useCss(config, s));
	    });
	    return compilerStyleUrls;
	};
	const useCss = (config, stylePath) => {
	    const sourceFileDir = config.sys.path.dirname(stylePath);
	    const sourceFileExt = config.sys.path.extname(stylePath);
	    const sourceFileName = config.sys.path.basename(stylePath, sourceFileExt);
	    return config.sys.path.join(sourceFileDir, sourceFileName + '.css');
	};
	const normalizeStyleUrls = (styleUrls) => {
	    const compilerStyleUrls = {};
	    Object.keys(styleUrls).forEach(key => {
	        compilerStyleUrls[key] = normalizeStyleUrl(styleUrls[key]);
	    });
	    return compilerStyleUrls;
	};
	const normalizeStyleUrl = (style) => {
	    if (Array.isArray(style)) {
	        return style;
	    }
	    if (style) {
	        return [style];
	    }
	    return [];
	};

	const componentDecoratorToStatic = (config, typeChecker, diagnostics, cmpNode, newMembers, componentDecorator) => {
	    removeDecorators(cmpNode, CLASS_DECORATORS_TO_REMOVE);
	    const [componentOptions] = getDeclarationParameters(componentDecorator);
	    if (!componentOptions) {
	        return;
	    }
	    if (!validateComponent(config, diagnostics, typeChecker, componentOptions, cmpNode, componentDecorator)) {
	        return;
	    }
	    newMembers.push(createStaticGetter('is', convertValueToLiteral(componentOptions.tag.trim())));
	    if (componentOptions.shadow) {
	        newMembers.push(createStaticGetter('encapsulation', convertValueToLiteral('shadow')));
	        if (typeof componentOptions.shadow !== 'boolean') {
	            if (componentOptions.shadow.delegatesFocus === true) {
	                newMembers.push(createStaticGetter('delegatesFocus', convertValueToLiteral(true)));
	            }
	        }
	    }
	    else if (componentOptions.scoped) {
	        newMembers.push(createStaticGetter('encapsulation', convertValueToLiteral('scoped')));
	    }
	    styleToStatic(config, newMembers, componentOptions);
	    let assetsDirs = componentOptions.assetsDirs || [];
	    if (componentOptions.assetsDir) {
	        assetsDirs = [
	            ...assetsDirs,
	            componentOptions.assetsDir,
	        ];
	    }
	    if (assetsDirs.length > 0) {
	        newMembers.push(createStaticGetter('assetsDirs', convertValueToLiteral(assetsDirs)));
	    }
	};
	const validateComponent = (config, diagnostics, typeChecker, componentOptions, cmpNode, componentDecorator) => {
	    const extendNode = cmpNode.heritageClauses && cmpNode.heritageClauses.find(c => c.token === ts.SyntaxKind.ExtendsKeyword);
	    if (extendNode) {
	        const err = buildError(diagnostics);
	        err.messageText = `Classes decorated with @Component can not extend from a base class.
    Stencil needs to be able to switch between different base classes in order to implement the different output targets such as: lazy and raw web components.`;
	        augmentDiagnosticWithNode(config, err, extendNode);
	        return false;
	    }
	    if (componentOptions.shadow && componentOptions.scoped) {
	        const err = buildError(diagnostics);
	        err.messageText = `Components cannot be "scoped" and "shadow" at the same time, they are mutually exclusive configurations.`;
	        augmentDiagnosticWithNode(config, err, findTagNode('scoped', componentDecorator));
	        return false;
	    }
	    const constructor = cmpNode.members.find(ts.isConstructorDeclaration);
	    if (constructor && constructor.parameters.length > 0) {
	        const err = buildError(diagnostics);
	        err.messageText = `Classes decorated with @Component can not have a "constructor" that takes arguments.
    All data required by a component must be passed by using class properties decorated with @Prop()`;
	        augmentDiagnosticWithNode(config, err, constructor.parameters[0]);
	        return false;
	    }
	    // check if class has more than one decorator
	    const otherDecorator = cmpNode.decorators && cmpNode.decorators.find(d => d !== componentDecorator);
	    if (otherDecorator) {
	        const err = buildError(diagnostics);
	        err.messageText = `Classes decorated with @Component can not be decorated with more decorators.
    Stencil performs extensive static analysis on top of your components in order to generate the necessary metadata, runtime decorators at the components level make this task very hard.`;
	        augmentDiagnosticWithNode(config, err, otherDecorator);
	        return false;
	    }
	    const tag = componentOptions.tag;
	    if (typeof tag !== 'string' || tag.trim().length === 0) {
	        const err = buildError(diagnostics);
	        err.messageText = `tag missing in component decorator`;
	        augmentDiagnosticWithNode(config, err, componentDecorator);
	        return false;
	    }
	    const tagError = validateComponentTag(tag);
	    if (tagError) {
	        const err = buildError(diagnostics);
	        err.messageText = `${tagError}. Please refer to https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name for more info.`;
	        augmentDiagnosticWithNode(config, err, findTagNode('tag', componentDecorator));
	        return false;
	    }
	    if (!config._isTesting) {
	        const nonTypeExports = typeChecker.getExportsOfModule(typeChecker.getSymbolAtLocation(cmpNode.getSourceFile()))
	            .filter(symbol => (symbol.flags & (ts.SymbolFlags.Interface | ts.SymbolFlags.TypeAlias)) === 0)
	            .filter(symbol => symbol.name !== cmpNode.name.text);
	        nonTypeExports.forEach(symbol => {
	            const err = buildError(diagnostics);
	            err.messageText = `To allow efficient bundling, modules using @Component() can only have a single export which is the component class itself.
      Any other exports should be moved to a separate file.
      For further information check out: https://stenciljs.com/docs/module-bundling`;
	            const errorNode = symbol.valueDeclaration
	                ? symbol.valueDeclaration
	                : symbol.declarations[0];
	            augmentDiagnosticWithNode(config, err, errorNode);
	        });
	        if (nonTypeExports.length > 0) {
	            return false;
	        }
	    }
	    return true;
	};
	const findTagNode = (propName, node) => {
	    if (ts.isDecorator(node) && ts.isCallExpression(node.expression)) {
	        const arg = node.expression.arguments[0];
	        if (ts.isObjectLiteralExpression(arg)) {
	            arg.properties.forEach(p => {
	                if (ts.isPropertyAssignment(p)) {
	                    if (p.name.getText() === propName) {
	                        node = p.initializer;
	                    }
	                }
	            });
	        }
	    }
	    return node;
	};

	const elementDecoratorsToStatic = (diagnostics, decoratedMembers, typeChecker, newMembers) => {
	    const elementRefs = decoratedMembers
	        .filter(ts.isPropertyDeclaration)
	        .map(prop => parseElementDecorator(diagnostics, typeChecker, prop))
	        .filter(element => !!element);
	    if (elementRefs.length > 0) {
	        newMembers.push(createStaticGetter('elementRef', ts.createLiteral(elementRefs[0])));
	        if (elementRefs.length > 1) {
	            const error = buildError(diagnostics);
	            error.messageText = `It's not valid to add more than one Element() decorator`;
	        }
	    }
	};
	const parseElementDecorator = (_diagnostics, _typeChecker, prop) => {
	    const elementDecorator = prop.decorators && prop.decorators.find(isDecoratorNamed('Element'));
	    if (elementDecorator == null) {
	        return null;
	    }
	    return prop.name.getText();
	};

	const eventDecoratorsToStatic = (config, diagnostics, decoratedProps, typeChecker, newMembers) => {
	    const events = decoratedProps
	        .filter(ts.isPropertyDeclaration)
	        .map(prop => parseEventDecorator(config, diagnostics, typeChecker, prop))
	        .filter(ev => !!ev);
	    if (events.length > 0) {
	        newMembers.push(createStaticGetter('events', convertValueToLiteral(events)));
	    }
	};
	const parseEventDecorator = (config, diagnostics, typeChecker, prop) => {
	    const eventDecorator = prop.decorators.find(isDecoratorNamed('Event'));
	    if (eventDecorator == null) {
	        return null;
	    }
	    const [opts] = getDeclarationParameters(eventDecorator);
	    const memberName = prop.name.getText();
	    if (!memberName) {
	        return null;
	    }
	    const symbol = typeChecker.getSymbolAtLocation(prop.name);
	    const name = getEventName$1(opts, memberName);
	    validateEventName(config, diagnostics, prop.name, name);
	    const eventMeta = {
	        method: memberName,
	        name,
	        bubbles: opts && typeof opts.bubbles === 'boolean' ? opts.bubbles : true,
	        cancelable: opts && typeof opts.cancelable === 'boolean' ? opts.cancelable : true,
	        composed: opts && typeof opts.composed === 'boolean' ? opts.composed : true,
	        docs: serializeSymbol(typeChecker, symbol),
	        complexType: getComplexType(typeChecker, prop)
	    };
	    validateReferences(config, diagnostics, eventMeta.complexType.references, prop.type);
	    return eventMeta;
	};
	const getEventName$1 = (eventOptions, memberName) => {
	    if (eventOptions && typeof eventOptions.eventName === 'string' && eventOptions.eventName.trim().length > 0) {
	        // always use the event name if given
	        return eventOptions.eventName.trim();
	    }
	    return memberName;
	};
	const getComplexType = (typeChecker, node) => {
	    const sourceFile = node.getSourceFile();
	    const eventType = node.type ? getEventType(node.type) : null;
	    return {
	        original: eventType ? eventType.getText() : 'any',
	        resolved: eventType ? resolveType(typeChecker, typeChecker.getTypeFromTypeNode(eventType)) : 'any',
	        references: eventType ? getAttributeTypeInfo(eventType, sourceFile) : {}
	    };
	};
	const getEventType = (type) => {
	    if (ts.isTypeReferenceNode(type) &&
	        ts.isIdentifier(type.typeName) &&
	        type.typeName.text === 'EventEmitter' &&
	        type.typeArguments &&
	        type.typeArguments.length > 0) {
	        return type.typeArguments[0];
	    }
	    return null;
	};
	const validateEventName = (config, diagnostics, node, eventName) => {
	    if (/^[A-Z]/.test(eventName)) {
	        const diagnostic = buildWarn(diagnostics);
	        diagnostic.messageText = [
	            `In order to be compatible with all event listeners on elements, the event name `,
	            `cannot start with a capital letter. `,
	            `Please lowercase the first character for the event to best work with all listeners.`
	        ].join('');
	        augmentDiagnosticWithNode(config, diagnostic, node);
	        return;
	    }
	    if (/^on[A-Z]/.test(eventName)) {
	        const warn = buildWarn(diagnostics);
	        warn.messageText = `Events decorated with @Event() should describe the actual DOM event name, not the handler. In other words "${eventName}" would be better named as "${suggestEventName(eventName)}".`;
	        augmentDiagnosticWithNode(config, warn, node);
	        return;
	    }
	    if (DOM_EVENT_NAMES.has(eventName.toLowerCase())) {
	        const diagnostic = buildWarn(diagnostics);
	        diagnostic.messageText = `The event name conflicts with the "${eventName}" native DOM event name.`;
	        augmentDiagnosticWithNode(config, diagnostic, node);
	        return;
	    }
	};
	function suggestEventName(onEvent) {
	    return onEvent[2].toLowerCase() + onEvent.slice(3);
	}
	const DOM_EVENT_NAMES = new Set([
	    'CheckboxStateChange',
	    'DOMContentLoaded',
	    'DOMMenuItemActive',
	    'DOMMenuItemInactive',
	    'DOMMouseScroll',
	    'MSManipulationStateChanged',
	    'MSPointerHover',
	    'MozAudioAvailable',
	    'MozGamepadButtonDown',
	    'MozGamepadButtonUp',
	    'MozMousePixelScroll',
	    'MozOrientation',
	    'MozScrolledAreaChanged',
	    'RadioStateChange',
	    'SVGAbort',
	    'SVGError',
	    'SVGLoad',
	    'SVGResize',
	    'SVGScroll',
	    'SVGUnload',
	    'SVGZoom',
	    'ValueChange',
	    'abort',
	    'afterprint',
	    'afterscriptexecute',
	    'alerting',
	    'animationcancel',
	    'animationend',
	    'animationiteration',
	    'animationstart',
	    'appinstalled',
	    'audioend',
	    'audioprocess',
	    'audiostart',
	    'auxclick',
	    'beforeinstallprompt',
	    'beforeprint',
	    'beforescriptexecute',
	    'beforeunload',
	    'beginEvent',
	    'blur',
	    'boundary',
	    'broadcast',
	    'busy',
	    'callschanged',
	    'canplay',
	    'canplaythrough',
	    'cardstatechange',
	    'cfstatechange',
	    'change',
	    'chargingchange',
	    'chargingtimechange',
	    'checking',
	    'click',
	    'command',
	    'commandupdate',
	    'compassneedscalibration',
	    'complete',
	    'compositionend',
	    'compositionstart',
	    'compositionupdate',
	    'connected',
	    'connecting',
	    'connectionInfoUpdate',
	    'contextmenu',
	    'copy',
	    'cut',
	    'datachange',
	    'dataerror',
	    'dblclick',
	    'delivered',
	    'devicechange',
	    'devicemotion',
	    'deviceorientation',
	    'dialing',
	    'disabled',
	    'dischargingtimechange',
	    'disconnected',
	    'disconnecting',
	    'downloading',
	    'drag',
	    'dragend',
	    'dragenter',
	    'dragleave',
	    'dragover',
	    'dragstart',
	    'drop',
	    'durationchange',
	    'emptied',
	    'enabled',
	    'end',
	    'endEvent',
	    'ended',
	    'error',
	    'focus',
	    'focusin',
	    'focusout',
	    'fullscreenchange',
	    'fullscreenerror',
	    'gamepadconnected',
	    'gamepaddisconnected',
	    'gotpointercapture',
	    'hashchange',
	    'held',
	    'holding',
	    'icccardlockerror',
	    'iccinfochange',
	    'incoming',
	    'input',
	    'invalid',
	    'keydown',
	    'keypress',
	    'keyup',
	    'languagechange',
	    'levelchange',
	    'load',
	    'loadeddata',
	    'loadedmetadata',
	    'loadend',
	    'loadstart',
	    'localized',
	    'lostpointercapture',
	    'mark',
	    'message',
	    'messageerror',
	    'mousedown',
	    'mouseenter',
	    'mouseleave',
	    'mousemove',
	    'mouseout',
	    'mouseover',
	    'mouseup',
	    'mousewheel',
	    'mozbrowseractivitydone',
	    'mozbrowserasyncscroll',
	    'mozbrowseraudioplaybackchange',
	    'mozbrowsercaretstatechanged',
	    'mozbrowserclose',
	    'mozbrowsercontextmenu',
	    'mozbrowserdocumentfirstpaint',
	    'mozbrowsererror',
	    'mozbrowserfindchange',
	    'mozbrowserfirstpaint',
	    'mozbrowsericonchange',
	    'mozbrowserloadend',
	    'mozbrowserloadstart',
	    'mozbrowserlocationchange',
	    'mozbrowsermanifestchange',
	    'mozbrowsermetachange',
	    'mozbrowseropensearch',
	    'mozbrowseropentab',
	    'mozbrowseropenwindow',
	    'mozbrowserresize',
	    'mozbrowserscroll',
	    'mozbrowserscrollareachanged',
	    'mozbrowserscrollviewchange',
	    'mozbrowsersecuritychange',
	    'mozbrowserselectionstatechanged',
	    'mozbrowsershowmodalprompt',
	    'mozbrowsertitlechange',
	    'mozbrowserusernameandpasswordrequired',
	    'mozbrowservisibilitychange',
	    'moztimechange',
	    'msContentZoom',
	    'nomatch',
	    'notificationclick',
	    'noupdate',
	    'obsolete',
	    'offline',
	    'online',
	    'orientationchange',
	    'overflow',
	    'pagehide',
	    'pageshow',
	    'paste',
	    'pause',
	    'play',
	    'playing',
	    'pointercancel',
	    'pointerdown',
	    'pointerenter',
	    'pointerleave',
	    'pointerlockchange',
	    'pointerlockerror',
	    'pointermove',
	    'pointerout',
	    'pointerover',
	    'pointerup',
	    'popstate',
	    'popuphidden',
	    'popuphiding',
	    'popupshowing',
	    'popupshown',
	    'progress',
	    'push',
	    'pushsubscriptionchange',
	    'ratechange',
	    'readystatechange',
	    'received',
	    'repeatEvent',
	    'reset',
	    'resize',
	    'resourcetimingbufferfull',
	    'result',
	    'resume',
	    'resuming',
	    'scroll',
	    'seeked',
	    'seeking',
	    'select',
	    'selectionchange',
	    'selectstart',
	    'sent',
	    'show',
	    'slotchange',
	    'smartcard-insert',
	    'smartcard-remove',
	    'soundend',
	    'soundstart',
	    'speechend',
	    'speechstart',
	    'stalled',
	    'start',
	    'statechange',
	    'statuschange',
	    'stkcommand',
	    'stksessionend',
	    'storage',
	    'submit',
	    'suspend',
	    'timeout',
	    'timeupdate',
	    'touchcancel',
	    'touchend',
	    'touchenter',
	    'touchleave',
	    'touchmove',
	    'touchstart',
	    'transitioncancel',
	    'transitionend',
	    'transitionrun',
	    'transitionstart',
	    'underflow',
	    'unload',
	    'updateready',
	    'userproximity',
	    'ussdreceived',
	    'visibilitychange',
	    'voicechange',
	    'voiceschanged',
	    'volumechange',
	    'vrdisplayactivate',
	    'vrdisplayblur',
	    'vrdisplayconnect',
	    'vrdisplaydeactivate',
	    'vrdisplaydisconnect',
	    'vrdisplayfocus',
	    'vrdisplaypresentchange',
	    'waiting',
	    'wheel',
	].map(e => e.toLowerCase()));

	const listenDecoratorsToStatic = (config, diagnostics, decoratedMembers, newMembers) => {
	    const listeners = decoratedMembers
	        .filter(ts.isMethodDeclaration)
	        .map(method => parseListenDecorators(config, diagnostics, method));
	    const flatListeners = flatOne(listeners);
	    if (flatListeners.length > 0) {
	        newMembers.push(createStaticGetter('listeners', convertValueToLiteral(flatListeners)));
	    }
	};
	const parseListenDecorators = (config, diagnostics, method) => {
	    const listenDecorators = method.decorators.filter(isDecoratorNamed('Listen'));
	    if (listenDecorators.length === 0) {
	        return [];
	    }
	    return listenDecorators.map(listenDecorator => {
	        const methodName = method.name.getText();
	        const [listenText, listenOptions] = getDeclarationParameters(listenDecorator);
	        const eventNames = listenText.split(',');
	        if (eventNames.length > 1) {
	            const err = buildError(diagnostics);
	            err.messageText = 'Please use multiple @Listen() decorators instead of comma-separated names.';
	            augmentDiagnosticWithNode(config, err, listenDecorator);
	        }
	        return parseListener(config, diagnostics, eventNames[0], listenOptions, methodName, listenDecorator);
	    });
	};
	const parseListener = (config, diagnostics, eventName, opts = {}, methodName, decoratorNode) => {
	    let rawEventName = eventName.trim();
	    let target = opts.target;
	    // DEPRECATED: handle old syntax (`TARGET:event`)
	    if (!target) {
	        const splt = eventName.split(':');
	        const prefix = splt[0].toLowerCase().trim();
	        if (splt.length > 1 && isValidTargetValue(prefix)) {
	            rawEventName = splt[1].trim();
	            target = prefix;
	            const warn = buildWarn(diagnostics);
	            warn.messageText = `Deprecated @Listen() feature on "${methodName}". Use @Listen('${rawEventName}', { target: '${prefix}' }) instead.`;
	            augmentDiagnosticWithNode(config, warn, decoratorNode);
	        }
	    }
	    // DEPRECATED: handle keycode syntax (`event:KEY`)
	    const [finalEvent, keycode, rest] = rawEventName.split('.');
	    if (rest === undefined && isValidKeycodeSuffix(keycode)) {
	        rawEventName = finalEvent;
	        const warn = buildError(diagnostics);
	        warn.messageText = `Deprecated @Listen() feature on "${methodName}". Using "${rawEventName}" is no longer supported, use "event.key" within the function itself instead.`;
	        augmentDiagnosticWithNode(config, warn, decoratorNode);
	    }
	    const listener = {
	        name: rawEventName,
	        method: methodName,
	        target,
	        capture: (typeof opts.capture === 'boolean') ? opts.capture : false,
	        passive: (typeof opts.passive === 'boolean') ? opts.passive :
	            // if the event name is kown to be a passive event then set it to true
	            (PASSIVE_TRUE_DEFAULTS.has(rawEventName.toLowerCase())),
	    };
	    return listener;
	};
	const isValidTargetValue = (prefix) => {
	    return (VALID_ELEMENT_REF_PREFIXES.has(prefix));
	};
	const isValidKeycodeSuffix = (prefix) => {
	    return (VALID_KEYCODE_SUFFIX.has(prefix));
	};
	const PASSIVE_TRUE_DEFAULTS = new Set([
	    'dragstart', 'drag', 'dragend', 'dragenter', 'dragover', 'dragleave', 'drop',
	    'mouseenter', 'mouseover', 'mousemove', 'mousedown', 'mouseup', 'mouseleave', 'mouseout', 'mousewheel',
	    'pointerover', 'pointerenter', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerout', 'pointerleave',
	    'resize',
	    'scroll',
	    'touchstart', 'touchmove', 'touchend', 'touchenter', 'touchleave', 'touchcancel',
	    'wheel',
	]);
	const VALID_ELEMENT_REF_PREFIXES = new Set([
	    'parent', 'body', 'document', 'window'
	]);
	const VALID_KEYCODE_SUFFIX = new Set([
	    'enter', 'escape', 'space', 'tab', 'up', 'right', 'down', 'left'
	]);

	const validatePublicName = (config, diagnostics, memberName, decorator, memberType, node) => {
	    if (RESERVED_PUBLIC_MEMBERS.has(memberName.toLowerCase())) {
	        const warn = buildWarn(diagnostics);
	        warn.messageText = [
	            `The ${decorator} name "${memberName}" is a reserved public name. `,
	            `Please rename the "${memberName}" ${memberType} so it does not conflict with an existing standardized prototype member. `,
	            `Reusing ${memberType} names that are already defined on the element's prototype may cause `,
	            `unexpected runtime errors or user-interface issues on various browsers, so it's best to avoid them entirely.`
	        ].join('');
	        augmentDiagnosticWithNode(config, warn, node);
	        return;
	    }
	};
	const HTML_ELEMENT_KEYS = [
	    'title',
	    'lang',
	    'translate',
	    'dir',
	    // 'dataset',
	    // 'hidden',
	    'tabIndex',
	    'accessKey',
	    'draggable',
	    // 'spellcheck',
	    // 'autocapitalize',
	    'contentEditable',
	    'isContentEditable',
	    // 'inputMode',
	    'offsetParent',
	    'offsetTop',
	    'offsetLeft',
	    'offsetWidth',
	    'offsetHeight',
	    'style',
	    'innerText',
	    'outerText',
	    'oncopy',
	    'oncut',
	    'onpaste',
	    'onabort',
	    'onblur',
	    'oncancel',
	    'oncanplay',
	    'oncanplaythrough',
	    'onchange',
	    'onclick',
	    'onclose',
	    'oncontextmenu',
	    'oncuechange',
	    'ondblclick',
	    'ondrag',
	    'ondragend',
	    'ondragenter',
	    'ondragleave',
	    'ondragover',
	    'ondragstart',
	    'ondrop',
	    'ondurationchange',
	    'onemptied',
	    'onended',
	    'onerror',
	    'onfocus',
	    'oninput',
	    'oninvalid',
	    'onkeydown',
	    'onkeypress',
	    'onkeyup',
	    'onload',
	    'onloadeddata',
	    'onloadedmetadata',
	    'onloadstart',
	    'onmousedown',
	    'onmouseenter',
	    'onmouseleave',
	    'onmousemove',
	    'onmouseout',
	    'onmouseover',
	    'onmouseup',
	    'onmousewheel',
	    'onpause',
	    'onplay',
	    'onplaying',
	    'onprogress',
	    'onratechange',
	    'onreset',
	    'onresize',
	    'onscroll',
	    'onseeked',
	    'onseeking',
	    'onselect',
	    'onstalled',
	    'onsubmit',
	    'onsuspend',
	    'ontimeupdate',
	    'ontoggle',
	    'onvolumechange',
	    'onwaiting',
	    'onwheel',
	    'onauxclick',
	    'ongotpointercapture',
	    'onlostpointercapture',
	    'onpointerdown',
	    'onpointermove',
	    'onpointerup',
	    'onpointercancel',
	    'onpointerover',
	    'onpointerout',
	    'onpointerenter',
	    'onpointerleave',
	    'onselectstart',
	    'onselectionchange',
	    'nonce',
	    'click',
	    'focus',
	    'blur'
	];
	const ELEMENT_KEYS = [
	    'namespaceURI',
	    'prefix',
	    'localName',
	    'tagName',
	    'id',
	    'className',
	    'classList',
	    'slot',
	    'attributes',
	    'shadowRoot',
	    'assignedSlot',
	    'innerHTML',
	    'outerHTML',
	    'scrollTop',
	    'scrollLeft',
	    'scrollWidth',
	    'scrollHeight',
	    'clientTop',
	    'clientLeft',
	    'clientWidth',
	    'clientHeight',
	    'attributeStyleMap',
	    'onbeforecopy',
	    'onbeforecut',
	    'onbeforepaste',
	    'onsearch',
	    'previousElementSibling',
	    'nextElementSibling',
	    'children',
	    'firstElementChild',
	    'lastElementChild',
	    'childElementCount',
	    'onfullscreenchange',
	    'onfullscreenerror',
	    'onwebkitfullscreenchange',
	    'onwebkitfullscreenerror',
	    'setPointerCapture',
	    'releasePointerCapture',
	    'hasPointerCapture',
	    'hasAttributes',
	    'getAttributeNames',
	    'getAttribute',
	    'getAttributeNS',
	    'setAttribute',
	    'setAttributeNS',
	    'removeAttribute',
	    'removeAttributeNS',
	    'hasAttribute',
	    'hasAttributeNS',
	    'toggleAttribute',
	    'getAttributeNode',
	    'getAttributeNodeNS',
	    'setAttributeNode',
	    'setAttributeNodeNS',
	    'removeAttributeNode',
	    'closest',
	    'matches',
	    'webkitMatchesSelector',
	    'attachShadow',
	    'getElementsByTagName',
	    'getElementsByTagNameNS',
	    'getElementsByClassName',
	    'insertAdjacentElement',
	    'insertAdjacentText',
	    'insertAdjacentHTML',
	    'requestPointerLock',
	    'getClientRects',
	    'getBoundingClientRect',
	    'scrollIntoView',
	    'scroll',
	    'scrollTo',
	    'scrollBy',
	    'scrollIntoViewIfNeeded',
	    'animate',
	    'computedStyleMap',
	    'before',
	    'after',
	    'replaceWith',
	    'remove',
	    'prepend',
	    'append',
	    'querySelector',
	    'querySelectorAll',
	    'requestFullscreen',
	    'webkitRequestFullScreen',
	    'webkitRequestFullscreen',
	    'part',
	    'createShadowRoot',
	    'getDestinationInsertionPoints'
	];
	const NODE_KEYS = [
	    'ELEMENT_NODE',
	    'ATTRIBUTE_NODE',
	    'TEXT_NODE',
	    'CDATA_SECTION_NODE',
	    'ENTITY_REFERENCE_NODE',
	    'ENTITY_NODE',
	    'PROCESSING_INSTRUCTION_NODE',
	    'COMMENT_NODE',
	    'DOCUMENT_NODE',
	    'DOCUMENT_TYPE_NODE',
	    'DOCUMENT_FRAGMENT_NODE',
	    'NOTATION_NODE',
	    'DOCUMENT_POSITION_DISCONNECTED',
	    'DOCUMENT_POSITION_PRECEDING',
	    'DOCUMENT_POSITION_FOLLOWING',
	    'DOCUMENT_POSITION_CONTAINS',
	    'DOCUMENT_POSITION_CONTAINED_BY',
	    'DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
	    'nodeType',
	    'nodeName',
	    'baseURI',
	    'isConnected',
	    'ownerDocument',
	    'parentNode',
	    'parentElement',
	    'childNodes',
	    'firstChild',
	    'lastChild',
	    'previousSibling',
	    'nextSibling',
	    'nodeValue',
	    'textContent',
	    'hasChildNodes',
	    'getRootNode',
	    'normalize',
	    'cloneNode',
	    'isEqualNode',
	    'isSameNode',
	    'compareDocumentPosition',
	    'contains',
	    'lookupPrefix',
	    'lookupNamespaceURI',
	    'isDefaultNamespace',
	    'insertBefore',
	    'appendChild',
	    'replaceChild',
	    'removeChild'
	];
	const JSX_KEYS = [
	    'ref',
	    'key'
	];
	const ALL_KEYS = [
	    ...HTML_ELEMENT_KEYS,
	    ...ELEMENT_KEYS,
	    ...NODE_KEYS,
	    ...JSX_KEYS,
	].map(p => p.toLowerCase());
	const RESERVED_PUBLIC_MEMBERS = new Set(ALL_KEYS);

	const methodDecoratorsToStatic = (config, diagnostics, sourceFile, decoratedProps, typeChecker, newMembers) => {
	    const methods = decoratedProps
	        .filter(ts.isMethodDeclaration)
	        .map(method => parseMethodDecorator(config, diagnostics, sourceFile, typeChecker, method))
	        .filter(method => !!method);
	    if (methods.length > 0) {
	        newMembers.push(createStaticGetter('methods', ts.createObjectLiteral(methods, true)));
	    }
	};
	const parseMethodDecorator = (config, diagnostics, sourceFile, typeChecker, method) => {
	    const methodDecorator = method.decorators.find(isDecoratorNamed('Method'));
	    if (methodDecorator == null) {
	        return null;
	    }
	    const methodName = method.name.getText();
	    const flags = ts.TypeFormatFlags.WriteArrowStyleSignature | ts.TypeFormatFlags.NoTruncation;
	    const signature = typeChecker.getSignatureFromDeclaration(method);
	    const returnType = typeChecker.getReturnTypeOfSignature(signature);
	    const returnTypeNode = typeChecker.typeToTypeNode(returnType);
	    let returnString = typeToString(typeChecker, returnType);
	    let signatureString = typeChecker.signatureToString(signature, method, flags, ts.SignatureKind.Call);
	    if (!config._isTesting) {
	        if (returnString === 'void') {
	            const warn = buildWarn(diagnostics);
	            warn.header = '@Method requires async';
	            warn.messageText = `External @Method() ${methodName}() must return a Promise.\n\n Consider prefixing the method with async, such as @Method async ${methodName}().`;
	            augmentDiagnosticWithNode(config, warn, method.name);
	            returnString = 'Promise<void>';
	            signatureString = signatureString.replace(/=> void$/, '=> Promise<void>');
	        }
	        else if (!isTypePromise(returnString)) {
	            const err = buildError(diagnostics);
	            err.header = '@Method requires async';
	            err.messageText = `External @Method() ${methodName}() must return a Promise.\n\n Consider prefixing the method with async, such as @Method async ${methodName}().`;
	            augmentDiagnosticWithNode(config, err, method.name);
	        }
	    }
	    if (isMemberPrivate(method)) {
	        const err = buildError(diagnostics);
	        err.messageText = 'Methods decorated with the @Method() decorator cannot be "private" nor "protected". More info: https://stenciljs.com/docs/methods';
	        augmentDiagnosticWithNode(config, err, method.modifiers[0]);
	    }
	    // Validate if the method name does not conflict with existing public names
	    validatePublicName(config, diagnostics, methodName, '@Method()', 'method', method.name);
	    const methodMeta = {
	        complexType: {
	            signature: signatureString,
	            parameters: signature.parameters.map(symbol => serializeSymbol(typeChecker, symbol)),
	            references: Object.assign(Object.assign({}, getAttributeTypeInfo(returnTypeNode, sourceFile)), getAttributeTypeInfo(method, sourceFile)),
	            return: returnString
	        },
	        docs: {
	            text: ts.displayPartsToString(signature.getDocumentationComment(typeChecker)),
	            tags: signature.getJsDocTags()
	        }
	    };
	    validateReferences(config, diagnostics, methodMeta.complexType.references, method.type || method.name);
	    const staticProp = ts.createPropertyAssignment(ts.createLiteral(methodName), convertValueToLiteral(methodMeta));
	    return staticProp;
	};
	const isTypePromise = (typeStr) => {
	    return /^Promise<.+>$/.test(typeStr);
	};

	const propDecoratorsToStatic = (config, diagnostics, decoratedProps, typeChecker, newMembers) => {
	    const connect = [];
	    const context = [];
	    const properties = decoratedProps
	        .filter(ts.isPropertyDeclaration)
	        .map(prop => parsePropDecorator(config, diagnostics, typeChecker, prop, context, connect, newMembers))
	        .filter(prop => prop != null);
	    if (properties.length > 0) {
	        newMembers.push(createStaticGetter('properties', ts.createObjectLiteral(properties, true)));
	    }
	    if (context.length > 0) {
	        newMembers.push(createStaticGetter('contextProps', convertValueToLiteral(context)));
	    }
	    if (connect.length > 0) {
	        newMembers.push(createStaticGetter('connectProps', convertValueToLiteral(connect)));
	    }
	};
	const parsePropDecorator = (config, diagnostics, typeChecker, prop, context, connect, newMembers) => {
	    const propDecorator = prop.decorators.find(isDecoratorNamed('Prop'));
	    if (propDecorator == null) {
	        return null;
	    }
	    const propName = prop.name.getText();
	    const propOptions = getPropOptions(propDecorator, diagnostics);
	    if (propOptions.context) {
	        context.push({
	            name: propName,
	            context: propOptions.context,
	        });
	        removeProp(prop, newMembers);
	        return null;
	    }
	    if (propOptions.connect) {
	        connect.push({
	            name: propName,
	            connect: propOptions.connect,
	        });
	        removeProp(prop, newMembers);
	        return null;
	    }
	    if (isMemberPrivate(prop)) {
	        const err = buildError(diagnostics);
	        err.messageText = 'Properties decorated with the @Prop() decorator cannot be "private" nor "protected". More info: https://stenciljs.com/docs/properties';
	        augmentDiagnosticWithNode(config, err, prop.modifiers[0]);
	    }
	    if (/^on(-|[A-Z])/.test(propName)) {
	        const warn = buildWarn(diagnostics);
	        warn.messageText = `The @Prop() name "${propName}" looks like an event. Please use the "@Event()" decorator to expose events instead, not properties or methods.`;
	        augmentDiagnosticWithNode(config, warn, prop.name);
	    }
	    else {
	        validatePublicName(config, diagnostics, propName, '@Prop()', 'prop', prop.name);
	    }
	    const symbol = typeChecker.getSymbolAtLocation(prop.name);
	    const type = typeChecker.getTypeAtLocation(prop);
	    const typeStr = propTypeFromTSType(type);
	    const propMeta = {
	        type: typeStr,
	        mutable: !!propOptions.mutable,
	        complexType: getComplexType$1(typeChecker, prop, type),
	        required: prop.exclamationToken !== undefined && propName !== 'mode',
	        optional: prop.questionToken !== undefined,
	        docs: serializeSymbol(typeChecker, symbol)
	    };
	    validateReferences(config, diagnostics, propMeta.complexType.references, prop.type);
	    // prop can have an attribute if type is NOT "unknown"
	    if (typeStr !== 'unknown') {
	        propMeta.attribute = getAttributeName(config, diagnostics, propName, propOptions, propDecorator);
	        propMeta.reflect = getReflect(diagnostics, propOptions);
	    }
	    // extract default value
	    const initializer = prop.initializer;
	    if (initializer) {
	        propMeta.defaultValue = initializer.getText();
	    }
	    const staticProp = ts.createPropertyAssignment(ts.createLiteral(propName), convertValueToLiteral(propMeta));
	    return staticProp;
	};
	const getAttributeName = (config, diagnostics, propName, propOptions, node) => {
	    if (propOptions.attribute === null) {
	        return undefined;
	    }
	    if (typeof propOptions.attribute === 'string' && propOptions.attribute.trim().length > 0) {
	        return propOptions.attribute.trim().toLowerCase();
	    }
	    if (typeof propOptions.attr === 'string' && propOptions.attr.trim().length > 0) {
	        const diagnostic = buildWarn(diagnostics);
	        diagnostic.messageText = `@Prop option "attr" has been deprecated. Please use "attribute" instead.`;
	        augmentDiagnosticWithNode(config, diagnostic, node);
	        return propOptions.attr.trim().toLowerCase();
	    }
	    return toDashCase(propName);
	};
	const getReflect = (_diagnostics, propOptions) => {
	    if (typeof propOptions.reflect === 'boolean') {
	        return propOptions.reflect;
	    }
	    if (typeof propOptions.reflectToAttr === 'boolean') {
	        // const diagnostic = buildWarn(diagnostics);
	        // diagnostic.messageText = `@Prop option "reflectToAttr" has been depreciated. Please use "reflect" instead.`;
	        return propOptions.reflectToAttr;
	    }
	    return false;
	};
	const getPropOptions = (propDecorator, diagnostics) => {
	    if (propDecorator.expression == null) {
	        return {};
	    }
	    const suppliedOptions = propDecorator.expression.arguments
	        .map(arg => {
	        try {
	            const fnStr = `return ${arg.getText()};`;
	            return new Function(fnStr)();
	        }
	        catch (e) {
	            catchError(diagnostics, e, `parse prop options: ${e}`);
	        }
	    });
	    const propOptions = suppliedOptions[0];
	    return propOptions || {};
	};
	const getComplexType$1 = (typeChecker, node, type) => {
	    const nodeType = node.type;
	    return {
	        original: nodeType ? nodeType.getText() : typeToString(typeChecker, type),
	        resolved: resolveType(typeChecker, type),
	        references: getAttributeTypeInfo(node, node.getSourceFile())
	    };
	};
	const propTypeFromTSType = (type) => {
	    const isAnyType = checkType(type, isAny);
	    if (isAnyType) {
	        return 'any';
	    }
	    const isStr = checkType(type, isString);
	    const isNu = checkType(type, isNumber);
	    const isBool = checkType(type, isBoolean);
	    // if type is more than a primitive type at the same time, we mark it as any
	    if (Number(isStr) + Number(isNu) + Number(isBool) > 1) {
	        return 'any';
	    }
	    // at this point we know the prop's type is NOT the mix of primitive types
	    if (isStr) {
	        return 'string';
	    }
	    if (isNu) {
	        return 'number';
	    }
	    if (isBool) {
	        return 'boolean';
	    }
	    return 'unknown';
	};
	const checkType = (type, check) => {
	    if (type.flags & ts.TypeFlags.Union) {
	        const union = type;
	        if (union.types.some(type => checkType(type, check))) {
	            return true;
	        }
	    }
	    return check(type);
	};
	const isBoolean = (t) => {
	    if (t) {
	        return !!(t.flags & (ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLike | ts.TypeFlags.BooleanLike));
	    }
	    return false;
	};
	const isNumber = (t) => {
	    if (t) {
	        return !!(t.flags & (ts.TypeFlags.Number | ts.TypeFlags.NumberLike | ts.TypeFlags.NumberLiteral));
	    }
	    return false;
	};
	const isString = (t) => {
	    if (t) {
	        return !!(t.flags & (ts.TypeFlags.String | ts.TypeFlags.StringLike | ts.TypeFlags.StringLiteral));
	    }
	    return false;
	};
	const isAny = (t) => {
	    if (t) {
	        return !!(t.flags & ts.TypeFlags.Any);
	    }
	    return false;
	};
	const removeProp = (prop, classElements) => {
	    const index = classElements.findIndex(p => prop === p);
	    if (index >= 0) {
	        classElements.splice(index, 1);
	    }
	};

	const stateDecoratorsToStatic = (diagnostics, _sourceFile, decoratedProps, typeChecker, newMembers) => {
	    const states = decoratedProps
	        .filter(ts.isPropertyDeclaration)
	        .map(prop => stateDecoratorToStatic(diagnostics, typeChecker, prop))
	        .filter(state => !!state);
	    if (states.length > 0) {
	        newMembers.push(createStaticGetter('states', ts.createObjectLiteral(states, true)));
	    }
	};
	const stateDecoratorToStatic = (_diagnostics, _typeChecker, prop) => {
	    const stateDecorator = prop.decorators.find(isDecoratorNamed('State'));
	    if (stateDecorator == null) {
	        return null;
	    }
	    const stateName = prop.name.getText();
	    return ts.createPropertyAssignment(ts.createLiteral(stateName), ts.createObjectLiteral([], true));
	};

	const watchDecoratorsToStatic = (diagnostics, decoratedProps, newMembers) => {
	    const watchers = decoratedProps
	        .filter(ts.isMethodDeclaration)
	        .map(method => parseWatchDecorator(diagnostics, method));
	    const flatWatchers = flatOne(watchers);
	    if (flatWatchers.length > 0) {
	        newMembers.push(createStaticGetter('watchers', convertValueToLiteral(flatWatchers)));
	    }
	};
	const isWatchDecorator = isDecoratorNamed('Watch');
	const isPropWillChangeDecorator = isDecoratorNamed('PropWillChange');
	const isPropDidChangeDecorator = isDecoratorNamed('PropDidChange');
	const parseWatchDecorator = (_diagnostics, method) => {
	    const methodName = method.name.getText();
	    return method.decorators
	        .filter(decorator => (isWatchDecorator(decorator) ||
	        isPropWillChangeDecorator(decorator) ||
	        isPropDidChangeDecorator(decorator)))
	        .map(decorator => {
	        const [propName] = getDeclarationParameters(decorator);
	        return {
	            propName,
	            methodName
	        };
	    });
	};
	// TODO
	// const isPropWatchable = (cmpMeta: d.ComponentMeta, propName: string) => {
	//   const membersMeta = cmpMeta.membersMeta;
	//   if (!membersMeta) {
	//     return false;
	//   }
	//   const member = membersMeta[propName];
	//   if (!member) {
	//     return false;
	//   }
	// const type = member.memberType;
	// return type === MEMBER_FLAGS.State || type === MEMBER_FLAGS.Prop || type === MEMBER_FLAGS.PropMutable;
	// };

	const convertDecoratorsToStatic = (config, diagnostics, typeChecker) => {
	    return transformCtx => {
	        const visit = (tsSourceFile, node) => {
	            if (ts.isClassDeclaration(node)) {
	                node = visitClass(config, diagnostics, typeChecker, tsSourceFile, node);
	            }
	            return ts.visitEachChild(node, node => visit(tsSourceFile, node), transformCtx);
	        };
	        return tsSourceFile => {
	            return visit(tsSourceFile, tsSourceFile);
	        };
	    };
	};
	const visitClass = (config, diagnostics, typeChecker, tsSourceFile, cmpNode) => {
	    if (!cmpNode.decorators) {
	        return cmpNode;
	    }
	    const componentDecorator = cmpNode.decorators.find(isDecoratorNamed('Component'));
	    if (!componentDecorator) {
	        return cmpNode;
	    }
	    const newMembers = [...cmpNode.members];
	    // parser component decorator (Component)
	    componentDecoratorToStatic(config, typeChecker, diagnostics, cmpNode, newMembers, componentDecorator);
	    // parse member decorators (Prop, State, Listen, Event, Method, Element and Watch)
	    const decoratedMembers = newMembers.filter(member => Array.isArray(member.decorators) && member.decorators.length > 0);
	    if (decoratedMembers.length > 0) {
	        propDecoratorsToStatic(config, diagnostics, decoratedMembers, typeChecker, newMembers);
	        stateDecoratorsToStatic(diagnostics, tsSourceFile, decoratedMembers, typeChecker, newMembers);
	        eventDecoratorsToStatic(config, diagnostics, decoratedMembers, typeChecker, newMembers);
	        methodDecoratorsToStatic(config, diagnostics, tsSourceFile, decoratedMembers, typeChecker, newMembers);
	        elementDecoratorsToStatic(diagnostics, decoratedMembers, typeChecker, newMembers);
	        watchDecoratorsToStatic(diagnostics, decoratedMembers, newMembers);
	        listenDecoratorsToStatic(config, diagnostics, decoratedMembers, newMembers);
	        removeStencilDecorators(decoratedMembers);
	    }
	    return ts.updateClassDeclaration(cmpNode, cmpNode.decorators, cmpNode.modifiers, cmpNode.name, cmpNode.typeParameters, cmpNode.heritageClauses, newMembers);
	};
	const removeStencilDecorators = (classMembers) => {
	    classMembers.forEach(member => removeDecorators(member, MEMBER_DECORATORS_TO_REMOVE));
	};

	const gatherVdomMeta = (m, args) => {
	    m.hasVdomRender = true;
	    // Parse vdom tag
	    const hTag = args[0];
	    if (!ts.isStringLiteral(hTag) && (!ts.isIdentifier(hTag) || hTag.text !== 'Host')) {
	        m.hasVdomFunctional = true;
	    }
	    // Parse attributes
	    if (args.length > 1) {
	        const objectLiteral = args[1];
	        if (ts.isCallExpression(objectLiteral) || ts.isIdentifier(objectLiteral)) {
	            m.hasVdomAttribute = true;
	            m.hasVdomClass = true;
	            m.hasVdomKey = true;
	            m.hasVdomListener = true;
	            m.hasVdomPropOrAttr = true;
	            m.hasVdomRef = true;
	            m.hasVdomStyle = true;
	            m.hasVdomXlink = true;
	        }
	        else if (ts.isObjectLiteralExpression(objectLiteral)) {
	            objectLiteral.properties.forEach(prop => {
	                m.hasVdomAttribute = true;
	                if (ts.isSpreadAssignment(prop) || ts.isComputedPropertyName(prop.name)) {
	                    m.hasVdomClass = true;
	                    m.hasVdomKey = true;
	                    m.hasVdomListener = true;
	                    m.hasVdomPropOrAttr = true;
	                    m.hasVdomRef = true;
	                    m.hasVdomStyle = true;
	                    m.hasVdomXlink = true;
	                }
	                else if (prop.name && prop.name.text && prop.name.text.length > 0) {
	                    const attrName = prop.name.text;
	                    if (attrName === 'key') {
	                        m.hasVdomKey = true;
	                    }
	                    else if (attrName === 'ref') {
	                        m.hasVdomRef = true;
	                    }
	                    else if (attrName === 'class' || attrName === 'className') {
	                        m.hasVdomClass = true;
	                    }
	                    else if (attrName === 'style') {
	                        m.hasVdomStyle = true;
	                    }
	                    else if (/^on(-|[A-Z])/.test(attrName)) {
	                        m.hasVdomListener = true;
	                    }
	                    else if (attrName.startsWith('xlink')) {
	                        m.hasVdomXlink = true;
	                        m.hasVdomPropOrAttr = true;
	                    }
	                    else {
	                        m.hasVdomPropOrAttr = true;
	                    }
	                    m.htmlAttrNames.push(attrName);
	                }
	            });
	        }
	    }
	    // Parse children
	    if (!m.hasVdomText) {
	        for (let i = 2; i < args.length; i++) {
	            const arg = args[i];
	            if (!ts.isCallExpression(arg) || !ts.isIdentifier(arg.expression) || (arg.expression.text !== 'h')) {
	                m.hasVdomText = true;
	                break;
	            }
	        }
	    }
	};

	const ATTACH_SHADOW = '__stencil_attachShadow';
	const CREATE_EVENT = '__stencil_createEvent';
	const DEFINE_CUSTOM_ELEMENT = '__stencil_defineCustomElement';
	const GET_CONNECT = '__stencil_getConnect';
	const GET_CONTEXT = '__stencil_getContext';
	const GET_ELEMENT = '__stencil_getElement';
	const HOST = '__stencil_Host';
	const HTML_ELEMENT = 'HTMLElement';
	const PROXY_CUSTOM_ELEMENT = '__stencil_proxyCustomElement';
	const REGISTER_INSTANCE = '__stencil_registerInstance';
	const REGISTER_HOST = '__stencil_registerHost';
	const H = '__stencil_h';
	const RUNTIME_APIS = {
	    attachShadow: `attachShadow as ${ATTACH_SHADOW}`,
	    createEvent: `createEvent as ${CREATE_EVENT}`,
	    defineCustomElement: `defineCustomElement as ${DEFINE_CUSTOM_ELEMENT}`,
	    getConnect: `getConnect as ${GET_CONNECT}`,
	    getContext: `getContext as ${GET_CONTEXT}`,
	    getElement: `getElement as ${GET_ELEMENT}`,
	    h: `h as ${H}`,
	    legacyH: `h`,
	    Host: `Host as ${HOST}`,
	    HTMLElement: HTML_ELEMENT,
	    proxyCustomElement: `proxyCustomElement as ${PROXY_CUSTOM_ELEMENT}`,
	    registerHost: `registerHost as ${REGISTER_HOST}`,
	    registerInstance: `registerInstance as ${REGISTER_INSTANCE}`,
	};
	const addCoreRuntimeApi = (moduleFile, coreRuntimeApi) => {
	    if (!moduleFile.coreRuntimeApis.includes(coreRuntimeApi)) {
	        moduleFile.coreRuntimeApis.push(coreRuntimeApi);
	    }
	};
	const addLegacyApis = (moduleFile) => {
	    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.legacyH);
	};

	const parseCallExpression = (m, node) => {
	    if (node.arguments != null && node.arguments.length > 0) {
	        if (ts.isIdentifier(node.expression)) {
	            // h('tag')
	            visitCallExpressionArgs(m, node.expression, node.arguments);
	        }
	        else if (ts.isPropertyAccessExpression(node.expression)) {
	            // document.createElement('tag')
	            const n = node.expression.name;
	            if (ts.isIdentifier(n) && n) {
	                visitCallExpressionArgs(m, n, node.arguments);
	            }
	        }
	    }
	};
	const visitCallExpressionArgs = (m, callExpressionName, args) => {
	    const fnName = callExpressionName.escapedText;
	    if (fnName === 'h' || fnName === H || fnName === 'createElement') {
	        visitCallExpressionArg(m, args[0]);
	        if (fnName === 'h' || fnName === H) {
	            gatherVdomMeta(m, args);
	        }
	    }
	    else if (args.length > 1 && fnName === 'createElementNS') {
	        visitCallExpressionArg(m, args[1]);
	    }
	    else if (fnName === 'require' && args.length > 0 && m.originalImports) {
	        const arg = args[0];
	        if (ts.isStringLiteral(arg)) {
	            if (!m.originalImports.includes(arg.text)) {
	                m.originalImports.push(arg.text);
	            }
	        }
	    }
	};
	const visitCallExpressionArg = (m, arg) => {
	    if (ts.isStringLiteral(arg)) {
	        let tag = arg.text;
	        if (typeof tag === 'string') {
	            tag = tag.toLowerCase();
	            m.htmlTagNames.push(tag);
	            if (tag.includes('-')) {
	                m.potentialCmpRefs.push(tag);
	            }
	        }
	    }
	};

	const setComponentBuildConditionals = (cmpMeta) => {
	    if (cmpMeta.properties.length > 0) {
	        cmpMeta.hasProp = true;
	        cmpMeta.hasPropMutable = cmpMeta.properties.some(p => p.mutable);
	        cmpMeta.hasReflect = cmpMeta.properties.some(p => p.reflect);
	        cmpMeta.hasAttribute = cmpMeta.properties.some(p => typeof p.attribute === 'string');
	        cmpMeta.hasPropBoolean = cmpMeta.properties.some(p => p.type === 'boolean');
	        cmpMeta.hasPropNumber = cmpMeta.properties.some(p => p.type === 'number');
	        cmpMeta.hasPropString = cmpMeta.properties.some(p => p.type === 'string');
	    }
	    if (cmpMeta.states.length > 0) {
	        cmpMeta.hasState = true;
	    }
	    if (cmpMeta.watchers.length > 0) {
	        cmpMeta.hasWatchCallback = true;
	    }
	    if (cmpMeta.methods.length > 0) {
	        cmpMeta.hasMethod = true;
	    }
	    if (cmpMeta.events.length > 0) {
	        cmpMeta.hasEvent = true;
	    }
	    if (cmpMeta.listeners.length > 0) {
	        cmpMeta.hasListener = true;
	        cmpMeta.hasListenerTargetWindow = cmpMeta.listeners.some(l => l.target === 'window');
	        cmpMeta.hasListenerTargetDocument = cmpMeta.listeners.some(l => l.target === 'document');
	        cmpMeta.hasListenerTargetBody = cmpMeta.listeners.some(l => l.target === 'body');
	        cmpMeta.hasListenerTargetParent = cmpMeta.listeners.some(l => l.target === 'parent');
	        cmpMeta.hasListenerTarget = cmpMeta.listeners.some(l => !!l.target);
	    }
	    cmpMeta.hasMember = (cmpMeta.hasProp || cmpMeta.hasState || cmpMeta.hasElement || cmpMeta.hasMethod);
	    cmpMeta.isUpdateable = (cmpMeta.hasProp || cmpMeta.hasState);
	    if (cmpMeta.styles.length > 0) {
	        cmpMeta.hasStyle = true;
	        cmpMeta.hasMode = cmpMeta.styles.some(s => s.modeName !== DEFAULT_STYLE_MODE);
	    }
	    cmpMeta.hasLifecycle = (cmpMeta.hasComponentWillLoadFn || cmpMeta.hasComponentDidLoadFn || cmpMeta.hasComponentShouldUpdateFn || cmpMeta.hasComponentWillUpdateFn || cmpMeta.hasComponentDidUpdateFn || cmpMeta.hasComponentWillRenderFn || cmpMeta.hasComponentDidRenderFn);
	    cmpMeta.isPlain = !cmpMeta.hasMember && !cmpMeta.hasStyle && !cmpMeta.hasLifecycle && !cmpMeta.hasListener && !cmpMeta.hasVdomRender;
	};

	function parseComponentsDeprecated(config, compilerCtx, collection, collectionDir, collectionManifest) {
	    if (collectionManifest.components) {
	        collectionManifest.components.forEach(cmpData => {
	            parseComponentDeprecated(config, compilerCtx, collection, collectionDir, cmpData);
	        });
	    }
	}
	function parseComponentDeprecated(config, compilerCtx, collection, collectionDir, cmpData) {
	    const sourceFilePath = normalizePath(config.sys.path.join(collectionDir, cmpData.componentPath));
	    const moduleFile = getModule(config, compilerCtx, sourceFilePath);
	    moduleFile.isCollectionDependency = true;
	    moduleFile.isLegacy = true;
	    moduleFile.collectionName = collection.collectionName;
	    moduleFile.excludeFromCollection = excludeFromCollection(config, cmpData);
	    moduleFile.originalCollectionComponentPath = cmpData.componentPath;
	    moduleFile.jsFilePath = parseJsFilePath(config, collectionDir, cmpData);
	    const cmpMeta = {
	        isLegacy: moduleFile.isLegacy,
	        excludeFromCollection: moduleFile.excludeFromCollection,
	        isCollectionDependency: moduleFile.isCollectionDependency,
	        tagName: parseTag(cmpData),
	        componentClassName: parseComponentClass(cmpData),
	        virtualProperties: [],
	        docs: {
	            text: '',
	            tags: []
	        },
	        internal: false,
	        jsFilePath: moduleFile.jsFilePath,
	        sourceFilePath: '',
	        styleDocs: [],
	        assetsDirs: parseAssetsDir(config, collectionDir, cmpData),
	        styles: parseStyles(config, collectionDir, cmpData),
	        properties: parseProps(cmpData),
	        states: parseStates(cmpData),
	        listeners: parseListeners(cmpData),
	        methods: parseMethods(cmpData),
	        elementRef: parseHostElementMember(cmpData),
	        events: parseEvents(cmpData),
	        encapsulation: parseEncapsulation(cmpData),
	        shadowDelegatesFocus: null,
	        watchers: parseWatchers(cmpData),
	        legacyConnect: parseConnectProps(cmpData),
	        legacyContext: parseContextProps(cmpData),
	        hasAttributeChangedCallbackFn: false,
	        hasComponentWillLoadFn: true,
	        hasComponentDidLoadFn: true,
	        hasComponentShouldUpdateFn: true,
	        hasComponentWillUpdateFn: true,
	        hasComponentDidUpdateFn: true,
	        hasComponentWillRenderFn: false,
	        hasComponentDidRenderFn: false,
	        hasComponentDidUnloadFn: true,
	        hasConnectedCallbackFn: false,
	        hasDisconnectedCallbackFn: false,
	        hasElement: false,
	        hasEvent: false,
	        hasLifecycle: false,
	        hasListener: false,
	        hasListenerTarget: false,
	        hasListenerTargetWindow: false,
	        hasListenerTargetDocument: false,
	        hasListenerTargetBody: false,
	        hasListenerTargetParent: false,
	        hasMember: false,
	        hasMethod: false,
	        hasMode: false,
	        hasAttribute: false,
	        hasProp: false,
	        hasPropNumber: false,
	        hasPropBoolean: false,
	        hasPropString: false,
	        hasPropMutable: false,
	        hasReflect: false,
	        hasRenderFn: false,
	        hasState: false,
	        hasStyle: false,
	        hasVdomAttribute: true,
	        hasVdomXlink: true,
	        hasVdomClass: true,
	        hasVdomFunctional: true,
	        hasVdomKey: true,
	        hasVdomListener: true,
	        hasVdomPropOrAttr: true,
	        hasVdomRef: true,
	        hasVdomRender: false,
	        hasVdomStyle: true,
	        hasVdomText: true,
	        hasWatchCallback: false,
	        isPlain: false,
	        htmlAttrNames: [],
	        htmlTagNames: [],
	        isUpdateable: false,
	        potentialCmpRefs: []
	    };
	    setComponentBuildConditionals(cmpMeta);
	    moduleFile.cmps = [cmpMeta];
	    // parseComponentDependencies(cmpData, cmpMeta);
	    // parseContextMember(cmpData, cmpMeta);
	    // parseConnectMember(cmpData, cmpMeta);
	    collection.moduleFiles.push(moduleFile);
	}
	function excludeFromCollection(config, cmpData) {
	    // this is a component from a collection dependency
	    // however, this project may also become a collection
	    // for example, "ionicons" is a dependency of "ionic"
	    // and "ionic" is it's own stand-alone collection, so within
	    // ionic's collection we want ionicons to just work
	    // cmpData is a component from a collection dependency
	    // if this component is listed in this config's bundles
	    // then we'll need to ensure it also becomes apart of this collection
	    const isInBundle = config.bundles && config.bundles.some(bundle => {
	        return bundle.components && bundle.components.some(tag => tag === cmpData.tag);
	    });
	    // if it's not in the config bundle then it's safe to exclude
	    // this component from going into this build's collection
	    return !isInBundle;
	}
	function parseTag(cmpData) {
	    return cmpData.tag;
	}
	function parseJsFilePath(config, collectionDir, cmpData) {
	    // convert the path that's relative to the collection file
	    // into an absolute path to the component's js file path
	    if (typeof cmpData.componentPath !== 'string') {
	        throw new Error(`parseModuleJsFilePath, "componentPath" missing on cmpData: ${cmpData.tag}`);
	    }
	    return normalizePath(config.sys.path.join(collectionDir, cmpData.componentPath));
	}
	// function parseComponentDependencies(cmpData: d.ComponentDataDeprecated, cmpMeta: d.ComponentCompilerMeta) {
	//   if (invalidArrayData(cmpData.dependencies)) {
	//     cmpMeta.dependencies = [];
	//   } else {
	//     cmpMeta.dependencies = cmpData.dependencies.sort();
	//   }
	// }
	function parseComponentClass(cmpData) {
	    return cmpData.componentClass;
	}
	function parseStyles(config, collectionDir, cmpData) {
	    const stylesData = cmpData.styles;
	    if (stylesData) {
	        const modeNames = Object.keys(stylesData);
	        return modeNames.map(modeName => {
	            return parseStyle(config, collectionDir, cmpData, stylesData[modeName], modeName.toLowerCase());
	        });
	    }
	    else {
	        return [];
	    }
	}
	function parseAssetsDir(config, collectionDir, cmpData) {
	    if (invalidArrayData(cmpData.assetPaths)) {
	        return [];
	    }
	    return cmpData.assetPaths.map(assetsPath => {
	        const assetsMeta = {
	            absolutePath: normalizePath(config.sys.path.join(collectionDir, assetsPath)),
	            cmpRelativePath: normalizePath(config.sys.path.relative(config.sys.path.dirname(cmpData.componentPath), assetsPath)),
	            originalComponentPath: normalizePath(assetsPath)
	        };
	        return assetsMeta;
	    }).sort((a, b) => {
	        if (a.cmpRelativePath < b.cmpRelativePath)
	            return -1;
	        if (a.cmpRelativePath > b.cmpRelativePath)
	            return 1;
	        return 0;
	    });
	}
	function parseStyle(config, collectionDir, cmpData, modeStyleData, modeName) {
	    const modeStyle = {
	        modeName: modeName,
	        styleId: cmpData.tag,
	        styleStr: modeStyleData.style,
	        styleIdentifier: null,
	        externalStyles: [],
	        compiledStyleText: null,
	        compiledStyleTextScoped: null,
	        compiledStyleTextScopedCommented: null
	    };
	    if (Array.isArray(modeStyleData.stylePaths)) {
	        modeStyleData.stylePaths.forEach(stylePath => {
	            const externalStyle = {
	                absolutePath: normalizePath(config.sys.path.join(collectionDir, stylePath)),
	                relativePath: normalizePath(config.sys.path.relative(config.sys.path.dirname(cmpData.componentPath), stylePath)),
	                originalComponentPath: stylePath
	            };
	            modeStyle.externalStyles.push(externalStyle);
	        });
	    }
	    return modeStyle;
	}
	function parseProps(cmpData) {
	    const propsData = cmpData.props;
	    if (invalidArrayData(propsData)) {
	        return [];
	    }
	    return propsData.map(propData => {
	        const type = convertType(propData.type);
	        const prop = {
	            name: propData.name,
	            attribute: (typeof propData.attr === 'string' ? propData.attr : null),
	            mutable: !!propData.mutable,
	            optional: true,
	            required: false,
	            reflect: !!propData.reflectToAttr,
	            type,
	            internal: false,
	            complexType: {
	                original: type === 'unknown' ? 'any' : type,
	                resolved: type,
	                references: {},
	            },
	            docs: {
	                text: '',
	                tags: []
	            }
	        };
	        return prop;
	    });
	}
	function parseConnectProps(cmpData) {
	    const connectData = cmpData.connect;
	    if (invalidArrayData(connectData)) {
	        return [];
	    }
	    return connectData.map(propData => {
	        const prop = {
	            name: propData.name,
	            connect: propData.tag
	        };
	        return prop;
	    });
	}
	function parseContextProps(cmpData) {
	    const contextData = cmpData.context;
	    if (invalidArrayData(contextData)) {
	        return [];
	    }
	    return contextData.map(propData => {
	        return {
	            name: propData.name,
	            context: propData.id
	        };
	    });
	}
	function parseStates(cmpData) {
	    if (invalidArrayData(cmpData.states)) {
	        return [];
	    }
	    return cmpData.states.map(state => {
	        return {
	            name: state.name
	        };
	    });
	}
	function parseWatchers(cmpData) {
	    if (invalidArrayData(cmpData.props)) {
	        return [];
	    }
	    const watchers = [];
	    cmpData.props
	        .filter(prop => prop.watch && prop.watch.length > 0)
	        .forEach(prop => {
	        prop.watch.forEach(watch => {
	            watchers.push({
	                propName: prop.name,
	                methodName: watch
	            });
	        });
	    });
	    return watchers;
	}
	function parseListeners(cmpData) {
	    const listenersData = cmpData.listeners;
	    if (invalidArrayData(listenersData)) {
	        return [];
	    }
	    return listenersData.map(listenerData => {
	        const listener = {
	            name: listenerData.event,
	            method: listenerData.method,
	            target: undefined,
	            passive: (listenerData.passive !== false),
	            capture: (listenerData.capture !== false)
	        };
	        return listener;
	    });
	}
	function parseMethods(cmpData) {
	    if (invalidArrayData(cmpData.methods)) {
	        return [];
	    }
	    return cmpData.methods.map(methodData => {
	        const method = {
	            name: methodData.name,
	            internal: false,
	            complexType: {
	                signature: '(...args: any[]) => Promise<any>',
	                parameters: [],
	                return: 'Promise<any>',
	                references: {}
	            },
	            docs: {
	                text: '',
	                tags: []
	            }
	        };
	        return method;
	    });
	}
	function convertType(type) {
	    switch (type) {
	        case 'String': return 'string';
	        case 'Any': return 'any';
	        case 'Number': return 'number';
	        case 'Boolean': return 'boolean';
	        default: return 'unknown';
	    }
	}
	// function parseContextMember(cmpData: d.ComponentDataDeprecated, cmpMeta: d.ComponentCompilerMeta) {
	//   if (invalidArrayData(cmpData.context)) {
	//     return;
	//   }
	//   cmpData.context.forEach(methodData => {
	//     if (methodData.id) {
	//       cmpMeta.membersMeta = cmpMeta.membersMeta || {};
	//       cmpMeta.membersMeta[methodData.name] = {
	//         memberType: MEMBER_FLAGS.PropContext,
	//         ctrlId: methodData.id
	//       };
	//     }
	//   });
	// }
	// function parseConnectMember(cmpData: d.ComponentDataDeprecated, cmpMeta: d.ComponentCompilerMeta) {
	//   if (invalidArrayData(cmpData.connect)) {
	//     return;
	//   }
	//   cmpData.connect.forEach(methodData => {
	//     if (methodData.tag) {
	//       cmpMeta.membersMeta = cmpMeta.membersMeta || {};
	//       cmpMeta.membersMeta[methodData.name] = {
	//         memberType: MEMBER_FLAGS.PropConnect,
	//         ctrlId: methodData.tag
	//       };
	//     }
	//   });
	// }
	function parseHostElementMember(cmpData) {
	    if (!cmpData.hostElement) {
	        return undefined;
	    }
	    return cmpData.hostElement.name;
	}
	function parseEvents(cmpData) {
	    const eventsData = cmpData.events;
	    if (invalidArrayData(eventsData)) {
	        return [];
	    }
	    return eventsData.map(eventData => {
	        const event = {
	            name: eventData.event,
	            method: (eventData.method) ? eventData.method : eventData.event,
	            bubbles: (eventData.bubbles !== false),
	            cancelable: (eventData.cancelable !== false),
	            composed: (eventData.composed !== false),
	            internal: false,
	            docs: {
	                text: '',
	                tags: []
	            },
	            complexType: {
	                original: 'any',
	                resolved: 'any',
	                references: {}
	            }
	        };
	        return event;
	    });
	}
	function parseEncapsulation(cmpData) {
	    if (cmpData.shadow === true) {
	        return 'shadow';
	    }
	    else if (cmpData.scoped === true) {
	        return 'scoped';
	    }
	    else {
	        return 'none';
	    }
	}
	function invalidArrayData(arr) {
	    return (!arr || !Array.isArray(arr) || arr.length === 0);
	}

	function parseCollectionComponents(config, compilerCtx, buildCtx, collectionDir, collectionManifest, collection) {
	    collection.moduleFiles = collection.moduleFiles || [];
	    parseComponentsDeprecated(config, compilerCtx, collection, collectionDir, collectionManifest);
	    if (collectionManifest.entries) {
	        collectionManifest.entries.forEach(entryPath => {
	            const componentPath = config.sys.path.join(collectionDir, entryPath);
	            const sourceText = compilerCtx.fs.readFileSync(componentPath);
	            transpileCollectionEntry(config, compilerCtx, buildCtx, collection, componentPath, sourceText);
	        });
	    }
	}
	function transpileCollectionEntry(config, compilerCtx, buildCtx, collection, inputFileName, sourceText) {
	    const options = ts.getDefaultCompilerOptions();
	    options.isolatedModules = true;
	    options.suppressOutputPathCheck = true;
	    options.allowNonTsExtensions = true;
	    options.noLib = true;
	    options.lib = undefined;
	    options.types = undefined;
	    options.noEmit = undefined;
	    options.noEmitOnError = undefined;
	    options.paths = undefined;
	    options.rootDirs = undefined;
	    options.declaration = undefined;
	    options.composite = undefined;
	    options.declarationDir = undefined;
	    options.out = undefined;
	    options.outFile = undefined;
	    options.noResolve = true;
	    options.module = ts.ModuleKind.ESNext;
	    options.target = ts.ScriptTarget.ES2017;
	    const sourceFile = ts.createSourceFile(inputFileName, sourceText, options.target);
	    const compilerHost = {
	        getSourceFile: fileName => fileName === inputFileName ? sourceFile : undefined,
	        writeFile: noop,
	        getDefaultLibFileName: () => 'lib.d.ts',
	        useCaseSensitiveFileNames: () => false,
	        getCanonicalFileName: fileName => fileName,
	        getCurrentDirectory: () => '',
	        getNewLine: () => '',
	        fileExists: fileName => fileName === inputFileName,
	        readFile: () => '',
	        directoryExists: () => true,
	        getDirectories: () => []
	    };
	    const program = ts.createProgram([inputFileName], options, compilerHost);
	    const typeChecker = program.getTypeChecker();
	    program.emit(undefined, undefined, undefined, undefined, {
	        after: [
	            convertStaticToMeta(config, compilerCtx, buildCtx, typeChecker, collection, {
	                coreImportPath: '@stencil/core',
	                componentExport: null,
	                componentMetadata: null,
	                proxy: null,
	                style: 'static'
	            })
	        ]
	    });
	}

	const parseCollectionManifest = (config, compilerCtx, buildCtx, collectionName, collectionDir, collectionJsonStr) => {
	    const collectionManifest = JSON.parse(collectionJsonStr);
	    const compilerVersion = collectionManifest.compiler || {};
	    const collection = {
	        collectionName: collectionName,
	        dependencies: parseCollectionDependencies(collectionManifest),
	        compiler: {
	            name: compilerVersion.name || '',
	            version: compilerVersion.version || '',
	            typescriptVersion: compilerVersion.typescriptVersion || ''
	        },
	        bundles: parseBundles(collectionManifest),
	        global: parseGlobal(config, compilerCtx, collectionDir, collectionManifest)
	    };
	    parseCollectionComponents(config, compilerCtx, buildCtx, collectionDir, collectionManifest, collection);
	    return collection;
	};
	const parseCollectionDependencies = (collectionManifest) => {
	    return (collectionManifest.collections || []).map(c => c.name);
	};
	const parseGlobal = (config, compilerCtx, collectionDir, collectionManifest) => {
	    if (typeof collectionManifest.global !== 'string') {
	        return undefined;
	    }
	    const sourceFilePath = normalizePath(config.sys.path.join(collectionDir, collectionManifest.global));
	    const globalModule = getModule(config, compilerCtx, sourceFilePath);
	    globalModule.jsFilePath = normalizePath(config.sys.path.join(collectionDir, collectionManifest.global));
	    return globalModule;
	};
	const parseBundles = (collectionManifest) => {
	    if (invalidArrayData$1(collectionManifest.bundles)) {
	        return [];
	    }
	    return collectionManifest.bundles.map(b => {
	        return {
	            components: b.components.slice().sort()
	        };
	    });
	};
	const invalidArrayData$1 = (arr) => {
	    return (!arr || !Array.isArray(arr) || arr.length === 0);
	};

	const parseCollection = (config, compilerCtx, buildCtx, pkgJsonFilePath, pkgData) => {
	    // note this MUST be synchronous because this is used during transpile
	    const collectionName = pkgData.name;
	    let collection = compilerCtx.collections.find(c => c.collectionName === collectionName);
	    if (collection != null) {
	        // we've already cached the collection, no need for another resolve/readFile/parse
	        // thought being that /node_modules/ isn't changing between watch builds
	        return collection;
	    }
	    // get the root directory of the dependency
	    const collectionPackageRootDir = config.sys.path.dirname(pkgJsonFilePath);
	    // figure out the full path to the collection collection file
	    const collectionFilePath = config.sys.path.join(collectionPackageRootDir, pkgData.collection);
	    const relPath = config.sys.path.relative(config.rootDir, collectionFilePath);
	    config.logger.debug(`load collection: ${collectionName}, ${relPath}`);
	    // we haven't cached the collection yet, let's read this file
	    // sync on purpose :(
	    const collectionJsonStr = compilerCtx.fs.readFileSync(collectionFilePath);
	    // get the directory where the collection collection file is sitting
	    const collectionDir = normalizePath(config.sys.path.dirname(collectionFilePath));
	    // parse the json string into our collection data
	    collection = parseCollectionManifest(config, compilerCtx, buildCtx, collectionName, collectionDir, collectionJsonStr);
	    if (pkgData.module && pkgData.module !== pkgData.main) {
	        collection.hasExports = true;
	    }
	    // remember the source of this collection node_module
	    collection.moduleDir = collectionPackageRootDir;
	    // cache it for later yo
	    compilerCtx.collections.push(collection);
	    return collection;
	};

	const addExternalImport = (config, compilerCtx, buildCtx, moduleFile, resolveFromDir, moduleId) => {
	    moduleFile.externalImports = moduleFile.externalImports || [];
	    if (!moduleFile.externalImports.includes(moduleId)) {
	        moduleFile.externalImports.push(moduleId);
	        moduleFile.externalImports.sort();
	    }
	    compilerCtx.resolvedCollections = compilerCtx.resolvedCollections || new Set();
	    if (compilerCtx.resolvedCollections.has(moduleId)) {
	        // we've already handled this collection moduleId before
	        return;
	    }
	    // cache that we've already parsed this
	    compilerCtx.resolvedCollections.add(moduleId);
	    let pkgJsonFilePath;
	    try {
	        // get the full package.json file path
	        pkgJsonFilePath = normalizePath(config.sys.resolveModule(resolveFromDir, moduleId));
	    }
	    catch (e) {
	        // it's someone else's job to handle unresolvable paths
	        return;
	    }
	    if (pkgJsonFilePath === 'package.json') {
	        // the resolved package is actually this very same package, so whatever
	        return;
	    }
	    // open up and parse the package.json
	    // sync on purpose :(
	    const pkgJsonStr = compilerCtx.fs.readFileSync(pkgJsonFilePath);
	    const pkgData = JSON.parse(pkgJsonStr);
	    if (typeof pkgData.collection !== 'string' || !pkgData.collection.endsWith('.json')) {
	        // this import is not a stencil collection
	        return;
	    }
	    if (typeof pkgData.types !== 'string' || !pkgData.types.endsWith('.d.ts')) {
	        // this import should have types
	        return;
	    }
	    // this import is a stencil collection
	    // let's parse it and gather all the module data about it
	    // internally it'll cached collection data if we've already done this
	    const collection = parseCollection(config, compilerCtx, buildCtx, pkgJsonFilePath, pkgData);
	    // check if we already added this collection to the build context
	    const alreadyHasCollection = buildCtx.collections.some(c => {
	        return c.collectionName === collection.collectionName;
	    });
	    if (alreadyHasCollection) {
	        // we already have this collection in our build context
	        return;
	    }
	    // let's add the collection to the build context
	    buildCtx.collections.push(collection);
	    if (Array.isArray(collection.dependencies)) {
	        // this collection has more collections
	        // let's keep digging down and discover all of them
	        collection.dependencies.forEach(dependencyModuleId => {
	            const resolveFromDir = config.sys.path.dirname(pkgJsonFilePath);
	            addExternalImport(config, compilerCtx, buildCtx, moduleFile, resolveFromDir, dependencyModuleId);
	        });
	    }
	};

	const parseImport = (config, compilerCtx, buildCtx, moduleFile, dirPath, importNode) => {
	    if (importNode.moduleSpecifier && ts.isStringLiteral(importNode.moduleSpecifier)) {
	        let importPath = importNode.moduleSpecifier.text;
	        if (!moduleFile.originalImports.includes(importPath)) {
	            moduleFile.originalImports.push(importPath);
	        }
	        if (config.sys.path.isAbsolute(importPath)) {
	            // absolute import
	            importPath = normalizePath(importPath);
	            moduleFile.localImports.push(importPath);
	        }
	        else if (importPath.startsWith('.')) {
	            // relative import
	            importPath = normalizePath(config.sys.path.resolve(dirPath, importPath));
	            moduleFile.localImports.push(importPath);
	        }
	        else {
	            // node resolve side effect import
	            addExternalImport(config, compilerCtx, buildCtx, moduleFile, config.rootDir, importPath);
	            // test if this side effect import is a collection
	            const isCollectionImport = compilerCtx.collections.some(c => {
	                return c.collectionName === importPath;
	            });
	            if (!importNode.importClause && isCollectionImport) {
	                // turns out this is a side effect import is a collection,
	                // we actually don't want to include this in the JS output
	                // we've already gather the types we needed, kthxbai
	                return null;
	            }
	        }
	    }
	    return importNode;
	};

	const parseStaticMethods = (staticMembers) => {
	    const parsedMethods = getStaticValue(staticMembers, 'methods');
	    if (!parsedMethods) {
	        return [];
	    }
	    const methodNames = Object.keys(parsedMethods);
	    if (methodNames.length === 0) {
	        return [];
	    }
	    return methodNames.map(methodName => {
	        return {
	            name: methodName,
	            docs: parsedMethods[methodName].docs,
	            complexType: parsedMethods[methodName].complexType,
	            internal: isInternal(parsedMethods[methodName].docs)
	        };
	    });
	};

	const parseStaticListeners = (staticMembers) => {
	    const parsedListeners = getStaticValue(staticMembers, 'listeners');
	    if (!parsedListeners || parsedListeners.length === 0) {
	        return [];
	    }
	    return parsedListeners.map(parsedListener => {
	        return {
	            name: parsedListener.name,
	            method: parsedListener.method,
	            capture: !!parsedListener.capture,
	            passive: !!parsedListener.passive,
	            target: parsedListener.target
	        };
	    });
	};

	const parseClassMethods = (cmpNode, cmpMeta) => {
	    const classMembers = cmpNode.members;
	    if (!classMembers || classMembers.length === 0) {
	        return;
	    }
	    const classMethods = classMembers.filter(m => ts.isMethodDeclaration(m));
	    if (classMethods.length === 0) {
	        return;
	    }
	    const hasHostData = classMethods.some(m => isMethod(m, 'hostData'));
	    cmpMeta.hasAttributeChangedCallbackFn = classMethods.some(m => isMethod(m, 'attributeChangedCallback'));
	    cmpMeta.hasConnectedCallbackFn = classMethods.some(m => isMethod(m, 'connectedCallback'));
	    cmpMeta.hasDisconnectedCallbackFn = classMethods.some(m => isMethod(m, 'disconnectedCallback'));
	    cmpMeta.hasComponentWillLoadFn = classMethods.some(m => isMethod(m, 'componentWillLoad'));
	    cmpMeta.hasComponentWillUpdateFn = classMethods.some(m => isMethod(m, 'componentWillUpdate'));
	    cmpMeta.hasComponentWillRenderFn = classMethods.some(m => isMethod(m, 'componentWillRender'));
	    cmpMeta.hasComponentDidRenderFn = classMethods.some(m => isMethod(m, 'componentDidRender'));
	    cmpMeta.hasComponentDidLoadFn = classMethods.some(m => isMethod(m, 'componentDidLoad'));
	    cmpMeta.hasComponentShouldUpdateFn = classMethods.some(m => isMethod(m, 'componentShouldUpdate'));
	    cmpMeta.hasComponentDidUpdateFn = classMethods.some(m => isMethod(m, 'componentDidUpdate'));
	    cmpMeta.hasComponentDidUnloadFn = classMethods.some(m => isMethod(m, 'componentDidUnload'));
	    cmpMeta.hasLifecycle = (cmpMeta.hasComponentWillLoadFn || cmpMeta.hasComponentDidLoadFn || cmpMeta.hasComponentWillUpdateFn || cmpMeta.hasComponentDidUpdateFn);
	    cmpMeta.hasRenderFn = classMethods.some(m => isMethod(m, 'render')) || hasHostData;
	    cmpMeta.hasVdomRender = cmpMeta.hasVdomRender || hasHostData;
	};

	const parseStaticElementRef = (staticMembers) => {
	    const parsedElementRef = getStaticValue(staticMembers, 'elementRef');
	    if (typeof parsedElementRef === 'string') {
	        return parsedElementRef;
	    }
	    return null;
	};

	const parseStaticEncapsulation = (staticMembers) => {
	    let encapsulation = getStaticValue(staticMembers, 'encapsulation');
	    if (typeof encapsulation === 'string') {
	        encapsulation = encapsulation.toLowerCase().trim();
	        if (encapsulation === 'shadow' || encapsulation === 'scoped') {
	            return encapsulation;
	        }
	    }
	    return 'none';
	};
	const parseStaticShadowDelegatesFocus = (encapsulation, staticMembers) => {
	    if (encapsulation === 'shadow') {
	        const delegatesFocus = getStaticValue(staticMembers, 'delegatesFocus');
	        return !!delegatesFocus;
	    }
	    return null;
	};

	const parseStaticEvents = (staticMembers) => {
	    const parsedEvents = getStaticValue(staticMembers, 'events');
	    if (!parsedEvents || parsedEvents.length === 0) {
	        return [];
	    }
	    return parsedEvents.map(parsedEvent => {
	        return {
	            name: parsedEvent.name,
	            method: parsedEvent.method,
	            bubbles: parsedEvent.bubbles,
	            cancelable: parsedEvent.cancelable,
	            composed: parsedEvent.composed,
	            docs: parsedEvent.docs,
	            complexType: parsedEvent.complexType,
	            internal: isInternal(parsedEvent.docs)
	        };
	    });
	};

	const parseStaticProps = (staticMembers) => {
	    const parsedProps = getStaticValue(staticMembers, 'properties');
	    if (!parsedProps) {
	        return [];
	    }
	    const propNames = Object.keys(parsedProps);
	    if (propNames.length === 0) {
	        return [];
	    }
	    return propNames.map(propName => {
	        const val = parsedProps[propName];
	        return {
	            name: propName,
	            type: val.type,
	            attribute: val.attribute ? val.attribute.toLowerCase() : undefined,
	            reflect: (typeof val.reflect === 'boolean' ? val.reflect : (typeof val.reflect === 'boolean' ? val.reflect : false)),
	            mutable: !!val.mutable,
	            required: !!val.required,
	            optional: !!val.optional,
	            defaultValue: val.defaultValue,
	            complexType: val.complexType,
	            docs: val.docs,
	            internal: isInternal(val.docs)
	        };
	    });
	};

	const parseStaticStates = (staticMembers) => {
	    const parsedStates = getStaticValue(staticMembers, 'states');
	    if (!parsedStates) {
	        return [];
	    }
	    const stateNames = Object.keys(parsedStates);
	    if (stateNames.length === 0) {
	        return [];
	    }
	    return stateNames.map(stateName => {
	        return {
	            name: stateName,
	        };
	    });
	};

	const parseStaticWatchers = (staticMembers) => {
	    const parsedWatchers = getStaticValue(staticMembers, 'watchers');
	    if (!parsedWatchers || parsedWatchers.length === 0) {
	        return [];
	    }
	    return parsedWatchers.map(parsedWatch => {
	        return {
	            propName: parsedWatch.propName,
	            methodName: parsedWatch.methodName
	        };
	    });
	};

	const normalizeStyles = (config, tagName, componentFilePath, styles) => {
	    styles.forEach(style => {
	        if (style.modeName === DEFAULT_STYLE_MODE) {
	            style.styleId = tagName.toUpperCase();
	        }
	        else {
	            style.styleId = `${tagName.toUpperCase()}#${style.modeName}`;
	        }
	        if (Array.isArray(style.externalStyles)) {
	            style.externalStyles.forEach(externalStyle => {
	                normalizeExternalStyle(config, componentFilePath, externalStyle);
	            });
	        }
	    });
	};
	const normalizeExternalStyle = (config, componentFilePath, externalStyle) => {
	    if (typeof externalStyle.originalComponentPath !== 'string' || externalStyle.originalComponentPath.trim().length === 0) {
	        return;
	    }
	    // get the absolute path of the directory which the component is sitting in
	    const componentDir = config.sys.path.dirname(componentFilePath);
	    if (config.sys.path.isAbsolute(externalStyle.originalComponentPath)) {
	        // this path is absolute already!
	        // add to our list of style absolute paths
	        externalStyle.absolutePath = normalizePath(externalStyle.originalComponentPath);
	        // if this is an absolute path already, let's convert it to be relative
	        externalStyle.relativePath = normalizePath(config.sys.path.relative(componentDir, externalStyle.originalComponentPath));
	    }
	    else {
	        // this path is relative to the component
	        // add to our list of style relative paths
	        externalStyle.relativePath = normalizePath(externalStyle.originalComponentPath);
	        // create the absolute path to the style file
	        externalStyle.absolutePath = normalizePath(config.sys.path.join(componentDir, externalStyle.originalComponentPath));
	    }
	};

	const parseStaticStyles = (config, compilerCtx, tagName, componentFilePath, isCollectionDependency, staticMembers) => {
	    const styles = [];
	    const styleUrlsProp = isCollectionDependency ? 'styleUrls' : 'originalStyleUrls';
	    const parsedStyleUrls = getStaticValue(staticMembers, styleUrlsProp);
	    let parsedStyle = getStaticValue(staticMembers, 'styles');
	    if (parsedStyle) {
	        if (typeof parsedStyle === 'string') {
	            // styles: 'div { padding: 10px }'
	            parsedStyle = parsedStyle.trim();
	            if (parsedStyle.length > 0) {
	                styles.push({
	                    modeName: DEFAULT_STYLE_MODE,
	                    styleId: null,
	                    styleStr: parsedStyle,
	                    styleIdentifier: null,
	                    compiledStyleText: null,
	                    compiledStyleTextScoped: null,
	                    compiledStyleTextScopedCommented: null,
	                    externalStyles: []
	                });
	                compilerCtx.styleModeNames.add(DEFAULT_STYLE_MODE);
	            }
	        }
	        else if (parsedStyle.__identifier) {
	            styles.push(parseStyleIdentifier(parsedStyle));
	            compilerCtx.styleModeNames.add(DEFAULT_STYLE_MODE);
	        }
	    }
	    if (parsedStyleUrls && typeof parsedStyleUrls === 'object') {
	        Object.keys(parsedStyleUrls).forEach(modeName => {
	            const externalStyles = [];
	            const styleObj = parsedStyleUrls[modeName];
	            styleObj.forEach(styleUrl => {
	                if (typeof styleUrl === 'string' && styleUrl.trim().length > 0) {
	                    externalStyles.push({
	                        absolutePath: null,
	                        relativePath: null,
	                        originalComponentPath: styleUrl.trim()
	                    });
	                }
	            });
	            if (externalStyles.length > 0) {
	                const style = {
	                    modeName: modeName,
	                    styleId: null,
	                    styleStr: null,
	                    styleIdentifier: null,
	                    compiledStyleText: null,
	                    compiledStyleTextScoped: null,
	                    compiledStyleTextScopedCommented: null,
	                    externalStyles: externalStyles
	                };
	                styles.push(style);
	                compilerCtx.styleModeNames.add(modeName);
	            }
	        });
	    }
	    normalizeStyles(config, tagName, componentFilePath, styles);
	    return sortBy(styles, s => s.modeName);
	};
	const parseStyleIdentifier = (parsedStyle) => {
	    const style = {
	        modeName: DEFAULT_STYLE_MODE,
	        styleId: null,
	        styleStr: null,
	        styleIdentifier: parsedStyle.__escapedText,
	        compiledStyleText: null,
	        compiledStyleTextScoped: null,
	        compiledStyleTextScopedCommented: null,
	        externalStyles: []
	    };
	    return style;
	};

	const parseStringLiteral = (m, node) => {
	    if (typeof node.text === 'string' && node.text.includes('</')) {
	        if (node.text.includes('<slot')) {
	            m.htmlTagNames.push('slot');
	        }
	        if (node.text.includes('<svg')) {
	            m.htmlTagNames.push('svg');
	        }
	    }
	};

	const parseStaticComponentMeta = (config, compilerCtx, typeChecker, cmpNode, moduleFile, nodeMap, transformOpts, fileCmpNodes) => {
	    if (cmpNode.members == null) {
	        return cmpNode;
	    }
	    const staticMembers = cmpNode.members.filter(isStaticGetter);
	    const tagName = getComponentTagName(staticMembers);
	    if (tagName == null) {
	        return cmpNode;
	    }
	    const symbol = typeChecker.getSymbolAtLocation(cmpNode.name);
	    const docs = serializeSymbol(typeChecker, symbol);
	    const isCollectionDependency = moduleFile.isCollectionDependency;
	    const encapsulation = parseStaticEncapsulation(staticMembers);
	    const cmp = {
	        isLegacy: false,
	        tagName: tagName,
	        excludeFromCollection: moduleFile.excludeFromCollection,
	        isCollectionDependency,
	        componentClassName: (cmpNode.name ? cmpNode.name.text : ''),
	        elementRef: parseStaticElementRef(staticMembers),
	        encapsulation,
	        shadowDelegatesFocus: parseStaticShadowDelegatesFocus(encapsulation, staticMembers),
	        properties: parseStaticProps(staticMembers),
	        virtualProperties: parseVirtualProps(docs),
	        states: parseStaticStates(staticMembers),
	        methods: parseStaticMethods(staticMembers),
	        listeners: parseStaticListeners(staticMembers),
	        events: parseStaticEvents(staticMembers),
	        watchers: parseStaticWatchers(staticMembers),
	        styles: parseStaticStyles(config, compilerCtx, tagName, moduleFile.sourceFilePath, isCollectionDependency, staticMembers),
	        legacyConnect: getStaticValue(staticMembers, 'connectProps') || [],
	        legacyContext: getStaticValue(staticMembers, 'contextProps') || [],
	        internal: isInternal(docs),
	        assetsDirs: parseAssetsDirs(config, staticMembers, moduleFile.jsFilePath),
	        styleDocs: [],
	        docs,
	        jsFilePath: moduleFile.jsFilePath,
	        sourceFilePath: moduleFile.sourceFilePath,
	        hasAttributeChangedCallbackFn: false,
	        hasComponentWillLoadFn: false,
	        hasComponentDidLoadFn: false,
	        hasComponentShouldUpdateFn: false,
	        hasComponentWillUpdateFn: false,
	        hasComponentDidUpdateFn: false,
	        hasComponentWillRenderFn: false,
	        hasComponentDidRenderFn: false,
	        hasComponentDidUnloadFn: false,
	        hasConnectedCallbackFn: false,
	        hasDisconnectedCallbackFn: false,
	        hasElement: false,
	        hasEvent: false,
	        hasLifecycle: false,
	        hasListener: false,
	        hasListenerTarget: false,
	        hasListenerTargetWindow: false,
	        hasListenerTargetDocument: false,
	        hasListenerTargetBody: false,
	        hasListenerTargetParent: false,
	        hasMember: false,
	        hasMethod: false,
	        hasMode: false,
	        hasAttribute: false,
	        hasProp: false,
	        hasPropNumber: false,
	        hasPropBoolean: false,
	        hasPropString: false,
	        hasPropMutable: false,
	        hasReflect: false,
	        hasRenderFn: false,
	        hasState: false,
	        hasStyle: false,
	        hasVdomAttribute: false,
	        hasVdomXlink: false,
	        hasVdomClass: false,
	        hasVdomFunctional: false,
	        hasVdomKey: false,
	        hasVdomListener: false,
	        hasVdomPropOrAttr: false,
	        hasVdomRef: false,
	        hasVdomRender: false,
	        hasVdomStyle: false,
	        hasVdomText: false,
	        hasWatchCallback: false,
	        isPlain: false,
	        htmlAttrNames: [],
	        htmlTagNames: [],
	        isUpdateable: false,
	        potentialCmpRefs: []
	    };
	    const visitComponentChildNode = (node) => {
	        if (ts.isCallExpression(node)) {
	            parseCallExpression(cmp, node);
	        }
	        else if (ts.isStringLiteral(node)) {
	            parseStringLiteral(cmp, node);
	        }
	        node.forEachChild(visitComponentChildNode);
	    };
	    visitComponentChildNode(cmpNode);
	    parseClassMethods(cmpNode, cmp);
	    cmp.legacyConnect.forEach(({ connect }) => {
	        cmp.htmlTagNames.push(connect);
	        if (connect.includes('-')) {
	            cmp.potentialCmpRefs.push(connect);
	        }
	    });
	    cmp.htmlAttrNames = unique(cmp.htmlAttrNames);
	    cmp.htmlTagNames = unique(cmp.htmlTagNames);
	    cmp.potentialCmpRefs = unique(cmp.potentialCmpRefs);
	    setComponentBuildConditionals(cmp);
	    if (transformOpts.componentMetadata === 'compilerstatic') {
	        cmpNode = addComponentMetaStatic(cmpNode, cmp);
	    }
	    // add to module map
	    moduleFile.cmps.push(cmp);
	    // add to node map
	    nodeMap.set(cmpNode, cmp);
	    fileCmpNodes.push(cmpNode);
	    return cmpNode;
	};
	const parseVirtualProps = (docs) => {
	    return docs.tags
	        .filter(({ name }) => name === 'virtualProp')
	        .map(parseVirtualProp)
	        .filter(prop => !!prop);
	};
	const parseVirtualProp = (tag) => {
	    const results = /^\s*(?:\{([^}]+)\}\s+)?(\w+)\s+-\s+(.*)$/.exec(tag.text);
	    if (!results) {
	        return undefined;
	    }
	    const [, type, name, docs] = results;
	    return {
	        type: type == null ? 'any' : type.trim(),
	        name: name.trim(),
	        docs: docs.trim()
	    };
	};
	const parseAssetsDirs = (config, staticMembers, componentFilePath) => {
	    const dirs = getStaticValue(staticMembers, 'assetsDirs') || [];
	    const componentDir = normalizePath(config.sys.path.dirname(componentFilePath));
	    return dirs.map(dir => {
	        // get the relative path from the component file to the assets directory
	        dir = normalizePath(dir.trim());
	        let absolutePath = dir;
	        let cmpRelativePath = dir;
	        if (config.sys.path.isAbsolute(dir)) {
	            // if this is an absolute path already, let's convert it to be relative
	            cmpRelativePath = config.sys.path.relative(componentDir, dir);
	        }
	        else {
	            // create the absolute path to the asset dir
	            absolutePath = config.sys.path.join(componentDir, dir);
	        }
	        return {
	            absolutePath,
	            cmpRelativePath,
	            originalComponentPath: dir,
	        };
	    });
	};

	const convertStaticToMeta = (config, compilerCtx, buildCtx, typeChecker, collection, transformOpts) => {
	    return transformCtx => {
	        let dirPath;
	        let moduleFile;
	        const fileCmpNodes = [];
	        const visitNode = (node) => {
	            if (ts.isClassDeclaration(node)) {
	                return parseStaticComponentMeta(config, compilerCtx, typeChecker, node, moduleFile, compilerCtx.nodeMap, transformOpts, fileCmpNodes);
	            }
	            else if (ts.isImportDeclaration(node)) {
	                return parseImport(config, compilerCtx, buildCtx, moduleFile, dirPath, node);
	            }
	            else if (ts.isCallExpression(node)) {
	                parseCallExpression(moduleFile, node);
	            }
	            else if (ts.isStringLiteral(node)) {
	                parseStringLiteral(moduleFile, node);
	            }
	            return ts.visitEachChild(node, visitNode, transformCtx);
	        };
	        return tsSourceFile => {
	            dirPath = config.sys.path.dirname(tsSourceFile.fileName);
	            moduleFile = getModule(config, compilerCtx, tsSourceFile.fileName);
	            resetModule(moduleFile);
	            if (collection != null) {
	                moduleFile.isCollectionDependency = true;
	                moduleFile.collectionName = collection.collectionName;
	                collection.moduleFiles.push(moduleFile);
	            }
	            else {
	                moduleFile.isCollectionDependency = false;
	                moduleFile.collectionName = null;
	            }
	            return visitNode(tsSourceFile);
	        };
	    };
	};

	const addImports = (transformOpts, tsSourceFile, importFnNames, importPath) => {
	    if (importFnNames.length === 0) {
	        return tsSourceFile;
	    }
	    if (transformOpts.module === ts.ModuleKind.CommonJS) {
	        // CommonJS require()
	        return addCjsRequires(tsSourceFile, importFnNames, importPath);
	    }
	    // ESM Imports
	    return addEsmImports(tsSourceFile, importFnNames, importPath);
	};
	const addEsmImports = (tsSourceFile, importFnNames, importPath) => {
	    // ESM Imports
	    // import { importNames } from 'importPath';
	    const importSpecifiers = importFnNames.map(importKey => {
	        const splt = importKey.split(' as ');
	        let importAs = importKey;
	        let importFnName = importKey;
	        if (splt.length > 1) {
	            importAs = splt[1];
	            importFnName = splt[0];
	        }
	        return ts.createImportSpecifier(typeof importFnName === 'string' && importFnName !== importAs ? ts.createIdentifier(importFnName) : undefined, ts.createIdentifier(importAs));
	    });
	    const statements = tsSourceFile.statements.slice();
	    const newImport = ts.createImportDeclaration(undefined, undefined, ts.createImportClause(undefined, ts.createNamedImports(importSpecifiers)), ts.createLiteral(importPath));
	    statements.unshift(newImport);
	    return ts.updateSourceFileNode(tsSourceFile, statements);
	};
	const addCjsRequires = (tsSourceFile, importFnNames, importPath) => {
	    // CommonJS require()
	    // const { a, b, c } = require(importPath);
	    const importBinding = ts.createObjectBindingPattern(importFnNames.map(importKey => {
	        const splt = importKey.split(' as ');
	        let importAs = importKey;
	        let importFnName = importKey;
	        if (splt.length > 1) {
	            importAs = splt[1];
	            importFnName = splt[0];
	        }
	        return ts.createBindingElement(undefined, importFnName, importAs);
	    }));
	    const requireStatement = ts.createVariableStatement(undefined, ts.createVariableDeclarationList([
	        ts.createVariableDeclaration(importBinding, undefined, ts.createCall(ts.createIdentifier('require'), [], [ts.createLiteral(importPath)]))
	    ], ts.NodeFlags.Const));
	    const statements = tsSourceFile.statements.slice();
	    statements.splice(2, 0, requireStatement);
	    return ts.updateSourceFileNode(tsSourceFile, statements);
	};

	const formatComponentRuntimeMeta = (compilerMeta, includeMethods) => {
	    let flags = 0;
	    if (compilerMeta.encapsulation === 'shadow') {
	        flags |= 1 /* shadowDomEncapsulation */;
	        if (compilerMeta.shadowDelegatesFocus) {
	            flags |= 16 /* shadowDelegatesFocus */;
	        }
	    }
	    else if (compilerMeta.encapsulation === 'scoped') {
	        flags |= 2 /* scopedCssEncapsulation */;
	    }
	    if (compilerMeta.encapsulation !== 'shadow' && compilerMeta.htmlTagNames.includes('slot')) {
	        flags |= 4 /* hasSlotRelocation */;
	    }
	    const members = formatComponentRuntimeMembers(compilerMeta, includeMethods);
	    const hostListeners = formatHostListeners(compilerMeta);
	    return trimFalsy([
	        flags,
	        compilerMeta.tagName,
	        Object.keys(members).length > 0 ? members : undefined,
	        hostListeners.length > 0 ? hostListeners : undefined
	    ]);
	};
	const formatComponentRuntimeMembers = (compilerMeta, includeMethods = true) => {
	    return Object.assign(Object.assign(Object.assign({}, formatPropertiesRuntimeMember(compilerMeta.properties)), formatStatesRuntimeMember(compilerMeta.states)), includeMethods ? formatMethodsRuntimeMember(compilerMeta.methods) : {});
	};
	const formatPropertiesRuntimeMember = (properties) => {
	    const runtimeMembers = {};
	    properties.forEach(member => {
	        runtimeMembers[member.name] = trimFalsy([
	            /**
	             * [0] member type
	             */
	            formatFlags(member),
	            formatAttrName(member)
	        ]);
	    });
	    return runtimeMembers;
	};
	const formatFlags = (compilerProperty) => {
	    let type = formatPropType(compilerProperty.type);
	    if (compilerProperty.mutable) {
	        type |= 1024 /* Mutable */;
	    }
	    if (compilerProperty.reflect) {
	        type |= 512 /* ReflectAttr */;
	    }
	    return type;
	};
	const formatAttrName = (compilerProperty) => {
	    if (typeof compilerProperty.attribute === 'string') {
	        // string attr name means we should observe this attribute
	        if (compilerProperty.name === compilerProperty.attribute) {
	            // property name and attribute name are the exact same
	            // true value means to use the property name for the attribute name
	            return undefined;
	        }
	        // property name and attribute name are not the same
	        // so we need to return the actual string value
	        // example: "multiWord" !== "multi-word"
	        return compilerProperty.attribute;
	    }
	    // we shouldn't even observe an attribute for this property
	    return undefined;
	};
	const formatPropType = (type) => {
	    if (type === 'string') {
	        return 1 /* String */;
	    }
	    if (type === 'number') {
	        return 2 /* Number */;
	    }
	    if (type === 'boolean') {
	        return 4 /* Boolean */;
	    }
	    if (type === 'any') {
	        return 8 /* Any */;
	    }
	    return 16 /* Unknown */;
	};
	const formatStatesRuntimeMember = (states) => {
	    const runtimeMembers = {};
	    states.forEach(member => {
	        runtimeMembers[member.name] = [
	            32 /* State */
	        ];
	    });
	    return runtimeMembers;
	};
	const formatMethodsRuntimeMember = (methods) => {
	    const runtimeMembers = {};
	    methods.forEach(member => {
	        runtimeMembers[member.name] = [
	            64 /* Method */
	        ];
	    });
	    return runtimeMembers;
	};
	const formatHostListeners = (compilerMeta) => {
	    return compilerMeta.listeners.map(compilerListener => {
	        const hostListener = [
	            computeListenerFlags(compilerListener),
	            compilerListener.name,
	            compilerListener.method,
	        ];
	        return hostListener;
	    });
	};
	const computeListenerFlags = (listener) => {
	    let flags = 0;
	    if (listener.capture) {
	        flags |= 2 /* Capture */;
	    }
	    if (listener.passive) {
	        flags |= 1 /* Passive */;
	    }
	    switch (listener.target) {
	        case 'document':
	            flags |= 4 /* TargetDocument */;
	            break;
	        case 'window':
	            flags |= 8 /* TargetWindow */;
	            break;
	        case 'parent':
	            flags |= 16 /* TargetParent */;
	            break;
	        case 'body':
	            flags |= 32 /* TargetBody */;
	            break;
	    }
	    return flags;
	};
	const trimFalsy = (data) => {
	    const arr = data;
	    for (var i = arr.length - 1; i >= 0; i--) {
	        if (arr[i]) {
	            break;
	        }
	        // if falsy, safe to pop()
	        arr.pop();
	    }
	    return arr;
	};

	const addModuleMetadataProxies = (tsSourceFile, moduleFile) => {
	    const statements = tsSourceFile.statements.slice();
	    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.proxyCustomElement);
	    statements.push(...moduleFile.cmps.map(addComponentMetadataProxy));
	    return ts.updateSourceFileNode(tsSourceFile, statements);
	};
	const addComponentMetadataProxy = (compilerMeta) => {
	    const compactMeta = formatComponentRuntimeMeta(compilerMeta, true);
	    const liternalCmpClassName = ts.createIdentifier(compilerMeta.componentClassName);
	    const liternalMeta = convertValueToLiteral(compactMeta);
	    return ts.createStatement(ts.createCall(ts.createIdentifier(PROXY_CUSTOM_ELEMENT), [], [
	        liternalCmpClassName,
	        liternalMeta
	    ]));
	};

	const defineCustomElement = (tsSourceFile, moduleFile, transformOpts) => {
	    let statements = tsSourceFile.statements.slice();
	    statements.push(...moduleFile.cmps.map(cmp => {
	        return addDefineCustomElement(moduleFile, cmp);
	    }));
	    if (transformOpts.module === ts.ModuleKind.CommonJS) {
	        // remove commonjs exports keyword from component classes
	        statements = removeComponentCjsExport(statements, moduleFile);
	    }
	    return ts.updateSourceFileNode(tsSourceFile, statements);
	};
	const addDefineCustomElement = (moduleFile, compilerMeta) => {
	    if (compilerMeta.isPlain) {
	        // add customElements.define('cmp-a', CmpClass);
	        return ts.createStatement(ts.createCall(ts.createPropertyAccess(ts.createIdentifier('customElements'), ts.createIdentifier('define')), [], [
	            ts.createLiteral(compilerMeta.tagName),
	            ts.createIdentifier(compilerMeta.componentClassName)
	        ]));
	    }
	    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.defineCustomElement);
	    const compactMeta = formatComponentRuntimeMeta(compilerMeta, true);
	    const liternalCmpClassName = ts.createIdentifier(compilerMeta.componentClassName);
	    const liternalMeta = convertValueToLiteral(compactMeta);
	    return ts.createStatement(ts.createCall(ts.createIdentifier(DEFINE_CUSTOM_ELEMENT), [], [
	        liternalCmpClassName,
	        liternalMeta
	    ]));
	};
	const removeComponentCjsExport = (statements, moduleFile) => {
	    const cmpClassNames = new Set(moduleFile.cmps.map(cmp => cmp.componentClassName));
	    return statements.filter(s => {
	        if (s.kind === ts.SyntaxKind.ExpressionStatement) {
	            const exp = s.expression;
	            if (exp && exp.kind === ts.SyntaxKind.BinaryExpression) {
	                const left = exp.left;
	                if (left && left.kind === ts.SyntaxKind.PropertyAccessExpression) {
	                    if (left.expression && left.expression.kind === ts.SyntaxKind.Identifier) {
	                        const leftText = left.expression;
	                        if (leftText.text === 'exports') {
	                            const right = exp.right;
	                            if (right && cmpClassNames.has(right.text)) {
	                                return false;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return true;
	    });
	};

	const addNativeConnectedCallback = (classMembers, cmp) => {
	    // function call to stencil's exported connectedCallback(elm, plt)
	    // TODO: fast path
	    if (cmp.isPlain && cmp.hasRenderFn) {
	        const fnCall = ts.createExpressionStatement(ts.createAssignment(ts.createPropertyAccess(ts.createThis(), 'textContent'), ts.createCall(ts.createPropertyAccess(ts.createThis(), 'render'), undefined, undefined)));
	        const connectedCallback = classMembers.find(classMember => {
	            return (ts.isMethodDeclaration(classMember) && classMember.name.escapedText === 'connectedCallback');
	        });
	        const prependBody = [
	            fnCall,
	        ];
	        if (connectedCallback != null) {
	            // class already has a connectedCallback(), so update it
	            connectedCallback.body = ts.updateBlock(connectedCallback.body, [
	                ...prependBody,
	                ...connectedCallback.body.statements
	            ]);
	        }
	        else {
	            // class doesn't have a connectedCallback(), so add it
	            const callbackMethod = ts.createMethod(undefined, undefined, undefined, 'connectedCallback', undefined, undefined, undefined, undefined, ts.createBlock(prependBody, true));
	            classMembers.push(callbackMethod);
	        }
	    }
	};

	const addNativeElementGetter = (classMembers, cmp) => {
	    // @Element() element;
	    // is transformed into:
	    // get element() { return this; }
	    if (cmp.elementRef) {
	        classMembers.push(ts.createGetAccessor(undefined, undefined, cmp.elementRef, [], undefined, ts.createBlock([
	            ts.createReturn(ts.createThis())
	        ])));
	    }
	};

	const addNativeStaticStyle = (classMembers, cmp) => {
	    if (Array.isArray(cmp.styles) && cmp.styles.length > 0) {
	        if (cmp.styles.length > 1 || (cmp.styles.length === 1 && cmp.styles[0].modeName !== DEFAULT_STYLE_MODE)) {
	            // multiple style modes
	            addMultipleModeStyleGetter(classMembers, cmp, cmp.styles);
	        }
	        else {
	            // single style
	            addSingleStyleGetter(classMembers, cmp, cmp.styles[0]);
	        }
	    }
	};
	const addMultipleModeStyleGetter = (classMembers, cmp, styles) => {
	    const styleModes = [];
	    styles.forEach(style => {
	        if (typeof style.styleStr === 'string') {
	            // inline the style string
	            // static get style() { return { "ios": "string" }; }
	            const styleLiteral = createStyleLiteral(cmp, style);
	            const propStr = ts.createPropertyAssignment(style.modeName, styleLiteral);
	            styleModes.push(propStr);
	        }
	        else if (typeof style.styleIdentifier === 'string') {
	            // direct import already written in the source code
	            // import myTagIosStyle from './import-path.css';
	            // static get style() { return { "ios": myTagIosStyle }; }
	            const styleIdentifier = ts.createIdentifier(style.styleIdentifier);
	            const propIdentifier = ts.createPropertyAssignment(style.modeName, styleIdentifier);
	            styleModes.push(propIdentifier);
	        }
	        else if (Array.isArray(style.externalStyles) && style.externalStyles.length > 0) {
	            // import generated from @Component() styleUrls option
	            // import myTagIosStyle from './import-path.css';
	            // static get style() { return { "ios": myTagIosStyle }; }
	            const styleUrlIdentifier = createStyleIdentifierFromUrl(cmp, style);
	            const propUrlIdentifier = ts.createPropertyAssignment(style.modeName, styleUrlIdentifier);
	            styleModes.push(propUrlIdentifier);
	        }
	    });
	    const styleObj = ts.createObjectLiteral(styleModes, true);
	    classMembers.push(createStaticGetter('style', styleObj));
	};
	const addSingleStyleGetter = (classMembers, cmp, style) => {
	    if (typeof style.styleStr === 'string') {
	        // inline the style string
	        // static get style() { return "string"; }
	        const styleLiteral = createStyleLiteral(cmp, style);
	        classMembers.push(createStaticGetter('style', styleLiteral));
	    }
	    else if (typeof style.styleIdentifier === 'string') {
	        // direct import already written in the source code
	        // import myTagStyle from './import-path.css';
	        // static get style() { return myTagStyle; }
	        const styleIdentifier = ts.createIdentifier(style.styleIdentifier);
	        classMembers.push(createStaticGetter('style', styleIdentifier));
	    }
	    else if (Array.isArray(style.externalStyles) && style.externalStyles.length > 0) {
	        // import generated from @Component() styleUrls option
	        // import myTagStyle from './import-path.css';
	        // static get style() { return myTagStyle; }
	        const styleUrlIdentifier = createStyleIdentifierFromUrl(cmp, style);
	        classMembers.push(createStaticGetter('style', styleUrlIdentifier));
	    }
	};
	const createStyleLiteral = (cmp, style) => {
	    if (cmp.encapsulation === 'scoped') {
	        // scope the css first
	        const scopeId = getScopeId(cmp.tagName, style.modeName);
	        return ts.createStringLiteral(scopeCss(style.styleStr, scopeId, false));
	    }
	    return ts.createStringLiteral(style.styleStr);
	};
	const createStyleIdentifierFromUrl = (cmp, style) => {
	    style.styleIdentifier = dashToPascalCase(cmp.tagName);
	    style.styleIdentifier = style.styleIdentifier.charAt(0).toLowerCase() + style.styleIdentifier.substring(1);
	    if (style.modeName !== DEFAULT_STYLE_MODE) {
	        style.styleIdentifier += dashToPascalCase(style.modeName);
	    }
	    style.styleIdentifier += 'Style';
	    style.externalStyles = [style.externalStyles[0]];
	    return ts.createIdentifier(style.styleIdentifier);
	};

	const addWatchers = (classMembers, cmp) => {
	    if (cmp.watchers.length > 0) {
	        const watcherObj = {};
	        cmp.watchers.forEach(({ propName, methodName }) => {
	            watcherObj[propName] = watcherObj[propName] || [];
	            watcherObj[propName].push(methodName);
	        });
	        classMembers.push(createStaticGetter('watchers', convertValueToLiteral(watcherObj)));
	    }
	};

	const removeStaticMetaProperties = (classNode) => {
	    if (classNode.members == null) {
	        return [];
	    }
	    return classNode.members.filter(classMember => {
	        if (classMember.modifiers) {
	            if (classMember.modifiers.some(m => m.kind === ts.SyntaxKind.StaticKeyword)) {
	                const memberName = classMember.name.escapedText;
	                if (REMOVE_STATIC_GETTERS.has(memberName)) {
	                    return false;
	                }
	            }
	        }
	        return true;
	    });
	};
	const REMOVE_STATIC_GETTERS = new Set([
	    'is',
	    'properties',
	    'encapsulation',
	    'elementRef',
	    'events',
	    'listeners',
	    'methods',
	    'states',
	    'originalStyleUrls',
	    'styleMode',
	    'style',
	    'styles',
	    'styleUrl',
	    'watchers',
	    'styleUrls',
	    'contextProps',
	    'connectProps'
	]);

	const transformHostData = (classElements, moduleFile) => {
	    const hasHostData = classElements.some(e => ts.isMethodDeclaration(e) && e.name.escapedText === 'hostData');
	    if (hasHostData) {
	        const renderIndex = classElements.findIndex(e => ts.isMethodDeclaration(e) && e.name.escapedText === 'render');
	        if (renderIndex >= 0) {
	            const renderMethod = classElements[renderIndex];
	            classElements[renderIndex] = ts.updateMethod(renderMethod, renderMethod.decorators, renderMethod.modifiers, renderMethod.asteriskToken, ts.createIdentifier(INTERNAL_RENDER), renderMethod.questionToken, renderMethod.typeParameters, renderMethod.parameters, renderMethod.type, renderMethod.body);
	        }
	        classElements.push(syntheticRender(moduleFile, renderIndex >= 0));
	    }
	};
	const syntheticRender = (moduleFile, hasRender) => {
	    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.Host);
	    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.h);
	    const hArguments = [
	        // __stencil_Host
	        ts.createIdentifier(HOST),
	        // this.hostData()
	        ts.createCall(ts.createPropertyAccess(ts.createThis(), 'hostData'), undefined, undefined)
	    ];
	    if (hasRender) {
	        hArguments.push(
	        // this.render()
	        ts.createCall(ts.createPropertyAccess(ts.createThis(), INTERNAL_RENDER), undefined, undefined));
	    }
	    /**
	     * render() {
	     *   return h(arguments);
	     * }
	     */
	    return ts.createMethod(undefined, undefined, undefined, 'render', undefined, undefined, undefined, undefined, ts.createBlock([
	        ts.createReturn(ts.createCall(ts.createIdentifier(H), undefined, hArguments))
	    ]));
	};
	const INTERNAL_RENDER = '__stencil_render';

	const updateComponentClass = (transformOpts, classNode, heritageClauses, members) => {
	    if (transformOpts.module === ts.ModuleKind.CommonJS) {
	        // CommonJS, leave component class as is
	        let classModifiers = (Array.isArray(classNode.modifiers) ? classNode.modifiers.slice() : []);
	        if (transformOpts.componentExport === 'customelement') {
	            // remove export from class
	            classModifiers = classModifiers.filter(m => {
	                return m.kind !== ts.SyntaxKind.ExportKeyword;
	            });
	        }
	        return ts.updateClassDeclaration(classNode, classNode.decorators, classModifiers, classNode.name, classNode.typeParameters, heritageClauses, members);
	    }
	    // ESM with export
	    return createConstClass(transformOpts, classNode, heritageClauses, members);
	};
	const createConstClass = (transformOpts, classNode, heritageClauses, members) => {
	    const className = classNode.name;
	    const classModifiers = (Array.isArray(classNode.modifiers) ? classNode.modifiers : []).filter(m => {
	        // remove the export
	        return m.kind !== ts.SyntaxKind.ExportKeyword;
	    });
	    const constModifiers = [];
	    if (transformOpts.componentExport !== 'customelement') {
	        constModifiers.push(ts.createModifier(ts.SyntaxKind.ExportKeyword));
	    }
	    return ts.createVariableStatement(constModifiers, ts.createVariableDeclarationList([
	        ts.createVariableDeclaration(className, undefined, ts.createClassExpression(classModifiers, undefined, classNode.typeParameters, heritageClauses, members))
	    ], ts.NodeFlags.Const));
	};

	const addCreateEvents = (moduleFile, cmp) => {
	    return cmp.events.map(ev => {
	        addCoreRuntimeApi(moduleFile, RUNTIME_APIS.createEvent);
	        return ts.createStatement(ts.createAssignment(ts.createPropertyAccess(ts.createThis(), ts.createIdentifier(ev.method)), ts.createCall(ts.createIdentifier(CREATE_EVENT), undefined, [
	            ts.createThis(),
	            ts.createLiteral(ev.name),
	            ts.createLiteral(computeFlags(ev))
	        ])));
	    });
	};
	const computeFlags = (eventMeta) => {
	    let flags = 0;
	    if (eventMeta.bubbles) {
	        flags |= 4 /* Bubbles */;
	    }
	    if (eventMeta.composed) {
	        flags |= 2 /* Composed */;
	    }
	    if (eventMeta.cancelable) {
	        flags |= 1 /* Cancellable */;
	    }
	    return flags;
	};

	const addLegacyProps = (moduleFile, cmp) => {
	    if (cmp.legacyConnect.length > 0) {
	        addCoreRuntimeApi(moduleFile, RUNTIME_APIS.getConnect);
	    }
	    if (cmp.legacyContext.length > 0) {
	        addCoreRuntimeApi(moduleFile, RUNTIME_APIS.getContext);
	    }
	    return [
	        ...cmp.legacyConnect.map(c => getStatement(c.name, GET_CONNECT, c.connect)),
	        ...cmp.legacyContext.map(c => getStatement(c.name, GET_CONTEXT, c.context))
	    ];
	};
	const getStatement = (propName, method, arg) => {
	    return ts.createExpressionStatement(ts.createAssignment(ts.createPropertyAccess(ts.createThis(), propName), ts.createCall(ts.createIdentifier(method), undefined, [
	        ts.createThis(),
	        ts.createLiteral(arg)
	    ])));
	};

	const updateNativeConstructor = (classMembers, moduleFile, cmp, ensureSuper) => {
	    if (cmp.isPlain) {
	        return;
	    }
	    const cstrMethodIndex = classMembers.findIndex(m => m.kind === ts.SyntaxKind.Constructor);
	    if (cstrMethodIndex >= 0) {
	        // add to the existing constructor()
	        const cstrMethod = classMembers[cstrMethodIndex];
	        let statements = [
	            ...nativeInit(moduleFile, cmp),
	            ...cstrMethod.body.statements,
	            ...addCreateEvents(moduleFile, cmp),
	            ...addLegacyProps(moduleFile, cmp)
	        ];
	        if (ensureSuper) {
	            const hasSuper = cstrMethod.body.statements.some(s => s.kind === ts.SyntaxKind.SuperKeyword);
	            if (!hasSuper) {
	                statements = [
	                    createNativeConstructorSuper(),
	                    ...statements
	                ];
	            }
	        }
	        classMembers[cstrMethodIndex] = ts.updateConstructor(cstrMethod, cstrMethod.decorators, cstrMethod.modifiers, cstrMethod.parameters, ts.updateBlock(cstrMethod.body, statements));
	    }
	    else {
	        // create a constructor()
	        let statements = [
	            ...nativeInit(moduleFile, cmp),
	            ...addCreateEvents(moduleFile, cmp),
	            ...addLegacyProps(moduleFile, cmp),
	        ];
	        if (ensureSuper) {
	            statements = [
	                createNativeConstructorSuper(),
	                ...statements
	            ];
	        }
	        const cstrMethod = ts.createConstructor(undefined, undefined, undefined, ts.createBlock(statements, true));
	        classMembers.unshift(cstrMethod);
	    }
	};
	const nativeInit = (moduleFile, cmp) => {
	    const initStatements = [
	        nativeRegisterHostStatement(moduleFile),
	    ];
	    if (cmp.encapsulation === 'shadow') {
	        initStatements.push(nativeAttachShadowStatement(moduleFile));
	    }
	    return initStatements;
	};
	const nativeRegisterHostStatement = (moduleFile) => {
	    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.registerHost);
	    return ts.createStatement(ts.createCall(ts.createIdentifier(REGISTER_HOST), undefined, [ts.createThis()]));
	};
	const nativeAttachShadowStatement = (moduleFile) => {
	    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.attachShadow);
	    return ts.createStatement(ts.createCall(ts.createIdentifier(ATTACH_SHADOW), undefined, [ts.createThis()]));
	};
	const createNativeConstructorSuper = () => {
	    return ts.createExpressionStatement(ts.createCall(ts.createIdentifier('super'), undefined, undefined));
	};

	const updateNativeComponentClass = (transformOpts, classNode, moduleFile, cmp) => {
	    const heritageClauses = updateNativeHostComponentHeritageClauses(classNode, moduleFile);
	    const members = updateNativeHostComponentMembers(transformOpts, classNode, moduleFile, cmp);
	    return updateComponentClass(transformOpts, classNode, heritageClauses, members);
	};
	const updateNativeHostComponentHeritageClauses = (classNode, moduleFile) => {
	    if (classNode.heritageClauses != null && classNode.heritageClauses.length > 0) {
	        return classNode.heritageClauses;
	    }
	    if (moduleFile.cmps.length > 1) {
	        addCoreRuntimeApi(moduleFile, RUNTIME_APIS.HTMLElement);
	    }
	    const heritageClause = ts.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
	        ts.createExpressionWithTypeArguments([], ts.createIdentifier(HTML_ELEMENT))
	    ]);
	    return [heritageClause];
	};
	const updateNativeHostComponentMembers = (transformOpts, classNode, moduleFile, cmp) => {
	    const classMembers = removeStaticMetaProperties(classNode);
	    updateNativeConstructor(classMembers, moduleFile, cmp, true);
	    addNativeConnectedCallback(classMembers, cmp);
	    addNativeElementGetter(classMembers, cmp);
	    addWatchers(classMembers, cmp);
	    if (transformOpts.style === 'static') {
	        addNativeStaticStyle(classMembers, cmp);
	    }
	    transformHostData(classMembers, moduleFile);
	    return classMembers;
	};

	const updateStyleImports = (transformOpts, tsSourceFile, moduleFile) => {
	    // add style imports built from @Component() styleUrl option
	    if (transformOpts.module === ts.ModuleKind.CommonJS) {
	        return updateCjsStyleRequires(tsSourceFile, moduleFile);
	    }
	    return updateEsmStyleImports(tsSourceFile, moduleFile);
	};
	const updateEsmStyleImports = (tsSourceFile, moduleFile) => {
	    const styleImports = [];
	    let statements = tsSourceFile.statements.slice();
	    let updateSourceFile = false;
	    moduleFile.cmps.forEach(cmp => {
	        cmp.styles.forEach(style => {
	            if (typeof style.styleIdentifier === 'string') {
	                updateSourceFile = true;
	                if (style.externalStyles.length > 0) {
	                    // add style imports built from @Component() styleUrl option
	                    styleImports.push(createEsmStyleImport(tsSourceFile, cmp, style));
	                }
	                else {
	                    // update existing esm import of a style identifier
	                    statements = updateEsmStyleImportPath(tsSourceFile, statements, cmp, style);
	                }
	            }
	        });
	    });
	    if (updateSourceFile) {
	        let lastImportIndex = -1;
	        for (let i = 0; i < statements.length; i++) {
	            if (ts.isImportDeclaration(statements[i])) {
	                lastImportIndex = i;
	            }
	        }
	        statements.splice(lastImportIndex + 1, 0, ...styleImports);
	        return ts.updateSourceFileNode(tsSourceFile, statements);
	    }
	    return tsSourceFile;
	};
	const updateEsmStyleImportPath = (tsSourceFile, statements, cmp, style) => {
	    for (let i = 0; i < statements.length; i++) {
	        const n = statements[i];
	        if (ts.isImportDeclaration(n) && n.importClause && n.moduleSpecifier && ts.isStringLiteral(n.moduleSpecifier)) {
	            if (n.importClause.name && n.importClause.name.escapedText === style.styleIdentifier) {
	                const orgImportPath = n.moduleSpecifier.text;
	                const importPath = getStyleImportPath(tsSourceFile, cmp, style, orgImportPath);
	                statements[i] = ts.updateImportDeclaration(n, n.decorators, n.modifiers, n.importClause, ts.createStringLiteral(importPath));
	                break;
	            }
	        }
	    }
	    return statements;
	};
	const createEsmStyleImport = (tsSourceFile, cmp, style) => {
	    const importName = ts.createIdentifier(style.styleIdentifier);
	    const importPath = getStyleImportPath(tsSourceFile, cmp, style, style.externalStyles[0].originalComponentPath);
	    return ts.createImportDeclaration(undefined, undefined, ts.createImportClause(importName, undefined), ts.createLiteral(importPath));
	};
	const updateCjsStyleRequires = (tsSourceFile, moduleFile) => {
	    const styleRequires = [];
	    moduleFile.cmps.forEach(cmp => {
	        cmp.styles.forEach(style => {
	            if (typeof style.styleIdentifier === 'string' && style.externalStyles.length > 0) {
	                // add style imports built from @Component() styleUrl option
	                styleRequires.push(createCjsStyleRequire(tsSourceFile, cmp, style));
	            }
	        });
	    });
	    if (styleRequires.length > 0) {
	        return ts.updateSourceFileNode(tsSourceFile, [
	            ...styleRequires,
	            ...tsSourceFile.statements
	        ]);
	    }
	    return tsSourceFile;
	};
	const createCjsStyleRequire = (tsSourceFile, cmp, style) => {
	    const importName = ts.createIdentifier(style.styleIdentifier);
	    const importPath = getStyleImportPath(tsSourceFile, cmp, style, style.externalStyles[0].originalComponentPath);
	    return ts.createVariableStatement(undefined, ts.createVariableDeclarationList([
	        ts.createVariableDeclaration(importName, undefined, ts.createCall(ts.createIdentifier('require'), [], [ts.createLiteral(importPath)]))
	    ], ts.NodeFlags.Const));
	};
	const getStyleImportPath = (tsSourceFile, cmp, style, importPath) => {
	    const importeeDir = pathBrowserify.dirname(tsSourceFile.fileName);
	    importPath = normalizePath(pathBrowserify.resolve(importeeDir, importPath));
	    return `${createStencilImportPath('css', cmp.tagName, cmp.encapsulation, style.modeName, importPath)}`;
	};

	const nativeComponentTransform = (compilerCtx, transformOpts) => {
	    return transformCtx => {
	        return tsSourceFile => {
	            const moduleFile = getModuleFromSourceFile(compilerCtx, tsSourceFile);
	            const visitNode = (node) => {
	                if (ts.isClassDeclaration(node)) {
	                    const cmp = getComponentMeta(compilerCtx, tsSourceFile, node);
	                    if (cmp != null) {
	                        return updateNativeComponentClass(transformOpts, node, moduleFile, cmp);
	                    }
	                }
	                return ts.visitEachChild(node, visitNode, transformCtx);
	            };
	            tsSourceFile = ts.visitEachChild(tsSourceFile, visitNode, transformCtx);
	            if (moduleFile.cmps.length > 0) {
	                if (transformOpts.componentExport === 'customelement') {
	                    // define custom element, will have no export
	                    tsSourceFile = defineCustomElement(tsSourceFile, moduleFile, transformOpts);
	                }
	                else if (transformOpts.proxy === 'defineproperty') {
	                    // exporting as a module, but also add the component proxy fn
	                    tsSourceFile = addModuleMetadataProxies(tsSourceFile, moduleFile);
	                }
	                tsSourceFile = updateStyleImports(transformOpts, tsSourceFile, moduleFile);
	            }
	            if (moduleFile.isLegacy) {
	                addLegacyApis(moduleFile);
	            }
	            tsSourceFile = addImports(transformOpts, tsSourceFile, moduleFile.coreRuntimeApis, transformOpts.coreImportPath);
	            return tsSourceFile;
	        };
	    };
	};

	const addLazyElementGetter = (classMembers, moduleFile, cmp) => {
	    // @Element() element;
	    // is transformed into:
	    // get element() { return __stencil_getElement(this); }
	    if (cmp.elementRef) {
	        addCoreRuntimeApi(moduleFile, RUNTIME_APIS.getElement);
	        classMembers.push(ts.createGetAccessor(undefined, undefined, cmp.elementRef, [], undefined, ts.createBlock([
	            ts.createReturn(ts.createCall(ts.createIdentifier(GET_ELEMENT), undefined, [ts.createThis()]))
	        ])));
	    }
	};

	const getStyleTextPlaceholder = (cmp) => {
	    return `STYLE_TEXT_PLACEHOLDER:${cmp.tagName}`;
	};

	const updateLazyComponentConstructor = (classMembers, moduleFile, cmp) => {
	    const cstrMethodArgs = [
	        ts.createParameter(undefined, undefined, undefined, ts.createIdentifier(HOST_REF_ARG))
	    ];
	    const cstrMethodIndex = classMembers.findIndex(m => m.kind === ts.SyntaxKind.Constructor);
	    if (cstrMethodIndex >= 0) {
	        // add to the existing constructor()
	        const cstrMethod = classMembers[cstrMethodIndex];
	        const body = ts.updateBlock(cstrMethod.body, [
	            registerInstanceStatement(moduleFile),
	            ...cstrMethod.body.statements,
	            ...addCreateEvents(moduleFile, cmp),
	            ...addLegacyProps(moduleFile, cmp)
	        ]);
	        classMembers[cstrMethodIndex] = ts.updateConstructor(cstrMethod, cstrMethod.decorators, cstrMethod.modifiers, cstrMethodArgs, body);
	    }
	    else {
	        // create a constructor()
	        const cstrMethod = ts.createConstructor(undefined, undefined, cstrMethodArgs, ts.createBlock([
	            registerInstanceStatement(moduleFile),
	            ...addCreateEvents(moduleFile, cmp),
	            ...addLegacyProps(moduleFile, cmp)
	        ], true));
	        classMembers.unshift(cstrMethod);
	    }
	};
	const registerInstanceStatement = (moduleFile) => {
	    addCoreRuntimeApi(moduleFile, RUNTIME_APIS.registerInstance);
	    return ts.createStatement(ts.createCall(ts.createIdentifier(REGISTER_INSTANCE), undefined, [
	        ts.createThis(),
	        ts.createIdentifier(HOST_REF_ARG)
	    ]));
	};
	const HOST_REF_ARG = 'hostRef';

	const updateLazyComponentClass = (transformOpts, classNode, moduleFile, cmp) => {
	    const members = updateLazyComponentMembers(transformOpts, classNode, moduleFile, cmp);
	    return updateComponentClass(transformOpts, classNode, classNode.heritageClauses, members);
	};
	const updateLazyComponentMembers = (transformOpts, classNode, moduleFile, cmp) => {
	    const classMembers = removeStaticMetaProperties(classNode);
	    updateLazyComponentConstructor(classMembers, moduleFile, cmp);
	    addLazyElementGetter(classMembers, moduleFile, cmp);
	    addWatchers(classMembers, cmp);
	    transformHostData(classMembers, moduleFile);
	    if (transformOpts.style === 'static') {
	        addComponentStylePlaceholders(classMembers, cmp);
	    }
	    return classMembers;
	};
	const addComponentStylePlaceholders = (classMembers, cmp) => {
	    if (cmp.hasStyle) {
	        classMembers.push(createStaticGetter('style', ts.createStringLiteral(getStyleTextPlaceholder(cmp))));
	    }
	};

	const lazyComponentTransform = (compilerCtx, transformOpts) => {
	    return transformCtx => {
	        return tsSourceFile => {
	            const moduleFile = getModuleFromSourceFile(compilerCtx, tsSourceFile);
	            const visitNode = (node) => {
	                if (ts.isClassDeclaration(node)) {
	                    const cmp = getComponentMeta(compilerCtx, tsSourceFile, node);
	                    if (cmp != null) {
	                        return updateLazyComponentClass(transformOpts, node, moduleFile, cmp);
	                    }
	                }
	                return ts.visitEachChild(node, visitNode, transformCtx);
	            };
	            tsSourceFile = ts.visitEachChild(tsSourceFile, visitNode, transformCtx);
	            if (moduleFile.isLegacy) {
	                addLegacyApis(moduleFile);
	            }
	            tsSourceFile = addImports(transformOpts, tsSourceFile, moduleFile.coreRuntimeApis, transformOpts.coreImportPath);
	            return tsSourceFile;
	        };
	    };
	};

	const updateStencilCoreImports = (updatedCoreImportPath) => {
	    return transformCtx => {
	        const visit = (tsSourceFile, node) => {
	            if (ts.isImportDeclaration(node)) {
	                return updateStencilCoreImport(node, updatedCoreImportPath);
	            }
	            return ts.visitEachChild(node, node => visit(tsSourceFile, node), transformCtx);
	        };
	        return tsSourceFile => {
	            return visit(tsSourceFile, tsSourceFile);
	        };
	    };
	};
	const updateStencilCoreImport = (importNode, updatedCoreImportPath) => {
	    if (importNode.moduleSpecifier != null && ts.isStringLiteral(importNode.moduleSpecifier)) {
	        if (importNode.moduleSpecifier.text === '@stencil/core') {
	            if (importNode.importClause && importNode.importClause.namedBindings && importNode.importClause.namedBindings.kind === ts.SyntaxKind.NamedImports) {
	                const origImports = importNode.importClause.namedBindings.elements;
	                const keepImports = origImports
	                    .map(e => e.getText())
	                    .filter(name => KEEP_IMPORTS.has(name));
	                if (keepImports.length > 0) {
	                    return ts.updateImportDeclaration(importNode, undefined, undefined, ts.createImportClause(undefined, ts.createNamedImports(keepImports.map(name => ts.createImportSpecifier(undefined, ts.createIdentifier(name))))), ts.createStringLiteral(updatedCoreImportPath));
	                }
	            }
	            return null;
	        }
	    }
	    return importNode;
	};
	const KEEP_IMPORTS = new Set([
	    'h',
	    'setMode',
	    'getMode',
	    'Build',
	    'Host',
	    'getAssetPath',
	    'writeTask',
	    'readTask',
	    'getElement',
	    'forceUpdate',
	    'getRenderingElement'
	]);

	/**
	 * Mainly used as the typescript preprocessor for unit tests
	 */
	const transpileModule = (config, input, transformOpts, sourceFilePath) => {
	    const compilerCtx = new CompilerContext(config);
	    const buildCtx = new BuildContext(config, compilerCtx);
	    if (typeof sourceFilePath === 'string') {
	        sourceFilePath = normalizePath(sourceFilePath);
	    }
	    else {
	        sourceFilePath = (transformOpts.jsx ? `module.tsx` : `module.ts`);
	    }
	    const results = {
	        sourceFilePath: sourceFilePath,
	        code: null,
	        map: null,
	        diagnostics: [],
	        moduleFile: null,
	        build: {}
	    };
	    if ((sourceFilePath.endsWith('.tsx') || sourceFilePath.endsWith('.jsx')) && transformOpts.jsx == null) {
	        // ensure we're setup for JSX in typescript
	        transformOpts.jsx = ts.JsxEmit.React;
	    }
	    if (transformOpts.jsx != null && typeof transformOpts.jsxFactory !== 'string') {
	        transformOpts.jsxFactory = 'h';
	    }
	    const sourceFile = ts.createSourceFile(sourceFilePath, input, transformOpts.target);
	    // Create a compilerHost object to allow the compiler to read and write files
	    const compilerHost = {
	        getSourceFile: fileName => {
	            return normalizePath(fileName) === normalizePath(sourceFilePath) ? sourceFile : undefined;
	        },
	        writeFile: (name, text) => {
	            if (name.endsWith('.map')) {
	                results.map = text;
	            }
	            else {
	                results.code = text;
	            }
	        },
	        getDefaultLibFileName: () => `lib.d.ts`,
	        useCaseSensitiveFileNames: () => false,
	        getCanonicalFileName: fileName => fileName,
	        getCurrentDirectory: () => '',
	        getNewLine: () => ts.sys.newLine,
	        fileExists: fileName => normalizePath(fileName) === normalizePath(sourceFilePath),
	        readFile: () => '',
	        directoryExists: () => true,
	        getDirectories: () => []
	    };
	    const program = ts.createProgram([sourceFilePath], transformOpts, compilerHost);
	    const typeChecker = program.getTypeChecker();
	    const after = [
	        convertStaticToMeta(config, compilerCtx, buildCtx, typeChecker, null, transformOpts)
	    ];
	    if (transformOpts.componentExport === 'customelement' || transformOpts.componentExport === 'native') {
	        after.push(nativeComponentTransform(compilerCtx, transformOpts));
	    }
	    else {
	        after.push(lazyComponentTransform(compilerCtx, transformOpts));
	    }
	    program.emit(undefined, undefined, undefined, false, {
	        before: [
	            convertDecoratorsToStatic(config, buildCtx.diagnostics, typeChecker),
	            updateStencilCoreImports(transformOpts.coreImportPath)
	        ],
	        after
	    });
	    const tsDiagnostics = [...program.getSyntacticDiagnostics()];
	    if (config.validateTypes) {
	        tsDiagnostics.push(...program.getOptionsDiagnostics());
	    }
	    buildCtx.diagnostics.push(...loadTypeScriptDiagnostics(tsDiagnostics));
	    results.diagnostics.push(...buildCtx.diagnostics);
	    results.moduleFile = compilerCtx.moduleMap.get(results.sourceFilePath);
	    return results;
	};

	const compile = async (code, opts = {}) => {
	    const r = {
	        diagnostics: [],
	        code: (typeof code === 'string' ? code : ''),
	        map: null,
	        inputFilePath: (typeof opts.file === 'string' ? opts.file.trim() : 'module.tsx'),
	        outputFilePath: null,
	        inputOptions: null,
	        imports: [],
	        componentMeta: []
	    };
	    try {
	        const config = getCompilerConfig();
	        r.inputOptions = getCompileOptions(opts, r.inputFilePath);
	        if (r.inputOptions.type === 'tsx' || r.inputOptions.type === 'ts' || r.inputOptions.type === 'jsx') {
	            initTypescript();
	            const transformOpts = getTransformOptions(r.inputOptions);
	            const transpileResults = transpileModule(config, code, transformOpts, r.inputFilePath);
	            r.diagnostics.push(...transpileResults.diagnostics);
	            if (typeof transpileResults.code === 'string') {
	                r.code = transpileResults.code;
	            }
	            r.map = transpileResults.map;
	            if (typeof transpileResults.sourceFilePath === 'string') {
	                r.inputFilePath = transpileResults.sourceFilePath;
	            }
	            const moduleFile = transpileResults.moduleFile;
	            if (moduleFile) {
	                r.outputFilePath = moduleFile.jsFilePath;
	                moduleFile.cmps.forEach(cmp => {
	                    r.componentMeta.push(getPublicCompilerMeta(cmp));
	                });
	                moduleFile.originalImports.forEach(originalImport => {
	                    r.imports.push({
	                        path: originalImport
	                    });
	                });
	            }
	        }
	        else if (r.inputOptions.type === 'dts') {
	            r.code = '';
	            r.map = null;
	        }
	        else if (r.inputOptions.type === 'css') {
	            const styleData = opts.data;
	            const cssResults = transformCssToEsm(config, code, r.inputFilePath, styleData.tag, styleData.encapsulation, styleData.mode);
	            r.code = cssResults.code;
	            r.map = cssResults.map;
	        }
	    }
	    catch (e) {
	        catchError(r.diagnostics, e);
	    }
	    return r;
	};

	const createCompiler = () => {
	    const stencilResolved = new Map();
	    const diagnostics = [];
	    const defaultOpts = {};
	    const reset = () => {
	        stencilResolved.clear();
	        diagnostics.length = 0;
	    };
	    const getResolvedData = (id) => {
	        return stencilResolved.get(id);
	    };
	    const setResolvedData = (id, r) => {
	        return stencilResolved.set(id, r);
	    };
	    return {
	        resolveId(importee, importer) {
	            // import Css from 'stencil?tag=cmp-a&scopeId=sc-cmp-a-md&mode=md!./filepath.css
	            const r = parseStencilImportPath(importee, importer);
	            if (r != null) {
	                setResolvedData(r.resolvedId, r);
	                return r;
	            }
	            return null;
	        },
	        getLoadPath(filePath) {
	            if (typeof filePath === 'string') {
	                return filePath.split('?')[0];
	            }
	            return null;
	        },
	        async transform(code, filePath, opts) {
	            const r = getResolvedData(filePath);
	            if (r != null) {
	                const compileOpts = Object.assign({}, defaultOpts, opts);
	                compileOpts.type = r.type;
	                compileOpts.file = r.resolvedFilePath;
	                compileOpts.data = r.data;
	                const results = await compile(code, compileOpts);
	                return {
	                    code: results.code,
	                    map: results.map,
	                    diagnostics: results.diagnostics
	                };
	            }
	            return null;
	        },
	        writeBuild() {
	            reset();
	        },
	        reset,
	        getResolvedData,
	        setResolvedData,
	    };
	};

	const stencilRollupPlugin = () => {
	    const compiler = createCompiler();
	    return {
	        name: 'stencilPlugin',
	        resolveId(importee, importer) {
	            const r = compiler.resolveId(importee, importer);
	            if (r != null) {
	                return r.resolvedId;
	            }
	            return null;
	        },
	        async transform(code, id, opts = {}) {
	            return compiler.transform(code, id, opts);
	        },
	        writeBundle() {
	            compiler.writeBuild();
	        }
	    };
	};

	const version = '1.8.11';
	const dependencies = [
	    {
	        name: 'typescript',
	        version: '3.8.2',
	        url: 'https://cdn.jsdelivr.net/npm/typescript@3.8.2/lib/typescript.js'
	    }
	];

	exports.compile = compile;
	exports.dependencies = dependencies;
	exports.getMinifyScriptOptions = getMinifyScriptOptions;
	exports.path = pathBrowserify;
	exports.rollupPlugin = stencilRollupPlugin;
	exports.version = version;

	return exports;

}({}));

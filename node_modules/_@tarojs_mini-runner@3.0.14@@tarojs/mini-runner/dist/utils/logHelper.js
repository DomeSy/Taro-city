"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bindProdLogger = exports.bindDevLogger = exports.getServeSpinner = exports.printCompiling = exports.printBuildError = exports.printPrerenderFail = exports.printPrerenderSuccess = void 0;
const ora = require("ora");
const fp_1 = require("lodash/fp");
const formatMessages = require("webpack-format-messages");
const helper_1 = require("@tarojs/helper");
const getServeSpinner = (() => {
    let spinner;
    return () => {
        if (!spinner) {
            spinner = ora('å³å°†å¼€å§‹å¯åŠ¨ç¼–è¯‘ï¼Œè¯·ç¨ç­‰~');
            spinner.start();
        }
        return spinner;
    };
})();
exports.getServeSpinner = getServeSpinner;
const printCompiling = () => {
    getServeSpinner().text = 'æ­£åœ¨ç¼–è¯‘...';
};
exports.printCompiling = printCompiling;
const printBuildError = (err) => {
    const message = err.message;
    const stack = err.stack;
    if (stack && message.indexOf('from UglifyJs') !== -1) {
        try {
            const matched = /(.+)\[(.+):(.+),(.+)\]\[.+\]/.exec(stack);
            if (!matched) {
                throw new Error('Using errors for control flow is bad.');
            }
            const problemPath = matched[2];
            const line = matched[3];
            const column = matched[4];
            console.log('Failed to minify the code from this file: \n\n', helper_1.chalk.yellow(`\t${problemPath}:${line}${column !== '0' ? ':' + column : ''}`), '\n');
        }
        catch (ignored) {
            console.log('Failed to minify the bundle.', err);
        }
    }
    else {
        console.log((message || err) + '\n');
    }
    console.log();
};
exports.printBuildError = printBuildError;
const printSuccess = () => {
    getServeSpinner().stopAndPersist({
        symbol: 'âœ… ',
        text: helper_1.chalk.green('ç¼–è¯‘æˆåŠŸ\n')
    });
};
exports.printPrerenderSuccess = (path) => {
    getServeSpinner().stopAndPersist({
        symbol: 'ðŸš€ ',
        text: helper_1.chalk.green(`é¡µé¢ ${path} é¢„æ¸²æŸ“æˆåŠŸ`)
    });
};
exports.printPrerenderFail = (path) => {
    getServeSpinner().stopAndPersist({
        symbol: 'âš ï¸ ',
        text: helper_1.chalk.yellow(`é¡µé¢ ${path} é¢„æ¸²æŸ“å¤±è´¥ï¼š`)
    });
};
const printWarning = () => {
    getServeSpinner().stopAndPersist({
        symbol: 'âš ï¸ ',
        text: helper_1.chalk.yellow('ç¼–è¯‘è­¦å‘Š.\n')
    });
};
const printFailed = () => {
    getServeSpinner().stopAndPersist({
        symbol: 'ðŸ™…  ',
        text: helper_1.chalk.red('ç¼–è¯‘å¤±è´¥.\n')
    });
};
const printWhenBeforeCompile = compiler => {
    compiler.hooks.beforeCompile.tap('taroBeforeCompile', () => {
        printCompiling();
    });
    return compiler;
};
const printWhenInvalid = compiler => {
    compiler.hooks.invalid.tap('taroInvalid', () => {
        printCompiling();
    });
    return compiler;
};
const printWhenFailed = compiler => {
    compiler.hooks.failed.tap('taroFailed', error => {
        printBuildError(error);
    });
    return compiler;
};
let isFirst = true;
const printWhenFirstDone = (compiler) => {
    compiler.hooks.done.tap('taroDone', () => {
        if (isFirst) {
            isFirst = false;
            getServeSpinner().clear();
            console.log(helper_1.chalk.gray('\nç›‘å¬æ–‡ä»¶ä¿®æ”¹ä¸­...\n'));
        }
    });
    return compiler;
};
const _printWhenDone = ({ verbose = false }, compiler) => {
    compiler.hooks.done.tap('taroDone', stats => {
        const { errors, warnings } = formatMessages(stats);
        if (!stats.hasErrors() && !stats.hasWarnings()) {
            printSuccess();
        }
        if (stats.hasErrors()) {
            printFailed();
            errors.forEach(e => console.log(e + '\n'));
            verbose && process.exit(1);
            return;
        }
        if (stats.hasWarnings()) {
            printWarning();
            warnings.forEach(w => console.log(w + '\n'));
        }
        verbose && console.log(stats.toString({
            colors: true,
            modules: false,
            children: false,
            chunks: false,
            chunkModules: false,
            warnings: verbose
        }) + '\n');
    });
    return compiler;
};
const printWhenDone = fp_1.partial(_printWhenDone, [{ verbose: false }]);
const printWhenDoneVerbosely = fp_1.partial(_printWhenDone, [{ verbose: true }]);
const bindDevLogger = compiler => {
    console.log();
    fp_1.pipe(printWhenBeforeCompile, printWhenDone, printWhenFailed, printWhenInvalid, printWhenFirstDone)(compiler);
    return compiler;
};
exports.bindDevLogger = bindDevLogger;
const bindProdLogger = compiler => {
    console.log();
    fp_1.pipe(printWhenBeforeCompile, printWhenDoneVerbosely, printWhenFailed)(compiler);
    return compiler;
};
exports.bindProdLogger = bindProdLogger;
//# sourceMappingURL=logHelper.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const lodash_1 = require("lodash");
const helper_1 = require("@tarojs/helper");
const PLUGIN_NAME = 'MainPlugin';
class MainPlugin {
    constructor(options = {}) {
        this.pagesConfigList = new Map();
        this.pages = new Set();
        this.tryAsync = fn => (arg, callback) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield fn(arg);
                callback();
            }
            catch (err) {
                callback(err);
            }
        });
        this.options = lodash_1.defaults(options || {}, {
            sourceDir: '',
            outputDir: '',
            entryFileName: 'app',
            routerConfig: {},
            framework: helper_1.FRAMEWORK_MAP.NERV
        });
        this.sourceDir = this.options.sourceDir;
        this.outputDir = this.options.outputDir;
    }
    apply(compiler) {
        this.appEntry = this.getAppEntry(compiler);
        compiler.hooks.run.tapAsync(PLUGIN_NAME, this.tryAsync(() => {
            this.run();
        }));
        compiler.hooks.watchRun.tapAsync(PLUGIN_NAME, this.tryAsync(() => {
            this.run();
        }));
        compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
            compilation.hooks.normalModuleLoader.tap(PLUGIN_NAME, (loaderContext, module) => {
                const { framework, entryFileName } = this.options;
                const { dir, name } = path.parse(module.resource);
                if (path.join(dir, name) === this.appEntry) {
                    module.loaders.unshift({
                        loader: '@tarojs/taro-loader/lib/h5',
                        options: {
                            framework,
                            filename: entryFileName,
                            pages: this.pagesConfigList,
                            config: Object.assign({ router: this.options.routerConfig }, this.appConfig)
                        }
                    });
                }
            });
        });
    }
    getAppEntry(compiler) {
        const { entry } = compiler.options;
        const { entryFileName } = this.options;
        function getEntryPath(entry) {
            const app = entry[entryFileName];
            if (Array.isArray(app)) {
                return app.filter(item => path.basename(item, path.extname(item)) === entryFileName)[0];
            }
            return app;
        }
        const appEntryPath = getEntryPath(entry);
        return appEntryPath;
    }
    run() {
        this.getAppConfig();
        this.getPages();
        this.getPagesConfigList();
    }
    getPages() {
        const appPages = this.appConfig.pages;
        if (!appPages || !appPages.length) {
            throw new Error('全局配置缺少 pages 字段，请检查！');
        }
        const { framework } = this.options;
        this.pages = new Set([
            ...appPages.map(item => ({
                name: item,
                path: helper_1.resolveMainFilePath(path.join(this.options.sourceDir, item), helper_1.FRAMEWORK_EXT_MAP[framework])
            }))
        ]);
        this.getSubPackages();
    }
    getSubPackages() {
        const appConfig = this.appConfig;
        const subPackages = appConfig.subPackages || appConfig.subpackages;
        const { framework } = this.options;
        if (subPackages && subPackages.length) {
            subPackages.forEach(item => {
                if (item.pages && item.pages.length) {
                    const root = item.root;
                    item.pages.forEach(page => {
                        var _a;
                        let pageItem = `${root}/${page}`;
                        pageItem = pageItem.replace(/\/{2,}/g, '/');
                        let hasPageIn = false;
                        this.pages.forEach(({ name }) => {
                            if (name === pageItem) {
                                hasPageIn = true;
                            }
                        });
                        if (!hasPageIn) {
                            const pagePath = helper_1.resolveMainFilePath(path.join(this.options.sourceDir, pageItem), helper_1.FRAMEWORK_EXT_MAP[framework]);
                            this.pages.add({
                                name: pageItem,
                                path: pagePath
                            });
                            // eslint-disable-next-line no-unused-expressions
                            (_a = this.appConfig.pages) === null || _a === void 0 ? void 0 : _a.push(pageItem);
                        }
                    });
                }
            });
        }
    }
    getPagesConfigList() {
        const pages = this.pages;
        pages.forEach(({ name, path }) => {
            const pageConfigPath = this.getConfigFilePath(path);
            this.pagesConfigList.set(name, pageConfigPath);
        });
    }
    getAppConfig() {
        const appConfigPath = this.getConfigFilePath(this.appEntry);
        const appConfig = helper_1.readConfig(appConfigPath);
        if (helper_1.isEmptyObject(appConfig)) {
            throw new Error('缺少 app 全局配置，请检查！');
        }
        this.appConfig = appConfig;
    }
    getConfigFilePath(filePath) {
        return helper_1.resolveMainFilePath(`${filePath.replace(path.extname(filePath), '')}.config`);
    }
}
exports.default = MainPlugin;
//# sourceMappingURL=MainPlugin.js.map
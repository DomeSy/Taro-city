'use strict';

exports.__esModule = true;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _csso = require('csso');

var _csso2 = _interopRequireDefault(_csso);

var _async = require('async');

var _async2 = _interopRequireDefault(_async);

var _RawSource = require('webpack-sources/lib/RawSource');

var _RawSource2 = _interopRequireDefault(_RawSource);

var _SourceMapSource = require('webpack-sources/lib/SourceMapSource');

var _SourceMapSource2 = _interopRequireDefault(_SourceMapSource);

var _sourceMap = require('source-map');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var filterDefault = function filterDefault(file) {
    return file.endsWith('.css');
};
var createRegexpFilter = function createRegexpFilter(regex) {
    return function (str) {
        return regex.test(str);
    };
};
var isFilterType = function isFilterType(inst) {
    return typeof inst === 'function' || inst instanceof RegExp;
};

var getOutputAssetFilename = function getOutputAssetFilename(postfix) {
    return function (file) {
        var parsed = _path2.default.parse(file);
        parsed.ext = '.' + postfix + parsed.ext;
        /* `base` for node <= 4 version required:
         *   https://travis-ci.org/zoobestik/csso-webpack-plugin/jobs/296380161#L525 */
        parsed.base = '' + parsed.name + parsed.ext;
        return _path2.default.format(parsed);
    };
};

/*
    New webpack 4 API,
    for webpack 2-3 compatibility used .plugin('...', cb)
 */
var unCamelCase = function unCamelCase(str) {
    return str.replace(/[A-Z]/g, function (letter) {
        return '-' + letter.toLowerCase();
    });
};

var pluginCompatibility = function pluginCompatibility(caller, hook, cb) {
    if (caller.hooks) {
        caller.hooks[hook].tap('csso-webpack-plugin', cb);
    } else {
        caller.plugin(unCamelCase(hook), cb);
    }
};

var CssoWebpackPlugin = function () {
    function CssoWebpackPlugin(opts, filter) {
        _classCallCheck(this, CssoWebpackPlugin);

        this.options = opts;
        this.filter = filter;
        this.pluginOutputPostfix = null;

        if (isFilterType(opts) && filter === undefined) {
            this.filter = opts;
            this.options = undefined;
        }

        if (this.filter === undefined) {
            this.filter = filterDefault;
        }

        if (this.filter instanceof RegExp) {
            this.filter = createRegexpFilter(this.filter);
        }

        if (typeof this.filter !== 'function') {
            throw new Error('filter should be one of these types: function, regexp, undefined');
        }

        var _ref = this.options || {},
            pluginOutputPostfix = _ref.pluginOutputPostfix,
            options = _objectWithoutProperties(_ref, ['pluginOutputPostfix']);

        if (pluginOutputPostfix) {
            this.pluginOutputPostfix = typeof pluginOutputPostfix === 'function' ? pluginOutputPostfix : getOutputAssetFilename(pluginOutputPostfix);
        }

        this.options = options;
    }

    CssoWebpackPlugin.prototype.apply = function apply(compiler) {
        var _this = this;

        pluginCompatibility(compiler, 'compilation', function (compilation) {
            var options = _this.options;

            pluginCompatibility(compilation, 'optimizeChunkAssets', function (chunks, done) {
                _async2.default.forEach(chunks, function (chunk, chunked) {
                    _async2.default.forEach(chunk.files, function (file, callback) {
                        try {
                            if (!_this.filter(file)) {
                                return callback();
                            }

                            var source = void 0;
                            var sourceMap = void 0;

                            var asset = compilation.assets[file];

                            if (asset.sourceAndMap) {
                                var sourceAndMap = asset.sourceAndMap();
                                sourceMap = sourceAndMap.map;
                                source = sourceAndMap.source;
                            } else {
                                sourceMap = asset.map();
                                source = asset.source();
                            }

                            if (Buffer.isBuffer(source)) {
                                source = source.toString('utf-8');
                            }

                            if (options.sourceMap !== undefined) {
                                compilation.warnings.push(new Error('CssoWebpackPlugin: ' + '“sourceMap” option is DEPRECATED. ' + 'Use webpack “devtool” instead.\n\tFor more info about the usage see ' + 'https://github.com/zoobestik/csso-webpack-plugin/releases/tag/v1.0.0-beta.8'));
                            }

                            var fileOutput = file;

                            if (_this.pluginOutputPostfix) {
                                fileOutput = _this.pluginOutputPostfix(file);
                            }

                            var _csso$minify = _csso2.default.minify(source, Object.assign({}, options, {
                                filename: fileOutput,
                                sourceMap: Boolean(compiler.options.devtool)
                            })),
                                css = _csso$minify.css,
                                map = _csso$minify.map;

                            if (map && sourceMap) {
                                map.applySourceMap(new _sourceMap.SourceMapConsumer(sourceMap), fileOutput);
                            }

                            if (!map) {
                                map = sourceMap;
                            }

                            compilation.assets[fileOutput] = map ? new _SourceMapSource2.default(css, fileOutput, map.toJSON ? map.toJSON() : map) : new _RawSource2.default(css);
                        } catch (err) {
                            var error = err;
                            var prefix = file + ' from CssoWebpackPlugin\n';
                            var message = err.message,
                                parseError = err.parseError,
                                stack = err.stack;


                            if (parseError) {
                                error = message + ' [' + file + ':' + parseError.line + ':' + parseError.column + ']';
                            } else {
                                error = message + ' ' + stack;
                            }

                            compilation.errors.push(new Error('' + prefix + error));
                        }

                        return callback();
                    }, chunked);
                }, done);
            });
        });
    };

    return CssoWebpackPlugin;
}();

exports.default = CssoWebpackPlugin;
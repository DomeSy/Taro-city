{"version":3,"sources":["../node_modules/object-assign/index.js","../src/lib.js","../src/jsonp.js","../src/store.js"],"names":["toObject","val","undefined","TypeError","Object","serializeParams","params","keys","map","item","enc","join","isFunction","fn","getUrlQueryParamByName","url","name","window","location","href","replace","regex","RegExp","results","exec","decodeURIComponent","updateQueryStringParamByName","value","re","separator","indexOf","match","jsonp","opts","cb","_typeof","assign","defaultConfig","noop","urlWithParams","generateJsonpUrlWithParams","datafromStore","getDataFromStore","useStore","storeCheck","storeCheckKey","storeSign","dataCheck","originalUrl","promiseClose","canUsePromise","Promise","resolve","reject","err","data","Error","fetchData","cleanup","funcId","script","parentNode","removeChild","win","charset","jsonpUrlQueryParam","timestamp","gotoBackupInfo","arguments","encodeC","split","pop","cache","Date","getTime","prevFunc","__$$backupCall","fallback","appendScriptTagToHead","timeout","TIMEOUT_CONST","setTimeout","retryTimes","storeCheckFn","storeData","_ref","storeKey","store","enabled","get","getDataFromStoreWithoutCheck","_ref2","setDataToStore","_ref3","set","backup","backupWithParams","Array","isArray","length","backupUrl","shift","dataFromStoreWithoutCheck","_ref4","doc","createElement","type","src","appendChild","getOwnPropertySymbols","hasOwnProperty","prototype","propIsEnumerable","propertyIsEnumerable","objectAssign$1","test1","String","getOwnPropertyNames","test2","i","fromCharCode","order2","n","test3","forEach","letter","target","source","from","to","symbols","s","key","call","encodeURIComponent","global","storage","remove","setItem","serialize","defaultVal","deserialize","getItem","removeItem","clear","callback","ret","JSON","stringify","parse","disabled","document","head","getElementsByTagName"],"mappings":";;;;IAYA,SAASA,SAASC;QACjB,IAAY,SAARA,YAAwBC,MAARD,KACnB,MAAM,IAAIE,UAAU;QAGrB,OAAOC,OAAOH;;ICff,SAAgBI,gBAAiBC;aAC1BA,eACI,gBAEFF,OAAOG,KAAKD,QAChBE,IAAI,SAAAC;mBAAYA,OAAZ,MAAoBC,IAAIJ,OAAOG;WAAWE,KAAK;;IAGxD,SAAgBC,WAAYC;eACL,qBAAPA;;IAGhB,SAAgBC,uBAAwBC,KAAKC;aACtCD,WACGE,OAAOC,SAASC;eAEjBH,KAAKI,QAAQ,SAAS;YACvBC,QAAQ,IAAIC,OAAO,SAASN,OAAO;YACnCO,UAAUF,MAAMG,KAAKT;aACtBQ,gBACI;aAEJA,QAAQ,WACJ,gBAEFE,mBAAmBF,QAAQ,GAAGH,QAAQ,OAAO;;IAGtD,SAAgBM,6BAA8BX,KAAKC,MAAMW;YACjDC,KAAK,IAAIN,OAAO,WAAWN,OAAO,aAAa;YAC/Ca,aAAkC,MAAtBd,IAAIe,QAAQ,OAAc,MAAM;YAC9Cf,IAAIgB,MAAMH,YACLb,IAAIK,QAAQQ,IAAI,OAAOZ,OAAO,MAAMW,QAAQ,mBAE9CZ,MAAMc,YAAYb,OAAO,MAAMW;;ICExC,SAASK,QAAOjB,KAAKkB,MAAMC;YACrBtB,WAAWG,MAAM;iBACdA;;eAEA,IAAIA,OAAsB,mBAAf,MAAOA,MAAP,cAAAoB,QAAOpB,OAAkB;iBACpCkB;mBACElB;kBACDkB,KAAKlB;;YAETH,WAAWqB,OAAO;iBACfA;;;aAGFA;eAGEG,mBAAWC,eAAeJ;cAC3BlB,OAAOkB,KAAKlB;aACbmB,MAAMI;YACNvB,OAAsB,mBAARA;gBASbwB,gBAAgBC,2BAA2BzB,KAAKkB,KAAK3B;gBAErDmC,gBAAgBC;0BACVT,KAAKU;0BACLJ;4BACEN,KAAKW;+BACFX,KAAKY;2BACTZ,KAAKa;2BACLb,KAAKc;;iBAEdN;qBASCO,cAAcT;qBACdP,QAAMiB,gBAAgBC,sBAClB,IAAIC,QAAQ,SAACC,SAASC;8BACjBd,eAAeN,MAAM,SAACqB,KAAKC;4BAC/BD,KAAK;+BACJA;mCACID,OAAOC;;2BAEb,MAAMC;gCACDA;;;0BAIJhB,eAAeN,MAAMC;;mBArB1B,MAAMO;qBACJT,QAAMiB,gBAAgBC,sBAClB,IAAIC,QAAQ,SAAAC;2BACVA,QAAQX;;;;eAtBhB,IAAIe,MAAM;iBACRxB,QAAMiB,gBAAgBC,sBAClB,IAAIC,QAAQ,SAACC,SAASC;uBACpBA,OAAO,IAAIG,MAAM;;;;IAwChC,SAAShB,2BAA4BzB,KAAKT;iBACb,mBAAXA,SAAsBA,SAASD,gBAAgBC;iBACtDS,IAAIe,QAAQ,OAAO,MAAM,OAAUxB;cACtCS,IAAIK,QAAQ,MAAM;eACjBL;;IAGT,SAAS0C,UAAW1C,KAAKkB,MAAMC;iBAoEpBwB,QAASC;gBACZC,OAAOC,mBACFA,WAAWC,YAAYF;gBAE5BD,UAAUrB;yBACDyB,IAAI,WAAWJ;;YAxExBX,cAAcf,KAAKe;YACnBgB,UAAU/B,KAAK+B;YACfC,qBAAqBnD,uBAAuBC,KAAKkB,KAAKD;YACtD2B,UAAiC,QAAvBM,sBAA6B,IAAQA,uBAAuBhC,KAAKjB,QAAlE,YAAoFkD;YAC7FC,iBAAiBC,UAAU,MAAM;YACnCH;gBACyB,QAAvBA,0BACIvC,6BAA6BX,KAAKkB,KAAKD,OAAOqC,QAAQV;uBAG9B,QAAxB5C,IAAIuD,MAAM,IAAIC,QAAgB,KAAK,OAAUtC,KAAKD,QAAnD,MAA4DqC,QAAQV;aAExE1B,KAAKuC,eACwB,QAAxBzD,IAAIuD,MAAM,IAAIC,QAAgB,KAAK,OAApC,OAAgD,IAAIE,OAAOC;qBAIvDX,IAAI,WAAWJ;YACtBgB,WAAWZ,IAAIJ;YACjBA,UAAU,SAAUJ;wBACVoB,SAASpB;oBACbI;gBACJQ,qBACGS,iBAAiBT;gBAEpBlC,KAAKc,WAAW;qBACW,MAAzBd,KAAKc,UAAUQ,OAAiB;;kCAGtBtB,KAAKU;kCACLK;;;2BAGLd,GAAG,MAAMqB;;qBAEsB,MAApCsB,SAAS7B,aAAaf,MAAMC,QAC3B,IAAIsB,MAAM;mBAEV;;8BAGOvB,KAAKU;8BACLK;;;mBAGT,MAAMO;;;YAGPK,SAASkB;;;;YAKTC,UAA0B,QAAhB9C,KAAK8C,UAAkB9C,KAAK8C,UAAUC;YAElD,WAAWrB,UAAUsB,WAAW;oBAC1BtB;gBAEuB,mBAApB1B,KAAKiD,cAA2BjD,KAAKiD,aAAa,GAAG;qBACzDA;uBACEzB,UAAUT,aAAaf,MAAMC;;iBAEE,MAApC2C,SAAS7B,aAAaf,MAAMC,YACvBA,GAAG,IAAIsB,MAAM;WAErBuB;;IAWL,SAASI,aAAcC,WAAWvC,eAAeC;YAC3CsC,aAAavC,iBAAiBC,kBACzBsC,UAAUvC,kBAAkBuC,UAAUvC,mBAAmBC,wBAE3D;;IAGT,SAASJ,iBAAT2C;YAA6B1C,WAAuE0C,KAAvE1C,UAAU2C,WAA6DD,KAA7DC,UAAU1C,aAAmDyC,KAAnDzC,YAAYC,gBAAuCwC,KAAvCxC,eAAeC,YAAwBuC,KAAxBvC,WAAWC,YAAasC,KAAbtC;mBAC1EJ,WAAW4C,MAAMC,WAAU;YAClC7C,UAAU;gBACNyC,YAAYG,MAAME,IAAIH;yBACf1C,cAAcuC;gBACvBvC,WAAWwC,WAAWvC,eAAeC,iBAClCC,aAAcqC,aAAarC,cAAsC,MAAzBA,UAAUqC,mBAC9CA;;eAIN;;IAGT,SAASM,6BAATC;YAAyChD,WAAiCgD,MAAjChD,UAAU2C,WAAuBK,MAAvBL,UAAUvC,YAAa4C,MAAb5C;mBAChDJ,WAAW4C,MAAMC,WAAU;YAClC7C,UAAU;gBACNyC,YAAYG,MAAME,IAAIH;iBACvBvC,aAAcqC,aAAarC,cAAsC,MAAzBA,UAAUqC,mBAC9CA;;eAGJ;;IAGT,SAASQ,eAATC;YAA2BlD,WAA4BkD,MAA5BlD,UAAU2C,WAAkBO,MAAlBP,UAAU/B,OAAQsC,MAARtC;mBAClCZ,WAAW4C,MAAMC,WAAU;YAClC7C,gBACImD,IAAIR,UAAU/B;;IAIxB,SAASsB,SAAU9D,KAAKkB,MAAMC;YACtB6D,SAAS9D,KAAK8D;YAChBC,wBAAAA;YACAD,YACoB,mBAAXA,QAAqB;mBACvB9D,KAAK8D;+BACOvD,2BAA2BuD,QAAQ9D,KAAK3B;mBACpDmD,UAAUuC,kBAAkB/D,MAAMC;;;eAGpC,IAAI+D,MAAMC,QAAQH,aACnBA,OAAOI,QAAQ;gBACXC,YAAYL,OAAOM;+BACN7D,2BAA2B4D,WAAWnE,KAAK3B;mBACvDmD,UAAUuC,kBAAkB/D,MAAMC;wBAC/BkE;;;YAMVE,4BAA4BZ;sBACtBzD,KAAKU;sBACL5B;uBACCkB,KAAKc;;YAEduD,2BAA2B;eAC1B,MAAMA;oBACF;;gBAEF;;IAGT,SAAgBxB,sBAATyB;YAAkCxF,MAAgBwF,MAAhBxF,KAAKiD,UAAWuC,MAAXvC;YACvCwC;gBAGC5C,SAAS4C,IAAIC,cAAc;mBAC1BC,OAAO;gBACV1C,gBACKA,UAAUA;mBAEZ2C,MAAM5F;iBACR6F,YAAYhD;mBACVA;;;IFpQT,IAAIiD,wBAAwBzG,OAAOyG;IACnC,IAAIC,iBAAiB1G,OAAO2G,UAAUD;IACtC,IAAIE,mBAAmB5G,OAAO2G,UAAUE;IAsDxC,IAAAC,iBA5CA;QACC;YACC,KAAK9G,OAAOgC,QACX,QAAO;YAMR,IAAI+E,QAAQ,IAAIC,OAAO;YACvBD,MAAM,KAAK;YACX,IAA6C,QAAzC/G,OAAOiH,oBAAoBF,OAAO,IACrC,QAAO;YAIR,IAAIG;YACJ,KAAK,IAAIC,IAAI,GAAGA,IAAI,IAAIA,KACvBD,MAAM,MAAMF,OAAOI,aAAaD,MAAMA;YAEvC,IAAIE,SAASrH,OAAOiH,oBAAoBC,OAAO9G,IAAI,SAAUkH;gBAC5D,OAAOJ,MAAMI;;YAEd,IAAwB,iBAApBD,OAAO9G,KAAK,KACf,QAAO;YAIR,IAAIgH;YACJ,uBAAuBrD,MAAM,IAAIsD,QAAQ,SAAUC;gBAClDF,MAAME,UAAUA;;YAEjB,IACE,2BADEzH,OAAOG,KAAKH,OAAOgC,WAAWuF,QAAQhH,KAAK,KAE9C,QAAO,QAGR,QAAO;UACN,OAAO2C;YAER,QAAO;;UAI4BlD,OAAOgC,SAAS,SAAU0F,QAAQC;QACtE,IAAIC;QACJ,IAAIC,KAAKjI,SAAS8H;QAClB,IAAII;QAEJ,KAAK,IAAIC,IAAI,GAAGA,IAAI/D,UAAU+B,QAAQgC,KAAK;YAC1CH,OAAO5H,OAAOgE,UAAU+D;YAExB,KAAK,IAAIC,OAAOJ,MACf,IAAIlB,eAAeuB,KAAKL,MAAMI,MAC7BH,GAAGG,OAAOJ,KAAKI;YAIjB,IAAIvB,uBAAuB;gBAC1BqB,UAAUrB,sBAAsBmB;gBAChC,KAAK,IAAIT,IAAI,GAAGA,IAAIW,QAAQ/B,QAAQoB,KACnC,IAAIP,iBAAiBqB,KAAKL,MAAME,QAAQX,KACvCU,GAAGC,QAAQX,MAAMS,KAAKE,QAAQX;;;QAMlC,OAAOU;;ICxFR,IAAMvH,MAAM4H;IEAZ,IAAMvE,QAAyB,sBAAX9C,SAAyBA,SAASsH;IAEtD,IAAMC,UAAUzE,MADS;IAGzB,IAAMwB;mBACM;aADE,SAEP6C,KAAKnI;qBACI,MAARA,YACKsF,MAAMkD,OAAOL;oBAEdM,QAAQN,KAAK7C,MAAMoD,UAAU1I;mBAC9BA;;aAPG,SASPmI,KAAKQ;gBACF3I,MAAMsF,MAAMsD,YAAYL,QAAQM,QAAQV;wBAC9BlI,MAARD,MAAoB2I,aAAa3I;;gBAX/B,SAaJmI;oBACEW,WAAWX;;eAdT;oBAiBFY;;aAjBE,SAmBPZ;wBACuB,MAAnB7C,MAAME,IAAI2C;;iBApBP,SAsBHa;iBACF,IAAI1B,IAAI,GAAGA,IAAIiB,QAAQrC,QAAQoB,KAAK;oBACjCa,MAAMI,QAAQJ,IAAIb;yBACfa,KAAK7C,MAAME,IAAI2C;;;gBAzBhB;gBA6BJc;kBACAtB,QAAQ,SAACQ,KAAKnI;oBACdmI,OAAOnI;;mBAENiJ;;mBAjCG,SAmCDvH;mBACFwH,KAAKC,UAAUzH;;qBApCZ,SAsCCA;gBACU,mBAAVA;uBAIFwH,KAAKE,MAAM1H;cAClB,OAAO2B;uBACA3B,cAAS;;;;IAKtB;cAEQmE,IADU,aAAA;YAAA,gBAEZP,MAAME,IAFM,oBAGR6D,YAAW;cAEbb,OALU;MAMhB,OAAOnF;cACDgG,YAAW;;IAEnB/D,MAAMC,WAAWD,MAAM+D;;;;;;IDhEvB,IAKMvF,MAAwB,sBAAX9C,SAAyBA,SAASsH;IAErD,IAAMrF,gBAAiB;eACd,aAAaa,OAAb5B,QACEvB,WAAWuC;;IAGtB,IAAMb,OAAO;IAEb,IAAM+B,UAAUiE;IAChB,IAAM9B,MAAMzC,IAAIwF;IAChB,IAAMC,OAAOhD,MAAOA,IAAIgD,QAAQhD,IAAIiD,qBAAqB,QAAQ,KAAM;IAEvE,IAAMzE,gBAAgB;IAEtB,IAAM3C;iBACK2C;oBACG;gBACJ;;eAED;cACD;gBACC;mBACG;oBACE;mBACD;uBACI;mBACJ;iBACF;;IAGX,IAAId,YAAY,IAAIO,OAAOC","file":"jsonp.js","sourcesContent":["/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","const enc = encodeURIComponent\n\nexport function serializeParams (params) {\n  if (!params) {\n    return ''\n  }\n  return Object.keys(params)\n    .map(item => (`${item}=${enc(params[item])}`)).join('&')\n}\n\nexport function isFunction (fn) {\n  return typeof fn === 'function'\n}\n\nexport function getUrlQueryParamByName (url, name) {\n  if (!url) {\n    url = window.location.href\n  }\n  name = name.replace(/[[]]/g, '\\\\$&')\n  const regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)')\n  const results = regex.exec(url)\n  if (!results) {\n    return null\n  }\n  if (!results[2]) {\n    return ''\n  }\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\nexport function updateQueryStringParamByName (url, name, value) {\n  const re = new RegExp('([?&])' + name + '=.*?(&|$)', 'i')\n  const separator = url.indexOf('?') !== -1 ? '&' : '?'\n  if (url.match(re)) {\n    return url.replace(re, '$1' + name + '=' + value + '$2')\n  }\n  return url + separator + name + '=' + value\n}\n","import assign from 'object-assign'\n\nimport { serializeParams, isFunction, getUrlQueryParamByName, updateQueryStringParamByName } from './lib'\nimport store from './store'\n\nconst win = typeof window !== 'undefined' ? window : global\n\nconst canUsePromise = (function () {\n  return 'Promise' in win &&\n    typeof isFunction(Promise)\n})()\n\nconst noop = function () {}\n\nconst encodeC = encodeURIComponent\nconst doc = win.document\nconst head = doc ? (doc.head || doc.getElementsByTagName('head')[0]) : null\n\nconst TIMEOUT_CONST = 2000\n\nconst defaultConfig = {\n  timeout: TIMEOUT_CONST,\n  retryTimes: 2,\n  backup: null,\n  params: {},\n  jsonp: 'callback',\n  name: null,\n  cache: false,\n  useStore: false,\n  storeCheck: null,\n  storeSign: null,\n  storeCheckKey: null,\n  dataCheck: null,\n  charset: 'UTF-8'\n}\n\nlet timestamp = new Date().getTime()\n\nfunction jsonp (url, opts, cb) {\n  if (isFunction(url)) {\n    cb = url\n    opts = {}\n  } else if (url && typeof url === 'object') {\n    cb = opts\n    opts = url || {}\n    url = opts.url\n  }\n  if (isFunction(opts)) {\n    cb = opts\n    opts = {}\n  }\n  if (!opts) {\n    opts = {}\n  }\n  opts = assign({}, defaultConfig, opts)\n  url = url || opts.url\n  cb = cb || noop\n  if (!url || typeof url !== 'string') {\n    cb(new Error('Param url is needed!'))\n    if (!jsonp.promiseClose && canUsePromise) {\n      return new Promise((resolve, reject) => {\n        return reject(new Error('Param url is needed!'))\n      })\n    }\n    return\n  }\n  const urlWithParams = generateJsonpUrlWithParams(url, opts.params)\n  // first get data from store\n  const datafromStore = getDataFromStore({\n    useStore: opts.useStore,\n    storeKey: urlWithParams,\n    storeCheck: opts.storeCheck,\n    storeCheckKey: opts.storeCheckKey,\n    storeSign: opts.storeSign,\n    dataCheck: opts.dataCheck\n  })\n  if (datafromStore) {\n    cb(null, datafromStore)\n    if (!jsonp.promiseClose && canUsePromise) {\n      return new Promise(resolve => {\n        return resolve(datafromStore)\n      })\n    }\n    return\n  }\n  opts.originalUrl = urlWithParams\n  if (!jsonp.promiseClose && canUsePromise) {\n    return new Promise((resolve, reject) => {\n      fetchData(urlWithParams, opts, (err, data) => {\n        if (err) {\n          cb(err)\n          return reject(err)\n        }\n        cb(null, data)\n        resolve(data)\n      })\n    })\n  }\n  fetchData(urlWithParams, opts, cb)\n}\n\nfunction generateJsonpUrlWithParams (url, params) {\n  params = typeof params === 'string' ? params : serializeParams(params)\n  url += (~url.indexOf('?') ? '&' : '?') + `${params}`\n  url = url.replace('?&', '?')\n  return url\n}\n\nfunction fetchData (url, opts, cb) {\n  const originalUrl = opts.originalUrl\n  const charset = opts.charset\n  const jsonpUrlQueryParam = getUrlQueryParamByName(url, opts.jsonp)\n  const funcId = (jsonpUrlQueryParam === '?' ? false : jsonpUrlQueryParam) || opts.name || `__jsonp${timestamp++}`\n  const gotoBackupInfo = arguments[3] || null\n  if (jsonpUrlQueryParam) {\n    if (jsonpUrlQueryParam === '?') {\n      url = updateQueryStringParamByName(url, opts.jsonp, encodeC(funcId))\n    }\n  } else {\n    url += (url.split('').pop() === '&' ? '' : '&') + `${opts.jsonp}=${encodeC(funcId)}`\n  }\n  if (!opts.cache) {\n    url += (url.split('').pop() === '&' ? '' : '&') + `_=${new Date().getTime()}`\n  }\n\n  // move prev callback into next when fetch parallel with same funcId\n  clearTimeout(win['timer_' + funcId])\n  const prevFunc = win[funcId]\n  win[funcId] = function (data) {\n    prevFunc && prevFunc(data)\n    cleanup(funcId)\n    if (gotoBackupInfo) {\n      data.__$$backupCall = gotoBackupInfo\n    }\n    if (opts.dataCheck) {\n      if (opts.dataCheck(data) !== false) {\n        // write data to store\n        setDataToStore({\n          useStore: opts.useStore,\n          storeKey: originalUrl,\n          data\n        })\n        return cb(null, data)\n      }\n      if (fallback(originalUrl, opts, cb) === false) {\n        cb(new Error('Data check error, and no fallback'))\n      }\n    } else {\n      // write data to store\n      setDataToStore({\n        useStore: opts.useStore,\n        storeKey: originalUrl,\n        data\n      })\n      cb(null, data)\n    }\n  }\n  const script = appendScriptTagToHead({\n    url,\n    charset\n  })\n\n  const timeout = opts.timeout != null ? opts.timeout : TIMEOUT_CONST\n  // when timeout, will try to retry\n  win['timer_' + funcId] = setTimeout(() => {\n    cleanup(funcId)\n    // no retryTimes left, go to backup\n    if (typeof opts.retryTimes === 'number' && opts.retryTimes > 0) {\n      opts.retryTimes--\n      return fetchData(originalUrl, opts, cb)\n    }\n    if (fallback(originalUrl, opts, cb) === false) {\n      return cb(new Error('Timeout and no data return'))\n    }\n  }, timeout)\n\n  function cleanup (funcId) {\n    if (script.parentNode) {\n      script.parentNode.removeChild(script)\n    }\n    win[funcId] = noop\n    clearTimeout(win['timer_' + funcId])\n  }\n}\n\nfunction storeCheckFn (storeData, storeCheckKey, storeSign) {\n  if (storeData && storeCheckKey && storeSign) {\n    return storeData[storeCheckKey] && storeData[storeCheckKey] === storeSign\n  }\n  return false\n}\n\nfunction getDataFromStore ({ useStore, storeKey, storeCheck, storeCheckKey, storeSign, dataCheck }) {\n  useStore = useStore ? store.enabled : false\n  if (useStore) {\n    const storeData = store.get(storeKey)\n    storeCheck = storeCheck || storeCheckFn\n    if (storeCheck(storeData, storeCheckKey, storeSign)) {\n      if (!dataCheck || (storeData && dataCheck && dataCheck(storeData) !== false)) {\n        return storeData\n      }\n    }\n  }\n  return null\n}\n\nfunction getDataFromStoreWithoutCheck ({ useStore, storeKey, dataCheck }) {\n  useStore = useStore ? store.enabled : false\n  if (useStore) {\n    const storeData = store.get(storeKey)\n    if (!dataCheck || (storeData && dataCheck && dataCheck(storeData) !== false)) {\n      return storeData\n    }\n  }\n  return null\n}\n\nfunction setDataToStore ({ useStore, storeKey, data }) {\n  useStore = useStore ? store.enabled : false\n  if (useStore) {\n    store.set(storeKey, data)\n  }\n}\n\nfunction fallback (url, opts, cb) {\n  const backup = opts.backup\n  let backupWithParams\n  if (backup) {\n    if (typeof backup === 'string') {\n      delete opts.backup\n      backupWithParams = generateJsonpUrlWithParams(backup, opts.params)\n      return fetchData(backupWithParams, opts, cb, {\n        backup\n      })\n    } else if (Array.isArray(backup)) {\n      if (backup.length) {\n        const backupUrl = backup.shift()\n        backupWithParams = generateJsonpUrlWithParams(backupUrl, opts.params)\n        return fetchData(backupWithParams, opts, cb, {\n          backup: backupUrl\n        })\n      }\n    }\n  }\n  // no backup to use, try to get data from store\n  const dataFromStoreWithoutCheck = getDataFromStoreWithoutCheck({\n    useStore: opts.useStore,\n    storeKey: url,\n    dataCheck: opts.dataCheck\n  })\n  if (dataFromStoreWithoutCheck) {\n    cb(null, dataFromStoreWithoutCheck)\n    return true\n  }\n  return false\n}\n\nexport function appendScriptTagToHead ({ url, charset }) {\n  if (!doc) {\n    return\n  }\n  const script = doc.createElement('script')\n  script.type = 'text/javascript'\n  if (charset) {\n    script.charset = charset\n  }\n  script.src = url\n  head.appendChild(script)\n  return script\n}\n\nexport default jsonp\n","const win = (typeof window !== 'undefined' ? window : global)\nconst localStorageName = 'localStorage'\nconst storage = win[localStorageName]\n\nconst store = {\n  disabled: false,\n  set (key, val) {\n    if (val === void 666) {\n      return store.remove(key)\n    }\n    storage.setItem(key, store.serialize(val))\n    return val\n  },\n  get (key, defaultVal) {\n    const val = store.deserialize(storage.getItem(key))\n    return (val === undefined ? defaultVal : val)\n  },\n  remove (key) {\n    storage.removeItem(key)\n  },\n  clear () {\n    storage.clear()\n  },\n  has (key) {\n    return store.get(key) !== void 666\n  },\n  forEach (callback) {\n    for (let i = 0; i < storage.length; i++) {\n      const key = storage.key(i)\n      callback(key, store.get(key))\n    }\n  },\n  getAll () {\n    const ret = {}\n    store.forEach((key, val) => {\n      ret[key] = val\n    })\n    return ret\n  },\n  serialize (value) {\n    return JSON.stringify(value)\n  },\n  deserialize (value) {\n    if (typeof value !== 'string') {\n      return\n    }\n    try {\n      return JSON.parse(value)\n    } catch (err) {\n      return value || void 666\n    }\n  }\n}\n\ntry {\n  const testKey = '__store__'\n  store.set(testKey, testKey)\n  if (store.get(testKey) !== testKey) {\n    store.disabled = true\n  }\n  store.remove(testKey)\n} catch (err) {\n  store.disabled = true\n}\nstore.enabled = !store.disabled\n\nexport default store\n"]}
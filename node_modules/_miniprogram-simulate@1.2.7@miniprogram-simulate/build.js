window["simulate"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 59);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(100);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(98);


/***/ }),
/* 2 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports=function(e){function t(n){if(r[n])return r[n].exports;var o=r[n]={exports:{},id:n,loaded:!1};return e[n].call(o.exports,o,o.exports,t),o.loaded=!0,o.exports}var r={};return t.m=e,t.c=r,t.p="",t(0)}([function(e,t,r){var n=r(1),o=r(3),i=r(5),a=r(6),l=r(7),s=r(8),_=r(9),c=r(15),u=r(12),d=r(17),f=r(18),p=r(19),h=r(16),v=r(10),m=r(20),b=r(14),g=r(4),w=r(13),y=r(21);t.FreeTmpl=y,t.precompileTemplate=y.precompiler?y.precompiler.compile:null,t.precompiler=y.precompiler?y.precompiler:null,t.HtmlLLParser=y.htmlParser?y.htmlParser:null,t.LLParser=n,t.dataPath=l,t.dataUtils=i,t.Event=a,t.Element=_,t.TextNode=u,t.NativeNode=d,t.VirtualNode=f,t.ShadowRoot=p,t.Behavior=s,t.Component=c,t.Observer=v,t.DataGroup=h,t.ElementIterator=m,t.FakeDomElement=b,t.registerBehavior=s.create,t.registerElement=c.register,t.createElement=c.create,t.createTextNode=u.create,t.createVirtualNode=f.create,t.appendChild=_.appendChild,t.insertBefore=_.insertBefore,t.removeChild=_.removeChild,t.replaceChild=_.replaceChild,t.addListenerToElement=a.addListenerToElement,t.removeListenerFromElement=a.removeListenerFromElement,t.triggerEvent=a.triggerEvent,t.safeCallback=o.safeCallback,t.addGlobalErrorListener=o.addGlobalErrorListener,t.removeGlobalErrorListener=o.removeGlobalErrorListener,t.globalOptions=g,t.globalState=w,c._setDefaultTemplateEngine(y);var x=t.updateDefaultComponent=function(){delete c._list[""],c.register({is:"",options:{writeOnly:!0,allowInWriteOnly:!0,lazyRegistration:!1,classPrefix:"",addGlobalClass:!1,templateEngine:null,renderingMode:"full",multipleSlots:!1,reflectToAttributes:!1}})};x();var C=function(e){var t="";if(e instanceof exparser.Element&&(e.id&&(t+=' id="'+e.id+'"'),e.slot&&(t+=' slot="'+e.slot+'"'),e.__slotName&&(t+=' name="'+e.__slotName+'"'),e.classList&&(t+=' class="'+e.class+'"'),e.$$&&e.$$.getAttribute("style")&&(t+=' style="'+e.$$.getAttribute("style")+'"')),e instanceof exparser.VirtualNode)return t;if(e instanceof exparser.Component)return c.listPublicProperties(e).forEach(function(r){t+=" "+r+"="+JSON.stringify(e[r])}),t;for(var r=e.attributes,n=0;n<r.length;n++)t+=" "+r[n].name+'="'+r[n].value+'"';return t},E=t.dumpElementToString=function(e,t,r){var n=null;g.hasDOMBackend&&(n=window);var o=0;r=r||0;var i="";for(o=r;o;o--)i+="  ";var a="";if(e instanceof exparser.Element)a+=i+"<"+(e.$$?e.$$.tagName.toLowerCase()+":":"")+e.is+C(e)+">",a+=e instanceof exparser.VirtualNode?" [Exp-Virtual]":e instanceof exparser.NativeNode?" [Exp-Native]":" [Exp-Component]",a+="\n"+E(t?e.__wxSlotChildren:e.childNodes,t,r+1);else if(e instanceof exparser.TextNode)a+=i+e.textContent+" [Exp-Text]\n";else if(n&&n.HTMLElement&&e instanceof n.HTMLElement)a+=i+"<"+e.tagName.toLowerCase()+C(e)+"> [DOM-Element]",a+="\n"+E(t?e.__wxSlotChildren||e.childNodes:e.childNodes,t,r+1);else if(n&&n.Text&&e instanceof n.Text)a+=i+e.textContent+" [DOM-Text]\n";else if(void 0!==e.length)for(o=0;o<e.length;o++)a+=E(e[o],t,r);else a=i+"[unknown node]\n";return a};t.dumpElement=function(e,t){console.log(E(e,t))}},function(e,t,r){var n=null,o=16384,i=128,a=128,l=0,s=1,_=65536,c=function(){},u=c.stats={all:0,copyIn:0,parse:0,constructOut:0},d=function(e){var t=n.llparser_create_descriptor(e,1);return t},f=function(e,t){var r=n.llparser_create_descriptor(e,0),o=!1;"^"===t[0]&&(o=!0);for(var i=o?1:0;i<t.length;i++){var a=t.charCodeAt(i);if("-"===t[i+1]){var l=t.charCodeAt(i+2);a<=l?(n.llparser_descriptor_add_range(r,a,l),i+=2):n.llparser_descriptor_add_char(r,a)}else n.llparser_descriptor_add_char(r,a)}return o&&n.llparser_descriptor_revert(r),r};c.create=function(e,t,u){n||(n=r(2));var p=new c;u=u||o;var h=p._llp=n.llparser_create(u,i,a),v={},m={},b="";v.ALL=n.llparser_create_descriptor(h,0),n.llparser_descriptor_set_all(v.ALL),v.NULL=n.llparser_create_descriptor(h,0),n.llparser_descriptor_set_nil(v.NULL);for(b in e)v[b]=d(h);for(b in e)for(var g=e[b],w=v[b],y=0;y<g.length;y++){for(var x=g[y].id,C=g[y].states,E=[],S=0;S<C.length;S++){var O=C[S];v[O]||(v[O]=f(h,O)),E.push(v[O])}var N=l;"_raw"===x?N=s:"_jump"===x?N=_+0:"_blank"===x&&(N=_+1);var k=n.llparser_add_rule(h,N,w,E.length,E[0],E[1],E[2],E[3],E[4],E[5],E[6],E[7]);N===l&&(m[k]=t[x])}return n.llparser_prepare(h),p._inputPtr=n.llparser_get_input_buffer(h),p._resultPtr=n.llparser_get_result(h),p._stateIdMap=v,p._ruleCbMap=m,p._charCountLimit=u,p};var p=function(e,t,r,n,o){for(var i=[],a={i:0,r:0,n:!1,cc:-1,c:[]},l=a,s=o.pos,_=!1,c=!1,u=!1;;){var d=t[s],f=t[s+1];if(f<0?(c=!0,f=-f-1):c=!1,d>=0){u=!0;var p=r.slice(d,f);l.c.push(p),_=c}else{if(d===-1&&0===f)break;u=!1;var h=-d,v=f,m={i:l.c.length-(_?1:0),r:h,n:c,cc:v,c:[]};if(_){var b=l.c.length-1,g=l.c[b];m.c.push(g),l.c[b]=m}else l.c.push(m);i.push(l),l=m,_=!1}if(!u||!_)for(;l.c.length===l.cc;){_=l.n;var w=i.pop();if(w.c[l.i]=n[l.r].call(e,l.c),l=w,_)break}s+=2}return a.c[0]},h=function(e,t,r,n){for(var o=n>e.length?e.length:n,i=0;i<o;i++)t[r+i]=e.charCodeAt(i);t[r+o]=0};c.prototype.parse=function(e,t){var r=Date.now();h(t,new Uint16Array(n.memory.buffer),this._inputPtr>>1,this._charCountLimit),u.copyIn=u.copyIn+Date.now()-r,r=Date.now();var o=n.llparser_parse(this._llp,this._stateIdMap[e]);if(u.parse=u.parse+Date.now()-r,r=Date.now(),o)throw new Error("Parsing failed at character position "+(o-1)+' near "'+t.slice(o-20,o)+'"');var i=p(this,new Int32Array(n.memory.buffer),t,this._ruleCbMap,{pos:this._resultPtr>>2});return u.constructOut=u.constructOut+Date.now()-r,i},c.prototype.destroy=function(){n.llparser_destroy(this._llp)},e.exports=c},function(e,t){e.exports=function(e){function t(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var r={};return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:n})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(t.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var o in e)t.d(n,o,function(t){return e[t]}.bind(null,o));return n},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=0)}([function(e,t,r){"use strict";function n(e,t,r){return m.llparser_create(e,t,r)}function o(e){m.llparser_destroy(e)}function i(e,t){return m.llparser_create_descriptor(e,t)}function a(e){m.llparser_descriptor_set_all(e)}function l(e){m.llparser_descriptor_set_nil(e)}function s(e,t){m.llparser_descriptor_add_char(e,t)}function _(e,t,r){m.llparser_descriptor_add_range(e,t,r)}function c(e){m.llparser_descriptor_revert(e)}function u(e,t,r,n,o,i,a,l,s,_,c,u){return m.llparser_add_rule(e,t,r,n,o,i,a,l,s,_,c,u)}function d(e){m.llparser_prepare(e)}function f(e,t){return m.llparser_parse(e,t)}function p(e){return m.llparser_get_input_buffer(e)}function h(e){return m.llparser_get_result(e)}function v(){m.wasm_main()}r.r(t),r.d(t,"llparser_create",function(){return n}),r.d(t,"llparser_destroy",function(){return o}),r.d(t,"llparser_create_descriptor",function(){return i}),r.d(t,"llparser_descriptor_set_all",function(){return a}),r.d(t,"llparser_descriptor_set_nil",function(){return l}),r.d(t,"llparser_descriptor_add_char",function(){return s}),r.d(t,"llparser_descriptor_add_range",function(){return _}),r.d(t,"llparser_descriptor_revert",function(){return c}),r.d(t,"llparser_add_rule",function(){return u}),r.d(t,"llparser_prepare",function(){return d}),r.d(t,"llparser_parse",function(){return f}),r.d(t,"llparser_get_input_buffer",function(){return p}),r.d(t,"llparser_get_result",function(){return h}),r.d(t,"wasm_main",function(){return v}),r.d(t,"memory",function(){return b});var m=r(1),b=m.memory;m.__wbindgen_start()},function(e,t,r){"use strict";r.r(t),r.d(t,"memory",function(){return i}),r.d(t,"rust_calloc",function(){return a}),r.d(t,"rust_free",function(){return l}),r.d(t,"llparser_create",function(){return s}),r.d(t,"llparser_destroy",function(){return _}),r.d(t,"llparser_create_descriptor",function(){return c}),r.d(t,"llparser_descriptor_set_all",function(){return u}),r.d(t,"llparser_descriptor_set_nil",function(){return d}),r.d(t,"llparser_descriptor_add_char",function(){return f}),r.d(t,"llparser_descriptor_add_range",function(){return p}),r.d(t,"llparser_descriptor_revert",function(){return h}),r.d(t,"llparser_add_rule",function(){return v}),r.d(t,"llparser_prepare",function(){return m}),r.d(t,"llparser_parse",function(){return b}),r.d(t,"llparser_get_input_buffer",function(){return g}),r.d(t,"llparser_get_result",function(){return w}),r.d(t,"wasm_main",function(){return y}),r.d(t,"__wbindgen_start",function(){return x});var n=new ArrayBuffer(1114112),o=function(e,t,r){function n(e){var t=0,r=0,n=0,o=0,i=0,a=0,_=0;r=(t=e+-8|0)+(e=-8&(o=m[e+-4>>2]))|0;e:{t:{r:{n:{o:if(!(1&o)){if(!(3&o))break n;if(e=(o=m[t>>2])+e|0,(0|(t=t-o|0))==m[262246]){if(3!=(3&m[r+4>>2]))break o;return m[262244]=e,m[r+4>>2]=-2&m[r+4>>2],m[t+4>>2]=1|e,void(m[e+t>>2]=e)}o>>>0>=256?s(t):(0|(n=m[t+8>>2]))==(0|(i=m[t+12>>2]))?(a=1048576,_=m[262144]&p(o>>>3),m[a>>2]=_):(m[n+12>>2]=i,m[i+8>>2]=n)}if(2&(o=m[r+4>>2]))m[r+4>>2]=-2&o,m[t+4>>2]=1|e,m[e+t>>2]=e;else{o:{if(m[262247]!=(0|r)){if((0|r)!=m[262246])break o;return m[262246]=t,e=m[262244]+e|0,m[262244]=e,m[t+4>>2]=1|e,void(m[e+t>>2]=e)}if(m[262247]=t,e=m[262245]+e|0,m[262245]=e,m[t+4>>2]=1|e,(0|t)==m[262246]&&(m[262244]=0,m[262246]=0),(r=m[262254])>>>0>=e>>>0)break n;if(!(e=m[262247]))break n;i:if(!((o=m[262245])>>>0<41))for(t=1049e3;;){if((n=m[t>>2])+m[t+4>>2]>>>0>e>>>0&&n>>>0<=e>>>0)break i;if(!(t=m[t+8>>2]))break}if(n=4095,e=m[262252]){for(t=0;t=t+1|0,e=m[e+8>>2];);n=t>>>0>4095?t:4095}if(m[262256]=n,o>>>0<=r>>>0)break n;return void(m[262254]=-1)}if(e=(n=-8&o)+e|0,n>>>0>=256?s(r):(0|(n=m[r+12>>2]))==(0|(r=m[r+8>>2]))?(a=1048576,_=m[262144]&p(o>>>3),m[a>>2]=_):(m[r+12>>2]=n,m[n+8>>2]=r),m[t+4>>2]=1|e,m[e+t>>2]=e,m[262246]==(0|t)){m[262244]=e;break n}}if(e>>>0<256)break r;if(l(t,e),e=m[262256]+-1|0,m[262256]=e,!e){if(e=m[262252])break t;e=4095;break e}}return}return e=1048584+((r=e>>>3)<<3)|0,o=m[262144],r=1<<(31&r),n=m[e+8>>2],o&r||(m[262144]=r|o,n=e),r=n,m[e+8>>2]=t,m[r+12>>2]=t,m[t+12>>2]=e,void(m[t+8>>2]=r)}for(t=0;t=t+1|0,e=m[e+8>>2];);e=t>>>0>4095?t:4095}m[262256]=e}function o(e,t,r,n,o,i,a,l,s,_,c,u){var d;return C=d=C+-64|0,m[d+60>>2]=e,m[d+56>>2]=t,m[d+52>>2]=r,m[d+48>>2]=n,m[d+44>>2]=o,m[d+40>>2]=i,m[d+36>>2]=a,m[d+32>>2]=l,m[d+28>>2]=s,m[d+24>>2]=_,m[d+20>>2]=c,m[d+16>>2]=u,t=m[m[d+60>>2]+28>>2],r=m[d+60>>2],e=m[r>>2],m[r>>2]=e+1,m[d+12>>2]=t+y(e,44),m[m[d+12>>2]>>2]=m[d+52>>2],m[m[d+12>>2]+4>>2]=m[d+48>>2],m[d+48>>2]>0&&(m[m[d+12>>2]+8>>2]=m[d+44>>2]),m[d+48>>2]>1&&(m[m[d+12>>2]+12>>2]=m[d+40>>2]),m[d+48>>2]>2&&(m[m[d+12>>2]+16>>2]=m[d+36>>2]),m[d+48>>2]>3&&(m[m[d+12>>2]+20>>2]=m[d+32>>2]),m[d+48>>2]>4&&(m[m[d+12>>2]+24>>2]=m[d+28>>2]),m[d+48>>2]>5&&(m[m[d+12>>2]+28>>2]=m[d+24>>2]),m[d+48>>2]>6&&(m[m[d+12>>2]+32>>2]=m[d+20>>2]),m[d+48>>2]>7&&(m[m[d+12>>2]+36>>2]=m[d+16>>2]),m[m[d+12>>2]+40>>2]=m[d+56>>2],m[d+48>>2]>0&&function(e,t,r){var n=0;m[28+(n=C-32|0)>>2]=e,m[n+24>>2]=t,m[n+20>>2]=r,m[n+16>>2]=(m[n+20>>2]-m[m[n+28>>2]+24>>2]|0)/140,1==m[m[n+20>>2]+4>>2]&&(t=m[m[n+28>>2]+40>>2],r=m[n+28>>2],e=m[r+8>>2],m[r+8>>2]=e+1,m[n+12>>2]=t+(e<<3),m[m[n+12>>2]>>2]=m[n+24>>2],m[m[n+12>>2]+4>>2]=m[m[n+20>>2]+136>>2],m[m[n+20>>2]+136>>2]=m[n+12>>2])}(m[d+60>>2],m[d+12>>2],m[d+52>>2]),C=d- -64|0,m[d+12>>2]}function i(e,t,r,n,o){var a;if(C=a=C-48|0,m[a+44>>2]=e,m[a+40>>2]=t,m[a+36>>2]=r,m[a+32>>2]=n,m[a+28>>2]=o,m[m[a+40>>2]>>2]!=m[a+36>>2])for(m[m[a+40>>2]>>2]=m[a+36>>2],m[a+24>>2]=m[m[a+40>>2]+136>>2],m[a+20>>2]=1&(0!=m[a+28>>2]^-1^-1);m[a+24>>2];){for(m[a+20>>2]||(m[a+28>>2]=m[a+24>>2]),m[a+16>>2]=m[m[m[a+24>>2]>>2]+8>>2],1==m[m[a+16>>2]+4>>2]&&i(m[a+44>>2],m[a+16>>2],m[a+36>>2],m[a+32>>2],m[a+28>>2]),m[a+12>>2]=0;!(m[a+12>>2]>=128);)b[m[a+12>>2]+(m[a+16>>2]+8|0)|0]&&(w[m[a+28>>2]>>2]>=w[m[a+32>>2]+(m[a+12>>2]<<2)>>2]&&m[m[a+32>>2]+(m[a+12>>2]<<2)>>2]||(m[m[a+32>>2]+(m[a+12>>2]<<2)>>2]=m[m[a+28>>2]>>2])),m[a+12>>2]=m[a+12>>2]+1;m[a+24>>2]=m[m[a+24>>2]+4>>2]}C=a+48|0}function a(e,t,r,n){var o;for(m[44+(o=C-48|0)>>2]=e,m[o+40>>2]=t,m[o+36>>2]=r,m[o+32>>2]=n,m[o+28>>2]=m[m[o+40>>2]+136>>2];m[o+28>>2];){if(m[o+24>>2]=m[m[m[o+28>>2]>>2]+8>>2],m[o+24>>2]==m[o+40>>2])for(m[o+20>>2]=m[m[m[o+28>>2]>>2]+12>>2],m[o+16>>2]=0;!(m[o+16>>2]>=128);){e:{if(1!=m[m[o+20>>2]+4>>2]){if(!b[m[o+16>>2]+(m[o+20>>2]+8|0)|0])break e}else if(m[o+12>>2]=m[m[o+44>>2]+32>>2]+((m[o+20>>2]-m[m[o+44>>2]+24>>2]|0)/140<<9),!m[m[o+12>>2]+(m[o+16>>2]<<2)>>2])break e;w[m[o+28>>2]>>2]>=w[m[o+32>>2]+(m[o+16>>2]<<2)>>2]&&m[m[o+32>>2]+(m[o+16>>2]<<2)>>2]||(m[m[o+32>>2]+(m[o+16>>2]<<2)>>2]=m[m[o+28>>2]>>2])}m[o+16>>2]=m[o+16>>2]+1}m[o+28>>2]=m[m[o+28>>2]+4>>2]}}function l(e,t){var r=0,n=0,o=0,i=0;m[e+16>>2]=0,m[e+20>>2]=0,o=e,r=0,(n=t>>>8)&&(r=31,t>>>0>16777215||(r=62+((t>>>(6-(n=x(n))&31)&1)-(n<<1)|0)|0)),m[o+28>>2]=r,o=1048848+(r<<2)|0;e:{t:{r:{n:{if((i=m[262145])&(n=1<<(31&r))){if(n=m[o>>2],(-8&m[n+4>>2])!=(0|t))break n;r=n;break r}m[262145]=n|i,m[o>>2]=e,m[e+24>>2]=o;break e}for(o=t<<(31==(0|r)?0:25-(r>>>1)&31);;){if(!(r=m[(i=16+((o>>>29&4)+n|0)|0)>>2]))break t;if(o<<=1,n=r,(-8&m[r+4>>2])==(0|t))break}}return t=m[r+8>>2],m[t+12>>2]=e,m[r+8>>2]=e,m[e+24>>2]=0,m[e+12>>2]=r,void(m[e+8>>2]=t)}m[i>>2]=e,m[e+24>>2]=n}m[e+12>>2]=e,m[e+8>>2]=e}function s(e){var t,r=0,n=0,o=0,i=0,a=0,l=0;t=m[e+24>>2];e:{t:{if((0|e)==(0|(r=m[e+12>>2]))){if(o=m[(r=e+20|0)>>2],n=m[(o?20:16)+e>>2])break t;r=0;break e}n=m[e+8>>2],m[n+12>>2]=r,m[r+8>>2]=n;break e}for(o=o?r:e+16|0;i=o,(n=m[(o=(r=n)+20|0)>>2])||(o=r+16|0,n=m[r+16>>2]),n;);m[i>>2]=0}e:if(t){n=1048848+(m[e+28>>2]<<2)|0;t:{if((0|e)==m[n>>2]){if(m[n>>2]=r,r)break t;return a=1048580,l=m[262145]&p(m[e+28>>2]),void(m[a>>2]=l)}if(m[(m[t+16>>2]==(0|e)?16:20)+t>>2]=r,!r)break e}m[r+24>>2]=t,(n=m[e+16>>2])&&(m[r+16>>2]=n,m[n+24>>2]=r),(e=m[e+20>>2])&&(m[r+20>>2]=e,m[e+24>>2]=r)}}function _(e,t){var r,n,o;return C=r=C-32|0,m[r+24>>2]=e,m[r+20>>2]=t,m[r+16>>2]=0,m[r+12>>2]=0,n=r,o=function e(t,r,n,o,i,a,l){var s,_=0,c=0;C=s=C-96|0,m[s+88>>2]=t,m[s+84>>2]=r,m[s+80>>2]=n,m[s+76>>2]=o,m[s+72>>2]=i,m[s+68>>2]=a,m[s+64>>2]=l,m[s+60>>2]=g[m[s+80>>2]+(m[m[s+76>>2]>>2]<<1)>>1],w[s+60>>2]>=128&&(m[s+60>>2]=1);e:if(m[m[s+72>>2]>>2]>(m[s+64>>2]-4|0))m[s+92>>2]=-1;else if(1==m[m[s+84>>2]+4>>2])if(m[s+56>>2]=m[m[s+76>>2]>>2],m[s+52>>2]=m[m[s+72>>2]>>2],m[s+48>>2]=0,m[s+44>>2]=0,m[s+40>>2]=m[m[s+88>>2]+32>>2]+((m[s+84>>2]-m[m[s+88>>2]+24>>2]|0)/140<<9),m[s+36>>2]=0,!m[m[s+40>>2]+(m[s+60>>2]<<2)>>2]|w[s+60>>2]<=0|w[s+60>>2]>=127?!m[s+60>>2]|!m[m[s+40>>2]+508>>2]?m[m[s+40>>2]>>2]&&(m[s+36>>2]=m[m[s+40>>2]>>2]):m[s+36>>2]=m[m[s+40>>2]+508>>2]:m[s+36>>2]=m[m[s+40>>2]+(m[s+60>>2]<<2)>>2],m[s+36>>2]){for(m[s+68>>2]||m[m[s+36>>2]+40>>2]||(m[s+48>>2]=m[m[s+72>>2]>>2],t=m[s+72>>2],m[t>>2]=m[t>>2]+2),m[s+32>>2]=0;m[s+32>>2]<m[m[s+36>>2]+4>>2];){if(m[s+28>>2]=m[s+68>>2],m[s+68>>2]||!m[m[s+36>>2]+40>>2]|m[m[s+36>>2]+40>>2]==(m[s+32>>2]+65536|0)||(m[s+28>>2]=1),_=s,c=e(m[s+88>>2],m[(m[s+36>>2]+8|0)+(m[s+32>>2]<<2)>>2],m[s+80>>2],m[s+76>>2],m[s+72>>2],m[s+28>>2],m[s+64>>2]),m[_+24>>2]=c,m[s+24>>2]<0){m[s+92>>2]=-1;break e}m[s+68>>2]|m[m[s+36>>2]+40>>2]!=(m[s+32>>2]+65536|0)||(m[s+44>>2]=m[s+24>>2]),m[s+32>>2]=m[s+32>>2]+1}for(m[s+68>>2]||(m[m[s+36>>2]+40>>2]?1==m[m[s+36>>2]+40>>2]&&(r=m[s+56>>2],n=m[m[s+88>>2]+48>>2],o=m[s+72>>2],t=m[o>>2],m[o>>2]=t+1,m[n+(t<<2)>>2]=r,m[s+44>>2]=m[m[s+72>>2]>>2],r=m[m[s+76>>2]>>2],n=m[m[s+88>>2]+48>>2],o=m[s+72>>2],t=m[o>>2],m[o>>2]=t+1,m[n+(t<<2)>>2]=r):(m[m[m[s+88>>2]+48>>2]+(m[s+48>>2]<<2)>>2]=0-m[s+36>>2],m[m[m[s+88>>2]+48>>2]+(m[s+48>>2]+1<<2)>>2]=m[m[s+36>>2]+4>>2],m[s+44>>2]=m[s+48>>2]+1));;){if(m[m[s+72>>2]>>2]>(m[s+64>>2]-4|0)){m[s+92>>2]=-1;break e}if(m[s+20>>2]=m[m[s+88>>2]+36>>2]+((m[s+84>>2]-m[m[s+88>>2]+24>>2]|0)/140<<9),m[s+16>>2]=0,m[s+60>>2]=g[m[s+80>>2]+(m[m[s+76>>2]>>2]<<1)>>1],w[s+60>>2]>=128&&(m[s+60>>2]=1),!m[m[s+20>>2]+(m[s+60>>2]<<2)>>2]|w[s+60>>2]<=0|w[s+60>>2]>=127?!m[s+60>>2]|!m[m[s+20>>2]+508>>2]||(m[s+16>>2]=m[m[s+20>>2]+508>>2]):m[s+16>>2]=m[m[s+20>>2]+(m[s+60>>2]<<2)>>2],!m[s+16>>2])break;for(m[s+68>>2]||(m[m[s+16>>2]+40>>2]?65536!=m[m[s+16>>2]+40>>2]&&(m[m[s+72>>2]>>2]=m[s+52>>2]):(m[m[m[s+88>>2]+48>>2]+(m[s+44>>2]<<2)>>2]=(0-m[m[m[s+88>>2]+48>>2]+(m[s+44>>2]<<2)>>2]|0)-1,m[s+48>>2]=m[m[s+72>>2]>>2],t=m[s+72>>2],m[t>>2]=m[t>>2]+2)),m[s+12>>2]=1;m[s+12>>2]<m[m[s+16>>2]+4>>2];){if(m[s+8>>2]=m[s+68>>2],m[s+68>>2]||!m[m[s+16>>2]+40>>2]|m[m[s+16>>2]+40>>2]==(m[s+12>>2]+65536|0)||(m[s+8>>2]=1),_=s,c=e(m[s+88>>2],m[(m[s+16>>2]+8|0)+(m[s+12>>2]<<2)>>2],m[s+80>>2],m[s+76>>2],m[s+72>>2],m[s+8>>2],m[s+64>>2]),m[_+4>>2]=c,m[s+4>>2]<0){m[s+92>>2]=-1;break e}m[s+68>>2]|m[m[s+16>>2]+40>>2]!=(m[s+12>>2]+65536|0)||(m[s+44>>2]=m[s+4>>2]),m[s+12>>2]=m[s+12>>2]+1}m[s+68>>2]||(m[m[s+16>>2]+40>>2]?1==m[m[s+16>>2]+40>>2]&&(r=m[s+56>>2],n=m[m[s+88>>2]+48>>2],o=m[s+72>>2],t=m[o>>2],m[o>>2]=t+1,m[n+(t<<2)>>2]=r,m[s+44>>2]=m[m[s+72>>2]>>2],r=m[m[s+76>>2]>>2],n=m[m[s+88>>2]+48>>2],o=m[s+72>>2],t=m[o>>2],m[o>>2]=t+1,m[n+(t<<2)>>2]=r):(m[m[m[s+88>>2]+48>>2]+(m[s+48>>2]<<2)>>2]=0-m[s+16>>2],m[m[m[s+88>>2]+48>>2]+(m[s+48>>2]+1<<2)>>2]=m[m[s+16>>2]+4>>2],m[s+44>>2]=m[s+48>>2]+1))}m[s+92>>2]=m[s+44>>2]}else m[s+92>>2]=-1;else{if(m[s+60>>2]&&(-1==m[m[s+84>>2]+4>>2]&&(t=m[s+76>>2],m[t>>2]=m[t>>2]+1),!m[m[s+84>>2]+4>>2])){if(!b[m[s+60>>2]+(m[s+84>>2]+8|0)|0]){m[s+92>>2]=-1;break e}t=m[s+76>>2],m[t>>2]=m[t>>2]+1}m[s+68>>2]||(r=m[m[s+76>>2]>>2],n=m[m[s+84>>2]+4>>2],o=m[m[s+88>>2]+48>>2],i=m[s+72>>2],t=m[i>>2],m[i>>2]=t+1,m[o+(t<<2)>>2]=r-(-2==(0|n)?0:1),r=m[m[s+76>>2]>>2],n=m[m[s+88>>2]+48>>2],o=m[s+72>>2],t=m[o>>2],m[o>>2]=t+1,m[n+(t<<2)>>2]=r),m[s+92>>2]=m[m[s+72>>2]>>2]-1}return C=s+96|0,m[s+92>>2]}(m[r+24>>2],m[r+20>>2],m[m[r+24>>2]+44>>2],r+12|0,r+16|0,0,m[m[r+24>>2]+12>>2]<<1),m[n+8>>2]=o,e=m[m[r+24>>2]+48>>2],t=m[r+16>>2],m[r+16>>2]=t+1,m[e+(t<<2)>>2]=-1,e=m[m[r+24>>2]+48>>2],t=m[r+16>>2],m[r+16>>2]=t+1,m[e+(t<<2)>>2]=0,g[m[m[r+24>>2]+44>>2]+(m[r+12>>2]<<1)>>1]|m[r+8>>2]<0?m[r+28>>2]=m[r+12>>2]+1:m[r+28>>2]=0,C=r+32|0,m[r+28>>2]}function c(e){var t;return!(t=function(e){var t=0,r=0,n=0,o=0,i=0,a=0,_=0,c=0,u=0,d=0,v=0;e:{t:{r:{if(e>>>0>=245){if(e>>>0>=4294901709)break t;if(o=-8&(e=e+11|0),!(c=m[262145]))break r;r=0-o|0,_=0,(e>>>=8)&&(_=31,o>>>0>16777215||(_=62+((o>>>(6-(e=x(e))&31)&1)-(e<<1)|0)|0));n:{o:{if(e=m[1048848+(_<<2)>>2]){for(i=o<<(31==(0|_)?0:25-(_>>>1)&31);;){if(!((a=-8&m[e+4>>2])>>>0<o>>>0||(a=a-o|0)>>>0>=r>>>0||(n=e,r=a))){r=0;break o}if(a=m[e+20>>2],e=m[16+((i>>>29&4)+e|0)>>2],t=a&&(0|a)!=(0|e)?a:t,i<<=1,!e)break}if(t){e=t;break o}if(n)break n}if(n=0,!(e=(0-(e=2<<(31&_))|e)&c))break r;if(!(e=m[1048848+(f(e&0-e)<<2)>>2]))break r}for(;n=(a=(i=(t=-8&m[e+4>>2])-o|0)>>>0<r>>>0&t>>>0>=o>>>0)?e:n,r=a?i:r,e=(t=m[e+16>>2])||m[e+20>>2];);if(!n)break r}if(r>>>0>=(e=m[262244])-o>>>0&&e>>>0>=o>>>0)break r;s(n);n:if(r>>>0>=16){if(m[n+4>>2]=3|o,m[4+(t=n+o|0)>>2]=1|r,m[t+r>>2]=r,r>>>0>=256){l(t,r);break n}e=1048584+((r>>>=3)<<3)|0,i=m[262144],r=1<<(31&r),_=m[e+8>>2],i&r||(m[262144]=r|i,_=e),r=_,m[e+8>>2]=t,m[r+12>>2]=t,m[t+12>>2]=e,m[t+8>>2]=r}else e=r+o|0,m[n+4>>2]=3|e,m[4+(e=e+n|0)>>2]=1|m[e+4>>2];return n+8|0}n:{o:{if(!(3&(e=(t=m[262144])>>>(n=31&(r=(o=e>>>0<11?16:e+11&-8)>>>3))))){if(o>>>0<=w[262244])break r;if(e)break o;if(!(e=m[262145]))break r;for(t=m[1048848+(f(e&0-e)<<2)>>2],r=(-8&m[t+4>>2])-o|0,i=t;;){if(!(e=m[t+16>>2])&&!(e=m[t+20>>2]))break n;r=(t=(n=(-8&m[e+4>>2])-o|0)>>>0<r>>>0)?n:r,i=t?e:i,t=e}}r=(e=m[1048592+(a=(n=r+(1&(-1^e))|0)<<3)>>2])+8|0,(0|(i=m[e+8>>2]))==(0|(a=a+1048584|0))?(d=1048576,v=p(n)&t,m[d>>2]=v):(m[i+12>>2]=a,m[a+8>>2]=i),t=n<<3,m[e+4>>2]=3|t,m[4+(e=e+t|0)>>2]=1|m[e+4>>2];break t}return n=f(0-(e=(r=e<<n)&(0-(e=2<<n)|e))&e),e=m[1048592+(i=n<<3)>>2],(0|(r=m[e+8>>2]))==(0|(i=i+1048584|0))?(d=1048576,v=p(n)&t,m[d>>2]=v):(m[r+12>>2]=i,m[i+8>>2]=r),i=e+8|0,m[e+4>>2]=3|o,r=(t=n<<3)-o|0,m[4+(a=e+o|0)>>2]=1|r,m[e+t>>2]=r,(e=m[262244])&&(e=1048584+((n=e>>>3)<<3)|0,t=m[262246],o=m[262144],n=1<<(31&n),_=m[e+8>>2],o&n||(m[262144]=n|o,_=e),n=_,m[e+8>>2]=t,m[n+12>>2]=t,m[t+12>>2]=e,m[t+8>>2]=n),m[262246]=a,m[262244]=r,i}return s(i),r>>>0>=16?(m[i+4>>2]=3|o,m[4+(a=o+i|0)>>2]=1|r,m[r+a>>2]=r,(e=m[262244])&&(e=1048584+((n=e>>>3)<<3)|0,t=m[262246],o=m[262144],n=1<<(31&n),_=m[e+8>>2],o&n||(m[262144]=n|o,_=e),n=_,m[e+8>>2]=t,m[n+12>>2]=t,m[t+12>>2]=e,m[t+8>>2]=n),m[262246]=a,m[262244]=r):(e=r+o|0,m[i+4>>2]=3|e,m[4+(e=e+i|0)>>2]=1|m[e+4>>2]),i+8|0}r:{n:{o:{i:{if((t=m[262244])>>>0<o>>>0){if((e=m[262245])>>>0>o>>>0)break e;if(r=0,-1==(0|(t=h((e=o+65583|0)>>>16))))break t;if(!(n=t<<16))break t;if(e=(i=-65536&e)+m[262248]|0,m[262248]=e,t=m[262249],m[262249]=t>>>0>e>>>0?t:e,!(r=m[262247]))break i;for(e=1049e3;;){if((0|n)==((t=m[e>>2])+(a=m[e+4>>2])|0))break o;if(!(e=m[e+8>>2]))break}break n}return e=m[262246],(n=t-o|0)>>>0<=15?(m[262246]=0,m[262244]=0,m[e+4>>2]=3|t,o=4+(t=e+t|0)|0,r=1|m[t+4>>2]):(m[262244]=n,r=e+o|0,m[262246]=r,m[r+4>>2]=1|n,m[e+t>>2]=n,r=3|o,o=e+4|0),m[o>>2]=r,e+8|0}for((e=m[262255])>>>0<=n>>>0&&e||(m[262255]=n),e=0,m[262256]=4095,m[262251]=i,m[262250]=n,m[262253]=0;t=e+1048584|0,m[e+1048592>>2]=t,m[e+1048596>>2]=t,256!=(0|(e=e+8|0)););m[262247]=n,e=i+-40|0,m[262245]=e,m[n+4>>2]=1|e,m[4+(e+n|0)>>2]=40,m[262254]=2097152;break r}if(!(m[e+12>>2]|n>>>0<=r>>>0|t>>>0>r>>>0)){m[e+4>>2]=i+a,t=(e=m[262247])+15&-8,m[262247]=t+-8,r=8+((n=i+m[262245]|0)+(e-t|0)|0)|0,m[262245]=r,m[t+-4>>2]=1|r,m[4+(e+n|0)>>2]=40,m[262254]=2097152;break r}}e=m[262255],m[262255]=e>>>0<n>>>0?e:n,t=n+i|0,e=1049e3;n:{for(;;){if((0|t)!=m[e>>2]){if(e=m[e+8>>2])continue;break n}break}if(!m[e+12>>2]){m[e>>2]=n,m[e+4>>2]=i+m[e+4>>2],m[n+4>>2]=3|o,i=n+o|0,o=(t-n|0)-o|0;o:{i:{if((0|t)!=m[262247]){if(m[262246]==(0|t))break i;if(1==(3&(e=m[t+4>>2]))&&((r=-8&e)>>>0>=256?s(t):(0|(a=m[t+12>>2]))==(0|(_=m[t+8>>2]))?(d=1048576,v=m[262144]&p(e>>>3),m[d>>2]=v):(m[_+12>>2]=a,m[a+8>>2]=_),o=r+o|0,t=t+r|0),m[t+4>>2]=-2&m[t+4>>2],m[i+4>>2]=1|o,m[o+i>>2]=o,o>>>0>=256){l(i,o);break o}e=1048584+((t=o>>>3)<<3)|0,r=m[262144],t=1<<(31&t),_=m[e+8>>2],r&t||(m[262144]=t|r,_=e),r=_,m[e+8>>2]=i,m[r+12>>2]=i,m[i+12>>2]=e,m[i+8>>2]=r;break o}m[262247]=i,e=m[262245]+o|0,m[262245]=e,m[i+4>>2]=1|e;break o}m[262246]=i,e=m[262244]+o|0,m[262244]=e,m[i+4>>2]=1|e,m[e+i>>2]=e}return n+8|0}}for(e=1049e3;!((t=m[e>>2])>>>0<=r>>>0&&(a=t+m[e+4>>2]|0)>>>0>r>>>0);)e=m[e+8>>2];for(m[262247]=n,e=i+-40|0,m[262245]=e,m[n+4>>2]=1|e,m[4+(e+n|0)>>2]=40,m[262254]=2097152,m[(t=(e=(a+-32&-8)-8|0)>>>0<r+16>>>0?r:e)+4>>2]=27,e=m[262250],_=m[262251],u=m[262253],m[(c=t+16|0)>>2]=m[262252],m[c+4>>2]=u,m[t+8>>2]=e,m[t+12>>2]=_,m[262251]=i,m[262250]=n,m[262252]=t+8,m[262253]=0,e=t+28|0;m[e>>2]=7,a>>>0>(e=e+4|0)>>>0;);(0|t)!=(0|r)&&(m[t+4>>2]=-2&m[t+4>>2],e=t-r|0,m[r+4>>2]=1|e,m[t>>2]=e,e>>>0>=256?l(r,e):(e=1048584+((t=e>>>3)<<3)|0,n=m[262144],t=1<<(31&t),_=m[e+8>>2],n&t||(m[262144]=t|n,_=e),t=_,m[e+8>>2]=r,m[t+12>>2]=r,m[r+12>>2]=e,m[r+8>>2]=t))}if(r=0,!((e=m[262245])>>>0<=o>>>0))break e}return r}return t=e-o|0,m[262245]=t,n=(e=m[262247])+o|0,m[262247]=n,m[n+4>>2]=1|t,m[e+4>>2]=3|o,e+8|0}(e))|!(3&b[t+-4|0])||function(e,t){if(t)for(;v[0|e]=0,e=e+1|0,t=t+-1|0;);}(t,e),t}function u(e,t){return 0|c(y(e|=0,t|=0))}function d(){}function f(e){return e?31-x(e+-1^e)|0:32}function p(e){var t;return(-1>>>(t=31&e)&-2)<<t|(-1<<(e=0-e&31)&-2)>>>e}function h(t){t|=0;var n=0|r.byteLength/65536,o=n+t|0;if(n<o&&o<65536){var i=new ArrayBuffer(y(o,65536)),a=new e.Int8Array(i);a.set(v),v=a,v=new e.Int8Array(i),new e.Int16Array(i),m=new e.Int32Array(i),b=new e.Uint8Array(i),g=new e.Uint16Array(i),w=new e.Uint32Array(i),new e.Float32Array(i),new e.Float64Array(i),r=i}return n}var v=new e.Int8Array(r),m=(new e.Int16Array(r),new e.Int32Array(r)),b=new e.Uint8Array(r),g=new e.Uint16Array(r),w=new e.Uint32Array(r),y=(new e.Float32Array(r),new e.Float64Array(r),e.Math.imul),x=(e.Math.fround,e.Math.abs,e.Math.clz32),C=(e.Math.min,e.Math.max,e.Math.floor,e.Math.ceil,e.Math.sqrt,t.abort,e.NaN,e.Infinity,1048576);return{memory:Object.create(Object.prototype,{grow:{value:h},buffer:{get:function(){return r}}}),rust_calloc:u,rust_free:function(e){n(e|=0)},llparser_create:function(e,t,r){return 0|function(e,t,r){var n,o,i;return C=n=C-32|0,m[n+28>>2]=e,m[n+24>>2]=t,m[n+20>>2]=r,e=n,t=m[n+28>>2]?m[n+28>>2]:256,m[e+28>>2]=t,e=n,t=m[n+24>>2]?m[n+24>>2]:256,m[e+24>>2]=t,e=n,t=m[n+20>>2]?m[n+20>>2]:256,m[e+20>>2]=t,o=n,i=u(((((((y(m[n+24>>2],140)+52|0)+y(m[n+20>>2],44)|0)+(m[n+24>>2]<<9)|0)+(m[n+24>>2]<<9)|0)+y(m[n+20>>2],m[n+24>>2]<<3)|0)+(m[n+28>>2]<<1)|0)+(m[n+28>>2]<<3)|0,1),m[o+16>>2]=i,m[m[n+16>>2]+12>>2]=m[n+28>>2],m[m[n+16>>2]+16>>2]=m[n+24>>2],m[m[n+16>>2]+20>>2]=m[n+20>>2],m[m[n+16>>2]+4>>2]=0,m[m[n+16>>2]>>2]=0,m[m[n+16>>2]+8>>2]=0,m[n+12>>2]=m[n+16>>2]+52,m[m[n+16>>2]+24>>2]=m[n+12>>2],m[n+12>>2]=m[n+12>>2]+y(m[n+24>>2],140),m[m[n+16>>2]+28>>2]=m[n+12>>2],m[n+12>>2]=m[n+12>>2]+y(m[n+20>>2],44),m[m[n+16>>2]+32>>2]=m[n+12>>2],m[n+12>>2]=m[n+12>>2]+(m[n+24>>2]<<9),m[m[n+16>>2]+36>>2]=m[n+12>>2],m[n+12>>2]=m[n+12>>2]+(m[n+24>>2]<<9),m[m[n+16>>2]+40>>2]=m[n+12>>2],m[n+12>>2]=m[n+12>>2]+y(m[n+20>>2],m[n+24>>2]<<3),m[m[n+16>>2]+44>>2]=m[n+12>>2],m[n+12>>2]=m[n+12>>2]+(m[n+28>>2]<<1),m[m[n+16>>2]+48>>2]=m[n+12>>2],C=n+32|0,m[n+16>>2]}(e|=0,t|=0,r|=0)},llparser_destroy:function(e){!function(e){var t;C=t=C-16|0,m[t+12>>2]=e,n(m[t+12>>2]),C=t+16|0}(e|=0)},llparser_create_descriptor:function(e,t){return 0|function(e,t){var r,n;return m[12+(r=C-16|0)>>2]=e,m[r+8>>2]=t,t=m[m[r+12>>2]+24>>2],n=m[r+12>>2],e=m[n+4>>2],m[n+4>>2]=e+1,m[r+4>>2]=t+y(e,140),m[m[r+4>>2]+4>>2]=m[r+8>>2]?1:0,m[r+4>>2]}(e|=0,t|=0)},llparser_descriptor_set_all:function(e){var t;e|=0,m[12+(t=C-16|0)>>2]=e,m[m[t+12>>2]+4>>2]=-1,v[m[t+12>>2]+135|0]=1},llparser_descriptor_set_nil:function(e){var t;e|=0,m[12+(t=C-16|0)>>2]=e,m[m[t+12>>2]+4>>2]=-2,v[m[t+12>>2]+8|0]=1},llparser_descriptor_add_char:function(e,t){!function(e,t){var r;m[12+(r=C-16|0)>>2]=e,m[r+8>>2]=t,v[m[r+8>>2]+(m[r+12>>2]+8|0)|0]=1}(e|=0,t|=0)},llparser_descriptor_add_range:function(e,t,r){!function(e,t,r){var n;for(m[12+(n=C-16|0)>>2]=e,m[n+8>>2]=t,m[n+4>>2]=r,m[n>>2]=m[n+8>>2];!(m[n>>2]>m[n+4>>2]);)v[m[n>>2]+(m[n+12>>2]+8|0)|0]=1,m[n>>2]=m[n>>2]+1}(e|=0,t|=0,r|=0)},llparser_descriptor_revert:function(e){!function(e){var t;for(m[12+(t=C-16|0)>>2]=e,m[t+8>>2]=1;!(m[t+8>>2]>=127);)v[m[t+8>>2]+(m[t+12>>2]+8|0)|0]=1&(0!=b[m[t+8>>2]+(m[t+12>>2]+8|0)|0]^-1),m[t+8>>2]=m[t+8>>2]+1}(e|=0)},llparser_add_rule:function(e,t,r,n,i,a,l,s,_,c,u,d){return 0|o(e|=0,t|=0,r|=0,n|=0,i|=0,a|=0,l|=0,s|=0,_|=0,c|=0,u|=0,d|=0)},llparser_prepare:function(e){!function(e){var t;for(C=t=C-32|0,m[t+28>>2]=e,m[t+24>>2]=0;!(m[t+24>>2]>=m[m[t+28>>2]+4>>2]);)m[t+20>>2]=m[m[t+28>>2]+24>>2]+y(m[t+24>>2],140),1==m[m[t+20>>2]+4>>2]&&i(m[t+28>>2],m[t+20>>2],m[t+20>>2],m[m[t+28>>2]+32>>2]+(m[t+24>>2]<<9)|0,0),m[t+24>>2]=m[t+24>>2]+1;for(m[t+16>>2]=0;!(m[t+16>>2]>=m[m[t+28>>2]+4>>2]);)m[t+12>>2]=m[m[t+28>>2]+24>>2]+y(m[t+16>>2],140),1==m[m[t+12>>2]+4>>2]&&(m[m[t+12>>2]>>2]=0,a(m[t+28>>2],m[t+12>>2],m[t+12>>2],m[m[t+28>>2]+36>>2]+(m[t+16>>2]<<9)|0)),m[t+16>>2]=m[t+16>>2]+1;C=t+32|0}(e|=0)},llparser_parse:function(e,t){return 0|_(e|=0,t|=0)},llparser_get_input_buffer:function(e){var t;return e|=0,m[12+(t=C-16|0)>>2]=e,m[m[t+12>>2]+44>>2]},llparser_get_result:function(e){var t;return e|=0,m[12+(t=C-16|0)>>2]=e,m[m[t+12>>2]+48>>2]},wasm_main:d,__wbindgen_start:d}}({Math:Math,Int8Array:Int8Array,Uint8Array:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,NaN:NaN,Infinity:1/0},{abort:function(){throw new Error("abort")}},n),i=o.memory,a=o.rust_calloc,l=o.rust_free,s=o.llparser_create,_=o.llparser_destroy,c=o.llparser_create_descriptor,u=o.llparser_descriptor_set_all,d=o.llparser_descriptor_set_nil,f=o.llparser_descriptor_add_char,p=o.llparser_descriptor_add_range,h=o.llparser_descriptor_revert,v=o.llparser_add_rule,m=o.llparser_prepare,b=o.llparser_parse,g=o.llparser_get_input_buffer,w=o.llparser_get_result,y=o.wasm_main,x=o.__wbindgen_start}])},function(e,t,r){var n=r(4),o=function(e){this.empty=!0,this._type=e,this._arr=[],this._index=0};o.create=function(e){return new o(e)},o.prototype.add=function(e){var t=this._index++;return this._arr.push({id:t,func:e}),this.empty=!1,t},o.prototype.remove=function(e){var t=this._arr,r=0;if("function"==typeof e)for(r=0;r<t.length;r++){var n=t[r].func;if(n===e)return t.splice(r,1),this.empty=!t.length,n}else for(r=0;r<t.length;r++)if(t[r].id===e){var o=t[r].func;return t.splice(r,1),this.empty=!t.length,o}return null},o.prototype.call=function(e,t,r){for(var n=this._arr,o=!1,i=0;i<n.length;i++){var l=a(this._type,n[i].func,e,t,r);l===!1&&(o=!0)}if(o)return!1};var i=function(e,t){if(!t.type||l.call(null,[e,t])!==!1){if(n.throwGlobalError)throw e;console.error(e.stack)}},a=o.safeCallback=function(e,t,r,n,o){try{return t.apply(r,n)}catch(l){var a="[Exparser] [Error] [Component] "+(e||"Error Listener")+" Error @ ";r&&r.is&&(a+=r.is),a+="#"+(t.name||"(anonymous)"),o&&o.triggerLifeTime("error",[l]),i(l,{message:a,type:e,element:r,method:t,args:n})}},l=o.create();o.addGlobalErrorListener=function(e){return l.add(e)},o.removeGlobalErrorListener=function(e){return l.remove(e)},e.exports=o},function(e,t){var r={lazyRegistration:!0,publicProperties:!1,availability:null,domain:"",writeOnly:!1,allowInWriteOnly:!1,classPrefix:null,addGlobalClass:!1,templateEngine:null,renderingMode:"full",multipleSlots:!1,reflectToAttributes:!1,writeFieldsToNode:!0,writeIdToDOM:!1,separateInnerData:!0,innerDataExclude:null,listenerChangeLifeTimes:!1,randomizeTagName:!1,virtualHost:!1,throwGlobalError:!1,writeExtraInfoToAttr:!1,documentBackend:"undefined"!=typeof window&&"undefined"!=typeof document?"dom":"none",hasDOMBackend:!("undefined"==typeof window||"undefined"==typeof document)};e.exports=r},function(e,t){var r=Object.prototype.hasOwnProperty,n=function(e,t){var o=typeof e;if("object"===o&&null!==e){var i=t?t.get(e):void 0;if(void 0!==i)return i;if(e instanceof Array){i=[],t&&t.set(e,i);for(var a=0;a<e.length;a++)i[a]=n(e[a],t)}else{i={},t&&t.set(e,i);for(var l in e)r.call(e,l)&&(i[l]=n(e[l],t))}return i}if("symbol"!==o)return e};t.deepCopy=function(e,t){var r=t&&"undefined"!=typeof WeakMap?new WeakMap:null;return n(e,r)}},function(e,t,r){var n=r(3),o=(Object.prototype.hasOwnProperty,function(){});o.prototype=Object.create(Object.prototype,{constructor:{value:o,writable:!0,configurable:!0}});var i=null;o._setElementSystem=function(e){i=e,o._setElementSystem=null};var a=null;o._setComponent=function(e){a=e,o._setComponent=null};var l=Date.now();o.setInitTimeStamp=function(e){return l=void 0===e?Date.now():e},o.getInitTimeStamp=function(e){return l},o.create=function(e,t,r){r=r||{};var n=r.originalEvent,i=r.extraFields||{},a=Date.now()-l,s=new o;s.currentTarget=null,s.type=e,s.timeStamp=a,s.mark=null,s.detail=t,s.bubbles=!!r.bubbles,s.composed=!!r.composed,s.__originalEvent=n,s.__hasCapture=!!r.capturePhase,s.__stopped=!1,s.__dispatched=!1;for(var _ in i)s[_]=i[_];return s},o.prototype.preventDefault=function(){this.__originalEvent&&this.__originalEvent.preventDefault()},o.prototype.stopPropagation=function(){this.__stopped=!0},o.prototype.isStopped=function(){return!!this.__stopped};o.prototype.markMutated=function(){this.__mutatedMarked=!0},o.prototype.mutatedMarked=function(){return!!this.__mutatedMarked};var s=function(e,t,r,n){for(var o=e,a=e instanceof i?e.collectMarks():{},l=[],s=[],_=e;_;){if(o!==_&&(l.push(e),e=_,s.push(a),a=e instanceof i?e.collectMarks():{}),o=_.parentNode,n(_,e,a)===!1)return;if(_.__wxHost){if(r)break;e=l.pop()||_.__wxHost,a=s.pop()||(e instanceof i?e.collectMarks():{}),_=_.__wxHost,o=_}else{var c=!0;_ instanceof i&&(c=!1),_=c||r?_.parentNode:_.__wxSlotParent;
}}};o.dispatchEvent=function(e,t){if(!t.__dispatched){t.__dispatched=!0,e.__wxElement&&e.__wxHost!==e.__wxElement&&(e=e.__wxElement,e.shadowRoot instanceof i&&(e=e.shadowRoot)),t.target=e instanceof i?e.__methodCaller:e;var r=function(e,r,n){if(!(r&&r.length&&t.mutatedMarked())){var o=t.currentTarget=n instanceof i?n.__methodCaller:n,l=e.call(o,[t],n instanceof a?n:void 0);r&&r.length&&t.markMutated(),l===!1&&(t.__originalEvent&&t.__originalEvent.preventDefault(),t.__stopped=!0)}},n=t.type,o=!t.composed;if(t.__hasCapture){var l=[];s(e,n,o,function(e,t,r){return e.__wxCaptureEvents&&e.__wxCaptureEvents[n]&&l.push([e,t,r]),!0});for(var _=l.length-1;_>=0;_--){var c=l[_],u=c[0],d=c[1];t.target=d instanceof i?d.__methodCaller:d,t.mark=c[2];var f=u.__wxCaptureMutated&&u.__wxCaptureMutated[n];if(r(u.__wxCaptureEvents[n],f,u),t.__stopped)break}}if(t.target=e instanceof i?e.__methodCaller:e,!t.__stopped){var p=!t.bubbles;s(e,n,o,function(e,o,a){t.target=o instanceof i?o.__methodCaller:o,t.mark=a;var l=e.__wxMutated&&e.__wxMutated[n];return e.__wxEvents&&e.__wxEvents[n]&&r(e.__wxEvents[n],l,e),!p&&!t.__stopped})}}},o.triggerEvent=function(e,t,r,n){var i=o.create(t,r,n);o.dispatchEvent(e,i)},o.addListenerToElement=function(e,t,r,o){var i=o&&o.mutated;if(i){var l=r;r=function(e){if(!e.mutatedMarked()){var t=Array.prototype.slice.call(arguments);return l.apply(this,t)}}}var s=void 0;return o&&(o.useCapture||o.capture)?(e.__wxCaptureEvents||(e.__wxCaptureEvents=Object.create(null)),e.__wxCaptureEvents[t]||(e.__wxCaptureEvents[t]=n.create("Event Listener")),s=e.__wxCaptureEvents[t].add(r),i&&(e.__wxCaptureMutated||(e.__wxCaptureMutated=Object.create(null)),e.__wxCaptureMutated[t]||(e.__wxCaptureMutated[t]=[]),e.__wxCaptureMutated[t].push(s))):(e.__wxEvents||(e.__wxEvents=Object.create(null)),e.__wxEvents[t]||(e.__wxEvents[t]=n.create("Event Listener")),s=e.__wxEvents[t].add(r),i&&(e.__wxMutated||(e.__wxMutated=Object.create(null)),e.__wxMutated[t]||(e.__wxMutated[t]=[]),e.__wxMutated[t].push(s))),e instanceof a&&e.__componentOptions.listenerChangeLifeTimes&&e.triggerLifeTime("listenerChanged",[!0,t,r,o]),s},o.removeListenerFromElement=function(e,t,r,n){var o=null;if(n&&(n.useCapture||n.capture)){if(e.__wxCaptureEvents&&e.__wxCaptureEvents[t]&&(o=e.__wxCaptureEvents[t].remove(r)),e.__wxCaptureMutated&&e.__wxCaptureMutated[t]){var i=e.__wxCaptureMutated[t].indexOf(r);i!==-1&&e.__wxCaptureMutated[t].splice(i,1)}}else if(e.__wxEvents&&e.__wxEvents[t]&&(o=e.__wxEvents[t].remove(r)),e.__wxMutated&&e.__wxMutated[t]){var i=e.__wxMutated[t].indexOf(r);i!==-1&&e.__wxMutated[t].splice(i,1)}o&&e instanceof a&&e.__componentOptions.listenerChangeLifeTimes&&e.triggerLifeTime("listenerChanged",[!1,t,o,n])},e.exports=o},function(e,t,r){var n=r(1),o=" \n\r\t\f",i=null,a=function(){i=n.create({MULTIPLE_PATHS:[{id:"arrayConcat",states:["MULTIPLE_PATHS",",","SINGLE_PATH"]},{id:"array",states:["SINGLE_PATH"]}],SINGLE_PATH:[{id:"arrayConcat",states:["SINGLE_PATH",".","VAR_NAME"]},{id:"arrayConcat",states:["SINGLE_PATH","[","INT","]"]},{id:"array",states:["VAR_NAME"]},{id:"_jump",states:["SINGLE_PATH",o]}],VAR_NAME:[{id:"_blank",states:[o,"VAR_NAME"]},{id:"_jump",states:["VAR_NAME",o]},{id:"_raw",states:["*","*"]},{id:"_raw",states:["_a-zA-Z$","VAR_NAME_AFTER"]}],VAR_NAME_AFTER:[{id:"_raw",states:["_a-zA-Z0-9$","VAR_NAME_AFTER"]},{id:"_raw",states:["NULL"]}],INT:[{id:"_blank",states:[o,"INT"]},{id:"_jump",states:["INT",o]},{id:"toNumber",states:["0-9","INT_AFTER"]}],INT_AFTER:[{id:"_raw",states:["0-9","INT_AFTER"]},{id:"_raw",states:["NULL"]}]},{arrayConcat:function(e){return e[0].push(e[2]),e[0]},array:function(e){return e},toNumber:function(e){return parseInt(e[0]+e[1],10)}})};t.parseMultiPaths=function(e){return i||a(),i.parse("MULTIPLE_PATHS",e)},t.parseSinglePath=function(e){for(var t=e.length,r=[],n="",o=0,i=!1,a=!1,l=0;l<t;l++){var s=e[l];if("\\"===s)l+1<t&&("."===e[l+1]||"["===e[l+1]||"]"===e[l+1]||"\\"===e[l+1])?(n+=e[l+1],l++):n+="\\";else if("."===s)n&&(r.push(n),n="");else if("["===s){if(n&&(r.push(n),n=""),0===r.length)throw new Error("The path string should not start with []: "+e);a=!0,i=!1}else if("]"===s){if(!i)throw new Error("There should be digits inside [] in the path string: "+e);a=!1,r.push(o),o=0}else if(a){if(s<"0"||s>"9")throw new Error("Only digits (0-9) can be put inside [] in the path string: "+e);i=!0,o=10*o+s.charCodeAt(0)-48}else n+=s}if(n&&r.push(n),0===t)throw new Error("The path string should not be empty");return r}},function(e,t,r){var n=r(3),o=r(4),i=r(7),a=["created","ready","cacheAttached","attached","moved","detached","saved","restored","error","listenerChanged","performanceData"],l=[String,Number,Boolean,Object,Array,null],s=function(){},_=i.parseMultiPaths,c=function(){},u=(c.matchTypeWithValue=function(e,t){if(e===String){if("string"!=typeof t)return!1}else if(e===Number){if(!Number.isFinite(t))return!1}else if(e===Boolean){if("boolean"!=typeof t)return!1}else if(e===Object){if(null===t||t.constructor!==Object)return!1}else if(e===Array){if(t.constructor!==Array)return!1}else if(void 0===t)return!1;return!0},function(e){for(var t=[],r=0;r<e.length;r++)t[r]=e[r];return t}),d=function(e){var t={};for(var r in e)t[r]=e[r];return t},f=function(e,t){for(var r in t)hasOwnProperty.call(e,r)?"object"!=typeof e[r]||"object"!=typeof t[r]||null===t[r]||t[r]instanceof Array?e[r]=t[r]:(e[r]instanceof Array?e[r]=u(e[r]):e[r]=d(e[r]),f(e[r],t[r])):e[r]=t[r]};c.create=function(e){var t=new c;return t.is=e.is||"",t.using=e.using||{},t.generics=e.generics||{},t.template=e.template,t.externalClasses=e.externalClasses||[],t.data="object"==typeof e.data?{}:null,t.properties=Object.create(null),t.methods=Object.create(null),t.listeners=Object.create(null),t.relations=Object.create(null),t.ancestors=[],t.initiator=e.initiator,t.lifetimes=Object.create(null),t.pageLifetimes=Object.create(null),t.observers=[],t.options={publicProperties:!!(e.options&&void 0!==e.options.publicProperties?e.options.publicProperties:o.publicProperties)},t.definitionFilter=e.definitionFilter,t._unprepared=e,(e.options&&void 0!==e.options.lazyRegistration?e.options.lazyRegistration:o.lazyRegistration)||c.prepare(t),e.is&&(c._list[e.is]=t),t},c.prepare=function(e){var t=e._unprepared;if(t){e._unprepared=null;var r=e.ancestors,n="",o=0;for(o=0;o<(t.behaviors||[]).length;o++){var i=t.behaviors[o],u=i;"string"==typeof u&&(u=c._list[i]),u._unprepared&&c.prepare(u),"object"==typeof u.data&&(null===e.data?e.data=u.data:f(e.data,u.data));for(n in u.generics){var d=u.generics[n];"object"!=typeof d&&(d={}),e.generics[n]={default:d.default}}for(n in u.properties)e.properties[n]=u.properties[n];for(n in u.relations)e.relations[n]=u.relations[n];for(n in u.methods)e.methods[n]=u.methods[n];for(var p=0;p<u.ancestors.length;p++)r.indexOf(u.ancestors[p])<0&&r.push(u.ancestors[p])}"object"==typeof t.data&&(null===e.data?e.data=t.data:f(e.data,t.data));for(n in t.properties){var h=t.properties[n];l.indexOf(h)>=0?h={type:h}:l.indexOf(h.type)<0&&h.optionalTypes&&h.optionalTypes.length>0&&(h.type=h.optionalTypes[0]),void 0===h.value&&(h.type===String?h.value="":h.type===Number?h.value=0:h.type===Boolean?h.value=!1:h.type===Array?h.value=[]:h.value=null),e.properties[n]={type:h.type,optionalTypes:h.optionalTypes,value:h.value,filter:h.filter,observer:h.observer,public:!!(void 0===h.public?e.options.publicProperties:h.public),availability:h.availability,observeAssignments:!!h.observeAssignments}}if(t.lifetimes&&"object"==typeof t.lifetimes)for(n in t.lifetimes)e.lifetimes[n]=t.lifetimes[n];for(o=0;o<a.length;o++)void 0===e.lifetimes[a[o]]&&(e.lifetimes[a[o]]=t[a[o]]);for(n in t.listeners)e.listeners[n]=t.listeners[n];var v=t.observers;if(v instanceof Array)for(o=0;o<v.length;o++){var m=v[o];e.observers.push({paths:_(m.fields||"**"),observer:m.observer})}else for(n in v)e.observers.push({paths:_(n),observer:v[n]});if(t.pageLifetimes&&"object"==typeof t.pageLifetimes)for(n in t.pageLifetimes)e.pageLifetimes[n]=t.pageLifetimes[n];for(n in t.relations){var b=t.relations[n];e.relations[n]={target:b.target||n,type:b.type,linked:b.linked||s,linkChanged:b.linkChanged||s,unlinked:b.unlinked||s,linkFailed:b.linkFailed||s}}for(n in t.methods)"function"==typeof t.methods[n]&&(e.methods[n]=t.methods[n]);r.push(e)}},c._list=Object.create(null),c.prototype.hasBehavior=function(e){this._unprepared&&c.prepare(this);for(var t=0;t<this.ancestors.length;t++)if(e instanceof c){if(this.ancestors[t]===e)return!0}else if(this.ancestors[t]===c._list[e])return!0;return!1},c.prototype._getAllListeners=function(){for(var e={},t=this.ancestors,r=0;r<t.length;r++){var n=this.ancestors[r];for(var o in n.listeners)Object.prototype.hasOwnProperty.call(e,o)?e[o].push(n.listeners[o]):e[o]=[n.listeners[o]]}return e},c.prototype._addObserversToDataProxy=function(e){for(var t=this.ancestors,r=0;r<t.length;r++)for(var n=this.ancestors[r].observers,o=0;o<n.length;o++){var i=n[o];e.addObserver(i.observer,i.paths)}},c.prototype._getAllLifeTimeFuncs=function(){var e={},t=this.ancestors;a.forEach(function(t){e[t]=n.create("Lifetime Method")});for(var r=0;r<t.length;r++){var o=t[r];for(var i in o.lifetimes)o.lifetimes[i]&&(e[i]||(e[i]=n.create("Lifetime Method")),e[i].add(o.lifetimes[i]))}return e},c.prototype._getAllPageLifeTimeFuncs=function(){for(var e={},t=this.ancestors,r=0;r<t.length;r++){var o=t[r];for(var i in o.pageLifetimes)o.pageLifetimes[i]&&(e[i]||(e[i]=n.create("Page Lifetime Method")),e[i].add(o.pageLifetimes[i]))}return e},c.callDefinitionFilter=function(e){var t=e.definitionFilter,r=[];return e.behaviors instanceof Array&&e.behaviors.forEach(function(t){t="string"==typeof t?c._list[t]:t,t&&t.definitionFilter&&(r.push(t.definitionFilter),t.definitionFilter.call(null,e))}),"function"==typeof t?function(e){t(e,r)}:null},e.exports=c},function(e,t,r){var n=r(6),o=r(10),i=r(11),a=r(12),l=r(14),s=r(4),_=r(13),c=function(e){u(this,e||null)};c.prototype=Object.create(Object.prototype,{constructor:{value:c,writable:!0,configurable:!0},id:{get:function(){return this.__id},set:function(e){var t=String(e);if(this.__id!==t){if(this.__id=t,this.ownerShadowRoot){var r=this.ownerShadowRoot.__wxHost;r.__idCacheDirty=!0,this.__domElement&&r.__componentOptions.writeIdToDOM&&(this.__domElement.id=t)}s.writeExtraInfoToAttr&&this.__domElement&&this.__domElement.setAttribute("exparser:info-attr-id",t),(this.__propObservers&&!this.__propObservers.empty||this.__subtreeObserversCount)&&o._callObservers(this,"__propObservers",{type:"properties",target:this,propertyName:"id"})}},configurable:!0},slot:{get:function(){return this.__slot},set:function(e){e=String(e),this.__slot!==e&&(this.__inheritSlots||(this.__slot=e,w(this),(this.__propObservers&&!this.__propObservers.empty||this.__subtreeObserversCount)&&o._callObservers(this,"__propObservers",{type:"properties",target:this,propertyName:"slot"})))},configurable:!0},attributes:{get:function(){var e=[];if(!this.__attributes)return e;for(var t in this.__attributes)e.push({name:t,value:this.__attributes[t]});return e},set:function(){},configurable:!0},class:{get:function(){return this.classList.getClassNames()},set:function(e){this.classList&&this.classList.setClassNames(e),(this.__propObservers&&!this.__propObservers.empty||this.__subtreeObserversCount)&&o._callObservers(this,"__propObservers",{type:"properties",target:this,propertyName:"class"})},configurable:!0},style:{get:function(){return this.__domElement?this.__domElement.style:null},set:function(e){return P.call(this,e)},configurable:!0}}),n._setElementSystem(c),i._setElementSystem(c);var u=c.initialize=function(e,t,r){e.__id="",e.__slot="",e.__virtual=!1,e.__inheritSlots=!1,e.__attributes=null,e.__marks=null,e.__attached=!1,e.parentNode=null,e.childNodes=[],e.ownerShadowRoot=r,e.__wxSlotParent=null,e.__wxSlotChildren=e.childNodes,e.__subtreeObserversCount=0,e.classList=null,e.__styleSegments=[],e.__methodCaller=e,e.__relationHandler=null,e.__backendExtracted=_.backendExtractedDefault,e.__domElement=t,e.$$=t,t&&(t.__wxElement=e)};c._clone=function(e,t,r,n){if(e.__id=t.__id,e.__slot=t.__slot,e.__virtual=t.__virtual,e.__inheritSlots=t.__inheritSlots,e.__marks=t.__marks?{}:null,t.__marks)for(var o in t.__marks)e.__marks[o]=t.__marks[o];e.__attributes=Object.create(null);for(var i in t.__attributes)e.__attributes[i]=t.__attributes[i];e.__attached=!1,e.parentNode=null,e.childNodes=[],e.ownerShadowRoot=n,e.__wxSlotParent=null,e.__wxSlotChildren=e.childNodes,e.__subtreeObserversCount=0,e.classList=null,e.__styleSegments=[],e.__methodCaller=e,e.__relationHandler=null,e.__backendExtracted=_.backendExtractedDefault,e.__domElement=r,e.$$=r,r&&(r.__wxElement=e)};var d=function(e){if(!e.parentNode||e.parentNode.__attached){var t=function(e){if(e instanceof c){e.__attached=!0,e.__lifeTimeFuncs&&e.__lifeTimeFuncs.attached.call(e.__methodCaller,[],e),e.__relationHandler&&e.__relationHandler("attached"),e.__attachedObservers&&!e.__attachedObservers.empty&&o._callSingleObserver(e,"__attachedObservers",{type:"attachStatus",target:e,status:"attached"}),e.shadowRoot instanceof c&&t(e.shadowRoot);for(var r=e.childNodes,n=0;n<r.length;n++)t(r[n])}};t(e)}},f=function(e){if(e.__attached){var t=function(e){if(e instanceof c){for(var r=e.childNodes,n=0;n<r.length;n++)t(r[n]);e.shadowRoot instanceof c&&t(e.shadowRoot),e.__attached=!1,e.__lifeTimeFuncs&&e.__lifeTimeFuncs.detached.call(e.__methodCaller,[],e),e.__relationHandler&&e.__relationHandler("detached"),e.__attachedObservers&&!e.__attachedObservers.empty&&o._callSingleObserver(e,"__attachedObservers",{type:"attachStatus",target:e,status:"detached"})}};t(e)}},p=function(e){if(!e.__attached)return d(e);var t=function(e){if(e instanceof c){for(var r=e.childNodes,n=0;n<r.length;n++)t(r[n]);e.shadowRoot instanceof c&&t(e.shadowRoot),e.__lifeTimeFuncs&&e.__lifeTimeFuncs.moved.call(e.__methodCaller,[],e),e.__relationHandler&&e.__relationHandler("moved")}};t(e)},h=function(e,t,r){if(e.__childObservers&&!e.__childObservers.empty||e.__subtreeObserversCount){var n=null,i=[r];n="add"===t?{type:"childList",target:e,addedNodes:i}:"remove"===t?{type:"childList",target:e,removedNodes:i}:{type:"childList",target:e,addedNodes:i,removedNodes:i},o._callObservers(e,"__childObservers",n)}},v=function(e,t){if(e instanceof c&&(!t.__wxHost.__idCacheDirty||!t.__slotCacheDirty)){var r=function(e){e.__id&&(t.__wxHost.__idCacheDirty=!0),void 0!==e.__slotName&&(t.__slotCacheDirty=!0);for(var n=e.childNodes,o=0;o<n.length;o++){var i=n[o];i instanceof c&&r(i)}};r(e)}};c._updateIdMap=function(e){var t=e.shadowRoot;if(e.__idCacheDirty){e.__idCacheDirty=!1;var r=e.__idCache=Object.create(null),n=function(e){e.__id&&(r[e.__id]||(r[e.__id]=e));for(var t=e.childNodes,o=0;o<t.length;o++)t[o]instanceof c&&n(t[o])};n(t)}};var m=function(e){if(e.__hostAssociated&&e.__slotCacheDirty){e.__slotCacheDirty=!1;var t=e.__wxHost,r=null,n=Object.create(null);r=void 0!==t.__singleSlot?{"":t.__singleSlot}:t.__slots;var o=function(e){void 0!==e.__slotName&&(n[e.__slotName]||(n[e.__slotName]=e));for(var t=e.childNodes,r=0;r<t.length;r++)t[r]instanceof c&&o(t[r])};o(e),void 0!==t.__singleSlot?t.__singleSlot!==n[""]&&(n[""]&&(n[""].__wxSlotChildren=t.childNodes),b(t,n,r,!0),t.__singleSlot&&(t.__singleSlot.__wxSlotChildren=[]),t.__singleSlot=n[""]||null):(b(t,n,r,!1),t.__slots=n)}},b=function(e,t,r,n){var o=e.childNodes,i=0;if(n){var a=t[""];if(a)for(;i<o.length;i++)x(a,o[i],null,!1,!1,!1,-1);else if(a=r[""])for(;i<o.length;i++)x(a,null,o[i],!0,!1,!1,i)}else{var l=function(e){for(var n=0;n<e.length;n++){var o=e[n],i=o.__slot||"",a=t[i];a?x(a,o,null,!1,!0,!0):(a=r[i],a&&x(a,null,o,!0,!0,!0)),o.__inheritSlots&&l(o.childNodes)}};l(o)}},g=function(e,t,r,n){for(var o=function(e,t,n){var i=e.childNodes,a=0;for(t&&(a=i.indexOf(t)+(n?0:1));a<i.length;a++){var l=i[a];if(l.__slot===r)return l;if(l.__inheritSlots){var s=o(l,null,!1);if(s)return s}}return null};t!==e;t=t.parentNode){var i=o(t.parentNode,t,n);if(i)return i;n=!1}return null},w=function(e){for(var t=e.parentNode;t&&t.__inheritSlots;)t=t.parentNode;if(t&&void 0===t.__singleSlot){var r=e.__slot||"",n=t.__slots[r];if(n){var o=g(t,e,r,!1);x(n,e,o,!1,!0,!0)}else n=e.__wxSlotParent,n&&x(n,null,e,!0,!0,!0)}},y=function(e,t,r,n,o){var i=e;if(i instanceof c){for(;i.__virtual;){var a=i.__wxSlotParent;if(!a){i=null;break}if(t&&!r){var l=a.__wxSlotChildren.indexOf(i);r=a.__wxSlotChildren[l+1]}i=a}i instanceof c&&(i=i.__domElement)}if(i){var s=n,_=null,u=null;if(t)if(t.__virtual){var d=document.createDocumentFragment(),f=function(e){for(var t=0;t<e.__wxSlotChildren.length;t++){var r=e.__wxSlotChildren[t];r.__virtual?f(r):d.appendChild(r.__domElement)}};f(t),_=d}else _=t.__domElement;if(r)if(r.__virtual){var p=e,h=0;if(n){var v=function(e){for(var t=0;t<e.__wxSlotChildren.length;t++){var r=e.__wxSlotChildren[t];r.__virtual?v(r):i.removeChild(r.__domElement)}};v(r),s=!1,h=o+1}else p=r.__wxSlotParent,h=r===t?o:p.__wxSlotChildren.indexOf(r);if(t){var m=function(e,t){for(;t<e.__wxSlotChildren.length;t++){var r=e.__wxSlotChildren[t];if(!r.__virtual)return r;var n=m(r,0);if(n)return n}};r=null;for(var b=p;r=m(b,h),!r&&b.__virtual;b=b.__wxSlotParent)h=b.__wxSlotParent.__wxSlotChildren.indexOf(b)+1;r&&(u=r.__domElement)}}else u=r.__domElement;s?_?i.replaceChild(_,u):i.removeChild(u):_&&(u?i.insertBefore(_,u):i.appendChild(_))}else if(t&&t.__wxSlotParent){var g=function(e){if(e.__virtual)for(var t=0;t<e.__wxSlotChildren.length;t++)g(e.__wxSlotChildren[t]);else{var r=e.__domElement;r&&r.parentNode&&r.parentNode.removeChild(r)}};g(t)}},x=function(e,t,r,n,o,i,a){if(n&&(r.__wxSlotParent=null),o&&(a=e.__wxSlotChildren.indexOf(r)),t){var l=t.__wxSlotParent;if(t.__wxSlotParent=e,l&&i){var _=l.__wxSlotChildren.indexOf(t);l.__wxSlotChildren.splice(_,1),l===e&&_<a&&a--}}var u=!1;t&&t.__backendExtracted?u=!0:r&&r.__backendExtracted&&(u=!0),u||y(e,t,r,n,a),s.writeExtraInfoToAttr&&(n&&r instanceof c&&r.__domElement&&r.__domElement.removeAttribute("exparser:info-in-slot-of"),t instanceof c&&t.__domElement&&(void 0!==e.__slotName&&e.ownerShadowRoot?t.__domElement.setAttribute("exparser:info-in-slot-of",e.ownerShadowRoot.__wxHost.__componentInstanceId):t.__domElement.removeAttribute("exparser:info-in-slot-of"))),o&&(a===-1&&(a=e.__wxSlotChildren.length),t?e.__wxSlotChildren.splice(a,n?1:0,t):e.__wxSlotChildren.splice(a,n?1:0))},C=function(e,t){for(var r=e.childNodes,n=0;n<r.length;n++){var o=r[n];t(e,o),o.__inheritSlots&&C(o,t)}},E=c.insertChildToElement=function(e,t,r,n){if(void 0!==e.__slotName)return!1;var i=r>=0?e.childNodes[r]:null;n&&t===i&&(n=!1);var a=null,l=e,s=e;if(t){a=t.parentNode,t.parentNode=e;var _=e.__subtreeObserversCount;if(a){var c=a.childNodes.indexOf(t);a.childNodes.splice(c,1),a===e&&c<r&&r--,_-=a.__subtreeObserversCount}_&&o._updateSubtreeCaches(t,_)}for(var u=e;u&&u.__inheritSlots;)u=u.parentNode;for(var b=!u||!u.__slots,w=!b||e.__inheritSlots,y=a;y&&y.__inheritSlots;)y=y.parentNode;var E=!y||!y.__slots,S=!E||a&&a.__inheritSlots;if(b)void 0!==e.__singleSlot&&(l=s=e.__singleSlot),l?x(l,t,i,n,w,S,r):t.__wxSlotParent&&x(t.__wxSlotParent,null,t,!0,S,!1),t&&!E&&t.__inheritSlots&&C(t,function(e,t){x(e,t,null,!1,!0,!0,-1)});else{var O="";if(t&&(O=t.__slot||"",l=u.__slots[O]||null),i&&(s=u.__slots[i.__slot||""]||null),i&&s&&n&&x(s,null,i,n,!0,!1),t)if(l){var N=i?g(u,i,O,!n):g(u,e,O,!1);x(l,t,N,!1,!0,S)}else t.__wxSlotParent&&x(t.__wxSlotParent,null,t,!0,S,!1);i&&n&&i.__inheritSlots&&C(i,function(e,t){x(e,t,null,!1,!0,!0,-1)}),t&&t.__inheritSlots&&C(t,function(t,r){var o=r.__slot||"",a=u.__slots[o]||null;if(a){var l=i?g(u,i,o,!n):g(u,e,o,!1);x(a,r,l,!1,!0,!0)}else r.__wxSlotParent&&x(r.__wxSlotParent,null,r,!0,!0,!1)})}return n&&(e.__subtreeObserversCount&&o._updateSubtreeCaches(i,-e.__subtreeObserversCount),i.parentNode=null),r===-1&&(r=e.childNodes.length),t?e.childNodes.splice(r,n?1:0,t):e.childNodes.splice(r,n?1:0),e.ownerShadowRoot&&(n&&v(i,e.ownerShadowRoot),t&&v(t,e.ownerShadowRoot),m(e.ownerShadowRoot)),n&&(f(i),h(e,"remove",i)),t&&(a?p(t):d(t),a===e?h(e,"move",t):(a&&h(a,"remove",t),h(e,"add",t))),!0},S=function(e,t,r,n){if(t&&e.ownerShadowRoot!==t.ownerShadowRoot)throw new Error("Cannot move the node from one shadow tree to another shadow tree.");var o=n?r:t,i=-1;if(r&&(i=e.childNodes.indexOf(r),i<0))return null;var a=E(e,t,i,n);return a?o:null};c._attachShadowRoot=function(e){var t=e.__wxHost;t.__wxSlotChildren=[e],x(t,e,null,!1,!1,0),e.__hostAssociated=!0,m(e)},c.appendChild=function(e,t){return S(e,t,null,!1)},c.insertBefore=function(e,t,r){return S(e,t,r,!1)},c.removeChild=function(e,t){return S(e,null,t,!0)},c.replaceChild=function(e,t,r){return S(e,t,r,!0)},c.prototype.appendChild=function(e){return S(this,e,null,!1)},c.prototype.insertBefore=function(e,t){return S(this,e,t,!1)},c.prototype.removeChild=function(e){return S(this,null,e,!0)},c.prototype.replaceChild=function(e,t){return S(this,e,t,!0)};var O=function(e){var t=!0,r=!0;if(e instanceof c?(e.__backendExtracted=!0,e.$$=e.__domElement=null,r=!1):e instanceof a&&(e.__backendExtracted=!0,e.$$=e.__domElement=null,t=!1,r=!1),t&&e.__wxSlotChildren)for(var n=0;n<e.__wxSlotChildren.length;n++){var o=e.__wxSlotChildren[n];O(o)}else if(r&&e.childNodes)for(var i=0;i<e.childNodes.length;i++)O(e.childNodes[i])};c.extractBackend=function(e){if(e.__backendExtracted)return null;var t=e.__domElement;return O(e),t};var N=function(e,t){if(!t){var r=l.toElement(e.__domElement);return e.$$=e.__domElement=r,r}if(e.__domElement.tagName.toUpperCase()===t.tagName)e.$$=e.__domElement=t;else{var n=l.toElement(e.__domElement);e.$$=e.__domElement=n,t.parentNode.replaceChild(n,t)}return null},k=function(e,t){if(!t){var r=document.createTextNode(e.textContent);return e.$$=e.__domElement=r,r}if("undefined"!=typeof t.textContent)t.textContent=e.textContent,e.$$=e.__domElement=t;else{var n=document.createTextNode(e.textContent);e.$$=e.__domElement=n,t.parentNode.replaceChild(n,t)}return null},T=function(e,t){if(!t)return e;for(;e.childNodes&&t.childNodes&&t.childNodes.length;)e.appendChild(t.childNodes[0]);return t.parentNode.replaceChild(e,t),null},A=function(e,t,r){var n=e instanceof c&&e.__virtual,o=t?t.childNodes[r]:void 0,i=!0,l=!0,s=null;if(e instanceof c)e.__backendExtracted=!1,n||(s=N(e,o)),l=!1;else if(e instanceof a)e.__backendExtracted=!1,s=k(e,o),i=!1,l=!1;else{var _=document.createDocumentFragment();if(_.__wxSlotChildren=e.__wxSlotChildren,o&&o.childNodes)for(;o.childNodes.length;)_.appendChild(o.childNodes[0]);s=T(e,o),e=_}s?(t.appendChild(s),o=s):o=t?t.childNodes[r]:void 0;var u=0;if(i&&e.__wxSlotChildren)for(var d=0;d<e.__wxSlotChildren.length;d++){var f=e.__wxSlotChildren[d];if(n)r=A(f,t,r);else if(f.asShadowRoot){for(var p=0;p<f.asShadowRoot.childNodes.length;p++)u=A(f.asShadowRoot.childNodes[p],o,u);e.shadowRoot=o,o.__wxHost=e,e.__wxSlotChildren[0]=o,o.__wxSlotParent=e,e.__singleSlot===f&&(e.__singleSlot=o)}else u=A(f,o,u)}else if(l&&e.childNodes)for(var h=0;h<e.childNodes.length;h++)u=A(e.childNodes[h],o,u);if(n)return r;for(;o.childNodes.length>u;)o.removeChild(o.childNodes[u]);return r+1};c.injectBackend=function(e,t){if(e.__backendExtracted){var r=document.createDocumentFragment();r.appendChild(t),A(e,r,0)}},c.prototype.triggerEvent=function(e,t,r){n.triggerEvent(this,e,t,r)},c.prototype.dispatchEvent=function(e){n.dispatchEvent(this,e)},c.prototype.addListener=function(e,t,r){n.addListenerToElement(this,e,t,r)},c.prototype.removeListener=function(e,t,r){n.removeListenerFromElement(this,e,t,r)},c.setMethodCaller=function(e,t){e.__methodCaller=t},c.getMethodCaller=function(e){return e.__methodCaller},c.prototype.getAttribute=function(e){if(!this.__attributes)return null;var t=this.__attributes[e];return void 0===t?null:t},c.prototype.setAttribute=function(e,t){this.__attributes||(this.__attributes=Object.create(null)),t=String(t),this.__attributes[e]=t,this.__domElement&&this.__domElement.setAttribute(e,t)},c.prototype.removeAttribute=function(e){this.__attributes&&(delete this.__attributes[e],this.__domElement&&this.__domElement.removeAttribute(e))},c.prototype.setMark=function(e,t){this.__marks||(this.__marks={}),this.__marks[e]=t},c.prototype.collectMarks=function(){for(var e={},t=this;t;t=t.parentNode)if(t.__marks)for(var r in t.__marks)hasOwnProperty.call(e,r)||(e[r]=t.__marks[r]);return e};var P=c.prototype.setNodeStyle=function(e,t){this.__styleSegments[t||0]=e;var r=this.__styleSegments.join(";");if(this.__domElement&&this.ownerShadowRoot&&this.ownerShadowRoot.__childrenPropsFilter){var n=this.ownerShadowRoot.__childrenPropsFilter,i=n.style;if("function"==typeof i)return void this.__domElement.setAttribute("style",i.call(this,r))}this.__domElement&&this.__domElement.setAttribute("style",r),(this.__propObservers&&!this.__propObservers.empty||this.__subtreeObserversCount)&&o._callObservers(this,"__propObservers",{type:"properties",target:this,propertyName:"style"})};c.replaceDocumentElement=function(e,t){e.__attached||(t.parentNode.replaceChild(e.__domElement,t),d(e))},c.pretendAttached=function(e){e.__attached||d(e)},c.pretendDetached=function(e){e.__attached&&f(e)},c.isAttached=function(e){return e.__attached},c.setSlotName=function(e,t){if(t=null==t?"":String(t),void 0===e.__slotName){if(0!==e.childNodes.length||0!==e.__wxSlotChildren.length)return;e.__wxSlotChildren=[]}e.__slotName=t,e.ownerShadowRoot&&(e.ownerShadowRoot.__slotCacheDirty=!0,m(e.ownerShadowRoot))},c.setInheritSlots=function(e){e.__singleSlot||e.__slots||e.__wxSlotChildren.length||(e.__wxSlotChildren=[],e.__inheritSlots=!0)},c.getInheritSlots=function(e){return e.__inheritSlots};var L=function(e,t){var r=e.match(/^(#[_a-zA-Z][-_a-zA-Z0-9:]*|)((?:\.-?[_a-zA-Z][-_a-zA-Z0-9]*)+|)$/);if(!r)return null;var n=r[1].slice(1),o=r[2].split(".");return o.shift(),n||o.length?{id:n,classes:o,relation:t||""}:null},M=c.parseSelector=function(e){for(var t=String(e||"").split(","),r=[],n=!1,o=0;o<t.length;o++){for(var i=t[o].split(/( |\t|>+)/g),a=[],l="",s=0;s<i.length;s++){var _=i[s];if(_&&" "!==_&&"\t"!==_)if(">"!==_[0]){var c=L(_,l);if(l="",!c)break;a.push(c)}else{if(""!==l)break;l=_,">>>"===_&&(n=!0)}}s===i.length&&a.length&&r.push(a)}return r.length?{crossShadow:n,union:r}:null},R=function(e,t,r,n,o){if(t===e)return!1;var i=r[n],a=!0;i.id&&i.id!==t.__id&&(a=!1);for(var l=i.classes,s=0;a&&s<l.length;s++)t.classList.contains(l[s])||(a=!1);if(!a&&">"===o)return!1;var _=t;if(a&&0===n){if(null===e)return!0;for(_=_.parentNode;_;_=_.parentNode)if(_===e)return!0;if(">>>"!==o)return!1;_=t,a=!1}var c=a?i.relation:o;do _.parentNode?_=_.parentNode:">>>"===c?_=_.__wxHost:">>>"===o?(a=!1,_=_.__wxHost):_=null,_===e&&(_=null);while(_&&_.__virtual);if(!_)return!1;if(a){var u=R(e,_,r,n-1,c);if(u)return!0;if(">>>"!==o)return!1}return R(e,_,r,n,o)},I=function(e,t,r){if(r.__virtual)return!1;for(var n=e.union,o=0;o<n.length;o++){var i=n[o];if(R(t,r,i,i.length-1,">"))return!0}return!1},D=function(e,t,r,n,o){if(I(t,r,n)&&(e.push(n),o))return!0;if(n.shadowRoot&&t.crossShadow){var i=n.ownerShadowRoot?n.ownerShadowRoot.__wxHost.__componentOptions.domain:s.domain,a=n.__componentOptions.domain;if(i===a&&D(e,t,r,n.shadowRoot,o)&&o)return!0}for(var l=n.childNodes,_=0;_<l.length;_++)if(l[_]instanceof c&&D(e,t,r,l[_],o)&&o)return!0;return!1};c.prototype.querySelector=function(e){var t="object"==typeof e?e:M(e);if(!t)return null;var r=[];return D(r,t,this,this,!0),r[0]||null},c.prototype.querySelectorAll=function(e){var t="object"==typeof e?e:M(e),r=[];return t?(D(r,t,this,this,!1),r):[]},c.matchSelector=function(e,t){var r="object"==typeof e?e:M(e);return!!r&&I(r,null,t)},c.prototype.matchSelector=function(e,t){var r="object"==typeof e?e:M(e);return!!r&&I(r,this,t)},e.exports=c},function(e,t,r){var n=r(3),o=function(){};o.prototype=Object.create(Object.prototype,{constructor:{value:o,writable:!0,configurable:!0}}),o.create=function(e){var t=new o;return t._cb=e,t._noSubtreeCb=function(t){t.target===this&&e.call(this,t)},t._binded=[],t},o.prototype.observe=function(e,t){t=t||{};var r=0,o=t.subtree?this._cb:this._noSubtreeCb;t.properties&&(e.__propObservers||(e.__propObservers=n.create("Observer Callback")),this._binded.push({funcArr:e.__propObservers,id:e.__propObservers.add(o),subtree:t.subtree?e:null}),r++),t.childList&&(e.__childObservers||(e.__childObservers=n.create("Observer Callback")),this._binded.push({funcArr:e.__childObservers,id:e.__childObservers.add(o),subtree:t.subtree?e:null}),r++),t.characterData&&(e.__textObservers||(e.__textObservers=n.create("Observer Callback")),this._binded.push({funcArr:e.__textObservers,id:e.__textObservers.add(o),subtree:t.subtree?e:null}),r++),t.subtree&&i(e,r),t.attachStatus&&(e.__attachedObservers||(e.__attachedObservers=n.create("Observer Callback")),this._binded.push({funcArr:e.__attachedObservers,id:e.__attachedObservers.add(o),subtree:null}))},o.prototype.disconnect=function(){for(var e=this._binded,t=0;t<e.length;t++){var r=e[t];r.funcArr.remove(r.id),r.subtree&&i(r.subtree,-1)}this._binded=[]};var i=o._updateSubtreeCaches=function(e,t){e.__subtreeObserversCount+=t;var r=e.childNodes;if(r)for(var n=0;n<r.length;n++)i(r[n],t)};o._callObservers=function(e,t,r){do e[t]&&e[t].call(e,[r]),e=e.parentNode;while(e&&e.__subtreeObserversCount)},o._callSingleObserver=function(e,t,r){e[t]&&e[t].call(e,[r])},e.exports=o},function(e,t){var r=function(){},n=/(~|\^+)?-?[_0-9a-z][-_0-9a-z]*/gi,o=null;r._setElementSystem=function(e){o=e,r._setElementSystem=null};var i=Object.prototype.hasOwnProperty;r.create=function(e,t){var n=new r;n._prefix="",n._addOriginalClass=!1,n._alias=t,n._resolvedAlias={};for(var o in t)n._resolvedAlias[o]="";return n._rawNames=[],n._elem=e,n._owner=null,n};var a=function(e){var t="",r=e._rawNames,n=e._prefix,o=e._owner?e._owner._resolvedAlias:null,a=e._addOriginalClass;n&&(n+="--");for(var l=0;l<r.length;l++){var s=r[l];if(l&&(t+=" "),o&&i.call(o,s))t+=o[s];else if("~"===s[0])t+=s.slice(1);else if("^"===s[0]){s=s.slice(1);for(var _=e._owner||null;"^"===s[0];)s=s.slice(1),_=_?_._owner:null;var c=_?_._prefix:"";c&&(c+="--"),t+=c+s}else a&&(t+=s+" "),t+=n+s}return t},l=function(e){var t=e._elem.__domElement;if(t){var r=a(e);r?t.setAttribute("class",r):t.removeAttribute("class")}},s=function(e){var t=e.classList;t instanceof r&&(t._alias&&_(t),l(t));for(var n=e.childNodes,i=0;i<n.length;i++)n[i]instanceof o&&s(n[i])},_=function(e){var t=e._owner;if(!t)return!1;var r=!1;for(var n in e._alias){var a=e._alias[n],l=[];if(a)for(var _=0;_<a.length;_++){var c=a[_];if(i.call(t._alias,c)){var u=t._resolvedAlias[c];l.push(u)}else{var d=e._prefix&&c?e._prefix+"--"+c:c;l.push(d)}}var f=l.join(" ");e._resolvedAlias[n]!==f&&(r=!0,e._resolvedAlias[n]=f)}r&&e._elem.shadowRoot instanceof o&&s(e._elem.shadowRoot)};r.prototype.toggle=function(e,t){var r=this._rawNames.indexOf(e);void 0===t&&(t=r<0),t?r<0&&(this._rawNames.push(e),l(this)):r>=0&&(this._rawNames.splice(r,1),l(this))},r.prototype.contains=function(e){for(var t=this._rawNames,r=0;r<t.length;r++){var n=t[r];if("~"===n[0]){if(n.slice(1)===e)return!0}else if("^"===n[0]){for(var o=1;"^"===n[o];)o++;if(n.slice(o)===e)return!0}else if(n===e)return!0}return!1},r.prototype._setOwnerOptions=function(e,t,r){var n=this._prefix;this._prefix=t,n!==t&&(this._addOriginalClass=r,this._owner=e,this._alias&&_(this),l(this))},r.prototype._setAlias=function(e,t){var r=this._owner,o=String(t).match(n);this._alias[e]=o;var a=[];if(o)for(var l=0;l<o.length;l++){var _=o[l];r&&i.call(r._alias,_)?a.push(r._resolvedAlias[_]):a.push(this._prefix?this._prefix+"--"+_:_)}this._resolvedAlias[e]=a.join(" "),s(this._elem.shadowRoot)},r.prototype.setClassNames=function(e){e=void 0===e||null===e?"":String(e),this._rawNames=e.match(n)||[],l(this)},r.prototype.getClassNames=function(){return a(this)},r.prototype.getPrefix=function(){return this._prefix},r.prototype.getAddOriginalClass=function(){return this._addOriginalClass},e.exports=r},function(e,t,r){var n=r(10),o=r(4),i=r(13),a=function(){};a.prototype=Object.create(Object.prototype,{constructor:{
value:a,writable:!0,configurable:!0}});var l=a._advancedCreate=function(e,t){var r=new a;r.__slot="";var n=null;return i.backendExtractedDefault||"dom"!==o.documentBackend?r.__textContent=e:(n=document.createTextNode(e||""),n.__wxElement=r),r.$$=r.__domElement=n,r.__backendExtracted=i.backendExtractedDefault,r.__subtreeObserversCount=0,r.parentNode=null,r.ownerShadowRoot=t,r};a.create=function(e){return l(e,null)},Object.defineProperty(a.prototype,"textContent",{get:function(){return this.__domElement?this.__domElement.textContent:this.__textContent},set:function(e){this.__domElement?this.__domElement.textContent=e:this.__textContent=String(e),(this.__textObservers&&!this.__textObservers.empty||this.__subtreeObserversCount)&&n._callObservers(this,"__textObservers",{type:"characterData",target:this})}}),e.exports=a},function(e,t){t.backendExtractedDefault=!1,t.enableBackendExtractedDefault=function(){t.backendExtractedDefault=!0},t.disableBackendExtractedDefault=function(){t.backendExtractedDefault=!1}},function(e,t){var r=function(e){this.tagName=e,this.id="",this.attrs={}};r.toElement=function(e){var t=document.createElement(e.tagName);e.id&&(t.id=e.id);for(var r in e.attrs)t.setAttribute(r,e.attrs[r]);return t},r.fromElement=function(e){var t=new r(e.tagName);t.id=e.id;for(var n=e.attributes,o=0;o<n.length;o++)t.attrs[n[o].name]=n[o].value;return t},r.prototype.cloneNode=function(){var e=new r;e.id=this.id;for(var t in this.attrs)e.attrs[t]=this.attrs[t];return e},r.prototype.removeAttribute=function(e,t){delete this.attrs[e]},r.prototype.setAttribute=function(e,t){this.attrs[e]=t},r.prototype.getAttribute=function(e){return this.attrs[e]},e.exports=r},function(e,t,r){var n=r(3),o=r(5),i=r(16),a=r(6),l=r(8),s=r(9),_=r(17),c=r(10),u=r(11),d=r(14),f=r(4),p=r(13),h=r(7),v=a.addListenerToElement,m=h.parseSinglePath,b=o.deepCopy,g=function(){};g.prototype=Object.create(s.prototype,{constructor:{value:g,writable:!0,configurable:!0},data:{get:function(){return this.__dataProxy._data},set:function(e){var t=this.__dataProxy;for(var r in e)t.scheduleReplace([r],e[r]);t.doUpdates()},configurable:!0},$:{get:function(){return s._updateIdMap(this),this.__idCache},set:function(){}}});var w=function(){};w.prototype=Object.create(Object.prototype),a._setComponent(g);var y=null;g._setDefaultTemplateEngine=function(e){y=e,g._setDefaultTemplateEngine=null};var x=function(e,t,r){if(r)for(var n=0;n<r.length;n++)if(l.matchTypeWithValue(r[n],e))return e;return t===String?null===e||void 0===e?"":String(e):t===Number?isFinite(e)?Number(e):0:t===Boolean?!!e:t===Array?e instanceof Array?e:[]:t===Object?"object"==typeof e?e:null:void 0===e?null:e},C=function(e,t,r){var n=t.replace(/[A-Z]/g,function(e){return"-"+e.toLowerCase()}),o=typeof r;"boolean"===o?r?e.__domElement.setAttribute(n,""):e.__domElement.removeAttribute(n):"object"===o?e.__domElement.setAttribute(n,JSON.stringify(r)):e.__domElement.setAttribute(n,r)},E=function(e,t,r){var o=[t?t.__wxHost.__componentOptions.domain:void 0],i=n.safeCallback("Availablity Controller",r,e,o);return!!i},S=function(e,t,r,o){var i=[e.ownerShadowRoot?e.ownerShadowRoot.__wxHost.__componentOptions.domain:void 0,o?void 0:r],a=n.safeCallback("Availablity Controller",t,e.__methodCaller,i,e);return!!a};i.setPropUpdater(function(e,t,r,o){var i=e[0],a=this.__propData[i];r=x(r,t.type,t.optionalTypes);var l=!t.availability||S(this,t.availability,r,o);if(!l)return a;if(t.filter){var s=n.safeCallback("Property Filter",t.filter,this.__methodCaller,o?[]:[r,a,e],this);void 0!==s&&(r=s)}return this.__domElement&&this.__componentOptions.reflectToAttributes&&this.__propPublic[i]&&C(this,i,r),r}),i.setPropObserver(function(e,t,r,o,i,a){if(o.observeAssignments||e!==t){var l=r[0];this.__propertyChangeListeners&&this.__propertyChangeListeners[l]&&!a&&n.safeCallback("Property Observer",this.__propertyChangeListeners[l],this.__methodCaller,[e],this),o.observer&&n.safeCallback("Property Observer",o.observer,this.__methodCaller,i?[]:[e,t,r],this),o.public&&(this.__propObservers&&!this.__propObservers.empty||this.__subtreeObserversCount)&&c._callObservers(this,"__propObservers",{type:"properties",target:this,propertyName:l})}});var O=function(e,t,r){t.__relationLinks||(t.__relationLinks={});for(var n=t.__relationLinks[r]=[],o=0;o<e.length;o++)n.push(null)},N=function(e,t,r,o,i){for(var a=g.prototype.hasBehavior,s="parent"===o,_="shadowHost"===o,c=0;c<e.length;c++){var u=e[c],d=null;if(d="object"!=typeof u.target?l._list[u.target]:u.target){var f=t[c],p=null;if(!i)for(var h=_?r.ownerShadowRoot&&r.ownerShadowRoot.__wxHost:r.parentNode;h;h=_?h.ownerShadowRoot&&h.ownerShadowRoot.__wxHost:h.parentNode)if(!h.__virtual){if(a.call(h,d)){var v=null;v=s?h.__relationMap.child:_?h.__relationMap.shadowContent:h.__relationMap.descendant;for(var m=0;m<v.length;m++){var b=v[m],w=null;if(w="object"!=typeof b.target?l._list[b.target]:b.target,w&&a.call(r,w)){p={parent:h,relation:b};break}}}if(s||p)break}t[c]=p,!f||p&&f.parent===p.parent||(n.safeCallback("Relation Unlinked Callback",f.relation.unlinked,f.parent.__methodCaller,[r.__methodCaller],f.parent),n.safeCallback("Relation Unlinked Callback",u.unlinked,r.__methodCaller,[f.parent.__methodCaller],r)),!p||f&&f.parent===p.parent||(n.safeCallback("Relation Linked Callback",p.relation.linked,p.parent.__methodCaller,[r.__methodCaller],p.parent),n.safeCallback("Relation Linked Callback",u.linked,r.__methodCaller,[p.parent.__methodCaller],r)),f&&p&&f.parent===p.parent&&(n.safeCallback("Relation Link Changed Callback",p.relation.linkChanged,p.parent.__methodCaller,[r.__methodCaller],p.parent),n.safeCallback("Relation Link Changed Callback",u.linkChanged,r.__methodCaller,[p.parent.__methodCaller],r)),i||p||n.safeCallback("Relation Link Failed Callback",u.linkFailed,r.__methodCaller,[],r)}}},k=function(e,t){var r=[],n=t.type,o="child"===n,i="shadowContent"===n,a=function(n){for(var l=n.childNodes,_=0;_<l.length;_++){var c=l[_];if(c instanceof s)if(c.__virtual)a(c);else{if(c.__relationLinks){var u=null;if(u=o?c.__relationLinks.parent:i?c.__relationLinks.shadowHost:c.__relationLinks.ancestor)for(var d=0;d<u.length;d++){var f=u[d];if(f&&f.parent===e&&f.relation===t){r.push(c);break}}}i&&c instanceof g&&a(c.shadowRoot),o||a(c)}}};return a(i?e.shadowRoot:e),r},T=function(e,t,r){if(e instanceof s){var n=0,o=null;if(e instanceof g){for(e.__pageLifeTimeFuncs[t]&&e.__pageLifeTimeFuncs[t].call(e.__methodCaller,r||[]),o=e.childNodes,n=0;n<o.length;n++)T(o[n],t,r);e=e.shadowRoot}for(o=e.childNodes,n=0;n<o.length;n++)T(o[n],t,r)}};g._list={},g.register=function(e){var t=e.options||{},r=l.create(e),n=void 0!==t.classPrefix?t.classPrefix:f.classPrefix;null!==n&&void 0!==n||(n=r.is||"");var o=new w;return o._unprepared=r,o.is=e.is||"",o.behavior=r,o.protoFunc=null,o.props=null,o.template=null,o.innerEvents=null,o.generics=r.generics,o.initiator=r.initiator||null,o.options={availability:t.availability||f.availability,domain:t.domain||f.domain,writeOnly:!!(void 0!==t.writeOnly?t.writeOnly:f.writeOnly),allowInWriteOnly:!!(void 0!==t.allowInWriteOnly?t.allowInWriteOnly:f.allowInWriteOnly),classPrefix:n,addGlobalClass:!!(void 0!==t.addGlobalClass?t.addGlobalClass:f.addGlobalClass),templateEngine:t.templateEngine||f.templateEngine||y,renderingMode:t.renderingMode||f.renderingMode,multipleSlots:!!(void 0!==t.multipleSlots?t.multipleSlots:f.multipleSlots),reflectToAttributes:!!(void 0!==t.reflectToAttributes?t.reflectToAttributes:f.reflectToAttributes),writeFieldsToNode:!!(void 0!==t.writeFieldsToNode?t.writeFieldsToNode:f.writeFieldsToNode),writeIdToDOM:!!(void 0!==t.writeIdToDOM?t.writeIdToDOM:f.writeIdToDOM),separateInnerData:!!(void 0!==t.separateInnerData?t.separateInnerData:f.separateInnerData),innerDataExclude:t.innerDataExclude||f.innerDataExclude,listenerChangeLifeTimes:!!(void 0!==t.listenerChangeLifeTimes?t.listenerChangeLifeTimes:f.listenerChangeLifeTimes),randomizeTagName:!!(void 0!==t.randomizeTagName?t.randomizeTagName:f.randomizeTagName),virtualHost:!!(void 0!==t.virtualHost?t.virtualHost:f.virtualHost)},r._unprepared||g.prepare(o),void 0!==e.is&&(g._list[r.is]=o),o},g.isPrepared=function(e){return!e._unprepared},g.prepare=function(e){var t=e._unprepared;if(t){e._unprepared=null;var r=e.options,n={};t._unprepared&&l.prepare(t),r.writeOnly&&(n.data={value:null});var o=e.props={};Object.keys(t.properties).forEach(function(e){var i=t.properties[e];o[e]={type:i.type,optionalTypes:i.optionalTypes,value:i.value,filter:"function"==typeof i.filter?i.filter:null==i.filter?null:t.methods[i.filter],observer:"function"==typeof i.observer?i.observer:null==i.observer?null:t.methods[i.observer],public:i.public,availability:i.availability,observeAssignments:i.observeAssignments},r.writeFieldsToNode&&(n[e]={enumerable:!0,get:function(){return this.__propData[e]},set:function(t){var r=this.__dataProxy;r.scheduleReplace([e],t),r.doUpdates()}})});var a=function(){};e.protoFunc=a;var s=a.prototype=Object.create(g.prototype,n);if(s.is=e.is,s.__componentOptions=r,s.__using=t.using,e.dataGroupObserverTree=i._createObserverTree(o),t._addObserversToDataProxy(e.dataGroupObserverTree),s.__behavior=t,r.writeFieldsToNode)for(var _ in t.methods)s[_]=t.methods[_];s.__lifeTimeFuncs=t._getAllLifeTimeFuncs(),s.__pageLifeTimeFuncs=t._getAllPageLifeTimeFuncs();var c=t.relations,u=s.__relationMap={};for(var d in c){var f=c[d],p=f.type;u[p]?u[p].push(f):u[p]=[f]}var h=[];u.parent&&h.push(function(e){N(this.__relationMap.parent,this.__relationLinks.parent,this,"parent","detached"===e)}),u.ancestor&&h.push(function(e){N(this.__relationMap.ancestor,this.__relationLinks.ancestor,this,"ancestor","detached"===e)}),u.shadowHost&&h.push(function(e){N(this.__relationMap.shadowHost,this.__relationLinks.shadowHost,this,"shadowHost","detached"===e)}),e.relationHandler=function(e){for(var t=0;t<h.length;t++)h[t].call(this,e)};var v={},m={},b=t.data,w="";for(w in b)m[w]=b[w];for(w in o){var y=o[w];m[w]=y.value,v[w]=y.public}var x=m,C=r.separateInnerData,E=r.innerDataExclude;if(E){x={};for(var S in m)E.test(S)||(x[S]=m[S]);C||(m=x)}var O=r.templateEngine;e.template=O.create(t,m,x,r),s.__propPublic=v;var k=t._getAllListeners(),T=e.innerEvents=[];for(var A in k){for(var P=k[A],L=A.indexOf("."),M=A.slice(L+1),R=L<1?"":A.slice(0,L),I=[],D=0;D<P.length;D++){var j=P[D];"function"!=typeof j&&(j=null==j?null:t.methods[j]),I.push(j)}T.push({id:R,name:M,funcs:I})}}};var A=1,P=Object.prototype.hasOwnProperty,L=function(e,t){return function(r){return e.call(t.__methodCaller,r,t)}},M=function(e,t,r){var n={};for(var o in e){var i=e[o],a=t[o];"object"!=typeof a&&(a=g._list[a]),"object"!=typeof a&&null!=i.default&&(a=g._list[i.default]),a&&(n[o]=a)}return n},R=g._advancedCreate=function(e,t,r,o,a){var l=t;l._unprepared&&g.prepare(l);var _=l.options,c=!_.availability||E(l,r,_.availability);c||(l=g._list[""]);var h=l.protoFunc,m=new h,w=l.generics;w?m.__generics=M(w,o||{},_):m.__generics={};var y=null,x=f.documentBackend;if(_.virtualHost){var y=null;"dom"===f.documentBackend&&(y=void 0),s.initialize(m,y,r),m.__virtual=!0}else"dom"===x?(y=p.backendExtractedDefault?new d(e):document.createElement(e),s.initialize(m,y,r)):s.initialize(m,null,r);var C=0,S=m.__externalClassAlias={};if(l.behavior.externalClasses){var N=l.behavior.externalClasses;for(C=0;C<N.length;C++)S[N[C]]=null}if(m.classList=u.create(m,S),r){var k=r.__wxHost;m.classList._setOwnerOptions(k.classList,k.__componentOptions.classPrefix,k.__componentOptions.addGlobalClass),f.writeExtraInfoToAttr&&y&&y.setAttribute("exparser:info-class-prefix",k.__componentOptions.classPrefix&&k.__componentOptions.classPrefix+"--")}f.writeExtraInfoToAttr&&y&&(m.__componentInstanceId=A++,y.setAttribute("exparser:info-component-id",m.__componentInstanceId));var T=m.__templateInstance=l.template.createInstance(m,a);m.__propData=T.data;var P=_.separateInnerData;m.__innerData=P?b(m.__propData):null;var R=_.innerDataExclude;if(P&&R){var I={};for(var D in m.__innerData)R.test(D)||(I[D]=m.__innerData[D]);m.__innerData=I}m.__dataProxy=i._advancedCreate(m,m.__propData,m.__innerData,R,l.dataGroupObserverTree,function(e,t,r,n){m.__templateInstance.updateValues(m,P?m.__innerData:m.__propData,e,t,r,n)}),T.beforeMergeValues&&m.__dataProxy.setBeforeMergeCb(function(e,t,r){m.__templateInstance.beforeMergeValues(e,t,r)}),T.beforeUpdateValues&&m.__dataProxy.setBeforeUpdateCb(function(e){m.__templateInstance.beforeUpdateValues(m,P?m.__innerData:m.__propData,e)}),_.writeOnly&&m.__dataProxy.setHidingValue(!0),m.__idCacheDirty=!1,m.__idCache=T.idMap,null===T.slots[""]&&(T.slots[""]=y),l.options.multipleSlots?m.__slots=T.slots:(m.__singleSlot=T.slots[""]||null,m.__singleSlot&&(m.__singleSlot.__wxSlotChildren=m.childNodes)),T.shadowRoot instanceof s?(m.shadowRoot=T.shadowRoot,s._attachShadowRoot(T.shadowRoot)):y instanceof d?(m.shadowRoot=y,y.__wxHost=m,m.__domElement.asShadowRoot=T.shadowRoot,m.__wxSlotChildren=[y],y.__wxSlotParent=m):(m.shadowRoot=y,y.__wxHost=m,m.__domElement.appendChild(T.shadowRoot),m.__wxSlotChildren=[y],y.__wxSlotParent=m);for(var j=T.listeners,F=0;F<j.length;F++){var H=j[F];v(H.target,H.name,L(H.func,m))}var B=l.innerEvents;for(C=0;C<B.length;C++){var U=B[C],V=U.id?"this"===U.id?m:m.__idCache[U.id]:m.shadowRoot;if(V)for(var $=U.name,z=U.funcs,G=0;G<z.length;G++)v(V,$,L(z[G],m))}var W=m.__relationMap;return W.parent&&(O(W.parent,m,"parent"),m.__relationHandler=l.relationHandler),W.ancestor&&(O(W.ancestor,m,"ancestor"),m.__relationHandler=l.relationHandler),W.shadowHost&&(O(W.shadowHost,m,"shadowHost"),m.__relationHandler=l.relationHandler),m.__propertyChangeListeners=null,l.initiator&&n.safeCallback("Component Initiator",l.initiator,m.__methodCaller,[],m),m.__lifeTimeFuncs.created.call(m.__methodCaller,[],m),m};g.create=function(e,t,r){return"object"==typeof e?R(e.is,e,null,null,r):e?e.indexOf("-")<0&&!t?_.create(e):R(e.toLowerCase(),t||P.call(g._list,e)&&g._list[e]||g._list[""],null,null,r):R("virtual",g._list[""],null,null,r)},g.listProperties=function(e){var t=[];for(var r in e.__propPublic)void 0!==e.__propPublic[r]&&t.push(r);return t},g.listPublicProperties=function(e){var t=[];for(var r in e.__propPublic)e.__propPublic[r]===!0&&t.push(r);return t},g.hasProperty=function(e,t){return void 0!==e.__propPublic[t]},g.hasPublicProperty=function(e,t){return e.__propPublic[t]===!0},g.getMethodsFromDef=function(e){return e.behavior._unprepared&&l.prepare(e.behavior),e.behavior.methods},g.getMethod=function(e,t){return e.__behavior.methods[t]},g.getComponentOptions=function(e){return e.__componentOptions},g.prototype.triggerLifeTime=function(e,t){this.__lifeTimeFuncs[e].call(this.__methodCaller,t||[])},g.prototype.triggerPageLifeTime=function(e,t){T(this,e,t)},g.prototype.hasBehavior=function(e){return"object"!=typeof e&&Object.prototype.hasOwnProperty.call(this.__using,e)&&(e=this.__using[e]),!!this.__behavior&&this.__behavior.hasBehavior(e)},g.prototype.getRootBehavior=function(){return this.__behavior},g.prototype.getRelationNodes=function(e){var t=this.__behavior.relations[e];if(!t)return null;if("parent"===t.type||"ancestor"===t.type||"shadowHost"===t.type){for(var r=this.__relationMap[t.type],n=0;n<r.length&&r[n]!==t;n++);return this.__relationLinks[t.type][n]?[this.__relationLinks[t.type][n].parent]:[]}return k(this,t)},g.prototype.hasExternalClass=function(e){return P.call(this.__externalClassAlias,e)},g.prototype.setExternalClass=function(e,t){this.classList._setAlias(e,t)},g.prototype.setPropertyChangeListener=function(e,t){this.__propertyChangeListeners||(this.__propertyChangeListeners={}),this.__propertyChangeListeners[e]=t},g.prototype.replaceDataOnPath=function(e,t){this.__dataProxy.scheduleReplace(e,t)},g.prototype.isInnerDataExcluded=function(e){var t=this.__componentOptions.innerDataExclude;return!!t&&t.test(e)},g.getInnerData=function(e){return e.__innerData},g.getDataProxy=function(e){return e.__dataProxy},g.replaceWholeData=function(e,t,r){e.__propData=t,e.__dataProxy.replaceWholeData(t,r)},g.prototype.applyDataUpdates=function(){this.__dataProxy.doUpdates()},g.prototype.setData=function(e){var t=this.__dataProxy;for(var r in e)t.scheduleReplace(m(r),e[r]);t.doUpdates()},e.exports=g},function(e,t,r){var n=r(3),o=r(5),i=null,a=null,l=Object.prototype.hasOwnProperty,s=o.deepCopy,_=function(e,t,r,n,o,i){this._data=t,this._innerData=r,this._innerDataExclude=n,this._comp=e,this._updateCb=i,this._beforeMergeCb=null,this._beforeUpdateCb=null,this._hidingValue=!1,this._changes=[],this._doingUpdates=null,this._propFields=o._propFields,this._observers=o._observers,this._observerTree=o._observerTree,this._relatedObserverTreeObj=o,this._observerStatus=[]};_._advancedCreate=function(e,t,r,n,o,i){return new _(e,t,r,n,o,i)};var c=function(e){this._propFields=e,this._observerIdInc=0,this._observers=[],this._observerTree={}};_._createObserverTree=function(e){return new c(e)},_.create=function(e,t,r){var n=new c({});return new _({__methodCaller:e},t,null,null,n,r)},_.setPropUpdater=function(e){i=e},_.setPropObserver=function(e){a=e},_.prototype.replaceWholeData=function(e,t){this._data=e},_.prototype.setHidingValue=function(e){this._hidingValue=!!e},_.prototype.setBeforeMergeCb=function(e){this._beforeMergeCb=e},_.prototype.setBeforeUpdateCb=function(e){this._beforeUpdateCb=e};var u=function(e,t,r){for(var n=e,o=0;o<t.length;o++){var i=t[o];if("**"===i)return n["**"]||(n["**"]=[]),void n["**"].push(r);n[i]||(n[i]={}),n=n[i]}n["~"]||(n["~"]=[]),n["~"].push(r)},d=function(e,t,r){for(var n=0;n<t.length;n++)u(e,t[n],r)},f=function(e,t,r){for(var n=e,o=0,i="";o<t.length&&(i=t[o],"**"!==i);o++){if(!n)return;n=n[i]}var a="**"===i?n["**"]:n["~"];if(a)for(o=0;o<a.length;o++)if(a[o]===r){a.splice(o,1);break}},p=function(e,t,r){for(var n=0;n<t.length;n++)f(e,t[n],r)};c.prototype.addObserver=function(e,t){var r=this._observerIdInc++;return this._observers[r]={pathObj:t,func:e},d(this._observerTree,t,r),r},c.prototype.removeObserver=function(e){var t=this._observers[e];p(this._observerTree,t.pathObj,e),this._observers[e]=null},c.prototype.moveObserver=function(e,t){var r=this._observers[e];p(this._observerTree,r.pathObj,e),r.pathObj=t,d(this._observerTree,t,e)},_.prototype.getObserverTree=function(){return this._relatedObserverTreeObj};var h=function(e,t,r){for(var o=[],i=r.pathObj,a=0;a<i.length;a++){for(var l=i[a],s=t,_=0;_<l.length;_++){var c=l[_];if("**"===c)break;if("object"!=typeof s){s=void 0;break}s=s[c]}o[a]=s}n.safeCallback("Data Observer",r.func,e.__methodCaller,o,e)},v=function(e,t){var r=null,n=0,o=-1;for(var i in e)if("~"!==i)if("**"!==i)v(e[i],t);else for(r=e["**"],n=0;n<r.length;n++)o=r[n],t[o]=!0;else for(r=e["~"],n=0;n<r.length;n++)o=r[n],t[o]=!0},m=function(e,t,r){for(var n=e,o=0;o<r.length;o++){if(n["**"])for(var i=n["**"],a=0;a<i.length;a++){var s=i[a];t[s]=!0}var _=r[o];if("number"==typeof _){if(!l.call(n,_)){n=null;break}}else if(!/^[_a-zA-Z]/.test(_)||!l.call(n,_)){n=null;break}n=n[_]}n&&v(n,t)},b=function(e,t,r,n,o){for(var i=0;i<e.length;i++){var a=e[i],l=t[i];l&&l&&(t[i]=!1,h(r,o?void 0:n,a))}};_.prototype.scheduleReplace=function(e,t,r){this._changes.push([e,t,r])},_.prototype.setChanges=function(e){this._changes=e},_.prototype.getChanges=function(){return this._changes},_.prototype.doUpdates=function(e,t){var r=this._propFields,n=this._comp,o=this._hidingValue,_=this._innerDataExclude,c=!!this._doingUpdates,u=this._relatedObserverTreeObj._observerIdInc,d=null,f=null,p=null;u?(c||(this._doingUpdates={changedPaths:[],changedValues:[],combinedChanges:[],changesTotal:0}),d=this._doingUpdates.changedPaths,f=this._doingUpdates.changedValues,p=this._doingUpdates.combinedChanges):(d=[],f=[],p=[]);var h=this._changes;this._changes=[];var v=[];this._beforeMergeCb&&this._beforeMergeCb(h,v,e);for(var g=0;g<h.length;g++){var w=h[g],y=w[0],x=w[1],C=x,E=void 0,S=y[0],O=!!_&&_.test(S),N=r[S];if(N&&1===y.length)E=this._data[S],x=i.call(this._comp,y,N,x,this._hidingValue),O||(this._innerData?(C=s(x),v[g]||(this._innerData[S]=C)):C=x,w[1]=C),O&&!this._innerData||(this._data[S]=x);else{var k=this._data,T=S,A=null,P=1;if(!O||this._innerData){for(;P<y.length;P++)A=y[P],"number"==typeof A&&isFinite(A)?l.call(k,T)&&k[T]instanceof Array||(k[T]=[]):(!l.call(k,T)||null===k[T]||"object"!=typeof k[T]||k[T]instanceof Array)&&(k[T]={}),k=k[T],T=A;k[T]=x}if(this._innerData&&(k=this._innerData,T=S,!O)){for(P=1;P<y.length;P++)A=y[P],"number"==typeof A&&isFinite(A)?l.call(k,T)&&k[T]instanceof Array||(k[T]=[]):(!l.call(k,T)||null===k[T]||"object"!=typeof k[T]||k[T]instanceof Array)&&(k[T]={}),k=k[T],T=A;C=s(x),v[g]||(k[T]=C),w[1]=C}}m(this._observerTree,this._observerStatus,y),O||(d.push(y),f.push([C,E,x]),p.push(w)),u&&(this._doingUpdates.changesTotal+=1)}if(!c){if(this._beforeUpdateCb&&this._beforeUpdateCb(e),u){var L=0;do L=this._doingUpdates.changesTotal,b(this._observers,this._observerStatus,n,this._data,o);while(L!==this._doingUpdates.changesTotal);this._doingUpdates=null}this._updateCb(d,f,p,e);for(var M=0;M<f.length;M++){var R=f[M];if(R){var I=d[M],D=I[0],j=r[D];j&&a.call(n,R[2],R[1],I,j,o,t)}}}},e.exports=_},function(e,t,r){var n=r(9),o=r(11),i=r(14),a=r(4),l=r(13),s=function(){};s.prototype=Object.create(n.prototype,{constructor:{value:s,writable:!0,configurable:!0}});var _=s._advancedCreate=function(e,t){var r=new s;r.is=e.toLowerCase();var _=null;if("dom"===a.documentBackend&&(_=l.backendExtractedDefault?new i(e):document.createElement(e)),n.initialize(r,_,t),r.classList=o.create(r,null),t){var c=t.__wxHost;r.classList._setOwnerOptions(c.classList,c.__componentOptions.classPrefix,c.__componentOptions.addGlobalClass),a.writeExtraInfoToAttr&&_&&_.setAttribute("exparser:info-class-prefix",c.__componentOptions.classPrefix&&c.__componentOptions.classPrefix+"--")}return r};s.create=function(e){return _(e,null)};var c=s._advancedClone=function(e,t){var r=new s;r.is=e.is;var _=null;if(e.__domElement&&(_=e.__domElement instanceof i?l.backendExtractedDefault?e.__domElement.cloneNode():i.toElement(e.__domElement):l.backendExtractedDefault?i.fromElement(e.__domElement):document.importNode?document.importNode(e.__domElement,!1):e.__domElement.cloneNode(!1)),n._clone(r,e,_,t),r.classList=o.create(r,null),t){var c=t.__wxHost;r.classList._setOwnerOptions(c.classList,c.__componentOptions.classPrefix,c.__componentOptions.addGlobalClass),a.writeExtraInfoToAttr&&_&&_.setAttribute("exparser:info-class-prefix",c.__componentOptions.classPrefix&&c.__componentOptions.classPrefix+"--")}return r};s.cloneNode=function(e){return c(e,null)},e.exports=s},function(e,t,r){var n=r(9),o=r(4),i=function(e,t){a(this,e,t)};i.prototype=Object.create(n.prototype);var a=i.initialize=function(e,t,r){e.is=t||"";var i=null;"dom"===o.documentBackend&&(i=void 0),n.initialize(e,i,r),e.__virtual=!0};i._advancedCreate=function(e,t){return new i(e,t)},i.create=function(e){return new i(e,null)},e.exports=i},function(e,t,r){var n=r(9),o=r(15),i=r(18),a=r(17),l=r(12),s=Object.prototype.hasOwnProperty,_=function(e){i.initialize(this,"shadow",this),this.__hostAssociated=!1,this.__wxHost=e,this.__childrenPropsFilter=null,this.__slotCacheDirty=!1};_.prototype=Object.create(i.prototype),_.create=function(e){var t=new _(e);if(e.ownerShadowRoot&&e.ownerShadowRoot.__childrenPropsFilter)if(t.__childrenPropsFilter)for(var r in e.ownerShadowRoot.__childrenPropsFilter)t.__childrenPropsFilter[r]||(t.__childrenPropsFilter[r]=e.ownerShadowRoot.__childrenPropsFilter[r]);else t.__childrenPropsFilter=e.ownerShadowRoot.__childrenPropsFilter;return t};var c=function(e,t){var r={};for(var n in e){var i=e[n];"object"!=typeof i&&(s.call(t.__using,i)?i=t.__using[i]:s.call(t.__generics,i)&&(i=t.__generics[i]||o._list[""]),r[n]=i)}return r},u="abcdefghijklmnopqrstuvwxyz",d=function(){for(var e=Date.now(),t="exparser-",r=0;r<8;r++){var n=(e+Math.floor(26*Math.random()))%26;e=Math.floor(e/26),t+=u[n]}return t};_.prototype.createTextNode=function(e){return l._advancedCreate(e,this)},_.prototype.createNativeNode=function(e){return a._advancedCreate(e,this)},_.prototype.cloneNativeNode=function(e){return a._advancedClone(e,this)},_.prototype.createVirtualNode=function(e){return i._advancedCreate(e,this)},_.prototype.createComponent=function(e,t,r,n){var i=null;i=void 0===t?e:t;var a=this.__wxHost;return"object"!=typeof i&&(s.call(a.__using,i)?i=a.__using[i]:s.call(a.__generics,i)&&(i=a.__generics[i]),"object"!=typeof i&&(i=o._list[i]||o._list[""])),r&&(r=c(r,a)),"object"==typeof e&&(e=i.is),a.__componentOptions.randomizeTagName&&(e=d()),a.__componentOptions.writeOnly&&!i.options.allowInWriteOnly&&(i=o._list[""]),o._advancedCreate(e,i,this,r,n)},_.prototype.tagNameUsed=function(e){var t=this.__wxHost;return!!s.call(t.__using,e)||!!s.call(t.__generics,e)},_.prototype.getHostNode=function(){return this.__wxHost},_.prototype.getElementById=function(e){return n._updateIdMap(this.__wxHost),this.__wxHost.__idCache[e]},e.exports=_},function(e,t,r){var n=r(9),o=r(12),i=function(){};i.create=function(e,t,r){var a=new i;if(!(e instanceof n||e instanceof o))throw new Error("ElementIterator can only be used for exparser.Element or exparser.TextNode");a._elem=e,a._elemTypeLimit=r||n;var l=t.split("-");if("shadow"===l[0])a._composed=!1;else{if("composed"!==l[0])throw new Error("Unrecognized iterator type: "+t);a._composed=!0}if("ancestors"===l[1])a._relation="ancestors",a._order=0;else{if("descendants"!==l[1])throw new Error("Unrecognized iterator type: "+t);if(a._relation="descendants","root"!==l[2])throw new Error("Unrecognized iterator type: "+t);if("first"===l[3])a._order=-1;else{if("last"!==l[3])throw new Error("Unrecognized iterator type: "+t);a._order=1}}return a};var a=function(e,t,r,n){for(;e;e=r?e.__wxSlotParent||e.__wxHost||e.parentNode:e.parentNode)if(e instanceof t&&n(e)===!1)return!1;return!0},l=function(e,t,r,n,o){if(n<0&&e instanceof t&&o(e)===!1)return!1;var i=r?e.__wxSlotChildren||e.childNodes:e.childNodes;if(i)for(var a=0;a<i.length;a++)if(l(i[a],t,r,n,o)===!1)return!1;return!(n>0&&e instanceof t&&o(e)===!1)};i.prototype.forEach=function(e){return"ancestors"===this._relation?a(this._elem,this._elemTypeLimit,this._composed,e):l(this._elem,this._elemTypeLimit,this._composed,this._order,e)},e.exports=i},function(e,t,r){(function(t){var n=r(4),o=r(3),i=r(9),a=r(17),l=r(12),s=r(19),_=r(15),c=r(23),u=r(24),d=function(){};d.prototype=Object.create(Object.prototype,{constructor:{value:d,writable:!0,configurable:!0}});var f=function(){};f.prototype=Object.create(Object.prototype,{constructor:{value:f,writable:!0,configurable:!0}});var p=null,h=null;d.precompiler=h,d.htmlParser=p;var v=function(e){return e.replace(/-([a-z])/g,function(e,t){return t.toUpperCase()})},m=Object.prototype.hasOwnProperty,b=function(e,t){if(null!==e&&"object"==typeof e&&m.call(e,t))return e[t]},g=function(e,t,r,n){if(m.call(t,r)){var i=t[r];if("function"==typeof i)return o.safeCallback("Template Method",i,e,n)}},w=function(e,t){return[{t:1,n:"slot",a:[],c:[],p:null}]},y={t:1,n:'"slot"',v:!0,sn:"",a:[],c:[],p:null},x=function(e,t,r){e.classList.toggle(t,!!r)},C=function(e,t,r){e[t]=r},E=function(e,t,r){var n=e.__dataProxy;n.scheduleReplace([t],r),n.doUpdates()},S=function(e,t,r){e.class=r},O=function(e,t,r){e.setAttribute("style",r)},N=function(e,t,r){e.setAttribute("class",r)},k=function(e,t,r){e.textContent=r},T=function(e,t,r){e.dataset||(e.dataset={}),e.dataset[t]=r},A={$:function(e,t,r){r===!0?e.setAttribute(t,""):r===!1||void 0===r||null===r?e.removeAttribute(t):e.setAttribute(t,r)},":":C,c:x,s:function(e,t,r){var n=e.style;n&&(n[t]=r)},d:T},P=function(e,t,r){return[{t:1,n:"slot",v:!0,sn:"",a:[],c:[]}]};d.create=function(e,r,n,o){var i=void 0===e.template?P:e.template,a=i;if("function"!=typeof i)if(h&&"undefined"!=typeof window&&"undefined"!=typeof document){var l="__exparserFreeTmpl",s=h.compile(i),_=document.createElement("script");_.type="text/javascript",_.innerHTML="window."+l+"="+s,document.head.appendChild(_),document.head.removeChild(_),a=window[l],window[l]=null}else a="undefined"!=typeof t&&"undefined"!=typeof t.versions&&"undefined"!=typeof t.versions.node?d.precompileAndGetCreator(i):w;var c=Object.create(d.prototype);return c._initValuesJSON=JSON.stringify(n),r!==n?c._dataJSON=JSON.stringify(r):c._dataJSON=null,c._tagTreeRoot=L(a,n,e.methods,o),c._renderingMode=o.renderingMode,c};var L=function(e,t,r,o){var i=o.renderingMode,l="native"===i,s=l,_=!1,c=Object.create(null);l&&!n.hasDOMBackend&&(e=w);var d={},f=e(b,g,r),p=function(e){for(var r=0;r<e.length;r++){var n=e[r];if(3!==n.t){var o=n.n,i=!(l||"string"==typeof o&&o.indexOf("-")<0);"slot"===o&&""===n.sn&&(_=!0),n.n=o;var c=n.st;c&&c.e&&(c.o=O,s&&(c.v=c.e(t,d,null)));var f=n.cl;f&&f.e&&(f.o=l?N:S,s&&(f.v=f.e(t,d,null)));var h=null;i||(n.p=h=l?document.createElement(n.n):a.create(n.n),c&&void 0!==c.v&&h.setAttribute("style",c.v),l&&f&&void 0!==f.v&&h.setAttribute("class",f.v));for(var m=n.a,b=0;b<m.length;b++){var g=m[b];if(g.d)l||u[g.n].register(g.n,g,n);else{l||("bind"===g.n.slice(0,4)?(g.evCatch=!1,g.ev=v(g.n.slice(4)),":"===g.ev[0]&&(g.ev=g.ev.slice(1))):"catch"===g.n.slice(0,5)&&(g.evCatch=!0,g.ev=v(g.n.slice(5)),":"===g.ev[0]&&(g.ev=g.ev.slice(1))));var w=g.o;if(i)w?"&"===w?g.o=A[":"]:g.o=A[w]:(g.o=A[":"],g.n=v(g.n)),g.o===C&&(g.o=E),s&&g.e&&(g.v=g.e(t,d,null));else if(!g.ev){var y=A;w?"&"===w?g.o=y[":"]:g.o=y[w]:g.o=y.$,s?(g.e&&(g.v=g.e(t,d,null)),(g.o!==x||l)&&g.o(h,g.n,g.v)):g.e||g.o(h,g.n,g.v)}}}p(n.c),l&&(1!==n.c.length||void 0===n.c[0].sn||n.c[0].compressed||(n.sn=n.c[0].sn,n.compressed=!0,n.c.pop()))}else n.e&&(n.o=k,n.c=s?n.e(t,d,null):"")}};return p(f,c,!0),l&&(_||f.push(y),1!==f.length||""!==f[0].sn||f[0].compressed||f.pop()),f},M=function(e,t){return function(r){if(this[e](r),t)return!1}},R=function(e,t,r,n,o,a,l,s){for(var d=null,f=0,p=null,h=0;h<e.length;h++){var v=l,m=e[h];if(3===m.t)d=m.e?t.createTextNode(m.e(n,o,null)):t.createTextNode(m.c),m.e&&c.addBindings(a,v,m.b,d,m),i.appendChild(r,d);else{var b=m.cl,g=m.st,w=m.a,y=!1;for(f=0;f<w.length;f++)if(p=w[f],p.d){var S=u[p.n].create(p.n,p,m,n,o,a,v,s,t,R,r);if(u[p.n].requireBlock){d=S,i.appendChild(r,d),y=!0;break}}if(y)continue;if(m.v)d=t.createVirtualNode(m.n);else if(m.p){for(d=t.cloneNativeNode(m.p),f=0;f<w.length;f++)p=w[f],p.d||(p.ev?s(d,p.ev,p.v,p.evCatch):p.o===C?d.__domElement&&(p.o(d.__domElement,p.n,p.e(n,o,null)),c.addBindings(a,v,p.b,d.__domElement,p)):(p.e&&p.o(d,p.n,p.e(n,o,null)),(p.e||p.o===x||p.o===T)&&c.addBindings(a,v,p.b,d,p)));g&&g.e&&(d.setAttribute("style",g.e(n,o,null)),c.addBindings(a,v,g.b,d,g))}else{if(m.cpf){var O={},N=t.__wxHost;for(var k in m.cpf)!function(e){var t=m.cpf[e];O[e]=N.__behavior.methods[t]}(k);t.__childrenPropsFilter=O}for(d=t.createComponent(m.n,void 0,m.g,void 0),f=0;f<w.length;f++)if(p=w[f],!p.d){var A=p.v;p.o===E&&_.hasPublicProperty(d,p.n)?(p.e&&(A=p.e(n,o,null),c.addBindings(a,v,p.b,d,p)),p.e?E(d,p.n,A):d.__behavior.properties[p.n].type===Boolean?E(d,p.n,!0):E(d,p.n,A)):p.ev?s(d,p.ev,A,p.evCatch):p.o!==E&&(p.e&&(A=p.e(n,o,null),c.addBindings(a,v,p.b,d,p)),p.o(d,p.n,A))}g&&(g.e?(d.__domElement.setAttribute("style",g.e(n,o,null)),c.addBindings(a,v,g.b,d.__domElement,g)):d.__domElement.setAttribute("style",g.v))}m.id&&(d.id=m.id),b&&(b.e?d.class=b.e(n,o,null):d.class=b.v,b.o&&c.addBindings(a,v,b.b,d,b)),m.sl&&(d.slot=m.sl),void 0!==m.sn&&i.setSlotName(d,m.sn),i.appendChild(r,d),R(m.c,t,d,n,o,a,v,s)}}},I=function(e,t,r){for(var n=e.childNodes,o=0;o<n.length;o++){var i=n[o];i instanceof l||(i.__id&&(t[i.__id]=i),void 0!==i.__slotName&&(r[i.__slotName]=i),I(i,t,r))}},D=function(e,t,r,n,o,i){for(var a=null,l=0,s=null,_=0;_<e.length;_++){var u=e[_];if(void 0===u.n)a=document.createTextNode(u.c),u.e&&c.addBindings(o,i,u.b,a,u),t.appendChild(a);else{var d=u.cl,f=u.st,p=u.a;for(a=u.v?document.createElement("virtual"):document.importNode?document.importNode(u.p,!1):u.p.cloneNode(!1),l=0;l<p.length;l++)s=p[l],s.e&&c.addBindings(o,i,s.b,a,s);t.appendChild(a),u.id&&(r[u.id]=a),d&&d.e&&c.addBindings(o,i,d.b,a,d),f&&f.e&&c.addBindings(o,i,f.b,a,f),void 0!==u.sn&&(n[u.sn]=a),
D(u.c,a,r,n,o,i)}}};d.prototype.createInstance=function(e){var t=Object.create(f.prototype),r=JSON.parse(this._initValuesJSON),o=null===this._dataJSON?r:JSON.parse(this._dataJSON),i=Object.create(null),a=Object.create(null),l=[],_=c.create("",null,null,null,null,[],function(e,t){}),u=null;if("native"===this._renderingMode)"dom"===n.documentBackend&&(u=document.createDocumentFragment()),D(this._tagTreeRoot,u,i,a,_,{}),a[""]||(a[""]=null);else{var d=function(e,t,r,n){u.__wxHost?e.addListener(t,M(r,n).bind(u.__wxHost)):l.push({target:e,name:t,func:M(r,n)})};if(u=s.create(e),e.ownerShadowRoot&&e.ownerShadowRoot.__childrenPropsFilter)if(u.__childrenPropsFilter)for(var p in e.ownerShadowRoot.__childrenPropsFilter)u.__childrenPropsFilter[p]||(u.__childrenPropsFilter[p]=e.ownerShadowRoot.__childrenPropsFilter[p]);else u.__childrenPropsFilter=e.ownerShadowRoot.__childrenPropsFilter;R(this._tagTreeRoot,u,u,r,{},_,{},d),I(u,i,a)}return t.data=o,t.shadowRoot=u,t.idMap=i,t.slots=a,t.listeners=l,t._topScope=_,t},f.prototype.updateValues=function(e,t,r){for(var n=i.getMethodCaller(e),o=0;o<r.length;o++){var a=r[o];c.updateBinding(this._topScope,a,t,{},n)}},e.exports=d}).call(t,r(22))},function(e,t){function r(){throw new Error("setTimeout has not been defined")}function n(){throw new Error("clearTimeout has not been defined")}function o(e){if(c===setTimeout)return setTimeout(e,0);if((c===r||!c)&&setTimeout)return c=setTimeout,setTimeout(e,0);try{return c(e,0)}catch(t){try{return c.call(null,e,0)}catch(t){return c.call(this,e,0)}}}function i(e){if(u===clearTimeout)return clearTimeout(e);if((u===n||!u)&&clearTimeout)return u=clearTimeout,clearTimeout(e);try{return u(e)}catch(t){try{return u.call(null,e)}catch(t){return u.call(this,e)}}}function a(){h&&f&&(h=!1,f.length?p=f.concat(p):v=-1,p.length&&l())}function l(){if(!h){var e=o(a);h=!0;for(var t=p.length;t;){for(f=p,p=[];++v<t;)f&&f[v].run();v=-1,t=p.length}f=null,h=!1,i(e)}}function s(e,t){this.fun=e,this.array=t}function _(){}var c,u,d=e.exports={};!function(){try{c="function"==typeof setTimeout?setTimeout:r}catch(e){c=r}try{u="function"==typeof clearTimeout?clearTimeout:n}catch(e){u=n}}();var f,p=[],h=!1,v=-1;d.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];p.push(new s(e,t)),1!==p.length||h||o(l)},s.prototype.run=function(){this.fun.apply(null,this.array)},d.title="browser",d.browser=!0,d.env={},d.argv=[],d.version="",d.versions={},d.on=_,d.addListener=_,d.once=_,d.off=_,d.removeListener=_,d.removeAllListeners=_,d.emit=_,d.prependListener=_,d.prependOnceListener=_,d.listeners=function(e){return[]},d.binding=function(e){throw new Error("process.binding is not supported")},d.cwd=function(){return"/"},d.chdir=function(e){throw new Error("process.chdir is not supported")},d.umask=function(){return 0}},function(e,t){var r={};r.create=function(e,t,r,o,i,a,l){for(var s={inc:1,name:e,exp:o,lp:i,scopes:{},targets:{},children:null,lu:l,__scopeBinded:[]},_=0;_<a.length;_++){var c=a[_];null===c[0]?n(t,c,null,s):n(r[c[0]],c,null,s)}return s},r.proxyTopScope=function(e){var t={inc:1,linked:e,scopes:{},targets:{},children:null,__scopeBinded:[]};return n(e,[null],null,t),t},r.proxySubScopes=function(e){var t={};for(var r in e)t[r]={inc:1,linked:e[r],scopes:{},targets:{},children:null,__scopeBinded:[]},n(e[r],[null],null,t[r]);return t};var n=r.addBinding=function(e,t,r,n){for(var o=e,i=1;i<t.length;i++){var a=t[i];o.children||(o.children=Object.create(null));var l=o.children;l[a]||(l[a]={scopes:{},targets:{},children:null}),o=l[a]}var s=e.inc++;return r?o.targets[s]=[r,n]:(o.scopes[s]=n,n.__scopeBinded.push([o,s])),s};r.addBindings=function(e,t,r,o,i){for(var a=0;a<r.length;a++){var l=r[a];l[0]?n(t[l[0]],l,o,i):n(e,l,o,i)}},r.updateLvaluePath=function(e,t){e.lp=t},r.removeBindingsForScope=function(e){for(var t=e.__scopeBinded,r=0;r<t.length;r++){var n=t[r];delete n[0].scopes[n[1]]}};var o=function(e,t,r,n,o){if(e.linked)return void i(e,t,r,n,o);var a=n[e.name];n[e.name]=e.exp(r,n,o),i(e,t,r,n,o),n[e.name]=a},i=r.updateBinding=function(e,t,r,n,i){for(var a=e,l=0,s=0;s<t.length;s++){for(l in a.scopes)o(a.scopes[l],t,r,n,i);var _=t[s];if(!a.children)return;var c=a.children;if(!c[_])return;a=c[_]}var u=function(e){for(l in e.targets){var t=e.targets[l],a=t[1];a.o(t[0],a.n,a.e(r,n,i))}for(l in e.scopes)o(e.scopes[l],[],r,n,i);for(l in e.children)u(e.children[l])};u(a)};e.exports=r},function(e,t,r){e.exports={if:r(25),elif:r(25),else:r(25),for:r(27),key:r(28),"for-index":r(29),"for-item":r(30),alias:r(31)}},function(e,t,r){var n=r(23),o=r(26).RUNTIME_NAMES;o.TOP_SCOPE+","+o.SUB_SCOPE+","+o.CALLER;e.exports={requireBlock:!0,register:function(e,t,r){},create:function(e,t,r,o,i,a,l,s,_,c,u){var d=_.createVirtualNode("wx:"+e);d.__wxIfCondValue=!0,d.__wxIfNextNode=null,d.__wxIfHasTrueCond=!0;var f=null;"if"!==e&&(f=u.childNodes[u.childNodes.length-1],"wx:if"!==f.is&&"wx:elif"!==f.is?f=null:f.__wxIfNextNode=d),r.id&&(d.id=r.id);var p=d.__wxIfUpdateNode=function(){var e=d.__wxIfCondValue;if(f&&f.__wxIfHasTrueCond&&(e=!1),e&&!d.childNodes.length){var t=n.proxyTopScope(a),u=n.proxySubScopes(l);d.__wxTopScope=t,d.__wxSubScopes=u,c(r.c,_,d,o,i,t,u,s)}else if(!e&&d.childNodes.length){n.removeBindingsForScope(d.__wxTopScope);for(var p in d.__wxSubScopes)n.removeBindingsForScope(d.__wxSubScopes[p]);for(;d.childNodes.length;)d.removeChild(d.childNodes[0])}d.__wxIfNextNode&&d.__wxIfNextNode.__wxIfUpdateNode()},h=function(e){d.__wxIfCondValue=!!e,d.__wxIfHasTrueCond=d.__wxIfCondValue||f&&f.__wxIfHasTrueCond,p()};return"else"===e?h(!0):(n.addBindings(a,l,t.b,d,{e:t.d,o:function(e,t,r){h(r)}}),h(t.d(o,i,null))),d}}},function(e,t){t.TAG_TYPES={TAG_START:1,TAG_END:-1,TEXT:3,COMMENT:8},t.RUNTIME_NAMES={MEMBER:"m",CALL:"f",METHODS:"e",CALLER:"c",TOP_SCOPE:"t",SUB_SCOPE:"s"};var r=t.STRING_UNESCAPE_MAP={n:"\n",r:"\r",b:"\b",f:"\f",t:"\t",v:"\v",'"':'"',"'":"'","\\":"\\","\r":"\r","\n":"\n"},n=t.STRING_ESCAPE_MAP={},o="";for(var i in r)n[r[i]]=i,o+=r[i];t.STRING_ESCAPE_REGEXP=new RegExp("["+o+"]","g")},function(e,t,r){var n=(r(18),r(23)),o=r(26).RUNTIME_NAMES;o.TOP_SCOPE+","+o.SUB_SCOPE+","+o.CALLER;e.exports={requireBlock:!0,addDefaultAttrs:[{n:"wx:for-index",v:"index"},{n:"wx:for-item",v:"item"}],register:function(e,t,r){},create:function(e,t,r,o,i,a,l,s,_,c){var u=r._wxForIndex||"index",d=r._wxForItem||"item",f=r._wxKey,p=_.createVirtualNode("wx:for:list");r.id&&(p.id=r.id),n.create("",a,l,function(e,r,n){var o=t.d(e,r,null);return g(o,e,r,n),o},t.l,t.b);var h=function(e,t,o,i,f){var h=_.createVirtualNode("wx:for:item"),v=n.proxyTopScope(a),m=n.proxySubScopes(l);h.__wxTopScope=v,h.__wxSubScopes=m,h.__wxForToRemove=!1,h.__wxForKeyStr="";var b=n.create(u,v,m,null,null,[]),g=n.create(d,v,m,null,[o],[]);return m[u]=b,m[d]=g,t[u]=o,t[d]=i,c(r.c,_,h,e,t,v,m,s),void 0===f?p.appendChild(h):p.insertBefore(h,f),h},v=function(e,t,r,i,a,l){var s=e.__wxSubScopes[d];n.updateLvaluePath(s,[i]),a&&(l?p.insertBefore(e,l):p.appendChild(e));var _=e.__wxSubScopes[u];r[u]=i,n.updateBinding(_,[],o,r,t)},m=function(e,t,r,o,i,a){o[d]=i,n.updateBinding(e.__wxSubScopes[d],t,r,o,a)},b=function(e){n.removeBindingsForScope(e.__wxTopScope);for(var t in p.__wxSubScopes)n.removeBindingsForScope(e.__wxSubScopes[t]);p.removeChild(e)},g=function(e,t,r,n){var o="",i=e;"object"==typeof e&&null!==e||(i=[]);var a={};for(o in r)a[o]=r[o];var l=0;if(f){var s=[],_=e instanceof Array,c=[];if(!_){var u=i;i=[];for(o in u)i.push(u[o]),c.push(o)}for(l=0;l<i.length;l++)s.push(String(i[l][f]));if(0===i.length)for(;p.childNodes.length;)b(p.childNodes[0]);else{var d=Object.create(null),g=Object.create(null),w=p.childNodes,y=null,x="";for(l=0;l<w.length;l++)y=w[l],x=y.__wxForKeyStr,d[x]>=0?(b(y),l--):(d[x]=l,g[x]=y,y.__wxForToRemove=!0);var C=-1,E=0,S=1,O=[];for(E=d[i[0][f]],E>=0||(E=-1),w[E]&&(w[E].__wxForToRemove=!1),l=1;l<i.length;l++)S=d[i[l][f]],S>=0&&(C<E&&(E<S||C>S)&&(O.push(w[E]),C=E),E=S,w[E]&&(w[E].__wxForToRemove=!1));for(C<E&&O.push(w[E]),l=0;l<w.length;l++)y=w[l],y.__wxForToRemove&&(b(y),l--);var N=O.shift(),k=0;for(l=0;l<i.length;l++){var T=i[l],A=g[T[f]];if(g[T[f]]=null,A){var P=!0;if(A===N){for(;w[k]!==N;)k++;k++,N=O.shift(),P=!1}y=A,v(y,n,a,_?l:c[l],P,w[k]),P&&w[k]===y&&k++,m(y,[],t,a,i[l],n)}else y=h(t,a,_?l:c[l],i[l],w[k]),k++,y.__wxForKeyStr=String(T[f])}}}else{for(;p.childNodes.length;)b(p.childNodes[0]);if(e instanceof Array)for(l=0;l<i.length;l++)h(t,a,l,i[l]);else for(o in i)h(t,a,o,i[o])}};return g(t.d(o,i,null),o,i,null),p}}},function(e,t){e.exports={attachedToBlock:!0,register:function(e,t,r){r._wxKey=t.d},create:function(){}}},function(e,t){e.exports={attachedToBlock:"for",register:function(e,t,r){r._wxForIndex=t.d},create:function(){}}},function(e,t){e.exports={attachedToBlock:"for",register:function(e,t,r){r._wxForItem=t.d},create:function(){}}},function(e,t,r){var n=r(23),o=r(26).RUNTIME_NAMES;o.TOP_SCOPE+","+o.SUB_SCOPE+","+o.CALLER;e.exports={requireBlock:!0,register:function(e,t,r){},create:function(e,t,r,o,i,a,l,s,_,c){var u=t.s[0],d=n.create(u,a,l,t.d,t.l,t.b),f={},p="";for(p in l)f[p]=l[p];f[u]=d;var h={};for(p in i)h[p]=i[p];h[u]=t.d(o,i,null);var v=_.createVirtualNode("wx:alias");return r.id&&(v.id=r.id),c(r.c,_,v,o,h,a,f,s),v}}}]);

/***/ }),
/* 5 */
/***/ (function(module, exports) {

/**
 * 获取随机 id，生成 15 位
 */
let seed = 1e14 + Math.floor(Math.random() * 9e14)
const charString = 'abcdefghij'
function getId(notNumber) {
  const id = ++seed
  return notNumber ? id.toString().split('').map(item => charString[+item]).join('') : id
}

/**
 * 复制对象
 */
function copy(src) {
  if (typeof src === 'object' && src !== null) {
    let dest

    if (Array.isArray(src)) {
      dest = src.map(item => copy(item))
    } else {
      dest = {}
      Object.keys(src).forEach(key => dest[key] = copy(src[key]))
    }

    return dest
  }

  if (typeof src === 'symbol') return undefined
  return src
}

/**
 * 判断是否是 html 标签
 */
const tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'dfn', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'pre', 'progress', 'q', 'rb', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr']
function isHtmlTag(tagName) {
  return tags.indexOf(tagName) >= 0
}

/**
 * 判断是否是小程序内置组件
 */
const officialTags = [
  'view', 'scroll-view', 'swiper', 'movable-view', 'cover-view', 'cover-view',
  'icon', 'text', 'rich-text', 'progress',
  'button', 'checkbox', 'form', 'input', 'label', 'picker', 'picker', 'picker-view', 'radio', 'slider', 'switch', 'textarea',
  'navigator', 'function-page-navigator',
  'audio', 'image', 'video', 'camera', 'live-player', 'live-pusher',
  'map',
  'canvas',
  'open-data', 'web-view', 'ad'
]
function isOfficialTag(tagName) {
  return officialTags.indexOf(tagName) >= 0 || officialTags.indexOf(`wx-${tagName}`) >= 0
}

/**
 * 转换 rpx 单位为 px 单位
 */
function transformRpx(style) {
  return style.replace(/(\d+)rpx/ig, '$1px')
}

/**
 * 转换连字符为驼峰
 */
function dashToCamelCase(dash) {
  return dash.replace(/-[a-z]/g, s => s[1].toUpperCase())
}

/**
 * 转换驼峰为连字符
 */
function camelToDashCase(camel) {
  return camel.replace(/([A-Z])/g, '-$1').toLowerCase()
}

/**
 * 转换动画对象为样式
 */
function animationToStyle({animates, option = {}}) {
  const {transformOrigin, transition} = option

  if (transition === undefined || animates === undefined) {
    return {
      transformOrigin: '',
      transform: '',
      transition: '',
    }
  }

  const addPx = value => (typeof value === 'number' ? value + 'px' : value)
  const transform = animates.filter(({type}) => type !== 'style').map(({type, args}) => {
    switch (type) {
      case 'matrix':
        return `matrix(${args.join(',')})`
      case 'matrix3d':
        return `matrix3d(${args.join(',')})`

      case 'rotate':
        return `rotate(${args[0]}deg)`
      case 'rotate3d':
        args[3] += 'deg'
        return `rotate3d(${args.join(',')})`
      case 'rotateX':
        return `rotateX(${args[0]}deg)`
      case 'rotateY':
        return `rotateY(${args[0]}deg)`
      case 'rotateZ':
        return `rotateZ(${args[0]}deg)`

      case 'scale':
        return `scale(${args.join(',')})`
      case 'scale3d':
        return `scale3d(${args.join(',')})`
      case 'scaleX':
        return `scaleX(${args[0]})`
      case 'scaleY':
        return `scaleY(${args[0]})`
      case 'scaleZ':
        return `scaleZ(${args[0]})`

      case 'translate':
        return `translate(${args.map(addPx).join(',')})`
      case 'translate3d':
        return `translate3d(${args.map(addPx).join(',')})`
      case 'translateX':
        return `translateX(${addPx(args[0])})`
      case 'translateY':
        return `translateY(${addPx(args[0])})`
      case 'translateZ':
        return `translateZ(${addPx(args[0])})`

      case 'skew':
        return `skew(${args.map(value => value + 'deg').join(',')})`
      case 'skewX':
        return `skewX(${args[0]}deg)`
      case 'skewY':
        return `skewY(${args[0]}deg)`
      default:
        return ''
    }
  }).join(' ')
  const style = animates.filter(({type}) => type === 'style').reduce((previous, current) => {
    previous[current.args[0]] = current.args[1]
    return previous
  }, {})

  return {
    style,
    transformOrigin,
    transform,
    transitionProperty: ['transform', ...Object.keys(style)].join(','),
    transition: `${transition.duration}ms ${transition.timingFunction} ${transition.delay}ms`,
  }
}

/**
 * 调整 exparser 的定义对象
 */
function adjustExparserDefinition(definition) {
  // 调整 properties
  const properties = definition.properties || {}
  Object.keys(properties).forEach(key => {
    const value = properties[key]
    if (value === null) {
      properties[key] = {type: null}
    } else if (value === Number || value === String || value === Boolean || value === Object || value === Array) {
      properties[key] = {type: value.name}
    } else if (value.public === undefined || value.public) {
      properties[key] = {
        type: value.type === null ? null : value.type.name,
        value: value.value,
        observer: value.observer,
      }
    }
  })

  return definition
}

/**
 * 存入标签名
 */
const idTagNameMap = {}
function setTagName(id, tagName) {
  idTagNameMap[id] = tagName
}

/**
 * 根据 id 获取标签名
 */
function getTagName(id) {
  return idTagNameMap[id]
}

/**
 * 缓存 componentManager 实例
 */
const CACHE = {}
function cache(id, instance) {
  if (instance) {
    // 存入缓存
    CACHE[id] = instance
  } else {
    // 取缓存
    return CACHE[id]
  }
}

/**
 * 解析事件语法
 */
function parseEvent(name, value) {
  const res = /^(capture-)?(mut-)?(bind|catch|)(?::)?(.*)$/ig.exec(name)

  if (res[3] && res[4]) {
    // 事件绑定
    const isCapture = !!res[1]
    const isMutated = !!res[2]
    const isCatch = res[3] === 'catch'
    const eventName = res[4]

    return {
      name: eventName,
      isMutated,
      isCapture,
      isCatch,
      handler: value,
    }
  }
}

/**
 * 标准化文件绝对路径
 */
function normalizeAbsolute(absolutePath) {
  if (!absolutePath) return null

  absolutePath = absolutePath.replace(/\\/g, '/')
  return absolutePath.split('/').filter(item => !!item).join('/')
}

/**
 * 文件相对路径转绝对路径，其中 basePath 路径必须是文件路径
 */
function relativeToAbsolute(basePath, relativePath) {
  let baseDirPath = normalizeAbsolute(basePath).split('/')
  baseDirPath.pop()
  baseDirPath = baseDirPath.join('/')

  const pathList = []
  normalizeAbsolute(`${baseDirPath}/${relativePath}`).split('/').forEach(item => {
    if (item === '..') {
      pathList.pop()
    } else if (item !== '.') {
      pathList.push(item)
    }
  })

  return pathList.join('/')
}

module.exports = {
  getId,
  copy,
  isHtmlTag,
  isOfficialTag,
  transformRpx,
  dashToCamelCase,
  camelToDashCase,
  animationToStyle,
  adjustExparserDefinition,
  setTagName,
  getTagName,
  cache,
  parseEvent,
  normalizeAbsolute,
  relativeToAbsolute,
}


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = {
  // 节点类型
  TYPE_ROOT: 10,
  TYPE_SLOT: 11,
  TYPE_TEMPLATE: 12,
  TYPE_BLOCK: 13,
  TYPE_IMPORT: 14,
  TYPE_INCLUDE: 15,
  TYPE_WXS: 16,
  TYPE_COMPONENT: 17,
  TYPE_TEXT: 18,
  TYPE_IF: 19,
  TYPE_FOR: 20,
  TYPE_FORITEM: 21,
  TYPE_NATIVE: 22,
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//
//            item        item        item        item
//          /------\    /------\    /------\    /------\
//          | data |    | data |    | data |    | data |
//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
//          | next-+--->| next-+--->| next-+--->| next-+--> null
//          \------/    \------/    \------/    \------/
//             ^                                    ^
//             |                list                |
//             |              /------\              |
//             \--------------+-head |              |
//                            | tail-+--------------/
//                            \------/
//

function createItem(data) {
    return {
        prev: null,
        next: null,
        data: data
    };
}

function allocateCursor(node, prev, next) {
    var cursor;

    if (cursors !== null) {
        cursor = cursors;
        cursors = cursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = node.cursor;
    } else {
        cursor = {
            prev: prev,
            next: next,
            cursor: node.cursor
        };
    }

    node.cursor = cursor;

    return cursor;
}

function releaseCursor(node) {
    var cursor = node.cursor;

    node.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = cursors;
    cursors = cursor;
}

var cursors = null;
var List = function() {
    this.cursor = null;
    this.head = null;
    this.tail = null;
};

List.createItem = createItem;
List.prototype.createItem = createItem;

List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
    var cursor = this.cursor;

    while (cursor !== null) {
        if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
        }

        if (cursor.next === nextOld) {
            cursor.next = nextNew;
        }

        cursor = cursor.cursor;
    }
};

List.prototype.getSize = function() {
    var size = 0;
    var cursor = this.head;

    while (cursor) {
        size++;
        cursor = cursor.next;
    }

    return size;
};

List.prototype.fromArray = function(array) {
    var cursor = null;

    this.head = null;

    for (var i = 0; i < array.length; i++) {
        var item = createItem(array[i]);

        if (cursor !== null) {
            cursor.next = item;
        } else {
            this.head = item;
        }

        item.prev = cursor;
        cursor = item;
    }

    this.tail = cursor;

    return this;
};

List.prototype.toArray = function() {
    var cursor = this.head;
    var result = [];

    while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
    }

    return result;
};

List.prototype.toJSON = List.prototype.toArray;

List.prototype.isEmpty = function() {
    return this.head === null;
};

List.prototype.first = function() {
    return this.head && this.head.data;
};

List.prototype.last = function() {
    return this.tail && this.tail.data;
};

List.prototype.each = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.forEach = List.prototype.each;

List.prototype.eachRight = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.forEachRight = List.prototype.eachRight;

List.prototype.nextUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, start);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.prevUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, start, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.some = function(fn, context) {
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            return true;
        }

        cursor = cursor.next;
    }

    return false;
};

List.prototype.map = function(fn, context) {
    var result = new List();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        result.appendData(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
    }

    return result;
};

List.prototype.filter = function(fn, context) {
    var result = new List();
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
        }
        cursor = cursor.next;
    }

    return result;
};

List.prototype.clear = function() {
    this.head = null;
    this.tail = null;
};

List.prototype.copy = function() {
    var result = new List();
    var cursor = this.head;

    while (cursor !== null) {
        result.insert(createItem(cursor.data));
        cursor = cursor.next;
    }

    return result;
};

List.prototype.prepend = function(item) {
    //      head
    //    ^
    // item
    this.updateCursors(null, item, this.head, item);

    // insert to the beginning of the list
    if (this.head !== null) {
        // new item <- first item
        this.head.prev = item;

        // new item -> first item
        item.next = this.head;
    } else {
        // if list has no head, then it also has no tail
        // in this case tail points to the new item
        this.tail = item;
    }

    // head always points to new item
    this.head = item;

    return this;
};

List.prototype.prependData = function(data) {
    return this.prepend(createItem(data));
};

List.prototype.append = function(item) {
    return this.insert(item);
};

List.prototype.appendData = function(data) {
    return this.insert(createItem(data));
};

List.prototype.insert = function(item, before) {
    if (before !== undefined && before !== null) {
        // prev   before
        //      ^
        //     item
        this.updateCursors(before.prev, item, before, item);

        if (before.prev === null) {
            // insert to the beginning of list
            if (this.head !== before) {
                throw new Error('before doesn\'t belong to list');
            }

            // since head points to before therefore list doesn't empty
            // no need to check tail
            this.head = item;
            before.prev = item;
            item.next = before;

            this.updateCursors(null, item);
        } else {

            // insert between two items
            before.prev.next = item;
            item.prev = before.prev;

            before.prev = item;
            item.next = before;
        }
    } else {
        // tail
        //      ^
        //      item
        this.updateCursors(this.tail, item, null, item);

        // insert to the ending of the list
        if (this.tail !== null) {
            // last item -> new item
            this.tail.next = item;

            // last item <- new item
            item.prev = this.tail;
        } else {
            // if list has no tail, then it also has no head
            // in this case head points to new item
            this.head = item;
        }

        // tail always points to new item
        this.tail = item;
    }

    return this;
};

List.prototype.insertData = function(data, before) {
    return this.insert(createItem(data), before);
};

List.prototype.remove = function(item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
        item.prev.next = item.next;
    } else {
        if (this.head !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.head = item.next;
    }

    if (item.next !== null) {
        item.next.prev = item.prev;
    } else {
        if (this.tail !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
};

List.prototype.push = function(data) {
    this.insert(createItem(data));
};

List.prototype.pop = function() {
    if (this.tail !== null) {
        return this.remove(this.tail);
    }
};

List.prototype.unshift = function(data) {
    this.prepend(createItem(data));
};

List.prototype.shift = function() {
    if (this.head !== null) {
        return this.remove(this.head);
    }
};

List.prototype.prependList = function(list) {
    return this.insertList(list, this.head);
};

List.prototype.appendList = function(list) {
    return this.insertList(list);
};

List.prototype.insertList = function(list, before) {
    // ignore empty lists
    if (list.head === null) {
        return this;
    }

    if (before !== undefined && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head);

        // insert in the middle of dist list
        if (before.prev !== null) {
            // before.prev <-> list.head
            before.prev.next = list.head;
            list.head.prev = before.prev;
        } else {
            this.head = list.head;
        }

        before.prev = list.tail;
        list.tail.next = before;
    } else {
        this.updateCursors(this.tail, list.tail, null, list.head);

        // insert to end of the list
        if (this.tail !== null) {
            // if destination list has a tail, then it also has a head,
            // but head doesn't change

            // dest tail -> source head
            this.tail.next = list.head;

            // dest tail <- source head
            list.head.prev = this.tail;
        } else {
            // if list has no a tail, then it also has no a head
            // in this case points head to new item
            this.head = list.head;
        }

        // tail always start point to new item
        this.tail = list.tail;
    }

    list.head = null;
    list.tail = null;

    return this;
};

List.prototype.replace = function(oldItem, newItemOrList) {
    if ('head' in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
    } else {
        this.insert(newItemOrList, oldItem);
    }

    this.remove(oldItem);
};

module.exports = List;


/***/ }),
/* 8 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const path = __webpack_require__(3)

const compilerName = 'miniprogram-compiler' // 为了在 webpack 构建打包时不被分析出此依赖
let env = 'nodejs'
let fs = null
let compiler = null
let runJs = null // 执行 js

/**
 * 获取当前环境
 */
function getEnv() {
    return env
}

/**
 * 设置 nodejs 环境
 */
function setNodeJsEnv() {
    env = 'nodejs'
    fs = __webpack_require__(71)
    // eslint-disable-next-line import/no-dynamic-require
    compiler = __webpack_require__(14)(compilerName)
    runJs = filePath => {
        // eslint-disable-next-line import/no-dynamic-require
        __webpack_require__(14)(filePath)
        delete __webpack_require__.c[/*require.resolve*/(__webpack_require__(14).resolve(filePath))]
    }
}

/**
 * 设置浏览器环境
 */
function setBrowserEnv() {
    env = 'browser'
    fs = {
        readFileSync(filePath) {
            const fileMap = window.__FILE_MAP__ || {}
            if (fileMap[filePath]) {
                return fileMap[filePath]
            } else if (filePath[0] === '/') {
                // path.resolve 可能会加上 /，在 windows 下会有问题
                return fileMap[filePath.substr(1)] || null
            }

            return null
        }
    }
    window.require = runJs = filePath => {
        const content = fs.readFileSync(filePath + '.js')
        if (content) {
            // eslint-disable-next-line no-new-func
            const func = new Function('require', 'module', content)
            const mod = {exports: {}} // modules

            func.call(null, relativePath => {
                const realPath = path.join(path.dirname(filePath), relativePath)
                return window.require(realPath)
            }, mod)

            return mod.exports
        }

        return null
    }
}

try {
    if (typeof global === 'object' && typeof process === 'object') {
        // nodejs
        setNodeJsEnv()
    } else {
        // 浏览器
        setBrowserEnv()
    }
} catch (err) {
    // 浏览器
    setBrowserEnv()
}

/**
 * 读取文件
 */
function readFile(filePath) {
    try {
        return fs.readFileSync(filePath, 'utf8')
    } catch (err) {
        return null
    }
}

/**
 * 读取 json
 */
function readJson(filePath) {
    try {
        const content = readFile(filePath)
        return JSON.parse(content)
    } catch (err) {
        return null
    }
}

/**
 * 转换 rpx 单位为 px 单位
 */
function transformRpx(style) {
    return style.replace(/(\d+)rpx/ig, '$1px')
}

/**
 * 获取 wxml、wxss 编译器
 */
function getCompiler() {
    return compiler
}

/**
 * 获取随机 id
 */
let seed = +new Date()
const charString = 'abcdefghij'
function getId() {
    const id = ++seed
    return id.toString().split('').map(item => charString[+item]).join('')
}

/**
 * 判断是否是绝对路径
 */
function isAbsolute(input) {
    if (typeof input !== 'string') return false
    if (!input.length) return false

    return /^(\/|\\|([a-zA-Z]:[/\\]))/.test(input)
}

module.exports = {
    getEnv,
    setNodeJsEnv,
    setBrowserEnv,
    runJs,
    readFile,
    readJson,
    transformRpx,
    getCompiler,
    getId,
    isAbsolute,
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 11 */
/***/ (function(module, exports) {

var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
var unsafeToRemovePlusSignAfter = {
    Dimension: true,
    HexColor: true,
    Identifier: true,
    Number: true,
    Raw: true,
    UnicodeRange: true
};

function packNumber(value, item) {
    // omit plus sign only if no prev or prev is safe type
    var regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.hasOwnProperty(item.prev.data.type)
        ? KEEP_PLUSSIGN
        : OMIT_PLUSSIGN;

    // 100 -> '100'
    // 00100 -> '100'
    // +100 -> '100' (only when safe, e.g. omitting plus sign for 1px+1px leads to single dimension instead of two)
    // -100 -> '-100'
    // 0.123 -> '.123'
    // 0.12300 -> '.123'
    // 0.0 -> ''
    // 0 -> ''
    // -0 -> '-'
    value = String(value).replace(regexp, '$1$2$3');

    if (value === '' || value === '-') {
        value = '0';
    }

    return value;
}

module.exports = function(node, item) {
    node.value = packNumber(node.value, item);
};
module.exports.pack = packNumber;


/***/ }),
/* 12 */
/***/ (function(module, exports) {

/**
 * 异步方法通用部分
 */
function runInAsync(options, res) {
    setTimeout(() => {
        if (res.errMsg.indexOf(':ok') >= 0 && typeof options.success === 'function') options.success(res)
        if (res.errMsg.indexOf(':fail') >= 0 && typeof options.fail === 'function') options.fail(res)
        if (typeof options.complete === 'function') options.complete(res)
    }, 0)
}

/**
 * 计算字符串字节数
 */
function getSize(string) {
    let total = 0
    for (let i = 0, len = string.length; i < len; i++) {
        const charCode = string.charCodeAt(i)
        if (charCode <= 0x007f) {
            total += 1
        } else if (charCode <= 0x07ff) {
            total += 2
        } else if (charCode <= 0xffff) {
            total += 3
        } else {
            total += 4
        }
    }

    return total
}

/**
 * 快速模拟同步接口
 */
function mockSync(ret) {
    return () => ret
}

/**
 * 快速模拟异步接口
 */
function mockAsync(name) {
    return (options = {}) => {
        const res = {
            errMsg: `${name}:ok`,
        }
        runInAsync(options, res)
    }
}

module.exports = {
    runInAsync,
    getSize,
    mockSync,
    mockAsync,
}


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

const exparser = __webpack_require__(4)
const CONSTANT = __webpack_require__(6)
const _ = __webpack_require__(5)

const transitionKeys = ['transition', 'transitionProperty', 'transform', 'transformOrigin', 'webkitTransition', 'webkitTransitionProperty', 'webkitTransform', 'webkitTransformOrigin']

/**
 * 更新 exparser 节点的属性
 */
function updateAttrs(exparserNode, attrs) {
  const isComponentNode = exparserNode instanceof exparser.Component
  const dataProxy = exparser.Component.getDataProxy(exparserNode)
  let needDoUpdate = false

  exparserNode.dataset = exparserNode.dataset || {}

  for (const {name, value} of attrs) {
    if (name === 'id' || name === 'slot' || (isComponentNode && name === 'class')) {
      // 普通属性
      exparserNode[name] = value || ''
    } else if (isComponentNode && name === 'style' && exparserNode.$$) {
      // style
      let animationStyle = exparserNode.__animationStyle || {}

      animationStyle = transitionKeys.map(key => {
        const styleValue = animationStyle[key.replace('webkitT', 't')]

        return styleValue !== undefined ? `${_.camelToDashCase(key)}:${styleValue}` : ''
      }).filter(item => !!item.trim()).join(';')

      exparserNode.setNodeStyle(_.transformRpx(value || '', true) + animationStyle)
    } else if (isComponentNode && exparser.Component.hasPublicProperty(exparserNode, _.dashToCamelCase(name))) {
      // public 属性，延迟处理
      dataProxy.scheduleReplace([_.dashToCamelCase(name)], value)
      needDoUpdate = true
    } else if (/^data-/.test(name)) {
      // dataset
      exparserNode.dataset[_.dashToCamelCase(name.slice(5).toLowerCase())] = value
      exparserNode.setAttribute(name, value)
    } else if (isComponentNode && name === 'animation') {
      // 动画
      if (exparserNode.$$ && value && value.actions && value.actions.length > 0) {
        let index = 0
        const actions = value.actions
        const length = actions.length
        const step = function () {
          if (index < length) {
            const styleObject = _.animationToStyle(actions[index])
            const extraStyle = styleObject.style

            transitionKeys.forEach(key => {
              exparserNode.$$.style[key] = styleObject[key.replace('webkitT', 't')]
            })

            Object.keys(extraStyle).forEach(key => {
              exparserNode.$$.style[key] = _.transformRpx(extraStyle[key])
            })

            exparserNode.__animationStyle = styleObject
          }
        }

        exparserNode.addListener('transitionend', () => {
          index += 1
          step()
        })
        step()
      }
    } else if (isComponentNode && exparserNode.hasExternalClass(_.camelToDashCase(name))) {
      // 外部样式类
      exparserNode.setExternalClass(_.camelToDashCase(name), value)
    }
  }

  if (needDoUpdate) dataProxy.doUpdates(true)
}

/**
 * 更新 exparser 节点的事件监听
 */
function updateEvent(exparserNode, event) {
  const convertEventTarget = (target, currentTarget) => {
    if (currentTarget && (target instanceof exparser.VirtualNode) && !target.id && !Object.keys(target.dataset).length) {
      // 如果 target 是 slot 且 slot 未设置 id 和 dataset，则兼容以前的逻辑：target === currentTarget
      target = currentTarget
    }

    return {
      id: target.id,
      offsetLeft: target.$$ && target.$$.offsetLeft || 0,
      offsetTop: target.$$ && target.$$.offsetTop || 0,
      dataset: target.dataset,
    }
  }

  Object.keys(event).forEach(key => {
    const {
      name, isCapture, isMutated, isCatch, handler
    } = event[key]

    if (!handler) return

    event[key].id = exparser.addListenerToElement(exparserNode, name, function (evt) {
      const shadowRoot = exparserNode.ownerShadowRoot

      const mutatedMarked = evt.mutatedMarked()
      if (isMutated && evt.mutatedMarked()) return // 已经被标记为互斥的事件，不再触发 mut- 绑定的事件回调
      if (isMutated) evt.markMutated()

      if (shadowRoot) {
        const host = shadowRoot.getHostNode()
        const writeOnly = exparser.Component.getComponentOptions(host).writeOnly

        if (!writeOnly) {
          const caller = exparser.Element.getMethodCaller(host)

          if (typeof caller[handler] === 'function') {
            caller[handler]({
              type: evt.type,
              timeStamp: evt.timeStamp,
              target: convertEventTarget(evt.target, this),
              currentTarget: convertEventTarget(this, null),
              detail: evt.detail,
              touches: evt.touches,
              changedTouches: evt.changedTouches,
              mut: mutatedMarked,
            })
          }
        }
      }

      if (isCatch) return false
    }, {capture: isCapture})
  })
}

/**
 * 渲染成 exparser 节点
 */
function renderExparserNode(options, shadowRootHost, shadowRoot) {
  const type = options.type
  const tagName = options.tagName
  const componentId = options.componentId
  let exparserNode

  if (type === CONSTANT.TYPE_TEXT) {
    exparserNode = shadowRoot.createTextNode(options.content) // save exparser node
  } else {
    if (type === CONSTANT.TYPE_ROOT) {
      shadowRoot = exparser.ShadowRoot.create(shadowRootHost)
      exparserNode = shadowRoot
    } else if (type === CONSTANT.TYPE_SLOT) {
      exparserNode = shadowRoot.createVirtualNode(tagName)
      exparser.Element.setSlotName(exparserNode, options.slotName)
    } else if (type === CONSTANT.TYPE_TEMPLATE || type === CONSTANT.TYPE_IF || type === CONSTANT.TYPE_FOR || type === CONSTANT.TYPE_FORITEM) {
      exparserNode = shadowRoot.createVirtualNode(tagName)
      exparser.Element.setInheritSlots(exparserNode)
    } else {
      const componentTagName = _.getTagName(componentId || tagName) || tagName
      const componentName = componentId || tagName
      exparserNode = shadowRoot.createComponent(componentTagName, componentName, options.generics)
    }

    updateAttrs(exparserNode, options.attrs)
    updateEvent(exparserNode, options.event)

    // children
    options.children.forEach(vt => {
      const childExparserNode = renderExparserNode(vt, null, shadowRoot)
      exparserNode.appendChild(childExparserNode)
    })
  }

  options.exparserNode = exparserNode // 保存 exparser node
  exparserNode._vt = options

  return exparserNode
}

module.exports = {
  updateAttrs,
  updateEvent,
  renderExparserNode,
}


/***/ }),
/* 14 */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 14;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(__webpack_require__(16));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Represents a CSS declaration.
 *
 * @extends Node
 *
 * @example
 * const root = postcss.parse('a { color: black }')
 * const decl = root.first.first
 * decl.type       //=> 'decl'
 * decl.toString() //=> ' color: black'
 */
var Declaration =
/*#__PURE__*/
function (_Node) {
  _inheritsLoose(Declaration, _Node);

  function Declaration(defaults) {
    var _this;

    _this = _Node.call(this, defaults) || this;
    _this.type = 'decl';
    return _this;
  }
  /**
   * @memberof Declaration#
   * @member {string} prop The declaration’s property name.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   * decl.prop //=> 'color'
   */

  /**
   * @memberof Declaration#
   * @member {string} value The declaration’s value.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   * decl.value //=> 'black'
   */

  /**
   * @memberof Declaration#
   * @member {boolean} important `true` if the declaration
   *                             has an !important annotation.
   *
   * @example
   * const root = postcss.parse('a { color: black !important; color: red }')
   * root.first.first.important //=> true
   * root.first.last.important  //=> undefined
   */

  /**
   * @memberof Declaration#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `between`: the symbols between the property and value
   *   for declarations.
   * * `important`: the content of the important statement,
   *   if it is not just `!important`.
   *
   * PostCSS cleans declaration from comments and extra spaces,
   * but it stores origin content in raws properties.
   * As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('a {\n  color:black\n}')
   * root.first.first.raws //=> { before: '\n  ', between: ':' }
   */


  return Declaration;
}(_node.default);

var _default = Declaration;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlY2xhcmF0aW9uLmVzNiJdLCJuYW1lcyI6WyJEZWNsYXJhdGlvbiIsImRlZmF1bHRzIiwidHlwZSIsIk5vZGUiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7OztBQUVBOzs7Ozs7Ozs7OztJQVdNQSxXOzs7OztBQUNKLHVCQUFhQyxRQUFiLEVBQXVCO0FBQUE7O0FBQ3JCLDZCQUFNQSxRQUFOO0FBQ0EsVUFBS0MsSUFBTCxHQUFZLE1BQVo7QUFGcUI7QUFHdEI7QUFFRDs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXJDd0JDLGE7O2VBK0RYSCxXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE5vZGUgZnJvbSAnLi9ub2RlJ1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBDU1MgZGVjbGFyYXRpb24uXG4gKlxuICogQGV4dGVuZHMgTm9kZVxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSB7IGNvbG9yOiBibGFjayB9JylcbiAqIGNvbnN0IGRlY2wgPSByb290LmZpcnN0LmZpcnN0XG4gKiBkZWNsLnR5cGUgICAgICAgLy89PiAnZGVjbCdcbiAqIGRlY2wudG9TdHJpbmcoKSAvLz0+ICcgY29sb3I6IGJsYWNrJ1xuICovXG5jbGFzcyBEZWNsYXJhdGlvbiBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvciAoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cylcbiAgICB0aGlzLnR5cGUgPSAnZGVjbCdcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgRGVjbGFyYXRpb24jXG4gICAqIEBtZW1iZXIge3N0cmluZ30gcHJvcCBUaGUgZGVjbGFyYXRpb27igJlzIHByb3BlcnR5IG5hbWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdhIHsgY29sb3I6IGJsYWNrIH0nKVxuICAgKiBjb25zdCBkZWNsID0gcm9vdC5maXJzdC5maXJzdFxuICAgKiBkZWNsLnByb3AgLy89PiAnY29sb3InXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgRGVjbGFyYXRpb24jXG4gICAqIEBtZW1iZXIge3N0cmluZ30gdmFsdWUgVGhlIGRlY2xhcmF0aW9u4oCZcyB2YWx1ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2EgeyBjb2xvcjogYmxhY2sgfScpXG4gICAqIGNvbnN0IGRlY2wgPSByb290LmZpcnN0LmZpcnN0XG4gICAqIGRlY2wudmFsdWUgLy89PiAnYmxhY2snXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgRGVjbGFyYXRpb24jXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59IGltcG9ydGFudCBgdHJ1ZWAgaWYgdGhlIGRlY2xhcmF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYW4gIWltcG9ydGFudCBhbm5vdGF0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSB7IGNvbG9yOiBibGFjayAhaW1wb3J0YW50OyBjb2xvcjogcmVkIH0nKVxuICAgKiByb290LmZpcnN0LmZpcnN0LmltcG9ydGFudCAvLz0+IHRydWVcbiAgICogcm9vdC5maXJzdC5sYXN0LmltcG9ydGFudCAgLy89PiB1bmRlZmluZWRcbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBEZWNsYXJhdGlvbiNcbiAgICogQG1lbWJlciB7b2JqZWN0fSByYXdzIEluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGJ5dGUtdG8tYnl0ZSBlcXVhbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgbm9kZSBzdHJpbmcgYXMgaXQgd2FzIGluIHRoZSBvcmlnaW4gaW5wdXQuXG4gICAqXG4gICAqIEV2ZXJ5IHBhcnNlciBzYXZlcyBpdHMgb3duIHByb3BlcnRpZXMsXG4gICAqIGJ1dCB0aGUgZGVmYXVsdCBDU1MgcGFyc2VyIHVzZXM6XG4gICAqXG4gICAqICogYGJlZm9yZWA6IHRoZSBzcGFjZSBzeW1ib2xzIGJlZm9yZSB0aGUgbm9kZS4gSXQgYWxzbyBzdG9yZXMgYCpgXG4gICAqICAgYW5kIGBfYCBzeW1ib2xzIGJlZm9yZSB0aGUgZGVjbGFyYXRpb24gKElFIGhhY2spLlxuICAgKiAqIGBiZXR3ZWVuYDogdGhlIHN5bWJvbHMgYmV0d2VlbiB0aGUgcHJvcGVydHkgYW5kIHZhbHVlXG4gICAqICAgZm9yIGRlY2xhcmF0aW9ucy5cbiAgICogKiBgaW1wb3J0YW50YDogdGhlIGNvbnRlbnQgb2YgdGhlIGltcG9ydGFudCBzdGF0ZW1lbnQsXG4gICAqICAgaWYgaXQgaXMgbm90IGp1c3QgYCFpbXBvcnRhbnRgLlxuICAgKlxuICAgKiBQb3N0Q1NTIGNsZWFucyBkZWNsYXJhdGlvbiBmcm9tIGNvbW1lbnRzIGFuZCBleHRyYSBzcGFjZXMsXG4gICAqIGJ1dCBpdCBzdG9yZXMgb3JpZ2luIGNvbnRlbnQgaW4gcmF3cyBwcm9wZXJ0aWVzLlxuICAgKiBBcyBzdWNoLCBpZiB5b3UgZG9u4oCZdCBjaGFuZ2UgYSBkZWNsYXJhdGlvbuKAmXMgdmFsdWUsXG4gICAqIFBvc3RDU1Mgd2lsbCB1c2UgdGhlIHJhdyB2YWx1ZSB3aXRoIGNvbW1lbnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSB7XFxuICBjb2xvcjpibGFja1xcbn0nKVxuICAgKiByb290LmZpcnN0LmZpcnN0LnJhd3MgLy89PiB7IGJlZm9yZTogJ1xcbiAgJywgYmV0d2VlbjogJzonIH1cbiAgICovXG59XG5cbmV4cG9ydCBkZWZhdWx0IERlY2xhcmF0aW9uXG4iXSwiZmlsZSI6ImRlY2xhcmF0aW9uLmpzIn0=


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _cssSyntaxError = _interopRequireDefault(__webpack_require__(35));

var _stringifier = _interopRequireDefault(__webpack_require__(36));

var _stringify = _interopRequireDefault(__webpack_require__(17));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneNode(obj, parent) {
  var cloned = new obj.constructor();

  for (var i in obj) {
    if (!obj.hasOwnProperty(i)) continue;
    var value = obj[i];
    var type = typeof value;

    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent;
    } else if (i === 'source') {
      cloned[i] = value;
    } else if (value instanceof Array) {
      cloned[i] = value.map(function (j) {
        return cloneNode(j, cloned);
      });
    } else {
      if (type === 'object' && value !== null) value = cloneNode(value);
      cloned[i] = value;
    }
  }

  return cloned;
}
/**
 * All node classes inherit the following common methods.
 *
 * @abstract
 */


var Node =
/*#__PURE__*/
function () {
  /**
   * @param {object} [defaults] Value for node properties.
   */
  function Node(defaults) {
    if (defaults === void 0) {
      defaults = {};
    }

    this.raws = {};

    if (false) {}

    for (var name in defaults) {
      this[name] = defaults[name];
    }
  }
  /**
   * Returns a `CssSyntaxError` instance containing the original position
   * of the node in the source, showing line and column numbers and also
   * a small excerpt to facilitate debugging.
   *
   * If present, an input source map will be used to get the original position
   * of the source, even from a previous compilation step
   * (e.g., from Sass compilation).
   *
   * This method produces very useful error messages.
   *
   * @param {string} message     Error description.
   * @param {object} [opts]      Options.
   * @param {string} opts.plugin Plugin name that created this error.
   *                             PostCSS will set it automatically.
   * @param {string} opts.word   A word inside a node’s string that should
   *                             be highlighted as the source of the error.
   * @param {number} opts.index  An index inside a node’s string that should
   *                             be highlighted as the source of the error.
   *
   * @return {CssSyntaxError} Error object to throw it.
   *
   * @example
   * if (!variables[name]) {
   *   throw decl.error('Unknown variable ' + name, { word: name })
   *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
   *   //   color: $black
   *   // a
   *   //          ^
   *   //   background: white
   * }
   */


  var _proto = Node.prototype;

  _proto.error = function error(message, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (this.source) {
      var pos = this.positionBy(opts);
      return this.source.input.error(message, pos.line, pos.column, opts);
    }

    return new _cssSyntaxError.default(message);
  }
  /**
   * This method is provided as a convenience wrapper for {@link Result#warn}.
   *
   * @param {Result} result      The {@link Result} instance
   *                             that will receive the warning.
   * @param {string} text        Warning message.
   * @param {object} [opts]      Options
   * @param {string} opts.plugin Plugin name that created this warning.
   *                             PostCSS will set it automatically.
   * @param {string} opts.word   A word inside a node’s string that should
   *                             be highlighted as the source of the warning.
   * @param {number} opts.index  An index inside a node’s string that should
   *                             be highlighted as the source of the warning.
   *
   * @return {Warning} Created warning object.
   *
   * @example
   * const plugin = postcss.plugin('postcss-deprecated', () => {
   *   return (root, result) => {
   *     root.walkDecls('bad', decl => {
   *       decl.warn(result, 'Deprecated property bad')
   *     })
   *   }
   * })
   */
  ;

  _proto.warn = function warn(result, text, opts) {
    var data = {
      node: this
    };

    for (var i in opts) {
      data[i] = opts[i];
    }

    return result.warn(text, data);
  }
  /**
   * Removes the node from its parent and cleans the parent properties
   * from the node and its children.
   *
   * @example
   * if (decl.prop.match(/^-webkit-/)) {
   *   decl.remove()
   * }
   *
   * @return {Node} Node to make calls chain.
   */
  ;

  _proto.remove = function remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }

    this.parent = undefined;
    return this;
  }
  /**
   * Returns a CSS string representing the node.
   *
   * @param {stringifier|syntax} [stringifier] A syntax to use
   *                                           in string generation.
   *
   * @return {string} CSS string of this node.
   *
   * @example
   * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
   */
  ;

  _proto.toString = function toString(stringifier) {
    if (stringifier === void 0) {
      stringifier = _stringify.default;
    }

    if (stringifier.stringify) stringifier = stringifier.stringify;
    var result = '';
    stringifier(this, function (i) {
      result += i;
    });
    return result;
  }
  /**
   * Returns an exact clone of the node.
   *
   * The resulting cloned node and its (cloned) children will retain
   * code style properties.
   *
   * @param {object} [overrides] New properties to override in the clone.
   *
   * @example
   * decl.raws.before    //=> "\n  "
   * const cloned = decl.clone({ prop: '-moz-' + decl.prop })
   * cloned.raws.before  //=> "\n  "
   * cloned.toString()   //=> -moz-transform: scale(0)
   *
   * @return {Node} Clone of the node.
   */
  ;

  _proto.clone = function clone(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = cloneNode(this);

    for (var name in overrides) {
      cloned[name] = overrides[name];
    }

    return cloned;
  }
  /**
   * Shortcut to clone the node and insert the resulting cloned node
   * before the current node.
   *
   * @param {object} [overrides] Mew properties to override in the clone.
   *
   * @example
   * decl.cloneBefore({ prop: '-moz-' + decl.prop })
   *
   * @return {Node} New node
   */
  ;

  _proto.cloneBefore = function cloneBefore(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  /**
   * Shortcut to clone the node and insert the resulting cloned node
   * after the current node.
   *
   * @param {object} [overrides] New properties to override in the clone.
   *
   * @return {Node} New node.
   */
  ;

  _proto.cloneAfter = function cloneAfter(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  /**
   * Inserts node(s) before the current node and removes the current node.
   *
   * @param {...Node} nodes Mode(s) to replace current one.
   *
   * @example
   * if (atrule.name === 'mixin') {
   *   atrule.replaceWith(mixinRules[atrule.params])
   * }
   *
   * @return {Node} Current node to methods chain.
   */
  ;

  _proto.replaceWith = function replaceWith() {
    if (this.parent) {
      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
        nodes[_key] = arguments[_key];
      }

      for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {
        var node = _nodes[_i];
        this.parent.insertBefore(this, node);
      }

      this.remove();
    }

    return this;
  }
  /**
   * Returns the next child of the node’s parent.
   * Returns `undefined` if the current node is the last child.
   *
   * @return {Node|undefined} Next node.
   *
   * @example
   * if (comment.text === 'delete next') {
   *   const next = comment.next()
   *   if (next) {
   *     next.remove()
   *   }
   * }
   */
  ;

  _proto.next = function next() {
    if (!this.parent) return undefined;
    var index = this.parent.index(this);
    return this.parent.nodes[index + 1];
  }
  /**
   * Returns the previous child of the node’s parent.
   * Returns `undefined` if the current node is the first child.
   *
   * @return {Node|undefined} Previous node.
   *
   * @example
   * const annotation = decl.prev()
   * if (annotation.type === 'comment') {
   *   readAnnotation(annotation.text)
   * }
   */
  ;

  _proto.prev = function prev() {
    if (!this.parent) return undefined;
    var index = this.parent.index(this);
    return this.parent.nodes[index - 1];
  }
  /**
   * Insert new node before current node to current node’s parent.
   *
   * Just alias for `node.parent.insertBefore(node, add)`.
   *
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * decl.before('content: ""')
   */
  ;

  _proto.before = function before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  /**
   * Insert new node after current node to current node’s parent.
   *
   * Just alias for `node.parent.insertAfter(node, add)`.
   *
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * decl.after('color: black')
   */
  ;

  _proto.after = function after(add) {
    this.parent.insertAfter(this, add);
    return this;
  };

  _proto.toJSON = function toJSON() {
    var fixed = {};

    for (var name in this) {
      if (!this.hasOwnProperty(name)) continue;
      if (name === 'parent') continue;
      var value = this[name];

      if (value instanceof Array) {
        fixed[name] = value.map(function (i) {
          if (typeof i === 'object' && i.toJSON) {
            return i.toJSON();
          } else {
            return i;
          }
        });
      } else if (typeof value === 'object' && value.toJSON) {
        fixed[name] = value.toJSON();
      } else {
        fixed[name] = value;
      }
    }

    return fixed;
  }
  /**
   * Returns a {@link Node#raws} value. If the node is missing
   * the code style property (because the node was manually built or cloned),
   * PostCSS will try to autodetect the code style property by looking
   * at other nodes in the tree.
   *
   * @param {string} prop          Name of code style property.
   * @param {string} [defaultType] Name of default value, it can be missed
   *                               if the value is the same as prop.
   *
   * @example
   * const root = postcss.parse('a { background: white }')
   * root.nodes[0].append({ prop: 'color', value: 'black' })
   * root.nodes[0].nodes[1].raws.before   //=> undefined
   * root.nodes[0].nodes[1].raw('before') //=> ' '
   *
   * @return {string} Code style value.
   */
  ;

  _proto.raw = function raw(prop, defaultType) {
    var str = new _stringifier.default();
    return str.raw(this, prop, defaultType);
  }
  /**
   * Finds the Root instance of the node’s tree.
   *
   * @example
   * root.nodes[0].nodes[0].root() === root
   *
   * @return {Root} Root parent.
   */
  ;

  _proto.root = function root() {
    var result = this;

    while (result.parent) {
      result = result.parent;
    }

    return result;
  }
  /**
   * Clear the code style properties for the node and its children.
   *
   * @param {boolean} [keepBetween] Keep the raws.between symbols.
   *
   * @return {undefined}
   *
   * @example
   * node.raws.before  //=> ' '
   * node.cleanRaws()
   * node.raws.before  //=> undefined
   */
  ;

  _proto.cleanRaws = function cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween) delete this.raws.between;
  };

  _proto.positionInside = function positionInside(index) {
    var string = this.toString();
    var column = this.source.start.column;
    var line = this.source.start.line;

    for (var i = 0; i < index; i++) {
      if (string[i] === '\n') {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }

    return {
      line: line,
      column: column
    };
  };

  _proto.positionBy = function positionBy(opts) {
    var pos = this.source.start;

    if (opts.index) {
      pos = this.positionInside(opts.index);
    } else if (opts.word) {
      var index = this.toString().indexOf(opts.word);
      if (index !== -1) pos = this.positionInside(index);
    }

    return pos;
  }
  /**
   * @memberof Node#
   * @member {string} type String representing the node’s type.
   *                       Possible values are `root`, `atrule`, `rule`,
   *                       `decl`, or `comment`.
   *
   * @example
   * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
   */

  /**
   * @memberof Node#
   * @member {Container} parent The node’s parent node.
   *
   * @example
   * root.nodes[0].parent === root
   */

  /**
   * @memberof Node#
   * @member {source} source The input source of the node.
   *
   * The property is used in source map generation.
   *
   * If you create a node manually (e.g., with `postcss.decl()`),
   * that node will not have a `source` property and will be absent
   * from the source map. For this reason, the plugin developer should
   * consider cloning nodes to create new ones (in which case the new node’s
   * source will reference the original, cloned node) or setting
   * the `source` property manually.
   *
   * ```js
   * // Bad
   * const prefixed = postcss.decl({
   *   prop: '-moz-' + decl.prop,
   *   value: decl.value
   * })
   *
   * // Good
   * const prefixed = decl.clone({ prop: '-moz-' + decl.prop })
   * ```
   *
   * ```js
   * if (atrule.name === 'add-link') {
   *   const rule = postcss.rule({ selector: 'a', source: atrule.source })
   *   atrule.parent.insertBefore(atrule, rule)
   * }
   * ```
   *
   * @example
   * decl.source.input.from //=> '/home/ai/a.sass'
   * decl.source.start      //=> { line: 10, column: 2 }
   * decl.source.end        //=> { line: 10, column: 12 }
   */

  /**
   * @memberof Node#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `after`: the space symbols after the last child of the node
   *   to the end of the node.
   * * `between`: the symbols between the property and value
   *   for declarations, selector and `{` for rules, or last parameter
   *   and `{` for at-rules.
   * * `semicolon`: contains true if the last child has
   *   an (optional) semicolon.
   * * `afterName`: the space between the at-rule name and its parameters.
   * * `left`: the space symbols between `/*` and the comment’s text.
   * * `right`: the space symbols between the comment’s text
   *   and <code>*&#47;</code>.
   * * `important`: the content of the important statement,
   *   if it is not just `!important`.
   *
   * PostCSS cleans selectors, declaration values and at-rule parameters
   * from comments and extra spaces, but it stores origin content in raws
   * properties. As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('a {\n  color:black\n}')
   * root.first.first.raws //=> { before: '\n  ', between: ':' }
   */
  ;

  return Node;
}();

var _default = Node;
/**
 * @typedef {object} position
 * @property {number} line   Source line in file.
 * @property {number} column Source column in file.
 */

/**
 * @typedef {object} source
 * @property {Input} input    {@link Input} with input file
 * @property {position} start The starting position of the node’s source.
 * @property {position} end   The ending position of the node’s source.
 */

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGUuZXM2Il0sIm5hbWVzIjpbImNsb25lTm9kZSIsIm9iaiIsInBhcmVudCIsImNsb25lZCIsImNvbnN0cnVjdG9yIiwiaSIsImhhc093blByb3BlcnR5IiwidmFsdWUiLCJ0eXBlIiwiQXJyYXkiLCJtYXAiLCJqIiwiTm9kZSIsImRlZmF1bHRzIiwicmF3cyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsIm5hbWUiLCJlcnJvciIsIm1lc3NhZ2UiLCJvcHRzIiwic291cmNlIiwicG9zIiwicG9zaXRpb25CeSIsImlucHV0IiwibGluZSIsImNvbHVtbiIsIkNzc1N5bnRheEVycm9yIiwid2FybiIsInJlc3VsdCIsInRleHQiLCJkYXRhIiwibm9kZSIsInJlbW92ZSIsInJlbW92ZUNoaWxkIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJzdHJpbmdpZmllciIsImNsb25lIiwib3ZlcnJpZGVzIiwiY2xvbmVCZWZvcmUiLCJpbnNlcnRCZWZvcmUiLCJjbG9uZUFmdGVyIiwiaW5zZXJ0QWZ0ZXIiLCJyZXBsYWNlV2l0aCIsIm5vZGVzIiwibmV4dCIsImluZGV4IiwicHJldiIsImJlZm9yZSIsImFkZCIsImFmdGVyIiwidG9KU09OIiwiZml4ZWQiLCJyYXciLCJwcm9wIiwiZGVmYXVsdFR5cGUiLCJzdHIiLCJTdHJpbmdpZmllciIsInJvb3QiLCJjbGVhblJhd3MiLCJrZWVwQmV0d2VlbiIsImJldHdlZW4iLCJwb3NpdGlvbkluc2lkZSIsInN0cmluZyIsInN0YXJ0Iiwid29yZCIsImluZGV4T2YiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxTQUFTQSxTQUFULENBQW9CQyxHQUFwQixFQUF5QkMsTUFBekIsRUFBaUM7QUFDL0IsTUFBSUMsTUFBTSxHQUFHLElBQUlGLEdBQUcsQ0FBQ0csV0FBUixFQUFiOztBQUVBLE9BQUssSUFBSUMsQ0FBVCxJQUFjSixHQUFkLEVBQW1C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Li9jc3Mtc3ludGF4LWVycm9yJ1xuaW1wb3J0IFN0cmluZ2lmaWVyIGZyb20gJy4vc3RyaW5naWZpZXInXG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5J1xuXG5mdW5jdGlvbiBjbG9uZU5vZGUgKG9iaiwgcGFyZW50KSB7XG4gIGxldCBjbG9uZWQgPSBuZXcgb2JqLmNvbnN0cnVjdG9yKClcblxuICBmb3IgKGxldCBpIGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGkpKSBjb250aW51ZVxuICAgIGxldCB2YWx1ZSA9IG9ialtpXVxuICAgIGxldCB0eXBlID0gdHlwZW9mIHZhbHVlXG5cbiAgICBpZiAoaSA9PT0gJ3BhcmVudCcgJiYgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwYXJlbnQpIGNsb25lZFtpXSA9IHBhcmVudFxuICAgIH0gZWxzZSBpZiAoaSA9PT0gJ3NvdXJjZScpIHtcbiAgICAgIGNsb25lZFtpXSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBjbG9uZWRbaV0gPSB2YWx1ZS5tYXAoaiA9PiBjbG9uZU5vZGUoaiwgY2xvbmVkKSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB2YWx1ZSA9IGNsb25lTm9kZSh2YWx1ZSlcbiAgICAgIGNsb25lZFtpXSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKipcbiAqIEFsbCBub2RlIGNsYXNzZXMgaW5oZXJpdCB0aGUgZm9sbG93aW5nIGNvbW1vbiBtZXRob2RzLlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBOb2RlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZGVmYXVsdHNdIFZhbHVlIGZvciBub2RlIHByb3BlcnRpZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVmYXVsdHMgPSB7IH0pIHtcbiAgICB0aGlzLnJhd3MgPSB7IH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0cyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZmF1bHRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1Bvc3RDU1Mgbm9kZXMgY29uc3RydWN0b3IgYWNjZXB0cyBvYmplY3QsIG5vdCAnICtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShkZWZhdWx0cylcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgICB0aGlzW25hbWVdID0gZGVmYXVsdHNbbmFtZV1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGBDc3NTeW50YXhFcnJvcmAgaW5zdGFuY2UgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgcG9zaXRpb25cbiAgICogb2YgdGhlIG5vZGUgaW4gdGhlIHNvdXJjZSwgc2hvd2luZyBsaW5lIGFuZCBjb2x1bW4gbnVtYmVycyBhbmQgYWxzb1xuICAgKiBhIHNtYWxsIGV4Y2VycHQgdG8gZmFjaWxpdGF0ZSBkZWJ1Z2dpbmcuXG4gICAqXG4gICAqIElmIHByZXNlbnQsIGFuIGlucHV0IHNvdXJjZSBtYXAgd2lsbCBiZSB1c2VkIHRvIGdldCB0aGUgb3JpZ2luYWwgcG9zaXRpb25cbiAgICogb2YgdGhlIHNvdXJjZSwgZXZlbiBmcm9tIGEgcHJldmlvdXMgY29tcGlsYXRpb24gc3RlcFxuICAgKiAoZS5nLiwgZnJvbSBTYXNzIGNvbXBpbGF0aW9uKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgcHJvZHVjZXMgdmVyeSB1c2VmdWwgZXJyb3IgbWVzc2FnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlICAgICBFcnJvciBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSAgICAgIE9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnBsdWdpbiBQbHVnaW4gbmFtZSB0aGF0IGNyZWF0ZWQgdGhpcyBlcnJvci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3RDU1Mgd2lsbCBzZXQgaXQgYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud29yZCAgIEEgd29yZCBpbnNpZGUgYSBub2Rl4oCZcyBzdHJpbmcgdGhhdCBzaG91bGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGhpZ2hsaWdodGVkIGFzIHRoZSBzb3VyY2Ugb2YgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5pbmRleCAgQW4gaW5kZXggaW5zaWRlIGEgbm9kZeKAmXMgc3RyaW5nIHRoYXQgc2hvdWxkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBoaWdobGlnaHRlZCBhcyB0aGUgc291cmNlIG9mIHRoZSBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiB7Q3NzU3ludGF4RXJyb3J9IEVycm9yIG9iamVjdCB0byB0aHJvdyBpdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKCF2YXJpYWJsZXNbbmFtZV0pIHtcbiAgICogICB0aHJvdyBkZWNsLmVycm9yKCdVbmtub3duIHZhcmlhYmxlICcgKyBuYW1lLCB7IHdvcmQ6IG5hbWUgfSlcbiAgICogICAvLyBDc3NTeW50YXhFcnJvcjogcG9zdGNzcy12YXJzOmEuc2Fzczo0OjM6IFVua25vd24gdmFyaWFibGUgJGJsYWNrXG4gICAqICAgLy8gICBjb2xvcjogJGJsYWNrXG4gICAqICAgLy8gYVxuICAgKiAgIC8vICAgICAgICAgIF5cbiAgICogICAvLyAgIGJhY2tncm91bmQ6IHdoaXRlXG4gICAqIH1cbiAgICovXG4gIGVycm9yIChtZXNzYWdlLCBvcHRzID0geyB9KSB7XG4gICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICBsZXQgcG9zID0gdGhpcy5wb3NpdGlvbkJ5KG9wdHMpXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2UuaW5wdXQuZXJyb3IobWVzc2FnZSwgcG9zLmxpbmUsIHBvcy5jb2x1bW4sIG9wdHMpXG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3NzU3ludGF4RXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBhIGNvbnZlbmllbmNlIHdyYXBwZXIgZm9yIHtAbGluayBSZXN1bHQjd2Fybn0uXG4gICAqXG4gICAqIEBwYXJhbSB7UmVzdWx0fSByZXN1bHQgICAgICBUaGUge0BsaW5rIFJlc3VsdH0gaW5zdGFuY2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgd2lsbCByZWNlaXZlIHRoZSB3YXJuaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAgICAgICAgV2FybmluZyBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdICAgICAgT3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5wbHVnaW4gUGx1Z2luIG5hbWUgdGhhdCBjcmVhdGVkIHRoaXMgd2FybmluZy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3RDU1Mgd2lsbCBzZXQgaXQgYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud29yZCAgIEEgd29yZCBpbnNpZGUgYSBub2Rl4oCZcyBzdHJpbmcgdGhhdCBzaG91bGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGhpZ2hsaWdodGVkIGFzIHRoZSBzb3VyY2Ugb2YgdGhlIHdhcm5pbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLmluZGV4ICBBbiBpbmRleCBpbnNpZGUgYSBub2Rl4oCZcyBzdHJpbmcgdGhhdCBzaG91bGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGhpZ2hsaWdodGVkIGFzIHRoZSBzb3VyY2Ugb2YgdGhlIHdhcm5pbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge1dhcm5pbmd9IENyZWF0ZWQgd2FybmluZyBvYmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHBsdWdpbiA9IHBvc3Rjc3MucGx1Z2luKCdwb3N0Y3NzLWRlcHJlY2F0ZWQnLCAoKSA9PiB7XG4gICAqICAgcmV0dXJuIChyb290LCByZXN1bHQpID0+IHtcbiAgICogICAgIHJvb3Qud2Fsa0RlY2xzKCdiYWQnLCBkZWNsID0+IHtcbiAgICogICAgICAgZGVjbC53YXJuKHJlc3VsdCwgJ0RlcHJlY2F0ZWQgcHJvcGVydHkgYmFkJylcbiAgICogICAgIH0pXG4gICAqICAgfVxuICAgKiB9KVxuICAgKi9cbiAgd2FybiAocmVzdWx0LCB0ZXh0LCBvcHRzKSB7XG4gICAgbGV0IGRhdGEgPSB7IG5vZGU6IHRoaXMgfVxuICAgIGZvciAobGV0IGkgaW4gb3B0cykgZGF0YVtpXSA9IG9wdHNbaV1cbiAgICByZXR1cm4gcmVzdWx0Lndhcm4odGV4dCwgZGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBub2RlIGZyb20gaXRzIHBhcmVudCBhbmQgY2xlYW5zIHRoZSBwYXJlbnQgcHJvcGVydGllc1xuICAgKiBmcm9tIHRoZSBub2RlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGlmIChkZWNsLnByb3AubWF0Y2goL14td2Via2l0LS8pKSB7XG4gICAqICAgZGVjbC5yZW1vdmUoKVxuICAgKiB9XG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IE5vZGUgdG8gbWFrZSBjYWxscyBjaGFpbi5cbiAgICovXG4gIHJlbW92ZSAoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKVxuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIENTUyBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ2lmaWVyfHN5bnRheH0gW3N0cmluZ2lmaWVyXSBBIHN5bnRheCB0byB1c2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gc3RyaW5nIGdlbmVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ1NTIHN0cmluZyBvZiB0aGlzIG5vZGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHBvc3Rjc3MucnVsZSh7IHNlbGVjdG9yOiAnYScgfSkudG9TdHJpbmcoKSAvLz0+IFwiYSB7fVwiXG4gICAqL1xuICB0b1N0cmluZyAoc3RyaW5naWZpZXIgPSBzdHJpbmdpZnkpIHtcbiAgICBpZiAoc3RyaW5naWZpZXIuc3RyaW5naWZ5KSBzdHJpbmdpZmllciA9IHN0cmluZ2lmaWVyLnN0cmluZ2lmeVxuICAgIGxldCByZXN1bHQgPSAnJ1xuICAgIHN0cmluZ2lmaWVyKHRoaXMsIGkgPT4ge1xuICAgICAgcmVzdWx0ICs9IGlcbiAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4YWN0IGNsb25lIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBUaGUgcmVzdWx0aW5nIGNsb25lZCBub2RlIGFuZCBpdHMgKGNsb25lZCkgY2hpbGRyZW4gd2lsbCByZXRhaW5cbiAgICogY29kZSBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW292ZXJyaWRlc10gTmV3IHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgaW4gdGhlIGNsb25lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBkZWNsLnJhd3MuYmVmb3JlICAgIC8vPT4gXCJcXG4gIFwiXG4gICAqIGNvbnN0IGNsb25lZCA9IGRlY2wuY2xvbmUoeyBwcm9wOiAnLW1vei0nICsgZGVjbC5wcm9wIH0pXG4gICAqIGNsb25lZC5yYXdzLmJlZm9yZSAgLy89PiBcIlxcbiAgXCJcbiAgICogY2xvbmVkLnRvU3RyaW5nKCkgICAvLz0+IC1tb3otdHJhbnNmb3JtOiBzY2FsZSgwKVxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBDbG9uZSBvZiB0aGUgbm9kZS5cbiAgICovXG4gIGNsb25lIChvdmVycmlkZXMgPSB7IH0pIHtcbiAgICBsZXQgY2xvbmVkID0gY2xvbmVOb2RlKHRoaXMpXG4gICAgZm9yIChsZXQgbmFtZSBpbiBvdmVycmlkZXMpIHtcbiAgICAgIGNsb25lZFtuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkXG4gIH1cblxuICAvKipcbiAgICogU2hvcnRjdXQgdG8gY2xvbmUgdGhlIG5vZGUgYW5kIGluc2VydCB0aGUgcmVzdWx0aW5nIGNsb25lZCBub2RlXG4gICAqIGJlZm9yZSB0aGUgY3VycmVudCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW292ZXJyaWRlc10gTWV3IHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgaW4gdGhlIGNsb25lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBkZWNsLmNsb25lQmVmb3JlKHsgcHJvcDogJy1tb3otJyArIGRlY2wucHJvcCB9KVxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBOZXcgbm9kZVxuICAgKi9cbiAgY2xvbmVCZWZvcmUgKG92ZXJyaWRlcyA9IHsgfSkge1xuICAgIGxldCBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcylcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgY2xvbmVkKVxuICAgIHJldHVybiBjbG9uZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG9ydGN1dCB0byBjbG9uZSB0aGUgbm9kZSBhbmQgaW5zZXJ0IHRoZSByZXN1bHRpbmcgY2xvbmVkIG5vZGVcbiAgICogYWZ0ZXIgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvdmVycmlkZXNdIE5ldyBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIGluIHRoZSBjbG9uZS5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gTmV3IG5vZGUuXG4gICAqL1xuICBjbG9uZUFmdGVyIChvdmVycmlkZXMgPSB7IH0pIHtcbiAgICBsZXQgY2xvbmVkID0gdGhpcy5jbG9uZShvdmVycmlkZXMpXG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgY2xvbmVkKVxuICAgIHJldHVybiBjbG9uZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5vZGUocykgYmVmb3JlIHRoZSBjdXJyZW50IG5vZGUgYW5kIHJlbW92ZXMgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHsuLi5Ob2RlfSBub2RlcyBNb2RlKHMpIHRvIHJlcGxhY2UgY3VycmVudCBvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGlmIChhdHJ1bGUubmFtZSA9PT0gJ21peGluJykge1xuICAgKiAgIGF0cnVsZS5yZXBsYWNlV2l0aChtaXhpblJ1bGVzW2F0cnVsZS5wYXJhbXNdKVxuICAgKiB9XG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IEN1cnJlbnQgbm9kZSB0byBtZXRob2RzIGNoYWluLlxuICAgKi9cbiAgcmVwbGFjZVdpdGggKC4uLm5vZGVzKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBub2RlKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbW92ZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IGNoaWxkIG9mIHRoZSBub2Rl4oCZcyBwYXJlbnQuXG4gICAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGN1cnJlbnQgbm9kZSBpcyB0aGUgbGFzdCBjaGlsZC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZXx1bmRlZmluZWR9IE5leHQgbm9kZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKGNvbW1lbnQudGV4dCA9PT0gJ2RlbGV0ZSBuZXh0Jykge1xuICAgKiAgIGNvbnN0IG5leHQgPSBjb21tZW50Lm5leHQoKVxuICAgKiAgIGlmIChuZXh0KSB7XG4gICAqICAgICBuZXh0LnJlbW92ZSgpXG4gICAqICAgfVxuICAgKiB9XG4gICAqL1xuICBuZXh0ICgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdW5kZWZpbmVkXG4gICAgbGV0IGluZGV4ID0gdGhpcy5wYXJlbnQuaW5kZXgodGhpcylcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXggKyAxXVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZXZpb3VzIGNoaWxkIG9mIHRoZSBub2Rl4oCZcyBwYXJlbnQuXG4gICAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGN1cnJlbnQgbm9kZSBpcyB0aGUgZmlyc3QgY2hpbGQuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV8dW5kZWZpbmVkfSBQcmV2aW91cyBub2RlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBhbm5vdGF0aW9uID0gZGVjbC5wcmV2KClcbiAgICogaWYgKGFubm90YXRpb24udHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAqICAgcmVhZEFubm90YXRpb24oYW5ub3RhdGlvbi50ZXh0KVxuICAgKiB9XG4gICAqL1xuICBwcmV2ICgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdW5kZWZpbmVkXG4gICAgbGV0IGluZGV4ID0gdGhpcy5wYXJlbnQuaW5kZXgodGhpcylcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXggLSAxXVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBuZXcgbm9kZSBiZWZvcmUgY3VycmVudCBub2RlIHRvIGN1cnJlbnQgbm9kZeKAmXMgcGFyZW50LlxuICAgKlxuICAgKiBKdXN0IGFsaWFzIGZvciBgbm9kZS5wYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFkZClgLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV8b2JqZWN0fHN0cmluZ3xOb2RlW119IGFkZCBOZXcgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhpcyBub2RlIGZvciBtZXRob2RzIGNoYWluLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBkZWNsLmJlZm9yZSgnY29udGVudDogXCJcIicpXG4gICAqL1xuICBiZWZvcmUgKGFkZCkge1xuICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBhZGQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IG5vZGUgYWZ0ZXIgY3VycmVudCBub2RlIHRvIGN1cnJlbnQgbm9kZeKAmXMgcGFyZW50LlxuICAgKlxuICAgKiBKdXN0IGFsaWFzIGZvciBgbm9kZS5wYXJlbnQuaW5zZXJ0QWZ0ZXIobm9kZSwgYWRkKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZXxvYmplY3R8c3RyaW5nfE5vZGVbXX0gYWRkIE5ldyBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGRlY2wuYWZ0ZXIoJ2NvbG9yOiBibGFjaycpXG4gICAqL1xuICBhZnRlciAoYWRkKSB7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgYWRkKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0b0pTT04gKCkge1xuICAgIGxldCBmaXhlZCA9IHsgfVxuXG4gICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkpIGNvbnRpbnVlXG4gICAgICBpZiAobmFtZSA9PT0gJ3BhcmVudCcpIGNvbnRpbnVlXG4gICAgICBsZXQgdmFsdWUgPSB0aGlzW25hbWVdXG5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUubWFwKGkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ29iamVjdCcgJiYgaS50b0pTT04pIHtcbiAgICAgICAgICAgIHJldHVybiBpLnRvSlNPTigpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLnRvSlNPTikge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlLnRvSlNPTigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpeGVkXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHtAbGluayBOb2RlI3Jhd3N9IHZhbHVlLiBJZiB0aGUgbm9kZSBpcyBtaXNzaW5nXG4gICAqIHRoZSBjb2RlIHN0eWxlIHByb3BlcnR5IChiZWNhdXNlIHRoZSBub2RlIHdhcyBtYW51YWxseSBidWlsdCBvciBjbG9uZWQpLFxuICAgKiBQb3N0Q1NTIHdpbGwgdHJ5IHRvIGF1dG9kZXRlY3QgdGhlIGNvZGUgc3R5bGUgcHJvcGVydHkgYnkgbG9va2luZ1xuICAgKiBhdCBvdGhlciBub2RlcyBpbiB0aGUgdHJlZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgICAgICAgICAgTmFtZSBvZiBjb2RlIHN0eWxlIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RlZmF1bHRUeXBlXSBOYW1lIG9mIGRlZmF1bHQgdmFsdWUsIGl0IGNhbiBiZSBtaXNzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgdGhlIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHByb3AuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdhIHsgYmFja2dyb3VuZDogd2hpdGUgfScpXG4gICAqIHJvb3Qubm9kZXNbMF0uYXBwZW5kKHsgcHJvcDogJ2NvbG9yJywgdmFsdWU6ICdibGFjaycgfSlcbiAgICogcm9vdC5ub2Rlc1swXS5ub2Rlc1sxXS5yYXdzLmJlZm9yZSAgIC8vPT4gdW5kZWZpbmVkXG4gICAqIHJvb3Qubm9kZXNbMF0ubm9kZXNbMV0ucmF3KCdiZWZvcmUnKSAvLz0+ICcgJ1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvZGUgc3R5bGUgdmFsdWUuXG4gICAqL1xuICByYXcgKHByb3AsIGRlZmF1bHRUeXBlKSB7XG4gICAgbGV0IHN0ciA9IG5ldyBTdHJpbmdpZmllcigpXG4gICAgcmV0dXJuIHN0ci5yYXcodGhpcywgcHJvcCwgZGVmYXVsdFR5cGUpXG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIFJvb3QgaW5zdGFuY2Ugb2YgdGhlIG5vZGXigJlzIHRyZWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJvb3Qubm9kZXNbMF0ubm9kZXNbMF0ucm9vdCgpID09PSByb290XG4gICAqXG4gICAqIEByZXR1cm4ge1Jvb3R9IFJvb3QgcGFyZW50LlxuICAgKi9cbiAgcm9vdCAoKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXNcbiAgICB3aGlsZSAocmVzdWx0LnBhcmVudCkgcmVzdWx0ID0gcmVzdWx0LnBhcmVudFxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgY29kZSBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtrZWVwQmV0d2Vlbl0gS2VlcCB0aGUgcmF3cy5iZXR3ZWVuIHN5bWJvbHMuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5yYXdzLmJlZm9yZSAgLy89PiAnICdcbiAgICogbm9kZS5jbGVhblJhd3MoKVxuICAgKiBub2RlLnJhd3MuYmVmb3JlICAvLz0+IHVuZGVmaW5lZFxuICAgKi9cbiAgY2xlYW5SYXdzIChrZWVwQmV0d2Vlbikge1xuICAgIGRlbGV0ZSB0aGlzLnJhd3MuYmVmb3JlXG4gICAgZGVsZXRlIHRoaXMucmF3cy5hZnRlclxuICAgIGlmICgha2VlcEJldHdlZW4pIGRlbGV0ZSB0aGlzLnJhd3MuYmV0d2VlblxuICB9XG5cbiAgcG9zaXRpb25JbnNpZGUgKGluZGV4KSB7XG4gICAgbGV0IHN0cmluZyA9IHRoaXMudG9TdHJpbmcoKVxuICAgIGxldCBjb2x1bW4gPSB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW5cbiAgICBsZXQgbGluZSA9IHRoaXMuc291cmNlLnN0YXJ0LmxpbmVcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgaWYgKHN0cmluZ1tpXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgY29sdW1uID0gMVxuICAgICAgICBsaW5lICs9IDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbiArPSAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbGluZSwgY29sdW1uIH1cbiAgfVxuXG4gIHBvc2l0aW9uQnkgKG9wdHMpIHtcbiAgICBsZXQgcG9zID0gdGhpcy5zb3VyY2Uuc3RhcnRcbiAgICBpZiAob3B0cy5pbmRleCkge1xuICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4KVxuICAgIH0gZWxzZSBpZiAob3B0cy53b3JkKSB7XG4gICAgICBsZXQgaW5kZXggPSB0aGlzLnRvU3RyaW5nKCkuaW5kZXhPZihvcHRzLndvcmQpXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSBwb3MgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4KVxuICAgIH1cbiAgICByZXR1cm4gcG9zXG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlcm9mIE5vZGUjXG4gICAqIEBtZW1iZXIge3N0cmluZ30gdHlwZSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBub2Rl4oCZcyB0eXBlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgUG9zc2libGUgdmFsdWVzIGFyZSBgcm9vdGAsIGBhdHJ1bGVgLCBgcnVsZWAsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBgZGVjbGAsIG9yIGBjb21tZW50YC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcy5kZWNsKHsgcHJvcDogJ2NvbG9yJywgdmFsdWU6ICdibGFjaycgfSkudHlwZSAvLz0+ICdkZWNsJ1xuICAgKi9cblxuICAvKipcbiAgICogQG1lbWJlcm9mIE5vZGUjXG4gICAqIEBtZW1iZXIge0NvbnRhaW5lcn0gcGFyZW50IFRoZSBub2Rl4oCZcyBwYXJlbnQgbm9kZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcm9vdC5ub2Rlc1swXS5wYXJlbnQgPT09IHJvb3RcbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBOb2RlI1xuICAgKiBAbWVtYmVyIHtzb3VyY2V9IHNvdXJjZSBUaGUgaW5wdXQgc291cmNlIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBUaGUgcHJvcGVydHkgaXMgdXNlZCBpbiBzb3VyY2UgbWFwIGdlbmVyYXRpb24uXG4gICAqXG4gICAqIElmIHlvdSBjcmVhdGUgYSBub2RlIG1hbnVhbGx5IChlLmcuLCB3aXRoIGBwb3N0Y3NzLmRlY2woKWApLFxuICAgKiB0aGF0IG5vZGUgd2lsbCBub3QgaGF2ZSBhIGBzb3VyY2VgIHByb3BlcnR5IGFuZCB3aWxsIGJlIGFic2VudFxuICAgKiBmcm9tIHRoZSBzb3VyY2UgbWFwLiBGb3IgdGhpcyByZWFzb24sIHRoZSBwbHVnaW4gZGV2ZWxvcGVyIHNob3VsZFxuICAgKiBjb25zaWRlciBjbG9uaW5nIG5vZGVzIHRvIGNyZWF0ZSBuZXcgb25lcyAoaW4gd2hpY2ggY2FzZSB0aGUgbmV3IG5vZGXigJlzXG4gICAqIHNvdXJjZSB3aWxsIHJlZmVyZW5jZSB0aGUgb3JpZ2luYWwsIGNsb25lZCBub2RlKSBvciBzZXR0aW5nXG4gICAqIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBtYW51YWxseS5cbiAgICpcbiAgICogYGBganNcbiAgICogLy8gQmFkXG4gICAqIGNvbnN0IHByZWZpeGVkID0gcG9zdGNzcy5kZWNsKHtcbiAgICogICBwcm9wOiAnLW1vei0nICsgZGVjbC5wcm9wLFxuICAgKiAgIHZhbHVlOiBkZWNsLnZhbHVlXG4gICAqIH0pXG4gICAqXG4gICAqIC8vIEdvb2RcbiAgICogY29uc3QgcHJlZml4ZWQgPSBkZWNsLmNsb25lKHsgcHJvcDogJy1tb3otJyArIGRlY2wucHJvcCB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogYGBganNcbiAgICogaWYgKGF0cnVsZS5uYW1lID09PSAnYWRkLWxpbmsnKSB7XG4gICAqICAgY29uc3QgcnVsZSA9IHBvc3Rjc3MucnVsZSh7IHNlbGVjdG9yOiAnYScsIHNvdXJjZTogYXRydWxlLnNvdXJjZSB9KVxuICAgKiAgIGF0cnVsZS5wYXJlbnQuaW5zZXJ0QmVmb3JlKGF0cnVsZSwgcnVsZSlcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZGVjbC5zb3VyY2UuaW5wdXQuZnJvbSAvLz0+ICcvaG9tZS9haS9hLnNhc3MnXG4gICAqIGRlY2wuc291cmNlLnN0YXJ0ICAgICAgLy89PiB7IGxpbmU6IDEwLCBjb2x1bW46IDIgfVxuICAgKiBkZWNsLnNvdXJjZS5lbmQgICAgICAgIC8vPT4geyBsaW5lOiAxMCwgY29sdW1uOiAxMiB9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgTm9kZSNcbiAgICogQG1lbWJlciB7b2JqZWN0fSByYXdzIEluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGJ5dGUtdG8tYnl0ZSBlcXVhbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgbm9kZSBzdHJpbmcgYXMgaXQgd2FzIGluIHRoZSBvcmlnaW4gaW5wdXQuXG4gICAqXG4gICAqIEV2ZXJ5IHBhcnNlciBzYXZlcyBpdHMgb3duIHByb3BlcnRpZXMsXG4gICAqIGJ1dCB0aGUgZGVmYXVsdCBDU1MgcGFyc2VyIHVzZXM6XG4gICAqXG4gICAqICogYGJlZm9yZWA6IHRoZSBzcGFjZSBzeW1ib2xzIGJlZm9yZSB0aGUgbm9kZS4gSXQgYWxzbyBzdG9yZXMgYCpgXG4gICAqICAgYW5kIGBfYCBzeW1ib2xzIGJlZm9yZSB0aGUgZGVjbGFyYXRpb24gKElFIGhhY2spLlxuICAgKiAqIGBhZnRlcmA6IHRoZSBzcGFjZSBzeW1ib2xzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoZSBub2RlXG4gICAqICAgdG8gdGhlIGVuZCBvZiB0aGUgbm9kZS5cbiAgICogKiBgYmV0d2VlbmA6IHRoZSBzeW1ib2xzIGJldHdlZW4gdGhlIHByb3BlcnR5IGFuZCB2YWx1ZVxuICAgKiAgIGZvciBkZWNsYXJhdGlvbnMsIHNlbGVjdG9yIGFuZCBge2AgZm9yIHJ1bGVzLCBvciBsYXN0IHBhcmFtZXRlclxuICAgKiAgIGFuZCBge2AgZm9yIGF0LXJ1bGVzLlxuICAgKiAqIGBzZW1pY29sb25gOiBjb250YWlucyB0cnVlIGlmIHRoZSBsYXN0IGNoaWxkIGhhc1xuICAgKiAgIGFuIChvcHRpb25hbCkgc2VtaWNvbG9uLlxuICAgKiAqIGBhZnRlck5hbWVgOiB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgYXQtcnVsZSBuYW1lIGFuZCBpdHMgcGFyYW1ldGVycy5cbiAgICogKiBgbGVmdGA6IHRoZSBzcGFjZSBzeW1ib2xzIGJldHdlZW4gYC8qYCBhbmQgdGhlIGNvbW1lbnTigJlzIHRleHQuXG4gICAqICogYHJpZ2h0YDogdGhlIHNwYWNlIHN5bWJvbHMgYmV0d2VlbiB0aGUgY29tbWVudOKAmXMgdGV4dFxuICAgKiAgIGFuZCA8Y29kZT4qJiM0Nzs8L2NvZGU+LlxuICAgKiAqIGBpbXBvcnRhbnRgOiB0aGUgY29udGVudCBvZiB0aGUgaW1wb3J0YW50IHN0YXRlbWVudCxcbiAgICogICBpZiBpdCBpcyBub3QganVzdCBgIWltcG9ydGFudGAuXG4gICAqXG4gICAqIFBvc3RDU1MgY2xlYW5zIHNlbGVjdG9ycywgZGVjbGFyYXRpb24gdmFsdWVzIGFuZCBhdC1ydWxlIHBhcmFtZXRlcnNcbiAgICogZnJvbSBjb21tZW50cyBhbmQgZXh0cmEgc3BhY2VzLCBidXQgaXQgc3RvcmVzIG9yaWdpbiBjb250ZW50IGluIHJhd3NcbiAgICogcHJvcGVydGllcy4gQXMgc3VjaCwgaWYgeW91IGRvbuKAmXQgY2hhbmdlIGEgZGVjbGFyYXRpb27igJlzIHZhbHVlLFxuICAgKiBQb3N0Q1NTIHdpbGwgdXNlIHRoZSByYXcgdmFsdWUgd2l0aCBjb21tZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2Ege1xcbiAgY29sb3I6YmxhY2tcXG59JylcbiAgICogcm9vdC5maXJzdC5maXJzdC5yYXdzIC8vPT4geyBiZWZvcmU6ICdcXG4gICcsIGJldHdlZW46ICc6JyB9XG4gICAqL1xufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gcG9zaXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lICAgU291cmNlIGxpbmUgaW4gZmlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2x1bW4gU291cmNlIGNvbHVtbiBpbiBmaWxlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gc291cmNlXG4gKiBAcHJvcGVydHkge0lucHV0fSBpbnB1dCAgICB7QGxpbmsgSW5wdXR9IHdpdGggaW5wdXQgZmlsZVxuICogQHByb3BlcnR5IHtwb3NpdGlvbn0gc3RhcnQgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSBub2Rl4oCZcyBzb3VyY2UuXG4gKiBAcHJvcGVydHkge3Bvc2l0aW9ufSBlbmQgICBUaGUgZW5kaW5nIHBvc2l0aW9uIG9mIHRoZSBub2Rl4oCZcyBzb3VyY2UuXG4gKi9cbiJdLCJmaWxlIjoibm9kZS5qcyJ9


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _stringifier = _interopRequireDefault(__webpack_require__(36));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringify(node, builder) {
  var str = new _stringifier.default(builder);
  str.stringify(node);
}

var _default = stringify;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInN0cmluZ2lmeS5lczYiXSwibmFtZXMiOlsic3RyaW5naWZ5Iiwibm9kZSIsImJ1aWxkZXIiLCJzdHIiLCJTdHJpbmdpZmllciJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7OztBQUVBLFNBQVNBLFNBQVQsQ0FBb0JDLElBQXBCLEVBQTBCQyxPQUExQixFQUFtQztBQUNqQyxNQUFJQyxHQUFHLEdBQUcsSUFBSUMsb0JBQUosQ0FBZ0JGLE9BQWhCLENBQVY7QUFDQUMsRUFBQUEsR0FBRyxDQUFDSCxTQUFKLENBQWNDLElBQWQ7QUFDRDs7ZUFFY0QsUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdHJpbmdpZmllciBmcm9tICcuL3N0cmluZ2lmaWVyJ1xuXG5mdW5jdGlvbiBzdHJpbmdpZnkgKG5vZGUsIGJ1aWxkZXIpIHtcbiAgbGV0IHN0ciA9IG5ldyBTdHJpbmdpZmllcihidWlsZGVyKVxuICBzdHIuc3RyaW5naWZ5KG5vZGUpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeVxuIl0sImZpbGUiOiJzdHJpbmdpZnkuanMifQ==


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(78)
var ieee754 = __webpack_require__(79)
var isArray = __webpack_require__(80)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _parser = _interopRequireDefault(__webpack_require__(90));

var _input = _interopRequireDefault(__webpack_require__(92));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(css, opts) {
  var input = new _input.default(css, opts);
  var parser = new _parser.default(input);

  try {
    parser.parse();
  } catch (e) {
    if (false) {}

    throw e;
  }

  return parser.root;
}

var _default = parse;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlLmVzNiJdLCJuYW1lcyI6WyJwYXJzZSIsImNzcyIsIm9wdHMiLCJpbnB1dCIsIklucHV0IiwicGFyc2VyIiwiUGFyc2VyIiwiZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm5hbWUiLCJmcm9tIiwidGVzdCIsIm1lc3NhZ2UiLCJyb290Il0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUNBOzs7O0FBRUEsU0FBU0EsS0FBVCxDQUFnQkMsR0FBaEIsRUFBcUJDLElBQXJCLEVBQTJCO0FBQ3pCLE1BQUlDLEtBQUssR0FBRyxJQUFJQyxjQUFKLENBQVVILEdBQVYsRUFBZUMsSUFBZixDQUFaO0FBQ0EsTUFBSUcsTUFBTSxHQUFHLElBQUlDLGVBQUosQ0FBV0gsS0FBWCxDQUFiOztBQUNBLE1BQUk7QUFDRkUsSUFBQUEsTUFBTSxDQUFDTCxLQUFQO0FBQ0QsR0FGRCxDQUVFLE9BQU9PLENBQVAsRUFBVTtBQUNWLFFBQUlDLE9BQU8sQ0FBQ0MsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUlILENBQUMsQ0FBQ0ksSUFBRixLQUFXLGdCQUFYLElBQStCVCxJQUEvQixJQUF1Q0EsSUFBSSxDQUFDVSxJQUFoRCxFQUFzRDtBQUNwRCxZQUFJLFdBQVdDLElBQVgsQ0FBZ0JYLElBQUksQ0FBQ1UsSUFBckIsQ0FBSixFQUFnQztBQUM5QkwsVUFBQUEsQ0FBQyxDQUFDTyxPQUFGLElBQWEsb0NBQ0EsMkJBREEsR0FFQSx3Q0FGYjtBQUdELFNBSkQsTUFJTyxJQUFJLFVBQVVELElBQVYsQ0FBZVgsSUFBSSxDQUFDVSxJQUFwQixDQUFKLEVBQStCO0FBQ3BDTCxVQUFBQSxDQUFDLENBQUNPLE9BQUYsSUFBYSxvQ0FDQSwyQkFEQSxHQUVBLHdDQUZiO0FBR0QsU0FKTSxNQUlBLElBQUksV0FBV0QsSUFBWCxDQUFnQlgsSUFBSSxDQUFDVSxJQUFyQixDQUFKLEVBQWdDO0FBQ3JDTCxVQUFBQSxDQUFDLENBQUNPLE9BQUYsSUFBYSxvQ0FDQSwyQkFEQSxHQUVBLHdDQUZiO0FBR0Q7QUFDRjtBQUNGOztBQUNELFVBQU1QLENBQU47QUFDRDs7QUFFRCxTQUFPRixNQUFNLENBQUNVLElBQWQ7QUFDRDs7ZUFFY2YsSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYXJzZXIgZnJvbSAnLi9wYXJzZXInXG5pbXBvcnQgSW5wdXQgZnJvbSAnLi9pbnB1dCdcblxuZnVuY3Rpb24gcGFyc2UgKGNzcywgb3B0cykge1xuICBsZXQgaW5wdXQgPSBuZXcgSW5wdXQoY3NzLCBvcHRzKVxuICBsZXQgcGFyc2VyID0gbmV3IFBhcnNlcihpbnB1dClcbiAgdHJ5IHtcbiAgICBwYXJzZXIucGFyc2UoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChlLm5hbWUgPT09ICdDc3NTeW50YXhFcnJvcicgJiYgb3B0cyAmJiBvcHRzLmZyb20pIHtcbiAgICAgICAgaWYgKC9cXC5zY3NzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgIGUubWVzc2FnZSArPSAnXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNDU1Mgd2l0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ3RoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ3RyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNjc3MgcGFyc2VyJ1xuICAgICAgICB9IGVsc2UgaWYgKC9cXC5zYXNzL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgZS5tZXNzYWdlICs9ICdcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgU2FzcyB3aXRoICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAndGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAndHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2FzcyBwYXJzZXInXG4gICAgICAgIH0gZWxzZSBpZiAoL1xcLmxlc3MkL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgZS5tZXNzYWdlICs9ICdcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgTGVzcyB3aXRoICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAndGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAndHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3MtbGVzcyBwYXJzZXInXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlci5yb290XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlXG4iXSwiZmlsZSI6InBhcnNlLmpzIn0=


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _node = _interopRequireDefault(__webpack_require__(16));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Represents a comment between declarations or statements (rule and at-rules).
 *
 * Comments inside selectors, at-rule parameters, or declaration values
 * will be stored in the `raws` properties explained above.
 *
 * @extends Node
 */
var Comment =
/*#__PURE__*/
function (_Node) {
  _inheritsLoose(Comment, _Node);

  function Comment(defaults) {
    var _this;

    _this = _Node.call(this, defaults) || this;
    _this.type = 'comment';
    return _this;
  }
  /**
   * @memberof Comment#
   * @member {string} text The comment’s text.
   */

  /**
   * @memberof Comment#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node.
   * * `left`: the space symbols between `/*` and the comment’s text.
   * * `right`: the space symbols between the comment’s text.
   */


  return Comment;
}(_node.default);

var _default = Comment;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbW1lbnQuZXM2Il0sIm5hbWVzIjpbIkNvbW1lbnQiLCJkZWZhdWx0cyIsInR5cGUiLCJOb2RlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7QUFFQTs7Ozs7Ozs7SUFRTUEsTzs7Ozs7QUFDSixtQkFBYUMsUUFBYixFQUF1QjtBQUFBOztBQUNyQiw2QkFBTUEsUUFBTjtBQUNBLFVBQUtDLElBQUwsR0FBWSxTQUFaO0FBRnFCO0FBR3RCO0FBRUQ7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7OztFQVhvQkMsYTs7ZUF5QlBILE8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTm9kZSBmcm9tICcuL25vZGUnXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbW1lbnQgYmV0d2VlbiBkZWNsYXJhdGlvbnMgb3Igc3RhdGVtZW50cyAocnVsZSBhbmQgYXQtcnVsZXMpLlxuICpcbiAqIENvbW1lbnRzIGluc2lkZSBzZWxlY3RvcnMsIGF0LXJ1bGUgcGFyYW1ldGVycywgb3IgZGVjbGFyYXRpb24gdmFsdWVzXG4gKiB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgYHJhd3NgIHByb3BlcnRpZXMgZXhwbGFpbmVkIGFib3ZlLlxuICpcbiAqIEBleHRlbmRzIE5vZGVcbiAqL1xuY2xhc3MgQ29tbWVudCBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvciAoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cylcbiAgICB0aGlzLnR5cGUgPSAnY29tbWVudCdcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgQ29tbWVudCNcbiAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXh0IFRoZSBjb21tZW504oCZcyB0ZXh0LlxuICAgKi9cblxuICAvKipcbiAgICogQG1lbWJlcm9mIENvbW1lbnQjXG4gICAqIEBtZW1iZXIge29iamVjdH0gcmF3cyBJbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSBieXRlLXRvLWJ5dGUgZXF1YWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIG5vZGUgc3RyaW5nIGFzIGl0IHdhcyBpbiB0aGUgb3JpZ2luIGlucHV0LlxuICAgKlxuICAgKiBFdmVyeSBwYXJzZXIgc2F2ZXMgaXRzIG93biBwcm9wZXJ0aWVzLFxuICAgKiBidXQgdGhlIGRlZmF1bHQgQ1NTIHBhcnNlciB1c2VzOlxuICAgKlxuICAgKiAqIGBiZWZvcmVgOiB0aGUgc3BhY2Ugc3ltYm9scyBiZWZvcmUgdGhlIG5vZGUuXG4gICAqICogYGxlZnRgOiB0aGUgc3BhY2Ugc3ltYm9scyBiZXR3ZWVuIGAvKmAgYW5kIHRoZSBjb21tZW504oCZcyB0ZXh0LlxuICAgKiAqIGByaWdodGA6IHRoZSBzcGFjZSBzeW1ib2xzIGJldHdlZW4gdGhlIGNvbW1lbnTigJlzIHRleHQuXG4gICAqL1xufVxuXG5leHBvcnQgZGVmYXVsdCBDb21tZW50XG4iXSwiZmlsZSI6ImNvbW1lbnQuanMifQ==


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(__webpack_require__(22));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Represents an at-rule.
 *
 * If it’s followed in the CSS by a {} block, this node will have
 * a nodes property representing its children.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('@charset "UTF-8"; @media print {}')
 *
 * const charset = root.first
 * charset.type  //=> 'atrule'
 * charset.nodes //=> undefined
 *
 * const media = root.last
 * media.nodes   //=> []
 */
var AtRule =
/*#__PURE__*/
function (_Container) {
  _inheritsLoose(AtRule, _Container);

  function AtRule(defaults) {
    var _this;

    _this = _Container.call(this, defaults) || this;
    _this.type = 'atrule';
    return _this;
  }

  var _proto = AtRule.prototype;

  _proto.append = function append() {
    var _Container$prototype$;

    if (!this.nodes) this.nodes = [];

    for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
      children[_key] = arguments[_key];
    }

    return (_Container$prototype$ = _Container.prototype.append).call.apply(_Container$prototype$, [this].concat(children));
  };

  _proto.prepend = function prepend() {
    var _Container$prototype$2;

    if (!this.nodes) this.nodes = [];

    for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      children[_key2] = arguments[_key2];
    }

    return (_Container$prototype$2 = _Container.prototype.prepend).call.apply(_Container$prototype$2, [this].concat(children));
  }
  /**
   * @memberof AtRule#
   * @member {string} name The at-rule’s name immediately follows the `@`.
   *
   * @example
   * const root  = postcss.parse('@media print {}')
   * media.name //=> 'media'
   * const media = root.first
   */

  /**
   * @memberof AtRule#
   * @member {string} params The at-rule’s parameters, the values
   *                         that follow the at-rule’s name but precede
   *                         any {} block.
   *
   * @example
   * const root  = postcss.parse('@media print, screen {}')
   * const media = root.first
   * media.params //=> 'print, screen'
   */

  /**
   * @memberof AtRule#
   * @member {object} raws Information to generate byte-to-byte equal
   *                        node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `after`: the space symbols after the last child of the node
   *   to the end of the node.
   * * `between`: the symbols between the property and value
   *   for declarations, selector and `{` for rules, or last parameter
   *   and `{` for at-rules.
   * * `semicolon`: contains true if the last child has
   *   an (optional) semicolon.
   * * `afterName`: the space between the at-rule name and its parameters.
   *
   * PostCSS cleans at-rule parameters from comments and extra spaces,
   * but it stores origin content in raws properties.
   * As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('  @media\nprint {\n}')
   * root.first.first.raws //=> { before: '  ',
   *                       //     between: ' ',
   *                       //     afterName: '\n',
   *                       //     after: '\n' }
   */
  ;

  return AtRule;
}(_container.default);

var _default = AtRule;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImF0LXJ1bGUuZXM2Il0sIm5hbWVzIjpbIkF0UnVsZSIsImRlZmF1bHRzIiwidHlwZSIsImFwcGVuZCIsIm5vZGVzIiwiY2hpbGRyZW4iLCJwcmVwZW5kIiwiQ29udGFpbmVyIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBa0JNQSxNOzs7OztBQUNKLGtCQUFhQyxRQUFiLEVBQXVCO0FBQUE7O0FBQ3JCLGtDQUFNQSxRQUFOO0FBQ0EsVUFBS0MsSUFBTCxHQUFZLFFBQVo7QUFGcUI7QUFHdEI7Ozs7U0FFREMsTSxHQUFBLGtCQUFxQjtBQUFBOztBQUNuQixRQUFJLENBQUMsS0FBS0MsS0FBVixFQUFpQixLQUFLQSxLQUFMLEdBQWEsRUFBYjs7QUFERSxzQ0FBVkMsUUFBVTtBQUFWQSxNQUFBQSxRQUFVO0FBQUE7O0FBRW5CLHlEQUFhRixNQUFiLGtEQUF1QkUsUUFBdkI7QUFDRCxHOztTQUVEQyxPLEdBQUEsbUJBQXNCO0FBQUE7O0FBQ3BCLFFBQUksQ0FBQyxLQUFLRixLQUFWLEVBQWlCLEtBQUtBLEtBQUwsR0FBYSxFQUFiOztBQURHLHVDQUFWQyxRQUFVO0FBQVZBLE1BQUFBLFFBQVU7QUFBQTs7QUFFcEIsMERBQWFDLE9BQWIsbURBQXdCRCxRQUF4QjtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUF0Q21CRSxrQjs7ZUF1RU5QLE0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vY29udGFpbmVyJ1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYXQtcnVsZS5cbiAqXG4gKiBJZiBpdOKAmXMgZm9sbG93ZWQgaW4gdGhlIENTUyBieSBhIHt9IGJsb2NrLCB0aGlzIG5vZGUgd2lsbCBoYXZlXG4gKiBhIG5vZGVzIHByb3BlcnR5IHJlcHJlc2VudGluZyBpdHMgY2hpbGRyZW4uXG4gKlxuICogQGV4dGVuZHMgQ29udGFpbmVyXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdAY2hhcnNldCBcIlVURi04XCI7IEBtZWRpYSBwcmludCB7fScpXG4gKlxuICogY29uc3QgY2hhcnNldCA9IHJvb3QuZmlyc3RcbiAqIGNoYXJzZXQudHlwZSAgLy89PiAnYXRydWxlJ1xuICogY2hhcnNldC5ub2RlcyAvLz0+IHVuZGVmaW5lZFxuICpcbiAqIGNvbnN0IG1lZGlhID0gcm9vdC5sYXN0XG4gKiBtZWRpYS5ub2RlcyAgIC8vPT4gW11cbiAqL1xuY2xhc3MgQXRSdWxlIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IgKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGVmYXVsdHMpXG4gICAgdGhpcy50eXBlID0gJ2F0cnVsZSdcbiAgfVxuXG4gIGFwcGVuZCAoLi4uY2hpbGRyZW4pIHtcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXVxuICAgIHJldHVybiBzdXBlci5hcHBlbmQoLi4uY2hpbGRyZW4pXG4gIH1cblxuICBwcmVwZW5kICguLi5jaGlsZHJlbikge1xuICAgIGlmICghdGhpcy5ub2RlcykgdGhpcy5ub2RlcyA9IFtdXG4gICAgcmV0dXJuIHN1cGVyLnByZXBlbmQoLi4uY2hpbGRyZW4pXG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlcm9mIEF0UnVsZSNcbiAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lIFRoZSBhdC1ydWxl4oCZcyBuYW1lIGltbWVkaWF0ZWx5IGZvbGxvd3MgdGhlIGBAYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCAgPSBwb3N0Y3NzLnBhcnNlKCdAbWVkaWEgcHJpbnQge30nKVxuICAgKiBtZWRpYS5uYW1lIC8vPT4gJ21lZGlhJ1xuICAgKiBjb25zdCBtZWRpYSA9IHJvb3QuZmlyc3RcbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBBdFJ1bGUjXG4gICAqIEBtZW1iZXIge3N0cmluZ30gcGFyYW1zIFRoZSBhdC1ydWxl4oCZcyBwYXJhbWV0ZXJzLCB0aGUgdmFsdWVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgZm9sbG93IHRoZSBhdC1ydWxl4oCZcyBuYW1lIGJ1dCBwcmVjZWRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIGFueSB7fSBibG9jay5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCAgPSBwb3N0Y3NzLnBhcnNlKCdAbWVkaWEgcHJpbnQsIHNjcmVlbiB7fScpXG4gICAqIGNvbnN0IG1lZGlhID0gcm9vdC5maXJzdFxuICAgKiBtZWRpYS5wYXJhbXMgLy89PiAncHJpbnQsIHNjcmVlbidcbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBBdFJ1bGUjXG4gICAqIEBtZW1iZXIge29iamVjdH0gcmF3cyBJbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSBieXRlLXRvLWJ5dGUgZXF1YWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBub2RlIHN0cmluZyBhcyBpdCB3YXMgaW4gdGhlIG9yaWdpbiBpbnB1dC5cbiAgICpcbiAgICogRXZlcnkgcGFyc2VyIHNhdmVzIGl0cyBvd24gcHJvcGVydGllcyxcbiAgICogYnV0IHRoZSBkZWZhdWx0IENTUyBwYXJzZXIgdXNlczpcbiAgICpcbiAgICogKiBgYmVmb3JlYDogdGhlIHNwYWNlIHN5bWJvbHMgYmVmb3JlIHRoZSBub2RlLiBJdCBhbHNvIHN0b3JlcyBgKmBcbiAgICogICBhbmQgYF9gIHN5bWJvbHMgYmVmb3JlIHRoZSBkZWNsYXJhdGlvbiAoSUUgaGFjaykuXG4gICAqICogYGFmdGVyYDogdGhlIHNwYWNlIHN5bWJvbHMgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQgb2YgdGhlIG5vZGVcbiAgICogICB0byB0aGUgZW5kIG9mIHRoZSBub2RlLlxuICAgKiAqIGBiZXR3ZWVuYDogdGhlIHN5bWJvbHMgYmV0d2VlbiB0aGUgcHJvcGVydHkgYW5kIHZhbHVlXG4gICAqICAgZm9yIGRlY2xhcmF0aW9ucywgc2VsZWN0b3IgYW5kIGB7YCBmb3IgcnVsZXMsIG9yIGxhc3QgcGFyYW1ldGVyXG4gICAqICAgYW5kIGB7YCBmb3IgYXQtcnVsZXMuXG4gICAqICogYHNlbWljb2xvbmA6IGNvbnRhaW5zIHRydWUgaWYgdGhlIGxhc3QgY2hpbGQgaGFzXG4gICAqICAgYW4gKG9wdGlvbmFsKSBzZW1pY29sb24uXG4gICAqICogYGFmdGVyTmFtZWA6IHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBhdC1ydWxlIG5hbWUgYW5kIGl0cyBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBQb3N0Q1NTIGNsZWFucyBhdC1ydWxlIHBhcmFtZXRlcnMgZnJvbSBjb21tZW50cyBhbmQgZXh0cmEgc3BhY2VzLFxuICAgKiBidXQgaXQgc3RvcmVzIG9yaWdpbiBjb250ZW50IGluIHJhd3MgcHJvcGVydGllcy5cbiAgICogQXMgc3VjaCwgaWYgeW91IGRvbuKAmXQgY2hhbmdlIGEgZGVjbGFyYXRpb27igJlzIHZhbHVlLFxuICAgKiBQb3N0Q1NTIHdpbGwgdXNlIHRoZSByYXcgdmFsdWUgd2l0aCBjb21tZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJyAgQG1lZGlhXFxucHJpbnQge1xcbn0nKVxuICAgKiByb290LmZpcnN0LmZpcnN0LnJhd3MgLy89PiB7IGJlZm9yZTogJyAgJyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBiZXR3ZWVuOiAnICcsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgYWZ0ZXJOYW1lOiAnXFxuJyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBhZnRlcjogJ1xcbicgfVxuICAgKi9cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXRSdWxlXG4iXSwiZmlsZSI6ImF0LXJ1bGUuanMifQ==


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _declaration = _interopRequireDefault(__webpack_require__(15));

var _comment = _interopRequireDefault(__webpack_require__(20));

var _node = _interopRequireDefault(__webpack_require__(16));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function cleanSource(nodes) {
  return nodes.map(function (i) {
    if (i.nodes) i.nodes = cleanSource(i.nodes);
    delete i.source;
    return i;
  });
}
/**
 * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes
 * inherit some common methods to help work with their children.
 *
 * Note that all containers can store any content. If you write a rule inside
 * a rule, PostCSS will parse it.
 *
 * @extends Node
 * @abstract
 */


var Container =
/*#__PURE__*/
function (_Node) {
  _inheritsLoose(Container, _Node);

  function Container() {
    return _Node.apply(this, arguments) || this;
  }

  var _proto = Container.prototype;

  _proto.push = function push(child) {
    child.parent = this;
    this.nodes.push(child);
    return this;
  }
  /**
   * Iterates through the container’s immediate children,
   * calling `callback` for each child.
   *
   * Returning `false` in the callback will break iteration.
   *
   * This method only iterates through the container’s immediate children.
   * If you need to recursively iterate through all the container’s descendant
   * nodes, use {@link Container#walk}.
   *
   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
   * if you are mutating the array of child nodes during iteration.
   * PostCSS will adjust the current index to match the mutations.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * const root = postcss.parse('a { color: black; z-index: 1 }')
   * const rule = root.first
   *
   * for (const decl of rule.nodes) {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Cycle will be infinite, because cloneBefore moves the current node
   *   // to the next index
   * }
   *
   * rule.each(decl => {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Will be executed only for color and z-index
   * })
   */
  ;

  _proto.each = function each(callback) {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};
    this.lastEach += 1;
    var id = this.lastEach;
    this.indexes[id] = 0;
    if (!this.nodes) return undefined;
    var index, result;

    while (this.indexes[id] < this.nodes.length) {
      index = this.indexes[id];
      result = callback(this.nodes[index], index);
      if (result === false) break;
      this.indexes[id] += 1;
    }

    delete this.indexes[id];
    return result;
  }
  /**
   * Traverses the container’s descendant nodes, calling callback
   * for each node.
   *
   * Like container.each(), this method is safe to use
   * if you are mutating arrays during iteration.
   *
   * If you only need to iterate through the container’s immediate children,
   * use {@link Container#each}.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walk(node => {
   *   // Traverses all descendant nodes.
   * })
   */
  ;

  _proto.walk = function walk(callback) {
    return this.each(function (child, i) {
      var result;

      try {
        result = callback(child, i);
      } catch (e) {
        e.postcssNode = child;

        if (e.stack && child.source && /\n\s{4}at /.test(e.stack)) {
          var s = child.source;
          e.stack = e.stack.replace(/\n\s{4}at /, "$&" + s.input.from + ":" + s.start.line + ":" + s.start.column + "$&");
        }

        throw e;
      }

      if (result !== false && child.walk) {
        result = child.walk(callback);
      }

      return result;
    });
  }
  /**
   * Traverses the container’s descendant nodes, calling callback
   * for each declaration node.
   *
   * If you pass a filter, iteration will only happen over declarations
   * with matching properties.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [prop]   String or regular expression
   *                                 to filter declarations by property name.
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkDecls(decl => {
   *   checkPropertySupport(decl.prop)
   * })
   *
   * root.walkDecls('border-radius', decl => {
   *   decl.remove()
   * })
   *
   * root.walkDecls(/^background/, decl => {
   *   decl.value = takeFirstColorFromGradient(decl.value)
   * })
   */
  ;

  _proto.walkDecls = function walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk(function (child, i) {
        if (child.type === 'decl') {
          return callback(child, i);
        }
      });
    }

    if (prop instanceof RegExp) {
      return this.walk(function (child, i) {
        if (child.type === 'decl' && prop.test(child.prop)) {
          return callback(child, i);
        }
      });
    }

    return this.walk(function (child, i) {
      if (child.type === 'decl' && child.prop === prop) {
        return callback(child, i);
      }
    });
  }
  /**
   * Traverses the container’s descendant nodes, calling callback
   * for each rule node.
   *
   * If you pass a filter, iteration will only happen over rules
   * with matching selectors.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [selector] String or regular expression
   *                                   to filter rules by selector.
   * @param {childIterator} callback   Iterator receives each node and index.
   *
   * @return {false|undefined} returns `false` if iteration was broke.
   *
   * @example
   * const selectors = []
   * root.walkRules(rule => {
   *   selectors.push(rule.selector)
   * })
   * console.log(`Your CSS uses ${ selectors.length } selectors`)
   */
  ;

  _proto.walkRules = function walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk(function (child, i) {
        if (child.type === 'rule') {
          return callback(child, i);
        }
      });
    }

    if (selector instanceof RegExp) {
      return this.walk(function (child, i) {
        if (child.type === 'rule' && selector.test(child.selector)) {
          return callback(child, i);
        }
      });
    }

    return this.walk(function (child, i) {
      if (child.type === 'rule' && child.selector === selector) {
        return callback(child, i);
      }
    });
  }
  /**
   * Traverses the container’s descendant nodes, calling callback
   * for each at-rule node.
   *
   * If you pass a filter, iteration will only happen over at-rules
   * that have matching names.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [name]   String or regular expression
   *                                 to filter at-rules by name.
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkAtRules(rule => {
   *   if (isOld(rule.name)) rule.remove()
   * })
   *
   * let first = false
   * root.walkAtRules('charset', rule => {
   *   if (!first) {
   *     first = true
   *   } else {
   *     rule.remove()
   *   }
   * })
   */
  ;

  _proto.walkAtRules = function walkAtRules(name, callback) {
    if (!callback) {
      callback = name;
      return this.walk(function (child, i) {
        if (child.type === 'atrule') {
          return callback(child, i);
        }
      });
    }

    if (name instanceof RegExp) {
      return this.walk(function (child, i) {
        if (child.type === 'atrule' && name.test(child.name)) {
          return callback(child, i);
        }
      });
    }

    return this.walk(function (child, i) {
      if (child.type === 'atrule' && child.name === name) {
        return callback(child, i);
      }
    });
  }
  /**
   * Traverses the container’s descendant nodes, calling callback
   * for each comment node.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkComments(comment => {
   *   comment.remove()
   * })
   */
  ;

  _proto.walkComments = function walkComments(callback) {
    return this.walk(function (child, i) {
      if (child.type === 'comment') {
        return callback(child, i);
      }
    });
  }
  /**
   * Inserts new nodes to the end of the container.
   *
   * @param {...(Node|object|string|Node[])} children New nodes.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
   * rule.append(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   */
  ;

  _proto.append = function append() {
    for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
      children[_key] = arguments[_key];
    }

    for (var _i = 0, _children = children; _i < _children.length; _i++) {
      var child = _children[_i];
      var nodes = this.normalize(child, this.last);

      for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i2 >= _iterator.length) break;
          _ref = _iterator[_i2++];
        } else {
          _i2 = _iterator.next();
          if (_i2.done) break;
          _ref = _i2.value;
        }

        var node = _ref;
        this.nodes.push(node);
      }
    }

    return this;
  }
  /**
   * Inserts new nodes to the start of the container.
   *
   * @param {...(Node|object|string|Node[])} children New nodes.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
   * rule.prepend(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   */
  ;

  _proto.prepend = function prepend() {
    for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      children[_key2] = arguments[_key2];
    }

    children = children.reverse();

    for (var _iterator2 = children, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i3 >= _iterator2.length) break;
        _ref2 = _iterator2[_i3++];
      } else {
        _i3 = _iterator2.next();
        if (_i3.done) break;
        _ref2 = _i3.value;
      }

      var child = _ref2;
      var nodes = this.normalize(child, this.first, 'prepend').reverse();

      for (var _iterator3 = nodes, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i4 >= _iterator3.length) break;
          _ref3 = _iterator3[_i4++];
        } else {
          _i4 = _iterator3.next();
          if (_i4.done) break;
          _ref3 = _i4.value;
        }

        var node = _ref3;
        this.nodes.unshift(node);
      }

      for (var id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }

    return this;
  };

  _proto.cleanRaws = function cleanRaws(keepBetween) {
    _Node.prototype.cleanRaws.call(this, keepBetween);

    if (this.nodes) {
      for (var _iterator4 = this.nodes, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref4;

        if (_isArray4) {
          if (_i5 >= _iterator4.length) break;
          _ref4 = _iterator4[_i5++];
        } else {
          _i5 = _iterator4.next();
          if (_i5.done) break;
          _ref4 = _i5.value;
        }

        var node = _ref4;
        node.cleanRaws(keepBetween);
      }
    }
  }
  /**
   * Insert new node before old node within the container.
   *
   * @param {Node|number} exist             Child or child’s index.
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))
   */
  ;

  _proto.insertBefore = function insertBefore(exist, add) {
    exist = this.index(exist);
    var type = exist === 0 ? 'prepend' : false;
    var nodes = this.normalize(add, this.nodes[exist], type).reverse();

    for (var _iterator5 = nodes, _isArray5 = Array.isArray(_iterator5), _i6 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray5) {
        if (_i6 >= _iterator5.length) break;
        _ref5 = _iterator5[_i6++];
      } else {
        _i6 = _iterator5.next();
        if (_i6.done) break;
        _ref5 = _i6.value;
      }

      var node = _ref5;
      this.nodes.splice(exist, 0, node);
    }

    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (exist <= index) {
        this.indexes[id] = index + nodes.length;
      }
    }

    return this;
  }
  /**
   * Insert new node after old node within the container.
   *
   * @param {Node|number} exist             Child or child’s index.
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   */
  ;

  _proto.insertAfter = function insertAfter(exist, add) {
    exist = this.index(exist);
    var nodes = this.normalize(add, this.nodes[exist]).reverse();

    for (var _iterator6 = nodes, _isArray6 = Array.isArray(_iterator6), _i7 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
      var _ref6;

      if (_isArray6) {
        if (_i7 >= _iterator6.length) break;
        _ref6 = _iterator6[_i7++];
      } else {
        _i7 = _iterator6.next();
        if (_i7.done) break;
        _ref6 = _i7.value;
      }

      var node = _ref6;
      this.nodes.splice(exist + 1, 0, node);
    }

    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (exist < index) {
        this.indexes[id] = index + nodes.length;
      }
    }

    return this;
  }
  /**
   * Removes node from the container and cleans the parent properties
   * from the node and its children.
   *
   * @param {Node|number} child Child or child’s index.
   *
   * @return {Node} This node for methods chain
   *
   * @example
   * rule.nodes.length  //=> 5
   * rule.removeChild(decl)
   * rule.nodes.length  //=> 4
   * decl.parent        //=> undefined
   */
  ;

  _proto.removeChild = function removeChild(child) {
    child = this.index(child);
    this.nodes[child].parent = undefined;
    this.nodes.splice(child, 1);
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }

    return this;
  }
  /**
   * Removes all children from the container
   * and cleans their parent properties.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * rule.removeAll()
   * rule.nodes.length //=> 0
   */
  ;

  _proto.removeAll = function removeAll() {
    for (var _iterator7 = this.nodes, _isArray7 = Array.isArray(_iterator7), _i8 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
      var _ref7;

      if (_isArray7) {
        if (_i8 >= _iterator7.length) break;
        _ref7 = _iterator7[_i8++];
      } else {
        _i8 = _iterator7.next();
        if (_i8.done) break;
        _ref7 = _i8.value;
      }

      var node = _ref7;
      node.parent = undefined;
    }

    this.nodes = [];
    return this;
  }
  /**
   * Passes all declaration values within the container that match pattern
   * through callback, replacing those values with the returned result
   * of callback.
   *
   * This method is useful if you are using a custom unit or function
   * and need to iterate through all values.
   *
   * @param {string|RegExp} pattern      Replace pattern.
   * @param {object} opts                Options to speed up the search.
   * @param {string|string[]} opts.props An array of property names.
   * @param {string} opts.fast           String that’s used to narrow down
   *                                     values and speed up the regexp search.
   * @param {function|string} callback   String to replace pattern or callback
   *                                     that returns a new value. The callback
   *                                     will receive the same arguments
   *                                     as those passed to a function parameter
   *                                     of `String#replace`.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
   *   return 15 * parseInt(string) + 'px'
   * })
   */
  ;

  _proto.replaceValues = function replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }

    this.walkDecls(function (decl) {
      if (opts.props && opts.props.indexOf(decl.prop) === -1) return;
      if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;
      decl.value = decl.value.replace(pattern, callback);
    });
    return this;
  }
  /**
   * Returns `true` if callback returns `true`
   * for all of the container’s children.
   *
   * @param {childCondition} condition Iterator returns true or false.
   *
   * @return {boolean} Is every child pass condition.
   *
   * @example
   * const noPrefixes = rule.every(i => i.prop[0] !== '-')
   */
  ;

  _proto.every = function every(condition) {
    return this.nodes.every(condition);
  }
  /**
   * Returns `true` if callback returns `true` for (at least) one
   * of the container’s children.
   *
   * @param {childCondition} condition Iterator returns true or false.
   *
   * @return {boolean} Is some child pass condition.
   *
   * @example
   * const hasPrefix = rule.some(i => i.prop[0] === '-')
   */
  ;

  _proto.some = function some(condition) {
    return this.nodes.some(condition);
  }
  /**
   * Returns a `child`’s index within the {@link Container#nodes} array.
   *
   * @param {Node} child Child of the current container.
   *
   * @return {number} Child index.
   *
   * @example
   * rule.index( rule.nodes[2] ) //=> 2
   */
  ;

  _proto.index = function index(child) {
    if (typeof child === 'number') {
      return child;
    }

    return this.nodes.indexOf(child);
  }
  /**
   * The container’s first child.
   *
   * @type {Node}
   *
   * @example
   * rule.first === rules.nodes[0]
   */
  ;

  _proto.normalize = function normalize(nodes, sample) {
    var _this = this;

    if (typeof nodes === 'string') {
      var parse = __webpack_require__(19);

      nodes = cleanSource(parse(nodes).nodes);
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);

      for (var _iterator8 = nodes, _isArray8 = Array.isArray(_iterator8), _i9 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
        var _ref8;

        if (_isArray8) {
          if (_i9 >= _iterator8.length) break;
          _ref8 = _iterator8[_i9++];
        } else {
          _i9 = _iterator8.next();
          if (_i9.done) break;
          _ref8 = _i9.value;
        }

        var i = _ref8;
        if (i.parent) i.parent.removeChild(i, 'ignore');
      }
    } else if (nodes.type === 'root') {
      nodes = nodes.nodes.slice(0);

      for (var _iterator9 = nodes, _isArray9 = Array.isArray(_iterator9), _i10 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
        var _ref9;

        if (_isArray9) {
          if (_i10 >= _iterator9.length) break;
          _ref9 = _iterator9[_i10++];
        } else {
          _i10 = _iterator9.next();
          if (_i10.done) break;
          _ref9 = _i10.value;
        }

        var _i11 = _ref9;
        if (_i11.parent) _i11.parent.removeChild(_i11, 'ignore');
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === 'undefined') {
        throw new Error('Value field is missed in node creation');
      } else if (typeof nodes.value !== 'string') {
        nodes.value = String(nodes.value);
      }

      nodes = [new _declaration.default(nodes)];
    } else if (nodes.selector) {
      var Rule = __webpack_require__(23);

      nodes = [new Rule(nodes)];
    } else if (nodes.name) {
      var AtRule = __webpack_require__(21);

      nodes = [new AtRule(nodes)];
    } else if (nodes.text) {
      nodes = [new _comment.default(nodes)];
    } else {
      throw new Error('Unknown node type in node creation');
    }

    var processed = nodes.map(function (i) {
      if (i.parent) i.parent.removeChild(i);

      if (typeof i.raws.before === 'undefined') {
        if (sample && typeof sample.raws.before !== 'undefined') {
          i.raws.before = sample.raws.before.replace(/[^\s]/g, '');
        }
      }

      i.parent = _this;
      return i;
    });
    return processed;
  }
  /**
   * @memberof Container#
   * @member {Node[]} nodes An array containing the container’s children.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * root.nodes.length           //=> 1
   * root.nodes[0].selector      //=> 'a'
   * root.nodes[0].nodes[0].prop //=> 'color'
   */
  ;

  _createClass(Container, [{
    key: "first",
    get: function get() {
      if (!this.nodes) return undefined;
      return this.nodes[0];
    }
    /**
     * The container’s last child.
     *
     * @type {Node}
     *
     * @example
     * rule.last === rule.nodes[rule.nodes.length - 1]
     */

  }, {
    key: "last",
    get: function get() {
      if (!this.nodes) return undefined;
      return this.nodes[this.nodes.length - 1];
    }
  }]);

  return Container;
}(_node.default);

var _default = Container;
/**
 * @callback childCondition
 * @param {Node} node    Container child.
 * @param {number} index Child index.
 * @param {Node[]} nodes All container children.
 * @return {boolean}
 */

/**
 * @callback childIterator
 * @param {Node} node    Container child.
 * @param {number} index Child index.
 * @return {false|undefined} Returning `false` will break iteration.
 */

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbnRhaW5lci5lczYiXSwibmFtZXMiOlsiY2xlYW5Tb3VyY2UiLCJub2RlcyIsIm1hcCIsImkiLCJzb3VyY2UiLCJDb250YWluZXIiLCJwdXNoIiwiY2hpbGQiLCJwYXJlbnQiLCJlYWNoIiwiY2FsbGJhY2siLCJsYXN0RWFjaCIsImluZGV4ZXMiLCJpZCIsInVuZGVmaW5lZCIsImluZGV4IiwicmVzdWx0IiwibGVuZ3RoIiwid2FsayIsImUiLCJwb3N0Y3NzTm9kZSIsInN0YWNrIiwidGVzdCIsInMiLCJyZXBsYWNlIiwiaW5wdXQiLCJmcm9tIiwic3RhcnQiLCJsaW5lIiwiY29sdW1uIiwid2Fsa0RlY2xzIiwicHJvcCIsInR5cGUiLCJSZWdFeHAiLCJ3YWxrUnVsZXMiLCJzZWxlY3RvciIsIndhbGtBdFJ1bGVzIiwibmFtZSIsIndhbGtDb21tZW50cyIsImFwcGVuZCIsImNoaWxkcmVuIiwibm9ybWFsaXplIiwibGFzdCIsIm5vZGUiLCJwcmVwZW5kIiwicmV2ZXJzZSIsImZpcnN0IiwidW5zaGlmdCIsImNsZWFuUmF3cyIsImtlZXBCZXR3ZWVuIiwiaW5zZXJ0QmVmb3JlIiwiZXhpc3QiLCJhZGQiLCJzcGxpY2UiLCJpbnNlcnRBZnRlciIsInJlbW92ZUNoaWxkIiwicmVtb3ZlQWxsIiwicmVwbGFjZVZhbHVlcyIsInBhdHRlcm4iLCJvcHRzIiwiZGVjbCIsInByb3BzIiwiaW5kZXhPZiIsImZhc3QiLCJ2YWx1ZSIsImV2ZXJ5IiwiY29uZGl0aW9uIiwic29tZSIsInNhbXBsZSIsInBhcnNlIiwicmVxdWlyZSIsIkFycmF5IiwiaXNBcnJheSIsInNsaWNlIiwiRXJyb3IiLCJTdHJpbmciLCJEZWNsYXJhdGlvbiIsIlJ1bGUiLCJBdFJ1bGUiLCJ0ZXh0IiwiQ29tbWVudCIsInByb2Nlc3NlZCIsInJhd3MiLCJiZWZvcmUiLCJOb2RlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0FBRUEsU0FBU0EsV0FBVCxDQUFz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QVA7QUFDakIsYUFBTyxLQUFLYixLQUFMLENBQVcsQ0FBWCxDQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7d0JBUVk7QUFDVixVQUFJLENBQUMsS0FBS0EsS0FBVixFQUFpQixPQUFPYSxTQUFQO0FBQ2pCLGFBQU8sS0FBS2IsS0FBTCxDQUFXLEtBQUtBLEtBQUwsQ0FBV2dCLE1BQVgsR0FBb0IsQ0FBL0IsQ0FBUDtBQUNEOzs7O0VBaGpCcUJtRSxhOztlQSttQlQvRSxTO0FBRWY7Ozs7Ozs7O0FBUUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGVjbGFyYXRpb24gZnJvbSAnLi9kZWNsYXJhdGlvbidcbmltcG9ydCBDb21tZW50IGZyb20gJy4vY29tbWVudCdcbmltcG9ydCBOb2RlIGZyb20gJy4vbm9kZSdcblxuZnVuY3Rpb24gY2xlYW5Tb3VyY2UgKG5vZGVzKSB7XG4gIHJldHVybiBub2Rlcy5tYXAoaSA9PiB7XG4gICAgaWYgKGkubm9kZXMpIGkubm9kZXMgPSBjbGVhblNvdXJjZShpLm5vZGVzKVxuICAgIGRlbGV0ZSBpLnNvdXJjZVxuICAgIHJldHVybiBpXG4gIH0pXG59XG5cbi8qKlxuICogVGhlIHtAbGluayBSb290fSwge0BsaW5rIEF0UnVsZX0sIGFuZCB7QGxpbmsgUnVsZX0gY29udGFpbmVyIG5vZGVzXG4gKiBpbmhlcml0IHNvbWUgY29tbW9uIG1ldGhvZHMgdG8gaGVscCB3b3JrIHdpdGggdGhlaXIgY2hpbGRyZW4uXG4gKlxuICogTm90ZSB0aGF0IGFsbCBjb250YWluZXJzIGNhbiBzdG9yZSBhbnkgY29udGVudC4gSWYgeW91IHdyaXRlIGEgcnVsZSBpbnNpZGVcbiAqIGEgcnVsZSwgUG9zdENTUyB3aWxsIHBhcnNlIGl0LlxuICpcbiAqIEBleHRlbmRzIE5vZGVcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBOb2RlIHtcbiAgcHVzaCAoY2hpbGQpIHtcbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzXG4gICAgdGhpcy5ub2Rlcy5wdXNoKGNoaWxkKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgY29udGFpbmVy4oCZcyBpbW1lZGlhdGUgY2hpbGRyZW4sXG4gICAqIGNhbGxpbmcgYGNhbGxiYWNrYCBmb3IgZWFjaCBjaGlsZC5cbiAgICpcbiAgICogUmV0dXJuaW5nIGBmYWxzZWAgaW4gdGhlIGNhbGxiYWNrIHdpbGwgYnJlYWsgaXRlcmF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBvbmx5IGl0ZXJhdGVzIHRocm91Z2ggdGhlIGNvbnRhaW5lcuKAmXMgaW1tZWRpYXRlIGNoaWxkcmVuLlxuICAgKiBJZiB5b3UgbmVlZCB0byByZWN1cnNpdmVseSBpdGVyYXRlIHRocm91Z2ggYWxsIHRoZSBjb250YWluZXLigJlzIGRlc2NlbmRhbnRcbiAgICogbm9kZXMsIHVzZSB7QGxpbmsgQ29udGFpbmVyI3dhbGt9LlxuICAgKlxuICAgKiBVbmxpa2UgdGhlIGZvciBge31gLWN5Y2xlIG9yIGBBcnJheSNmb3JFYWNoYCB0aGlzIGl0ZXJhdG9yIGlzIHNhZmVcbiAgICogaWYgeW91IGFyZSBtdXRhdGluZyB0aGUgYXJyYXkgb2YgY2hpbGQgbm9kZXMgZHVyaW5nIGl0ZXJhdGlvbi5cbiAgICogUG9zdENTUyB3aWxsIGFkanVzdCB0aGUgY3VycmVudCBpbmRleCB0byBtYXRjaCB0aGUgbXV0YXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge2NoaWxkSXRlcmF0b3J9IGNhbGxiYWNrIEl0ZXJhdG9yIHJlY2VpdmVzIGVhY2ggbm9kZSBhbmQgaW5kZXguXG4gICAqXG4gICAqIEByZXR1cm4ge2ZhbHNlfHVuZGVmaW5lZH0gUmV0dXJucyBgZmFsc2VgIGlmIGl0ZXJhdGlvbiB3YXMgYnJva2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdhIHsgY29sb3I6IGJsYWNrOyB6LWluZGV4OiAxIH0nKVxuICAgKiBjb25zdCBydWxlID0gcm9vdC5maXJzdFxuICAgKlxuICAgKiBmb3IgKGNvbnN0IGRlY2wgb2YgcnVsZS5ub2Rlcykge1xuICAgKiAgIGRlY2wuY2xvbmVCZWZvcmUoeyBwcm9wOiAnLXdlYmtpdC0nICsgZGVjbC5wcm9wIH0pXG4gICAqICAgLy8gQ3ljbGUgd2lsbCBiZSBpbmZpbml0ZSwgYmVjYXVzZSBjbG9uZUJlZm9yZSBtb3ZlcyB0aGUgY3VycmVudCBub2RlXG4gICAqICAgLy8gdG8gdGhlIG5leHQgaW5kZXhcbiAgICogfVxuICAgKlxuICAgKiBydWxlLmVhY2goZGVjbCA9PiB7XG4gICAqICAgZGVjbC5jbG9uZUJlZm9yZSh7IHByb3A6ICctd2Via2l0LScgKyBkZWNsLnByb3AgfSlcbiAgICogICAvLyBXaWxsIGJlIGV4ZWN1dGVkIG9ubHkgZm9yIGNvbG9yIGFuZCB6LWluZGV4XG4gICAqIH0pXG4gICAqL1xuICBlYWNoIChjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5sYXN0RWFjaCkgdGhpcy5sYXN0RWFjaCA9IDBcbiAgICBpZiAoIXRoaXMuaW5kZXhlcykgdGhpcy5pbmRleGVzID0geyB9XG5cbiAgICB0aGlzLmxhc3RFYWNoICs9IDFcbiAgICBsZXQgaWQgPSB0aGlzLmxhc3RFYWNoXG4gICAgdGhpcy5pbmRleGVzW2lkXSA9IDBcblxuICAgIGlmICghdGhpcy5ub2RlcykgcmV0dXJuIHVuZGVmaW5lZFxuXG4gICAgbGV0IGluZGV4LCByZXN1bHRcbiAgICB3aGlsZSAodGhpcy5pbmRleGVzW2lkXSA8IHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpZF1cbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHRoaXMubm9kZXNbaW5kZXhdLCBpbmRleClcbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSBicmVha1xuXG4gICAgICB0aGlzLmluZGV4ZXNbaWRdICs9IDFcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5pbmRleGVzW2lkXVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgY29udGFpbmVy4oCZcyBkZXNjZW5kYW50IG5vZGVzLCBjYWxsaW5nIGNhbGxiYWNrXG4gICAqIGZvciBlYWNoIG5vZGUuXG4gICAqXG4gICAqIExpa2UgY29udGFpbmVyLmVhY2goKSwgdGhpcyBtZXRob2QgaXMgc2FmZSB0byB1c2VcbiAgICogaWYgeW91IGFyZSBtdXRhdGluZyBhcnJheXMgZHVyaW5nIGl0ZXJhdGlvbi5cbiAgICpcbiAgICogSWYgeW91IG9ubHkgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggdGhlIGNvbnRhaW5lcuKAmXMgaW1tZWRpYXRlIGNoaWxkcmVuLFxuICAgKiB1c2Uge0BsaW5rIENvbnRhaW5lciNlYWNofS5cbiAgICpcbiAgICogQHBhcmFtIHtjaGlsZEl0ZXJhdG9yfSBjYWxsYmFjayBJdGVyYXRvciByZWNlaXZlcyBlYWNoIG5vZGUgYW5kIGluZGV4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWxzZXx1bmRlZmluZWR9IFJldHVybnMgYGZhbHNlYCBpZiBpdGVyYXRpb24gd2FzIGJyb2tlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiByb290LndhbGsobm9kZSA9PiB7XG4gICAqICAgLy8gVHJhdmVyc2VzIGFsbCBkZXNjZW5kYW50IG5vZGVzLlxuICAgKiB9KVxuICAgKi9cbiAgd2FsayAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKChjaGlsZCwgaSkgPT4ge1xuICAgICAgbGV0IHJlc3VsdFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGUucG9zdGNzc05vZGUgPSBjaGlsZFxuICAgICAgICBpZiAoZS5zdGFjayAmJiBjaGlsZC5zb3VyY2UgJiYgL1xcblxcc3s0fWF0IC8udGVzdChlLnN0YWNrKSkge1xuICAgICAgICAgIGxldCBzID0gY2hpbGQuc291cmNlXG4gICAgICAgICAgZS5zdGFjayA9IGUuc3RhY2sucmVwbGFjZSgvXFxuXFxzezR9YXQgLyxcbiAgICAgICAgICAgIGAkJiR7IHMuaW5wdXQuZnJvbSB9OiR7IHMuc3RhcnQubGluZSB9OiR7IHMuc3RhcnQuY29sdW1uIH0kJmApXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UgJiYgY2hpbGQud2Fsaykge1xuICAgICAgICByZXN1bHQgPSBjaGlsZC53YWxrKGNhbGxiYWNrKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSBjb250YWluZXLigJlzIGRlc2NlbmRhbnQgbm9kZXMsIGNhbGxpbmcgY2FsbGJhY2tcbiAgICogZm9yIGVhY2ggZGVjbGFyYXRpb24gbm9kZS5cbiAgICpcbiAgICogSWYgeW91IHBhc3MgYSBmaWx0ZXIsIGl0ZXJhdGlvbiB3aWxsIG9ubHkgaGFwcGVuIG92ZXIgZGVjbGFyYXRpb25zXG4gICAqIHdpdGggbWF0Y2hpbmcgcHJvcGVydGllcy5cbiAgICpcbiAgICogTGlrZSB7QGxpbmsgQ29udGFpbmVyI2VhY2h9LCB0aGlzIG1ldGhvZCBpcyBzYWZlXG4gICAqIHRvIHVzZSBpZiB5b3UgYXJlIG11dGF0aW5nIGFycmF5cyBkdXJpbmcgaXRlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IFtwcm9wXSAgIFN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBmaWx0ZXIgZGVjbGFyYXRpb25zIGJ5IHByb3BlcnR5IG5hbWUuXG4gICAqIEBwYXJhbSB7Y2hpbGRJdGVyYXRvcn0gY2FsbGJhY2sgSXRlcmF0b3IgcmVjZWl2ZXMgZWFjaCBub2RlIGFuZCBpbmRleC5cbiAgICpcbiAgICogQHJldHVybiB7ZmFsc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGBmYWxzZWAgaWYgaXRlcmF0aW9uIHdhcyBicm9rZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcm9vdC53YWxrRGVjbHMoZGVjbCA9PiB7XG4gICAqICAgY2hlY2tQcm9wZXJ0eVN1cHBvcnQoZGVjbC5wcm9wKVxuICAgKiB9KVxuICAgKlxuICAgKiByb290LndhbGtEZWNscygnYm9yZGVyLXJhZGl1cycsIGRlY2wgPT4ge1xuICAgKiAgIGRlY2wucmVtb3ZlKClcbiAgICogfSlcbiAgICpcbiAgICogcm9vdC53YWxrRGVjbHMoL15iYWNrZ3JvdW5kLywgZGVjbCA9PiB7XG4gICAqICAgZGVjbC52YWx1ZSA9IHRha2VGaXJzdENvbG9yRnJvbUdyYWRpZW50KGRlY2wudmFsdWUpXG4gICAqIH0pXG4gICAqL1xuICB3YWxrRGVjbHMgKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBwcm9wXG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2RlY2wnKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAocHJvcCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdkZWNsJyAmJiBwcm9wLnRlc3QoY2hpbGQucHJvcCkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2RlY2wnICYmIGNoaWxkLnByb3AgPT09IHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSBjb250YWluZXLigJlzIGRlc2NlbmRhbnQgbm9kZXMsIGNhbGxpbmcgY2FsbGJhY2tcbiAgICogZm9yIGVhY2ggcnVsZSBub2RlLlxuICAgKlxuICAgKiBJZiB5b3UgcGFzcyBhIGZpbHRlciwgaXRlcmF0aW9uIHdpbGwgb25seSBoYXBwZW4gb3ZlciBydWxlc1xuICAgKiB3aXRoIG1hdGNoaW5nIHNlbGVjdG9ycy5cbiAgICpcbiAgICogTGlrZSB7QGxpbmsgQ29udGFpbmVyI2VhY2h9LCB0aGlzIG1ldGhvZCBpcyBzYWZlXG4gICAqIHRvIHVzZSBpZiB5b3UgYXJlIG11dGF0aW5nIGFycmF5cyBkdXJpbmcgaXRlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IFtzZWxlY3Rvcl0gU3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gZmlsdGVyIHJ1bGVzIGJ5IHNlbGVjdG9yLlxuICAgKiBAcGFyYW0ge2NoaWxkSXRlcmF0b3J9IGNhbGxiYWNrICAgSXRlcmF0b3IgcmVjZWl2ZXMgZWFjaCBub2RlIGFuZCBpbmRleC5cbiAgICpcbiAgICogQHJldHVybiB7ZmFsc2V8dW5kZWZpbmVkfSByZXR1cm5zIGBmYWxzZWAgaWYgaXRlcmF0aW9uIHdhcyBicm9rZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgc2VsZWN0b3JzID0gW11cbiAgICogcm9vdC53YWxrUnVsZXMocnVsZSA9PiB7XG4gICAqICAgc2VsZWN0b3JzLnB1c2gocnVsZS5zZWxlY3RvcilcbiAgICogfSlcbiAgICogY29uc29sZS5sb2coYFlvdXIgQ1NTIHVzZXMgJHsgc2VsZWN0b3JzLmxlbmd0aCB9IHNlbGVjdG9yc2ApXG4gICAqL1xuICB3YWxrUnVsZXMgKHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3JcblxuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdydWxlJykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ3J1bGUnICYmIHNlbGVjdG9yLnRlc3QoY2hpbGQuc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdydWxlJyAmJiBjaGlsZC5zZWxlY3RvciA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSBjb250YWluZXLigJlzIGRlc2NlbmRhbnQgbm9kZXMsIGNhbGxpbmcgY2FsbGJhY2tcbiAgICogZm9yIGVhY2ggYXQtcnVsZSBub2RlLlxuICAgKlxuICAgKiBJZiB5b3UgcGFzcyBhIGZpbHRlciwgaXRlcmF0aW9uIHdpbGwgb25seSBoYXBwZW4gb3ZlciBhdC1ydWxlc1xuICAgKiB0aGF0IGhhdmUgbWF0Y2hpbmcgbmFtZXMuXG4gICAqXG4gICAqIExpa2Uge0BsaW5rIENvbnRhaW5lciNlYWNofSwgdGhpcyBtZXRob2QgaXMgc2FmZVxuICAgKiB0byB1c2UgaWYgeW91IGFyZSBtdXRhdGluZyBhcnJheXMgZHVyaW5nIGl0ZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBbbmFtZV0gICBTdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gZmlsdGVyIGF0LXJ1bGVzIGJ5IG5hbWUuXG4gICAqIEBwYXJhbSB7Y2hpbGRJdGVyYXRvcn0gY2FsbGJhY2sgSXRlcmF0b3IgcmVjZWl2ZXMgZWFjaCBub2RlIGFuZCBpbmRleC5cbiAgICpcbiAgICogQHJldHVybiB7ZmFsc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGBmYWxzZWAgaWYgaXRlcmF0aW9uIHdhcyBicm9rZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcm9vdC53YWxrQXRSdWxlcyhydWxlID0+IHtcbiAgICogICBpZiAoaXNPbGQocnVsZS5uYW1lKSkgcnVsZS5yZW1vdmUoKVxuICAgKiB9KVxuICAgKlxuICAgKiBsZXQgZmlyc3QgPSBmYWxzZVxuICAgKiByb290LndhbGtBdFJ1bGVzKCdjaGFyc2V0JywgcnVsZSA9PiB7XG4gICAqICAgaWYgKCFmaXJzdCkge1xuICAgKiAgICAgZmlyc3QgPSB0cnVlXG4gICAqICAgfSBlbHNlIHtcbiAgICogICAgIHJ1bGUucmVtb3ZlKClcbiAgICogICB9XG4gICAqIH0pXG4gICAqL1xuICB3YWxrQXRSdWxlcyAobmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IG5hbWVcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnYXRydWxlJykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnYXRydWxlJyAmJiBuYW1lLnRlc3QoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2F0cnVsZScgJiYgY2hpbGQubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIGNvbnRhaW5lcuKAmXMgZGVzY2VuZGFudCBub2RlcywgY2FsbGluZyBjYWxsYmFja1xuICAgKiBmb3IgZWFjaCBjb21tZW50IG5vZGUuXG4gICAqXG4gICAqIExpa2Uge0BsaW5rIENvbnRhaW5lciNlYWNofSwgdGhpcyBtZXRob2QgaXMgc2FmZVxuICAgKiB0byB1c2UgaWYgeW91IGFyZSBtdXRhdGluZyBhcnJheXMgZHVyaW5nIGl0ZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtjaGlsZEl0ZXJhdG9yfSBjYWxsYmFjayBJdGVyYXRvciByZWNlaXZlcyBlYWNoIG5vZGUgYW5kIGluZGV4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWxzZXx1bmRlZmluZWR9IFJldHVybnMgYGZhbHNlYCBpZiBpdGVyYXRpb24gd2FzIGJyb2tlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiByb290LndhbGtDb21tZW50cyhjb21tZW50ID0+IHtcbiAgICogICBjb21tZW50LnJlbW92ZSgpXG4gICAqIH0pXG4gICAqL1xuICB3YWxrQ29tbWVudHMgKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkpID0+IHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSAnY29tbWVudCcpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgbm9kZXMgdG8gdGhlIGVuZCBvZiB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLihOb2RlfG9iamVjdHxzdHJpbmd8Tm9kZVtdKX0gY2hpbGRyZW4gTmV3IG5vZGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGRlY2wxID0gcG9zdGNzcy5kZWNsKHsgcHJvcDogJ2NvbG9yJywgdmFsdWU6ICdibGFjaycgfSlcbiAgICogY29uc3QgZGVjbDIgPSBwb3N0Y3NzLmRlY2woeyBwcm9wOiAnYmFja2dyb3VuZC1jb2xvcicsIHZhbHVlOiAnd2hpdGUnIH0pXG4gICAqIHJ1bGUuYXBwZW5kKGRlY2wxLCBkZWNsMilcbiAgICpcbiAgICogcm9vdC5hcHBlbmQoeyBuYW1lOiAnY2hhcnNldCcsIHBhcmFtczogJ1wiVVRGLThcIicgfSkgIC8vIGF0LXJ1bGVcbiAgICogcm9vdC5hcHBlbmQoeyBzZWxlY3RvcjogJ2EnIH0pICAgICAgICAgICAgICAgICAgICAgICAvLyBydWxlXG4gICAqIHJ1bGUuYXBwZW5kKHsgcHJvcDogJ2NvbG9yJywgdmFsdWU6ICdibGFjaycgfSkgICAgICAgLy8gZGVjbGFyYXRpb25cbiAgICogcnVsZS5hcHBlbmQoeyB0ZXh0OiAnQ29tbWVudCcgfSkgICAgICAgICAgICAgICAgICAgICAvLyBjb21tZW50XG4gICAqXG4gICAqIHJvb3QuYXBwZW5kKCdhIHt9JylcbiAgICogcm9vdC5maXJzdC5hcHBlbmQoJ2NvbG9yOiBibGFjazsgei1pbmRleDogMScpXG4gICAqL1xuICBhcHBlbmQgKC4uLmNoaWxkcmVuKSB7XG4gICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmxhc3QpXG4gICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB0aGlzLm5vZGVzLnB1c2gobm9kZSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBub2RlcyB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHsuLi4oTm9kZXxvYmplY3R8c3RyaW5nfE5vZGVbXSl9IGNoaWxkcmVuIE5ldyBub2Rlcy5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhpcyBub2RlIGZvciBtZXRob2RzIGNoYWluLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBkZWNsMSA9IHBvc3Rjc3MuZGVjbCh7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAnYmxhY2snIH0pXG4gICAqIGNvbnN0IGRlY2wyID0gcG9zdGNzcy5kZWNsKHsgcHJvcDogJ2JhY2tncm91bmQtY29sb3InLCB2YWx1ZTogJ3doaXRlJyB9KVxuICAgKiBydWxlLnByZXBlbmQoZGVjbDEsIGRlY2wyKVxuICAgKlxuICAgKiByb290LmFwcGVuZCh7IG5hbWU6ICdjaGFyc2V0JywgcGFyYW1zOiAnXCJVVEYtOFwiJyB9KSAgLy8gYXQtcnVsZVxuICAgKiByb290LmFwcGVuZCh7IHNlbGVjdG9yOiAnYScgfSkgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1bGVcbiAgICogcnVsZS5hcHBlbmQoeyBwcm9wOiAnY29sb3InLCB2YWx1ZTogJ2JsYWNrJyB9KSAgICAgICAvLyBkZWNsYXJhdGlvblxuICAgKiBydWxlLmFwcGVuZCh7IHRleHQ6ICdDb21tZW50JyB9KSAgICAgICAgICAgICAgICAgICAgIC8vIGNvbW1lbnRcbiAgICpcbiAgICogcm9vdC5hcHBlbmQoJ2Ege30nKVxuICAgKiByb290LmZpcnN0LmFwcGVuZCgnY29sb3I6IGJsYWNrOyB6LWluZGV4OiAxJylcbiAgICovXG4gIHByZXBlbmQgKC4uLmNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5yZXZlcnNlKClcbiAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgbGV0IG5vZGVzID0gdGhpcy5ub3JtYWxpemUoY2hpbGQsIHRoaXMuZmlyc3QsICdwcmVwZW5kJykucmV2ZXJzZSgpXG4gICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB0aGlzLm5vZGVzLnVuc2hpZnQobm9kZSlcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gdGhpcy5pbmRleGVzW2lkXSArIG5vZGVzLmxlbmd0aFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY2xlYW5SYXdzIChrZWVwQmV0d2Vlbikge1xuICAgIHN1cGVyLmNsZWFuUmF3cyhrZWVwQmV0d2VlbilcbiAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSBub2RlLmNsZWFuUmF3cyhrZWVwQmV0d2VlbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IG5ldyBub2RlIGJlZm9yZSBvbGQgbm9kZSB3aXRoaW4gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfG51bWJlcn0gZXhpc3QgICAgICAgICAgICAgQ2hpbGQgb3IgY2hpbGTigJlzIGluZGV4LlxuICAgKiBAcGFyYW0ge05vZGV8b2JqZWN0fHN0cmluZ3xOb2RlW119IGFkZCBOZXcgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhpcyBub2RlIGZvciBtZXRob2RzIGNoYWluLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBydWxlLmluc2VydEJlZm9yZShkZWNsLCBkZWNsLmNsb25lKHsgcHJvcDogJy13ZWJraXQtJyArIGRlY2wucHJvcCB9KSlcbiAgICovXG4gIGluc2VydEJlZm9yZSAoZXhpc3QsIGFkZCkge1xuICAgIGV4aXN0ID0gdGhpcy5pbmRleChleGlzdClcblxuICAgIGxldCB0eXBlID0gZXhpc3QgPT09IDAgPyAncHJlcGVuZCcgOiBmYWxzZVxuICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGFkZCwgdGhpcy5ub2Rlc1tleGlzdF0sIHR5cGUpLnJldmVyc2UoKVxuICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpIHRoaXMubm9kZXMuc3BsaWNlKGV4aXN0LCAwLCBub2RlKVxuXG4gICAgbGV0IGluZGV4XG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpZF1cbiAgICAgIGlmIChleGlzdCA8PSBpbmRleCkge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXggKyBub2Rlcy5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBuZXcgbm9kZSBhZnRlciBvbGQgbm9kZSB3aXRoaW4gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfG51bWJlcn0gZXhpc3QgICAgICAgICAgICAgQ2hpbGQgb3IgY2hpbGTigJlzIGluZGV4LlxuICAgKiBAcGFyYW0ge05vZGV8b2JqZWN0fHN0cmluZ3xOb2RlW119IGFkZCBOZXcgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhpcyBub2RlIGZvciBtZXRob2RzIGNoYWluLlxuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIgKGV4aXN0LCBhZGQpIHtcbiAgICBleGlzdCA9IHRoaXMuaW5kZXgoZXhpc3QpXG5cbiAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMubm9kZXNbZXhpc3RdKS5yZXZlcnNlKClcbiAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB0aGlzLm5vZGVzLnNwbGljZShleGlzdCArIDEsIDAsIG5vZGUpXG5cbiAgICBsZXQgaW5kZXhcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXVxuICAgICAgaWYgKGV4aXN0IDwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4ICsgbm9kZXMubGVuZ3RoXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIG5vZGUgZnJvbSB0aGUgY29udGFpbmVyIGFuZCBjbGVhbnMgdGhlIHBhcmVudCBwcm9wZXJ0aWVzXG4gICAqIGZyb20gdGhlIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfG51bWJlcn0gY2hpbGQgQ2hpbGQgb3IgY2hpbGTigJlzIGluZGV4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcnVsZS5ub2Rlcy5sZW5ndGggIC8vPT4gNVxuICAgKiBydWxlLnJlbW92ZUNoaWxkKGRlY2wpXG4gICAqIHJ1bGUubm9kZXMubGVuZ3RoICAvLz0+IDRcbiAgICogZGVjbC5wYXJlbnQgICAgICAgIC8vPT4gdW5kZWZpbmVkXG4gICAqL1xuICByZW1vdmVDaGlsZCAoY2hpbGQpIHtcbiAgICBjaGlsZCA9IHRoaXMuaW5kZXgoY2hpbGQpXG4gICAgdGhpcy5ub2Rlc1tjaGlsZF0ucGFyZW50ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5ub2Rlcy5zcGxpY2UoY2hpbGQsIDEpXG5cbiAgICBsZXQgaW5kZXhcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXVxuICAgICAgaWYgKGluZGV4ID49IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleCAtIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhlIGNvbnRhaW5lclxuICAgKiBhbmQgY2xlYW5zIHRoZWlyIHBhcmVudCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJ1bGUucmVtb3ZlQWxsKClcbiAgICogcnVsZS5ub2Rlcy5sZW5ndGggLy89PiAwXG4gICAqL1xuICByZW1vdmVBbGwgKCkge1xuICAgIGZvciAobGV0IG5vZGUgb2YgdGhpcy5ub2Rlcykgbm9kZS5wYXJlbnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLm5vZGVzID0gW11cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFBhc3NlcyBhbGwgZGVjbGFyYXRpb24gdmFsdWVzIHdpdGhpbiB0aGUgY29udGFpbmVyIHRoYXQgbWF0Y2ggcGF0dGVyblxuICAgKiB0aHJvdWdoIGNhbGxiYWNrLCByZXBsYWNpbmcgdGhvc2UgdmFsdWVzIHdpdGggdGhlIHJldHVybmVkIHJlc3VsdFxuICAgKiBvZiBjYWxsYmFjay5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGlmIHlvdSBhcmUgdXNpbmcgYSBjdXN0b20gdW5pdCBvciBmdW5jdGlvblxuICAgKiBhbmQgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggYWxsIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBwYXR0ZXJuICAgICAgUmVwbGFjZSBwYXR0ZXJuLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAgICAgICAgICAgICAgICBPcHRpb25zIHRvIHNwZWVkIHVwIHRoZSBzZWFyY2guXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRzLnByb3BzIEFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5mYXN0ICAgICAgICAgICBTdHJpbmcgdGhhdOKAmXMgdXNlZCB0byBuYXJyb3cgZG93blxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYW5kIHNwZWVkIHVwIHRoZSByZWdleHAgc2VhcmNoLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufHN0cmluZ30gY2FsbGJhY2sgICBTdHJpbmcgdG8gcmVwbGFjZSBwYXR0ZXJuIG9yIGNhbGxiYWNrXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgcmV0dXJucyBhIG5ldyB2YWx1ZS4gVGhlIGNhbGxiYWNrXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgcmVjZWl2ZSB0aGUgc2FtZSBhcmd1bWVudHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgdGhvc2UgcGFzc2VkIHRvIGEgZnVuY3Rpb24gcGFyYW1ldGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGBTdHJpbmcjcmVwbGFjZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRoaXMgbm9kZSBmb3IgbWV0aG9kcyBjaGFpbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcm9vdC5yZXBsYWNlVmFsdWVzKC9cXGQrcmVtLywgeyBmYXN0OiAncmVtJyB9LCBzdHJpbmcgPT4ge1xuICAgKiAgIHJldHVybiAxNSAqIHBhcnNlSW50KHN0cmluZykgKyAncHgnXG4gICAqIH0pXG4gICAqL1xuICByZXBsYWNlVmFsdWVzIChwYXR0ZXJuLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0c1xuICAgICAgb3B0cyA9IHsgfVxuICAgIH1cblxuICAgIHRoaXMud2Fsa0RlY2xzKGRlY2wgPT4ge1xuICAgICAgaWYgKG9wdHMucHJvcHMgJiYgb3B0cy5wcm9wcy5pbmRleE9mKGRlY2wucHJvcCkgPT09IC0xKSByZXR1cm5cbiAgICAgIGlmIChvcHRzLmZhc3QgJiYgZGVjbC52YWx1ZS5pbmRleE9mKG9wdHMuZmFzdCkgPT09IC0xKSByZXR1cm5cblxuICAgICAgZGVjbC52YWx1ZSA9IGRlY2wudmFsdWUucmVwbGFjZShwYXR0ZXJuLCBjYWxsYmFjaylcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYFxuICAgKiBmb3IgYWxsIG9mIHRoZSBjb250YWluZXLigJlzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge2NoaWxkQ29uZGl0aW9ufSBjb25kaXRpb24gSXRlcmF0b3IgcmV0dXJucyB0cnVlIG9yIGZhbHNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBldmVyeSBjaGlsZCBwYXNzIGNvbmRpdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgbm9QcmVmaXhlcyA9IHJ1bGUuZXZlcnkoaSA9PiBpLnByb3BbMF0gIT09ICctJylcbiAgICovXG4gIGV2ZXJ5IChjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5ldmVyeShjb25kaXRpb24pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIChhdCBsZWFzdCkgb25lXG4gICAqIG9mIHRoZSBjb250YWluZXLigJlzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge2NoaWxkQ29uZGl0aW9ufSBjb25kaXRpb24gSXRlcmF0b3IgcmV0dXJucyB0cnVlIG9yIGZhbHNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBzb21lIGNoaWxkIHBhc3MgY29uZGl0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBoYXNQcmVmaXggPSBydWxlLnNvbWUoaSA9PiBpLnByb3BbMF0gPT09ICctJylcbiAgICovXG4gIHNvbWUgKGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnNvbWUoY29uZGl0aW9uKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBgY2hpbGRg4oCZcyBpbmRleCB3aXRoaW4gdGhlIHtAbGluayBDb250YWluZXIjbm9kZXN9IGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkIENoaWxkIG9mIHRoZSBjdXJyZW50IGNvbnRhaW5lci5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBDaGlsZCBpbmRleC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcnVsZS5pbmRleCggcnVsZS5ub2Rlc1syXSApIC8vPT4gMlxuICAgKi9cbiAgaW5kZXggKGNoaWxkKSB7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBjaGlsZFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKGNoaWxkKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjb250YWluZXLigJlzIGZpcnN0IGNoaWxkLlxuICAgKlxuICAgKiBAdHlwZSB7Tm9kZX1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcnVsZS5maXJzdCA9PT0gcnVsZXMubm9kZXNbMF1cbiAgICovXG4gIGdldCBmaXJzdCAoKSB7XG4gICAgaWYgKCF0aGlzLm5vZGVzKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMubm9kZXNbMF1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGFpbmVy4oCZcyBsYXN0IGNoaWxkLlxuICAgKlxuICAgKiBAdHlwZSB7Tm9kZX1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcnVsZS5sYXN0ID09PSBydWxlLm5vZGVzW3J1bGUubm9kZXMubGVuZ3RoIC0gMV1cbiAgICovXG4gIGdldCBsYXN0ICgpIHtcbiAgICBpZiAoIXRoaXMubm9kZXMpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdXG4gIH1cblxuICBub3JtYWxpemUgKG5vZGVzLCBzYW1wbGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGVzID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG4gICAgICBub2RlcyA9IGNsZWFuU291cmNlKHBhcnNlKG5vZGVzKS5ub2RlcylcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICBub2RlcyA9IG5vZGVzLnNsaWNlKDApXG4gICAgICBmb3IgKGxldCBpIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChpLnBhcmVudCkgaS5wYXJlbnQucmVtb3ZlQ2hpbGQoaSwgJ2lnbm9yZScpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2Rlcy50eXBlID09PSAncm9vdCcpIHtcbiAgICAgIG5vZGVzID0gbm9kZXMubm9kZXMuc2xpY2UoMClcbiAgICAgIGZvciAobGV0IGkgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKGkucGFyZW50KSBpLnBhcmVudC5yZW1vdmVDaGlsZChpLCAnaWdub3JlJylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGVzLnR5cGUpIHtcbiAgICAgIG5vZGVzID0gW25vZGVzXVxuICAgIH0gZWxzZSBpZiAobm9kZXMucHJvcCkge1xuICAgICAgaWYgKHR5cGVvZiBub2Rlcy52YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBmaWVsZCBpcyBtaXNzZWQgaW4gbm9kZSBjcmVhdGlvbicpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2Rlcy52YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbm9kZXMudmFsdWUgPSBTdHJpbmcobm9kZXMudmFsdWUpXG4gICAgICB9XG4gICAgICBub2RlcyA9IFtuZXcgRGVjbGFyYXRpb24obm9kZXMpXVxuICAgIH0gZWxzZSBpZiAobm9kZXMuc2VsZWN0b3IpIHtcbiAgICAgIGxldCBSdWxlID0gcmVxdWlyZSgnLi9ydWxlJylcbiAgICAgIG5vZGVzID0gW25ldyBSdWxlKG5vZGVzKV1cbiAgICB9IGVsc2UgaWYgKG5vZGVzLm5hbWUpIHtcbiAgICAgIGxldCBBdFJ1bGUgPSByZXF1aXJlKCcuL2F0LXJ1bGUnKVxuICAgICAgbm9kZXMgPSBbbmV3IEF0UnVsZShub2RlcyldXG4gICAgfSBlbHNlIGlmIChub2Rlcy50ZXh0KSB7XG4gICAgICBub2RlcyA9IFtuZXcgQ29tbWVudChub2RlcyldXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGUgaW4gbm9kZSBjcmVhdGlvbicpXG4gICAgfVxuXG4gICAgbGV0IHByb2Nlc3NlZCA9IG5vZGVzLm1hcChpID0+IHtcbiAgICAgIGlmIChpLnBhcmVudCkgaS5wYXJlbnQucmVtb3ZlQ2hpbGQoaSlcbiAgICAgIGlmICh0eXBlb2YgaS5yYXdzLmJlZm9yZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHNhbXBsZSAmJiB0eXBlb2Ygc2FtcGxlLnJhd3MuYmVmb3JlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGkucmF3cy5iZWZvcmUgPSBzYW1wbGUucmF3cy5iZWZvcmUucmVwbGFjZSgvW15cXHNdL2csICcnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpLnBhcmVudCA9IHRoaXNcbiAgICAgIHJldHVybiBpXG4gICAgfSlcblxuICAgIHJldHVybiBwcm9jZXNzZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgQ29udGFpbmVyI1xuICAgKiBAbWVtYmVyIHtOb2RlW119IG5vZGVzIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbnRhaW5lcuKAmXMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdhIHsgY29sb3I6IGJsYWNrIH0nKVxuICAgKiByb290Lm5vZGVzLmxlbmd0aCAgICAgICAgICAgLy89PiAxXG4gICAqIHJvb3Qubm9kZXNbMF0uc2VsZWN0b3IgICAgICAvLz0+ICdhJ1xuICAgKiByb290Lm5vZGVzWzBdLm5vZGVzWzBdLnByb3AgLy89PiAnY29sb3InXG4gICAqL1xufVxuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXJcblxuLyoqXG4gKiBAY2FsbGJhY2sgY2hpbGRDb25kaXRpb25cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgICBDb250YWluZXIgY2hpbGQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggQ2hpbGQgaW5kZXguXG4gKiBAcGFyYW0ge05vZGVbXX0gbm9kZXMgQWxsIGNvbnRhaW5lciBjaGlsZHJlbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgY2hpbGRJdGVyYXRvclxuICogQHBhcmFtIHtOb2RlfSBub2RlICAgIENvbnRhaW5lciBjaGlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBDaGlsZCBpbmRleC5cbiAqIEByZXR1cm4ge2ZhbHNlfHVuZGVmaW5lZH0gUmV0dXJuaW5nIGBmYWxzZWAgd2lsbCBicmVhayBpdGVyYXRpb24uXG4gKi9cbiJdLCJmaWxlIjoiY29udGFpbmVyLmpzIn0=


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(__webpack_require__(22));

var _list = _interopRequireDefault(__webpack_require__(43));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Represents a CSS rule: a selector followed by a declaration block.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{}')
 * const rule = root.first
 * rule.type       //=> 'rule'
 * rule.toString() //=> 'a{}'
 */
var Rule =
/*#__PURE__*/
function (_Container) {
  _inheritsLoose(Rule, _Container);

  function Rule(defaults) {
    var _this;

    _this = _Container.call(this, defaults) || this;
    _this.type = 'rule';
    if (!_this.nodes) _this.nodes = [];
    return _this;
  }
  /**
   * An array containing the rule’s individual selectors.
   * Groups of selectors are split at commas.
   *
   * @type {string[]}
   *
   * @example
   * const root = postcss.parse('a, b { }')
   * const rule = root.first
   *
   * rule.selector  //=> 'a, b'
   * rule.selectors //=> ['a', 'b']
   *
   * rule.selectors = ['a', 'strong']
   * rule.selector //=> 'a, strong'
   */


  _createClass(Rule, [{
    key: "selectors",
    get: function get() {
      return _list.default.comma(this.selector);
    },
    set: function set(values) {
      var match = this.selector ? this.selector.match(/,\s*/) : null;
      var sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
      this.selector = values.join(sep);
    }
    /**
     * @memberof Rule#
     * @member {string} selector The rule’s full selector represented
     *                           as a string.
     *
     * @example
     * const root = postcss.parse('a, b { }')
     * const rule = root.first
     * rule.selector //=> 'a, b'
     */

    /**
     * @memberof Rule#
     * @member {object} raws Information to generate byte-to-byte equal
     *                       node string as it was in the origin input.
     *
     * Every parser saves its own properties,
     * but the default CSS parser uses:
     *
     * * `before`: the space symbols before the node. It also stores `*`
     *   and `_` symbols before the declaration (IE hack).
     * * `after`: the space symbols after the last child of the node
     *   to the end of the node.
     * * `between`: the symbols between the property and value
     *   for declarations, selector and `{` for rules, or last parameter
     *   and `{` for at-rules.
     * * `semicolon`: contains `true` if the last child has
     *   an (optional) semicolon.
     * * `ownSemicolon`: contains `true` if there is semicolon after rule.
     *
     * PostCSS cleans selectors from comments and extra spaces,
     * but it stores origin content in raws properties.
     * As such, if you don’t change a declaration’s value,
     * PostCSS will use the raw value with comments.
     *
     * @example
     * const root = postcss.parse('a {\n  color:black\n}')
     * root.first.first.raws //=> { before: '', between: ' ', after: '\n' }
     */

  }]);

  return Rule;
}(_container.default);

var _default = Rule;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJ1bGUuZXM2Il0sIm5hbWVzIjpbIlJ1bGUiLCJkZWZhdWx0cyIsInR5cGUiLCJub2RlcyIsImxpc3QiLCJjb21tYSIsInNlbGVjdG9yIiwidmFsdWVzIiwibWF0Y2giLCJzZXAiLCJyYXciLCJqb2luIiwiQ29udGFpbmVyIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUNBOzs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7O0lBV01BLEk7Ozs7O0FBQ0osZ0JBQWFDLFFBQWIsRUFBdUI7QUFBQTs7QUFDckIsa0NBQU1BLFFBQU47QUFDQSxVQUFLQyxJQUFMLEdBQVksTUFBWjtBQUNBLFFBQUksQ0FBQyxNQUFLQyxLQUFWLEVBQWlCLE1BQUtBLEtBQUwsR0FBYSxFQUFiO0FBSEk7QUFJdEI7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBZ0JpQjtBQUNmLGFBQU9DLGNBQUtDLEtBQUwsQ0FBVyxLQUFLQyxRQUFoQixDQUFQO0FBQ0QsSztzQkFFY0MsTSxFQUFRO0FBQ3JCLFVBQUlDLEtBQUssR0FBRyxLQUFLRixRQUFMLEdBQWdCLEtBQUtBLFFBQUwsQ0FBY0UsS0FBZCxDQUFvQixNQUFwQixDQUFoQixHQUE4QyxJQUExRDtBQUNBLFVBQUlDLEdBQUcsR0FBR0QsS0FBSyxHQUFHQSxLQUFLLENBQUMsQ0FBRCxDQUFSLEdBQWMsTUFBTSxLQUFLRSxHQUFMLENBQVMsU0FBVCxFQUFvQixZQUFwQixDQUFuQztBQUNBLFdBQUtKLFFBQUwsR0FBZ0JDLE1BQU0sQ0FBQ0ksSUFBUCxDQUFZRixHQUFaLENBQWhCO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE1Q2lCRyxrQjs7ZUEwRUpaLEkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vY29udGFpbmVyJ1xuaW1wb3J0IGxpc3QgZnJvbSAnLi9saXN0J1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBDU1MgcnVsZTogYSBzZWxlY3RvciBmb2xsb3dlZCBieSBhIGRlY2xhcmF0aW9uIGJsb2NrLlxuICpcbiAqIEBleHRlbmRzIENvbnRhaW5lclxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYXt9JylcbiAqIGNvbnN0IHJ1bGUgPSByb290LmZpcnN0XG4gKiBydWxlLnR5cGUgICAgICAgLy89PiAncnVsZSdcbiAqIHJ1bGUudG9TdHJpbmcoKSAvLz0+ICdhe30nXG4gKi9cbmNsYXNzIFJ1bGUgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3RvciAoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cylcbiAgICB0aGlzLnR5cGUgPSAncnVsZSdcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHJ1bGXigJlzIGluZGl2aWR1YWwgc2VsZWN0b3JzLlxuICAgKiBHcm91cHMgb2Ygc2VsZWN0b3JzIGFyZSBzcGxpdCBhdCBjb21tYXMuXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2EsIGIgeyB9JylcbiAgICogY29uc3QgcnVsZSA9IHJvb3QuZmlyc3RcbiAgICpcbiAgICogcnVsZS5zZWxlY3RvciAgLy89PiAnYSwgYidcbiAgICogcnVsZS5zZWxlY3RvcnMgLy89PiBbJ2EnLCAnYiddXG4gICAqXG4gICAqIHJ1bGUuc2VsZWN0b3JzID0gWydhJywgJ3N0cm9uZyddXG4gICAqIHJ1bGUuc2VsZWN0b3IgLy89PiAnYSwgc3Ryb25nJ1xuICAgKi9cbiAgZ2V0IHNlbGVjdG9ycyAoKSB7XG4gICAgcmV0dXJuIGxpc3QuY29tbWEodGhpcy5zZWxlY3RvcilcbiAgfVxuXG4gIHNldCBzZWxlY3RvcnMgKHZhbHVlcykge1xuICAgIGxldCBtYXRjaCA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yLm1hdGNoKC8sXFxzKi8pIDogbnVsbFxuICAgIGxldCBzZXAgPSBtYXRjaCA/IG1hdGNoWzBdIDogJywnICsgdGhpcy5yYXcoJ2JldHdlZW4nLCAnYmVmb3JlT3BlbicpXG4gICAgdGhpcy5zZWxlY3RvciA9IHZhbHVlcy5qb2luKHNlcClcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgUnVsZSNcbiAgICogQG1lbWJlciB7c3RyaW5nfSBzZWxlY3RvciBUaGUgcnVsZeKAmXMgZnVsbCBzZWxlY3RvciByZXByZXNlbnRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSwgYiB7IH0nKVxuICAgKiBjb25zdCBydWxlID0gcm9vdC5maXJzdFxuICAgKiBydWxlLnNlbGVjdG9yIC8vPT4gJ2EsIGInXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgUnVsZSNcbiAgICogQG1lbWJlciB7b2JqZWN0fSByYXdzIEluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGJ5dGUtdG8tYnl0ZSBlcXVhbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgbm9kZSBzdHJpbmcgYXMgaXQgd2FzIGluIHRoZSBvcmlnaW4gaW5wdXQuXG4gICAqXG4gICAqIEV2ZXJ5IHBhcnNlciBzYXZlcyBpdHMgb3duIHByb3BlcnRpZXMsXG4gICAqIGJ1dCB0aGUgZGVmYXVsdCBDU1MgcGFyc2VyIHVzZXM6XG4gICAqXG4gICAqICogYGJlZm9yZWA6IHRoZSBzcGFjZSBzeW1ib2xzIGJlZm9yZSB0aGUgbm9kZS4gSXQgYWxzbyBzdG9yZXMgYCpgXG4gICAqICAgYW5kIGBfYCBzeW1ib2xzIGJlZm9yZSB0aGUgZGVjbGFyYXRpb24gKElFIGhhY2spLlxuICAgKiAqIGBhZnRlcmA6IHRoZSBzcGFjZSBzeW1ib2xzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoZSBub2RlXG4gICAqICAgdG8gdGhlIGVuZCBvZiB0aGUgbm9kZS5cbiAgICogKiBgYmV0d2VlbmA6IHRoZSBzeW1ib2xzIGJldHdlZW4gdGhlIHByb3BlcnR5IGFuZCB2YWx1ZVxuICAgKiAgIGZvciBkZWNsYXJhdGlvbnMsIHNlbGVjdG9yIGFuZCBge2AgZm9yIHJ1bGVzLCBvciBsYXN0IHBhcmFtZXRlclxuICAgKiAgIGFuZCBge2AgZm9yIGF0LXJ1bGVzLlxuICAgKiAqIGBzZW1pY29sb25gOiBjb250YWlucyBgdHJ1ZWAgaWYgdGhlIGxhc3QgY2hpbGQgaGFzXG4gICAqICAgYW4gKG9wdGlvbmFsKSBzZW1pY29sb24uXG4gICAqICogYG93blNlbWljb2xvbmA6IGNvbnRhaW5zIGB0cnVlYCBpZiB0aGVyZSBpcyBzZW1pY29sb24gYWZ0ZXIgcnVsZS5cbiAgICpcbiAgICogUG9zdENTUyBjbGVhbnMgc2VsZWN0b3JzIGZyb20gY29tbWVudHMgYW5kIGV4dHJhIHNwYWNlcyxcbiAgICogYnV0IGl0IHN0b3JlcyBvcmlnaW4gY29udGVudCBpbiByYXdzIHByb3BlcnRpZXMuXG4gICAqIEFzIHN1Y2gsIGlmIHlvdSBkb27igJl0IGNoYW5nZSBhIGRlY2xhcmF0aW9u4oCZcyB2YWx1ZSxcbiAgICogUG9zdENTUyB3aWxsIHVzZSB0aGUgcmF3IHZhbHVlIHdpdGggY29tbWVudHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdhIHtcXG4gIGNvbG9yOmJsYWNrXFxufScpXG4gICAqIHJvb3QuZmlyc3QuZmlyc3QucmF3cyAvLz0+IHsgYmVmb3JlOiAnJywgYmV0d2VlbjogJyAnLCBhZnRlcjogJ1xcbicgfVxuICAgKi9cbn1cblxuZXhwb3J0IGRlZmF1bHQgUnVsZVxuIl0sImZpbGUiOiJydWxlLmpzIn0=


/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function createCustomError(name, message) {
    // use Object.create(), because some VMs prevent setting line/column otherwise
    // (iOS Safari 10 even throws an exception)
    var error = Object.create(SyntaxError.prototype);
    var errorStack = new Error();

    error.name = name;
    error.message = message;

    Object.defineProperty(error, 'stack', {
        get: function() {
            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
        }
    });

    return error;
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// token types (note: value shouldn't intersect with used char codes)
var WHITESPACE = 1;
var IDENTIFIER = 2;
var NUMBER = 3;
var STRING = 4;
var COMMENT = 5;
var PUNCTUATOR = 6;
var CDO = 7;
var CDC = 8;
var ATKEYWORD = 14;
var FUNCTION = 15;
var URL = 16;
var RAW = 17;

var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;

var TYPE = {
    WhiteSpace:   WHITESPACE,
    Identifier:   IDENTIFIER,
    Number:           NUMBER,
    String:           STRING,
    Comment:         COMMENT,
    Punctuator:   PUNCTUATOR,
    CDO:                 CDO,
    CDC:                 CDC,
    AtKeyword:     ATKEYWORD,
    Function:       FUNCTION,
    Url:                 URL,
    Raw:                 RAW,

    ExclamationMark:      33,  // !
    QuotationMark:        34,  // "
    NumberSign:           35,  // #
    DollarSign:           36,  // $
    PercentSign:          37,  // %
    Ampersand:            38,  // &
    Apostrophe:           39,  // '
    LeftParenthesis:      40,  // (
    RightParenthesis:     41,  // )
    Asterisk:             42,  // *
    PlusSign:             43,  // +
    Comma:                44,  // ,
    HyphenMinus:          45,  // -
    FullStop:             46,  // .
    Solidus:              47,  // /
    Colon:                58,  // :
    Semicolon:            59,  // ;
    LessThanSign:         60,  // <
    EqualsSign:           61,  // =
    GreaterThanSign:      62,  // >
    QuestionMark:         63,  // ?
    CommercialAt:         64,  // @
    LeftSquareBracket:    91,  // [
    Backslash:            92,  // \
    RightSquareBracket:   93,  // ]
    CircumflexAccent:     94,  // ^
    LowLine:              95,  // _
    GraveAccent:          96,  // `
    LeftCurlyBracket:    123,  // {
    VerticalLine:        124,  // |
    RightCurlyBracket:   125,  // }
    Tilde:               126   // ~
};

var NAME = Object.keys(TYPE).reduce(function(result, key) {
    result[TYPE[key]] = key;
    return result;
}, {});

// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
// > non-ASCII code point
// >   A code point with a value equal to or greater than U+0080 <control>
// > name-start code point
// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
// > name code point
// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
// That means only ASCII code points has a special meaning and we a maps for 0..127 codes only
var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported
var SYMBOL_TYPE = new SafeUint32Array(0x80);
var PUNCTUATION = new SafeUint32Array(0x80);
var STOP_URL_RAW = new SafeUint32Array(0x80);

for (var i = 0; i < SYMBOL_TYPE.length; i++) {
    SYMBOL_TYPE[i] = IDENTIFIER;
}

// fill categories
[
    TYPE.ExclamationMark,    // !
    TYPE.QuotationMark,      // "
    TYPE.NumberSign,         // #
    TYPE.DollarSign,         // $
    TYPE.PercentSign,        // %
    TYPE.Ampersand,          // &
    TYPE.Apostrophe,         // '
    TYPE.LeftParenthesis,    // (
    TYPE.RightParenthesis,   // )
    TYPE.Asterisk,           // *
    TYPE.PlusSign,           // +
    TYPE.Comma,              // ,
    TYPE.HyphenMinus,        // -
    TYPE.FullStop,           // .
    TYPE.Solidus,            // /
    TYPE.Colon,              // :
    TYPE.Semicolon,          // ;
    TYPE.LessThanSign,       // <
    TYPE.EqualsSign,         // =
    TYPE.GreaterThanSign,    // >
    TYPE.QuestionMark,       // ?
    TYPE.CommercialAt,       // @
    TYPE.LeftSquareBracket,  // [
    // TYPE.Backslash,          // \
    TYPE.RightSquareBracket, // ]
    TYPE.CircumflexAccent,   // ^
    // TYPE.LowLine,            // _
    TYPE.GraveAccent,        // `
    TYPE.LeftCurlyBracket,   // {
    TYPE.VerticalLine,       // |
    TYPE.RightCurlyBracket,  // }
    TYPE.Tilde               // ~
].forEach(function(key) {
    SYMBOL_TYPE[Number(key)] = PUNCTUATOR;
    PUNCTUATION[Number(key)] = PUNCTUATOR;
});

for (var i = 48; i <= 57; i++) {
    SYMBOL_TYPE[i] = NUMBER;
}

SYMBOL_TYPE[SPACE] = WHITESPACE;
SYMBOL_TYPE[TAB] = WHITESPACE;
SYMBOL_TYPE[N] = WHITESPACE;
SYMBOL_TYPE[R] = WHITESPACE;
SYMBOL_TYPE[F] = WHITESPACE;

SYMBOL_TYPE[TYPE.Apostrophe] = STRING;
SYMBOL_TYPE[TYPE.QuotationMark] = STRING;

STOP_URL_RAW[SPACE] = 1;
STOP_URL_RAW[TAB] = 1;
STOP_URL_RAW[N] = 1;
STOP_URL_RAW[R] = 1;
STOP_URL_RAW[F] = 1;
STOP_URL_RAW[TYPE.Apostrophe] = 1;
STOP_URL_RAW[TYPE.QuotationMark] = 1;
STOP_URL_RAW[TYPE.LeftParenthesis] = 1;
STOP_URL_RAW[TYPE.RightParenthesis] = 1;

// whitespace is punctuation ...
PUNCTUATION[SPACE] = PUNCTUATOR;
PUNCTUATION[TAB] = PUNCTUATOR;
PUNCTUATION[N] = PUNCTUATOR;
PUNCTUATION[R] = PUNCTUATOR;
PUNCTUATION[F] = PUNCTUATOR;
// ... hyper minus is not
PUNCTUATION[TYPE.HyphenMinus] = 0;

module.exports = {
    TYPE: TYPE,
    NAME: NAME,

    SYMBOL_TYPE: SYMBOL_TYPE,
    PUNCTUATION: PUNCTUATION,
    STOP_URL_RAW: STOP_URL_RAW
};


/***/ }),
/* 26 */
/***/ (function(module, exports) {

function noop(value) {
    return value;
}

function generateMultiplier(multiplier) {
    if (multiplier.min === 0 && multiplier.max === 0) {
        return '*';
    }

    if (multiplier.min === 0 && multiplier.max === 1) {
        return '?';
    }

    if (multiplier.min === 1 && multiplier.max === 0) {
        return multiplier.comma ? '#' : '+';
    }

    if (multiplier.min === 1 && multiplier.max === 1) {
        return '';
    }

    return (
        (multiplier.comma ? '#' : '') +
        (multiplier.min === multiplier.max
            ? '{' + multiplier.min + '}'
            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
        )
    );
}

function generateSequence(node, forceBraces, decorate) {
    var result = node.terms.map(function(term) {
        return generate(term, forceBraces, decorate);
    }).join(node.combinator === ' ' ? ' ' : ' ' + node.combinator + ' ');

    if (node.explicit || forceBraces) {
        result = (result[0] !== ',' ? '[ ' : '[') + result + ' ]';
    }

    return result;
}

function generate(node, forceBraces, decorate) {
    var result;

    switch (node.type) {
        case 'Group':
            result =
                generateSequence(node, forceBraces, decorate) +
                (node.disallowEmpty ? '!' : '');
            break;

        case 'Multiplier':
            // return since node is a composition
            return (
                generate(node.term, forceBraces, decorate) +
                decorate(generateMultiplier(node), node)
            );

        case 'Type':
            result = '<' + node.name + '>';
            break;

        case 'Property':
            result = '<\'' + node.name + '\'>';
            break;

        case 'Keyword':
            result = node.name;
            break;

        case 'AtKeyword':
            result = '@' + node.name;
            break;

        case 'Function':
            result = node.name + '(';
            break;

        case 'String':
        case 'Token':
            result = node.value;
            break;

        case 'Comma':
            result = ',';
            break;

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }

    return decorate(result, node);
}

module.exports = function(node, options) {
    var decorate = noop;
    var forceBraces = false;

    if (typeof options === 'function') {
        decorate = options;
    } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        if (typeof options.decorate === 'function') {
            decorate = options.decorate;
        }
    }

    return generate(node, forceBraces, decorate);
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasOwnProperty = Object.prototype.hasOwnProperty;
var keywords = Object.create(null);
var properties = Object.create(null);
var HYPHENMINUS = 45; // '-'.charCodeAt()

function isCustomProperty(str, offset) {
    offset = offset || 0;

    return str.length - offset >= 2 &&
           str.charCodeAt(offset) === HYPHENMINUS &&
           str.charCodeAt(offset + 1) === HYPHENMINUS;
}

function getVendorPrefix(str, offset) {
    offset = offset || 0;

    // verdor prefix should be at least 3 chars length
    if (str.length - offset >= 3) {
        // vendor prefix starts with hyper minus following non-hyper minus
        if (str.charCodeAt(offset) === HYPHENMINUS &&
            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
            // vendor prefix should contain a hyper minus at the ending
            var secondDashIndex = str.indexOf('-', offset + 2);

            if (secondDashIndex !== -1) {
                return str.substring(offset, secondDashIndex + 1);
            }
        }
    }

    return '';
}

function getKeywordDescriptor(keyword) {
    if (hasOwnProperty.call(keywords, keyword)) {
        return keywords[keyword];
    }

    var name = keyword.toLowerCase();

    if (hasOwnProperty.call(keywords, name)) {
        return keywords[keyword] = keywords[name];
    }

    var custom = isCustomProperty(name, 0);
    var vendor = !custom ? getVendorPrefix(name, 0) : '';

    return keywords[keyword] = Object.freeze({
        basename: name.substr(vendor.length),
        name: name,
        vendor: vendor,
        prefix: vendor,
        custom: custom
    });
}

function getPropertyDescriptor(property) {
    if (hasOwnProperty.call(properties, property)) {
        return properties[property];
    }

    var name = property;
    var hack = property[0];

    if (hack === '/') {
        hack = property[1] === '/' ? '//' : '/';
    } else if (hack !== '_' &&
               hack !== '*' &&
               hack !== '$' &&
               hack !== '#' &&
               hack !== '+') {
        hack = '';
    }

    var custom = isCustomProperty(name, hack.length);

    // re-use result when possible (the same as for lower case)
    if (!custom) {
        name = name.toLowerCase();
        if (hasOwnProperty.call(properties, name)) {
            return properties[property] = properties[name];
        }
    }

    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    var prefix = name.substr(0, hack.length + vendor.length);

    return properties[property] = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack: hack,
        vendor: vendor,
        prefix: prefix,
        custom: custom
    });
}

module.exports = {
    keyword: getKeywordDescriptor,
    property: getPropertyDescriptor,
    isCustomProperty: isCustomProperty,
    vendorPrefix: getVendorPrefix
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var Tokenizer = __webpack_require__(104);
var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;
var EXCLAMATIONMARK = 33;    // !
var NUMBERSIGN = 35;         // #
var AMPERSAND = 38;          // &
var APOSTROPHE = 39;         // '
var LEFTPARENTHESIS = 40;    // (
var RIGHTPARENTHESIS = 41;   // )
var ASTERISK = 42;           // *
var PLUSSIGN = 43;           // +
var COMMA = 44;              // ,
var LESSTHANSIGN = 60;       // <
var GREATERTHANSIGN = 62;    // >
var QUESTIONMARK = 63;       // ?
var COMMERCIALAT = 64;       // @
var LEFTSQUAREBRACKET = 91;  // [
var RIGHTSQUAREBRACKET = 93; // ]
var LEFTCURLYBRACKET = 123;  // {
var VERTICALLINE = 124;      // |
var RIGHTCURLYBRACKET = 125; // }
var NAME_CHAR = createCharMap(function(ch) {
    return /[a-zA-Z0-9\-]/.test(ch);
});
var COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
};

function createCharMap(fn) {
    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
    for (var i = 0; i < 128; i++) {
        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
    }
    return array;
}

function scanSpaces(tokenizer) {
    return tokenizer.substringToPos(
        tokenizer.findWsEnd(tokenizer.pos + 1)
    );
}

function scanWord(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a keyword');
    }

    return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a number');
    }

    return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
        tokenizer.pos = tokenizer.str.length;
        tokenizer.error('Expect an apostrophe');
    }

    return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer) {
    var min = null;
    var max = null;

    tokenizer.eat(LEFTCURLYBRACKET);

    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
        }
    } else {
        max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET);

    return {
        min: Number(min),
        max: max ? Number(max) : 0
    };
}

function readMultiplier(tokenizer) {
    var range = null;
    var comma = false;

    switch (tokenizer.charCode()) {
        case ASTERISK:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 0
            };

            break;

        case PLUSSIGN:
            tokenizer.pos++;

            range = {
                min: 1,
                max: 0
            };

            break;

        case QUESTIONMARK:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 1
            };

            break;

        case NUMBERSIGN:
            tokenizer.pos++;

            comma = true;

            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
                range = readMultiplierRange(tokenizer);
            } else {
                range = {
                    min: 1,
                    max: 0
                };
            }

            break;

        case LEFTCURLYBRACKET:
            range = readMultiplierRange(tokenizer);
            break;

        default:
            return null;
    }

    return {
        type: 'Multiplier',
        comma: comma,
        min: range.min,
        max: range.max,
        term: null
    };
}

function maybeMultiplied(tokenizer, node) {
    var multiplier = readMultiplier(tokenizer);

    if (multiplier !== null) {
        multiplier.term = node;
        return multiplier;
    }

    return node;
}

function maybeToken(tokenizer) {
    var ch = tokenizer.peek();

    if (ch === '') {
        return null;
    }

    return {
        type: 'Token',
        value: ch
    };
}

function readProperty(tokenizer) {
    var name;

    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE);

    name = scanWord(tokenizer);

    tokenizer.eat(APOSTROPHE);
    tokenizer.eat(GREATERTHANSIGN);

    return maybeMultiplied(tokenizer, {
        type: 'Property',
        name: name
    });
}

function readType(tokenizer) {
    var name;

    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS &&
        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
        tokenizer.pos += 2;
        name += '()';
    }

    tokenizer.eat(GREATERTHANSIGN);

    return maybeMultiplied(tokenizer, {
        type: 'Type',
        name: name
    });
}

function readKeywordOrFunction(tokenizer) {
    var name;

    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS) {
        tokenizer.pos++;

        return {
            type: 'Function',
            name: name
        };
    }

    return maybeMultiplied(tokenizer, {
        type: 'Keyword',
        name: name
    });
}

function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
        return {
            type: 'Group',
            terms: terms,
            combinator: combinator,
            disallowEmpty: false,
            explicit: false
        };
    }

    combinators = Object.keys(combinators).sort(function(a, b) {
        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
    });

    while (combinators.length > 0) {
        var combinator = combinators.shift();
        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
            var term = terms[i];
            if (term.type === 'Combinator') {
                if (term.value === combinator) {
                    if (subgroupStart === -1) {
                        subgroupStart = i - 1;
                    }
                    terms.splice(i, 1);
                    i--;
                } else {
                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
                        terms.splice(
                            subgroupStart,
                            i - subgroupStart,
                            createGroup(terms.slice(subgroupStart, i), combinator)
                        );
                        i = subgroupStart + 1;
                    }
                    subgroupStart = -1;
                }
            }
        }

        if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
                subgroupStart,
                i - subgroupStart,
                createGroup(terms.slice(subgroupStart, i), combinator)
            );
        }
    }

    return combinator;
}

function readImplicitGroup(tokenizer) {
    var terms = [];
    var combinators = {};
    var token;
    var prevToken = null;
    var prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
        if (token.type !== 'Spaces') {
            if (token.type === 'Combinator') {
                // check for combinator in group beginning and double combinator sequence
                if (prevToken === null || prevToken.type === 'Combinator') {
                    tokenizer.pos = prevTokenPos;
                    tokenizer.error('Unexpected combinator');
                }

                combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
                combinators[' '] = true;  // a b
                terms.push({
                    type: 'Combinator',
                    value: ' '
                });
            }

            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
        }
    }

    // check for combinator in group ending
    if (prevToken !== null && prevToken.type === 'Combinator') {
        tokenizer.pos -= prevTokenPos;
        tokenizer.error('Unexpected combinator');
    }

    return {
        type: 'Group',
        terms: terms,
        combinator: regroupTerms(terms, combinators) || ' ',
        disallowEmpty: false,
        explicit: false
    };
}

function readGroup(tokenizer) {
    var result;

    tokenizer.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET);

    result.explicit = true;

    if (tokenizer.charCode() === EXCLAMATIONMARK) {
        tokenizer.pos++;
        result.disallowEmpty = true;
    }

    return result;
}

function peek(tokenizer) {
    var code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
        case RIGHTSQUAREBRACKET:
            // don't eat, stop scan a group
            break;

        case LEFTSQUAREBRACKET:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));

        case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE
                ? readProperty(tokenizer)
                : readType(tokenizer);

        case VERTICALLINE:
            return {
                type: 'Combinator',
                value: tokenizer.substringToPos(
                    tokenizer.nextCharCode() === VERTICALLINE
                        ? tokenizer.pos + 2
                        : tokenizer.pos + 1
                )
            };

        case AMPERSAND:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND);

            return {
                type: 'Combinator',
                value: '&&'
            };

        case COMMA:
            tokenizer.pos++;
            return {
                type: 'Comma'
            };

        case APOSTROPHE:
            return maybeMultiplied(tokenizer, {
                type: 'String',
                value: scanString(tokenizer)
            });

        case SPACE:
        case TAB:
        case N:
        case R:
        case F:
            return {
                type: 'Spaces',
                value: scanSpaces(tokenizer)
            };

        case COMMERCIALAT:
            code = tokenizer.nextCharCode();

            if (code < 128 && NAME_CHAR[code] === 1) {
                tokenizer.pos++;
                return {
                    type: 'AtKeyword',
                    name: scanWord(tokenizer)
                };
            }

            return maybeToken(tokenizer);

        case ASTERISK:
        case PLUSSIGN:
        case QUESTIONMARK:
        case NUMBERSIGN:
        case EXCLAMATIONMARK:
            // prohibited tokens (used as a multiplier start)
            break;

        case LEFTCURLYBRACKET:
            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
            // check next char isn't a number, because it's likely a disjoined multiplier
            code = tokenizer.nextCharCode();

            if (code < 48 || code > 57) {
                return maybeToken(tokenizer);
            }

            break;

        default:
            return maybeToken(tokenizer);
    }
}

function parse(str) {
    var tokenizer = new Tokenizer(str);
    var result = readImplicitGroup(tokenizer);

    if (tokenizer.pos !== str.length) {
        tokenizer.error('Unexpected input');
    }

    // reduce redundant groups with single group term
    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
        result = result.terms[0];
    }

    return result;
}

// warm up parse to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

module.exports = parse;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    AnPlusB: __webpack_require__(128),
    Atrule: __webpack_require__(129),
    AtrulePrelude: __webpack_require__(130),
    AttributeSelector: __webpack_require__(131),
    Block: __webpack_require__(132),
    Brackets: __webpack_require__(133),
    CDC: __webpack_require__(134),
    CDO: __webpack_require__(135),
    ClassSelector: __webpack_require__(136),
    Combinator: __webpack_require__(137),
    Comment: __webpack_require__(138),
    Declaration: __webpack_require__(139),
    DeclarationList: __webpack_require__(140),
    Dimension: __webpack_require__(141),
    Function: __webpack_require__(142),
    HexColor: __webpack_require__(143),
    Identifier: __webpack_require__(144),
    IdSelector: __webpack_require__(145),
    MediaFeature: __webpack_require__(146),
    MediaQuery: __webpack_require__(147),
    MediaQueryList: __webpack_require__(148),
    Nth: __webpack_require__(149),
    Number: __webpack_require__(150),
    Operator: __webpack_require__(151),
    Parentheses: __webpack_require__(152),
    Percentage: __webpack_require__(153),
    PseudoClassSelector: __webpack_require__(154),
    PseudoElementSelector: __webpack_require__(155),
    Ratio: __webpack_require__(156),
    Raw: __webpack_require__(157),
    Rule: __webpack_require__(158),
    Selector: __webpack_require__(159),
    SelectorList: __webpack_require__(160),
    String: __webpack_require__(161),
    StyleSheet: __webpack_require__(162),
    TypeSelector: __webpack_require__(163),
    UnicodeRange: __webpack_require__(164),
    Url: __webpack_require__(165),
    Value: __webpack_require__(166),
    WhiteSpace: __webpack_require__(167)
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var lexer = __webpack_require__(1).lexer;
var packNumber = __webpack_require__(11).pack;

// http://www.w3.org/TR/css3-color/#svg-color
var NAME_TO_HEX = {
    'aliceblue': 'f0f8ff',
    'antiquewhite': 'faebd7',
    'aqua': '0ff',
    'aquamarine': '7fffd4',
    'azure': 'f0ffff',
    'beige': 'f5f5dc',
    'bisque': 'ffe4c4',
    'black': '000',
    'blanchedalmond': 'ffebcd',
    'blue': '00f',
    'blueviolet': '8a2be2',
    'brown': 'a52a2a',
    'burlywood': 'deb887',
    'cadetblue': '5f9ea0',
    'chartreuse': '7fff00',
    'chocolate': 'd2691e',
    'coral': 'ff7f50',
    'cornflowerblue': '6495ed',
    'cornsilk': 'fff8dc',
    'crimson': 'dc143c',
    'cyan': '0ff',
    'darkblue': '00008b',
    'darkcyan': '008b8b',
    'darkgoldenrod': 'b8860b',
    'darkgray': 'a9a9a9',
    'darkgrey': 'a9a9a9',
    'darkgreen': '006400',
    'darkkhaki': 'bdb76b',
    'darkmagenta': '8b008b',
    'darkolivegreen': '556b2f',
    'darkorange': 'ff8c00',
    'darkorchid': '9932cc',
    'darkred': '8b0000',
    'darksalmon': 'e9967a',
    'darkseagreen': '8fbc8f',
    'darkslateblue': '483d8b',
    'darkslategray': '2f4f4f',
    'darkslategrey': '2f4f4f',
    'darkturquoise': '00ced1',
    'darkviolet': '9400d3',
    'deeppink': 'ff1493',
    'deepskyblue': '00bfff',
    'dimgray': '696969',
    'dimgrey': '696969',
    'dodgerblue': '1e90ff',
    'firebrick': 'b22222',
    'floralwhite': 'fffaf0',
    'forestgreen': '228b22',
    'fuchsia': 'f0f',
    'gainsboro': 'dcdcdc',
    'ghostwhite': 'f8f8ff',
    'gold': 'ffd700',
    'goldenrod': 'daa520',
    'gray': '808080',
    'grey': '808080',
    'green': '008000',
    'greenyellow': 'adff2f',
    'honeydew': 'f0fff0',
    'hotpink': 'ff69b4',
    'indianred': 'cd5c5c',
    'indigo': '4b0082',
    'ivory': 'fffff0',
    'khaki': 'f0e68c',
    'lavender': 'e6e6fa',
    'lavenderblush': 'fff0f5',
    'lawngreen': '7cfc00',
    'lemonchiffon': 'fffacd',
    'lightblue': 'add8e6',
    'lightcoral': 'f08080',
    'lightcyan': 'e0ffff',
    'lightgoldenrodyellow': 'fafad2',
    'lightgray': 'd3d3d3',
    'lightgrey': 'd3d3d3',
    'lightgreen': '90ee90',
    'lightpink': 'ffb6c1',
    'lightsalmon': 'ffa07a',
    'lightseagreen': '20b2aa',
    'lightskyblue': '87cefa',
    'lightslategray': '789',
    'lightslategrey': '789',
    'lightsteelblue': 'b0c4de',
    'lightyellow': 'ffffe0',
    'lime': '0f0',
    'limegreen': '32cd32',
    'linen': 'faf0e6',
    'magenta': 'f0f',
    'maroon': '800000',
    'mediumaquamarine': '66cdaa',
    'mediumblue': '0000cd',
    'mediumorchid': 'ba55d3',
    'mediumpurple': '9370db',
    'mediumseagreen': '3cb371',
    'mediumslateblue': '7b68ee',
    'mediumspringgreen': '00fa9a',
    'mediumturquoise': '48d1cc',
    'mediumvioletred': 'c71585',
    'midnightblue': '191970',
    'mintcream': 'f5fffa',
    'mistyrose': 'ffe4e1',
    'moccasin': 'ffe4b5',
    'navajowhite': 'ffdead',
    'navy': '000080',
    'oldlace': 'fdf5e6',
    'olive': '808000',
    'olivedrab': '6b8e23',
    'orange': 'ffa500',
    'orangered': 'ff4500',
    'orchid': 'da70d6',
    'palegoldenrod': 'eee8aa',
    'palegreen': '98fb98',
    'paleturquoise': 'afeeee',
    'palevioletred': 'db7093',
    'papayawhip': 'ffefd5',
    'peachpuff': 'ffdab9',
    'peru': 'cd853f',
    'pink': 'ffc0cb',
    'plum': 'dda0dd',
    'powderblue': 'b0e0e6',
    'purple': '800080',
    'rebeccapurple': '639',
    'red': 'f00',
    'rosybrown': 'bc8f8f',
    'royalblue': '4169e1',
    'saddlebrown': '8b4513',
    'salmon': 'fa8072',
    'sandybrown': 'f4a460',
    'seagreen': '2e8b57',
    'seashell': 'fff5ee',
    'sienna': 'a0522d',
    'silver': 'c0c0c0',
    'skyblue': '87ceeb',
    'slateblue': '6a5acd',
    'slategray': '708090',
    'slategrey': '708090',
    'snow': 'fffafa',
    'springgreen': '00ff7f',
    'steelblue': '4682b4',
    'tan': 'd2b48c',
    'teal': '008080',
    'thistle': 'd8bfd8',
    'tomato': 'ff6347',
    'turquoise': '40e0d0',
    'violet': 'ee82ee',
    'wheat': 'f5deb3',
    'white': 'fff',
    'whitesmoke': 'f5f5f5',
    'yellow': 'ff0',
    'yellowgreen': '9acd32'
};

var HEX_TO_NAME = {
    '800000': 'maroon',
    '800080': 'purple',
    '808000': 'olive',
    '808080': 'gray',
    '00ffff': 'cyan',
    'f0ffff': 'azure',
    'f5f5dc': 'beige',
    'ffe4c4': 'bisque',
    '000000': 'black',
    '0000ff': 'blue',
    'a52a2a': 'brown',
    'ff7f50': 'coral',
    'ffd700': 'gold',
    '008000': 'green',
    '4b0082': 'indigo',
    'fffff0': 'ivory',
    'f0e68c': 'khaki',
    '00ff00': 'lime',
    'faf0e6': 'linen',
    '000080': 'navy',
    'ffa500': 'orange',
    'da70d6': 'orchid',
    'cd853f': 'peru',
    'ffc0cb': 'pink',
    'dda0dd': 'plum',
    'f00': 'red',
    'ff0000': 'red',
    'fa8072': 'salmon',
    'a0522d': 'sienna',
    'c0c0c0': 'silver',
    'fffafa': 'snow',
    'd2b48c': 'tan',
    '008080': 'teal',
    'ff6347': 'tomato',
    'ee82ee': 'violet',
    'f5deb3': 'wheat',
    'ffffff': 'white',
    'ffff00': 'yellow'
};

function hueToRgb(p, q, t) {
    if (t < 0) {
        t += 1;
    }
    if (t > 1) {
        t -= 1;
    }
    if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
        return q;
    }
    if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
}

function hslToRgb(h, s, l, a) {
    var r;
    var g;
    var b;

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;

        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
    }

    return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
        a
    ];
}

function toHex(value) {
    value = value.toString(16);
    return value.length === 1 ? '0' + value : value;
}

function parseFunctionArgs(functionArgs, count, rgb) {
    var cursor = functionArgs.head;
    var args = [];
    var wasValue = false;

    while (cursor !== null) {
        var node = cursor.data;
        var type = node.type;

        switch (type) {
            case 'Number':
            case 'Percentage':
                if (wasValue) {
                    return;
                }

                wasValue = true;
                args.push({
                    type: type,
                    value: Number(node.value)
                });
                break;

            case 'Operator':
                if (node.value === ',') {
                    if (!wasValue) {
                        return;
                    }
                    wasValue = false;
                } else if (wasValue || node.value !== '+') {
                    return;
                }
                break;

            default:
                // something we couldn't understand
                return;
        }

        cursor = cursor.next;
    }

    if (args.length !== count) {
        // invalid arguments count
        // TODO: remove those tokens
        return;
    }

    if (args.length === 4) {
        if (args[3].type !== 'Number') {
            // 4th argument should be a number
            // TODO: remove those tokens
            return;
        }

        args[3].type = 'Alpha';
    }

    if (rgb) {
        if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
            // invalid color, numbers and percentage shouldn't be mixed
            // TODO: remove those tokens
            return;
        }
    } else {
        if (args[0].type !== 'Number' ||
            args[1].type !== 'Percentage' ||
            args[2].type !== 'Percentage') {
            // invalid color, for hsl values should be: number, percentage, percentage
            // TODO: remove those tokens
            return;
        }

        args[0].type = 'Angle';
    }

    return args.map(function(arg) {
        var value = Math.max(0, arg.value);

        switch (arg.type) {
            case 'Number':
                // fit value to [0..255] range
                value = Math.min(value, 255);
                break;

            case 'Percentage':
                // convert 0..100% to value in [0..255] range
                value = Math.min(value, 100) / 100;

                if (!rgb) {
                    return value;
                }

                value = 255 * value;
                break;

            case 'Angle':
                // fit value to (-360..360) range
                return (((value % 360) + 360) % 360) / 360;

            case 'Alpha':
                // fit value to [0..1] range
                return Math.min(value, 1);
        }

        return Math.round(value);
    });
}

function compressFunction(node, item, list) {
    var functionName = node.name;
    var args;

    if (functionName === 'rgba' || functionName === 'hsla') {
        args = parseFunctionArgs(node.children, 4, functionName === 'rgba');

        if (!args) {
            // something went wrong
            return;
        }

        if (functionName === 'hsla') {
            args = hslToRgb.apply(null, args);
            node.name = 'rgba';
        }

        if (args[3] === 0) {
            // try to replace `rgba(x, x, x, 0)` to `transparent`
            // always replace `rgba(0, 0, 0, 0)` to `transparent`
            // otherwise avoid replacement in gradients since it may break color transition
            // http://stackoverflow.com/questions/11829410/css3-gradient-rendering-issues-from-transparent-to-white
            var scopeFunctionName = this['function'] && this['function'].name;
            if ((args[0] === 0 && args[1] === 0 && args[2] === 0) ||
                !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {

                item.data = {
                    type: 'Identifier',
                    loc: node.loc,
                    name: 'transparent'
                };

                return;
            }
        }

        if (args[3] !== 1) {
            // replace argument values for normalized/interpolated
            node.children.each(function(node, item, list) {
                if (node.type === 'Operator') {
                    if (node.value !== ',') {
                        list.remove(item);
                    }
                    return;
                }

                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: packNumber(args.shift(), null)
                };
            });

            return;
        }

        // otherwise convert to rgb, i.e. rgba(255, 0, 0, 1) -> rgb(255, 0, 0)
        functionName = 'rgb';
    }

    if (functionName === 'hsl') {
        args = args || parseFunctionArgs(node.children, 3, false);

        if (!args) {
            // something went wrong
            return;
        }

        // convert to rgb
        args = hslToRgb.apply(null, args);
        functionName = 'rgb';
    }

    if (functionName === 'rgb') {
        args = args || parseFunctionArgs(node.children, 3, true);

        if (!args) {
            // something went wrong
            return;
        }

        // check if color is not at the end and not followed by space
        var next = item.next;
        if (next && next.data.type !== 'WhiteSpace') {
            list.insert(list.createItem({
                type: 'WhiteSpace',
                value: ' '
            }), next);
        }

        item.data = {
            type: 'HexColor',
            loc: node.loc,
            value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
        };

        compressHex(item.data, item);
    }
}

function compressIdent(node, item) {
    if (this.declaration === null) {
        return;
    }

    var color = node.name.toLowerCase();

    if (NAME_TO_HEX.hasOwnProperty(color) &&
        lexer.matchDeclaration(this.declaration).isType(node, 'color')) {
        var hex = NAME_TO_HEX[color];

        if (hex.length + 1 <= color.length) {
            // replace for shorter hex value
            item.data = {
                type: 'HexColor',
                loc: node.loc,
                value: hex
            };
        } else {
            // special case for consistent colors
            if (color === 'grey') {
                color = 'gray';
            }

            // just replace value for lower cased name
            node.name = color;
        }
    }
}

function compressHex(node, item) {
    var color = node.value.toLowerCase();

    // #112233 -> #123
    if (color.length === 6 &&
        color[0] === color[1] &&
        color[2] === color[3] &&
        color[4] === color[5]) {
        color = color[0] + color[2] + color[4];
    }

    if (HEX_TO_NAME[color]) {
        item.data = {
            type: 'Identifier',
            loc: node.loc,
            name: HEX_TO_NAME[color]
        };
    } else {
        node.value = color;
    }
}

module.exports = {
    compressFunction: compressFunction,
    compressIdent: compressIdent,
    compressHex: compressHex
};


/***/ }),
/* 31 */
/***/ (function(module, exports) {

var hasOwnProperty = Object.prototype.hasOwnProperty;

function isEqualSelectors(a, b) {
    var cursor1 = a.head;
    var cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function isEqualDeclarations(a, b) {
    var cursor1 = a.head;
    var cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function compareDeclarations(declarations1, declarations2) {
    var result = {
        eq: [],
        ne1: [],
        ne2: [],
        ne2overrided: []
    };

    var fingerprints = Object.create(null);
    var declarations2hash = Object.create(null);

    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
        declarations2hash[cursor.data.id] = true;
    }

    for (var cursor = declarations1.head; cursor; cursor = cursor.next)  {
        var data = cursor.data;

        if (data.fingerprint) {
            fingerprints[data.fingerprint] = data.important;
        }

        if (declarations2hash[data.id]) {
            declarations2hash[data.id] = false;
            result.eq.push(data);
        } else {
            result.ne1.push(data);
        }
    }

    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
        var data = cursor.data;

        if (declarations2hash[data.id]) {
            // if declarations1 has overriding declaration, this is not a difference
            // but take in account !important - prev should be equal or greater than follow
            if (hasOwnProperty.call(fingerprints, data.fingerprint) &&
                Number(fingerprints[data.fingerprint]) >= Number(data.important)) {
                result.ne2overrided.push(data);
            } else {
                result.ne2.push(data);
            }
        }
    }

    return result;
}

function addSelectors(dest, source) {
    source.each(function(sourceData) {
        var newStr = sourceData.id;
        var cursor = dest.head;

        while (cursor) {
            var nextStr = cursor.data.id;

            if (nextStr === newStr) {
                return;
            }

            if (nextStr > newStr) {
                break;
            }

            cursor = cursor.next;
        }

        dest.insert(dest.createItem(sourceData), cursor);
    });

    return dest;
}

// check if simpleselectors has no equal specificity and element selector
function hasSimilarSelectors(selectors1, selectors2) {
    var cursor1 = selectors1.head;

    while (cursor1 !== null) {
        var cursor2 = selectors2.head;

        while (cursor2 !== null) {
            if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
                return true;
            }

            cursor2 = cursor2.next;
        }

        cursor1 = cursor1.next;
    }

    return false;
}

// test node can't to be skipped
function unsafeToSkipNode(node) {
    switch (node.type) {
        case 'Rule':
            // unsafe skip ruleset with selector similarities
            return hasSimilarSelectors(node.prelude.children, this);

        case 'Atrule':
            // can skip at-rules with blocks
            if (node.block) {
                // unsafe skip at-rule if block contains something unsafe to skip
                return node.block.children.some(unsafeToSkipNode, this);
            }
            break;

        case 'Declaration':
            return false;
    }

    // unsafe by default
    return true;
}

module.exports = {
    isEqualSelectors: isEqualSelectors,
    isEqualDeclarations: isEqualDeclarations,
    compareDeclarations: compareDeclarations,
    addSelectors: addSelectors,
    hasSimilarSelectors: hasSimilarSelectors,
    unsafeToSkipNode: unsafeToSkipNode
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(61);


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

const Expression = __webpack_require__(66)

module.exports = {
  /**
   * 获取表达式
   */
  getExpression(content) {
    let end = 0
    let start = content.indexOf('{{', end)
    const res = []

    while (start >= 0) {
      let expression

      res.push(content.substring(end, start)) // before
      start += 2
      end = content.indexOf('}}', start)

      if (end >= 0) {
        expression = new Expression(content.substring(start, end))
        end += 2
      } else {
        // without end
        res.push(content.substring(start - 2))
        end = content.length
      }

      if (expression) res.push(expression.parse())
      start = content.indexOf('{{', end)
    }

    res.push(content.substring(end)) // after

    return res.filter(item => !!item)
  },

  /**
   * 计算表达式
   */
  calcExpression(arr, data = {}) {
    if (!arr || typeof arr === 'string' || typeof arr === 'number' || typeof arr === 'boolean') {
      return arr
    } if (arr.length === 1 && typeof arr[0] === 'function') {
      return arr[0](data)
    }

    return arr.map(item => {
      if (typeof item === 'string') return item
      if (typeof item === 'function') return item(data)

      return ''
    }).join('')
  },
}


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

const exparser = __webpack_require__(4)
const _ = __webpack_require__(5)

/**
 * 测量相交区域
 */
function measureIntersect(baseRect, newRect) {
  const rect = {
    left: baseRect.left < newRect.left ? newRect.left : baseRect.left,
    top: baseRect.top < newRect.top ? newRect.top : baseRect.top,
    right: baseRect.right > newRect.right ? newRect.right : baseRect.right,
    bottom: baseRect.bottom > newRect.bottom ? newRect.bottom : baseRect.bottom,
    width: 0,
    height: 0,
  }
  if (rect.right > rect.left) rect.width = rect.right - rect.left
  else rect.right = rect.left = rect.bottom = rect.top = 0

  if (rect.bottom > rect.top) rect.height = rect.bottom - rect.top
  else rect.right = rect.left = rect.bottom = rect.top = 0

  return rect
}

/**
 * 测量参照区域
 */
function measureRelativeRect(relatives) {
  const clientWidth = document.documentElement.clientWidth
  const clientHeight = document.documentElement.clientHeight

  let retRect = null
  for (let i = 0; i < relatives.length; i++) {
    const {node, margins} = relatives[i]
    const boundingRect = node ? node.$$.getBoundingClientRect() : {
      left: 0,
      top: 0,
      right: clientWidth,
      bottom: clientHeight,
      width: clientWidth,
      height: clientHeight
    }
    const rect = {
      left: boundingRect.left - margins.left,
      top: boundingRect.top - margins.top,
      right: boundingRect.right + margins.right,
      bottom: boundingRect.bottom + margins.bottom,
    }

    if (retRect) retRect = measureIntersect(retRect, rect)
    else retRect = rect
  }

  return retRect
}

class IntersectionObserver {
  constructor(compInst, options = {}) {
    this._exparserNode = compInst._exparserNode
    this._relativeInfo = []
    this._options = options
    this._disconnected = false
    this._observers = []

    this._exparserNode._listenInfoMap = this._exparserNode._listenInfoMap || {} // 存入监听信息
  }

  /**
     * 检查并更新目标节点的相交情况
     */
  static updateTargetIntersection(listenerInfo) {
    const {
      targetNode, relatives, thresholds, minWidthOrHeight, currentRatio, callback
    } = listenerInfo
    const targetRect = targetNode.$$.getBoundingClientRect()

    if (targetRect.right - targetRect.left < minWidthOrHeight) {
      targetRect.right = targetRect.left + minWidthOrHeight
      targetRect.width = minWidthOrHeight
    }
    if (targetRect.bottom - targetRect.top < minWidthOrHeight) {
      targetRect.bottom = targetRect.top + minWidthOrHeight
      targetRect.height = minWidthOrHeight
    }

    const relativeRect = measureRelativeRect(relatives)
    const intersectRect = measureIntersect(relativeRect, targetRect)
    const targetArea = targetRect.width * targetRect.height
    const intersectRatio = targetArea ? intersectRect.width * intersectRect.height / targetArea : 0

    listenerInfo.currentRatio = intersectRatio

    let isUpdate = currentRatio === undefined
    if (intersectRatio !== currentRatio) {
      thresholds.forEach(threshold => {
        if (isUpdate) return
        if (intersectRatio <= threshold && currentRatio >= threshold) isUpdate = true
        else if (intersectRatio >= threshold && currentRatio <= threshold) isUpdate = true
      })
    }

    if (isUpdate) {
      callback.call(targetNode, {
        id: targetNode.id,
        dataset: targetNode.dataset,
        time: Date.now(),
        boundingClientRect: targetRect,
        intersectionRatio: intersectRatio,
        intersectionRect: intersectRect,
        relativeRect,
      })
    }
  }

  disconnect() {
    this._disconnected = true
    this._observers.forEach(observer => observer.disconnect())
    this._observers = []
  }

  observe(selector, callback) {
    // 获取目标节点
    const shadowRoot = this._exparserNode.shadowRoot
    let targetNodes = this._options.observeAll ? shadowRoot.querySelectorAll(selector) : shadowRoot.querySelector(selector)
    if (!Array.isArray(targetNodes)) targetNodes = targetNodes ? [targetNodes] : []

    // 获取参照区域
    const relatives = []
    this._relativeInfo.forEach(item => {
      const {selector, margins} = item
      const node = selector === null ? null : shadowRoot.querySelector(selector)
      if (selector === null || node) {
        relatives.push({
          node,
          margins: {
            left: margins.left || 0,
            top: margins.top || 0,
            right: margins.right || 0,
            bottom: margins.bottom || 0,
          },
        })
      }
    })

    targetNodes.forEach(targetNode => {
      const id = _.getId()
      const listenerInfo = {
        targetNode,
        relatives,
        thresholds: this._options.thresholds || [0],
        currentRatio: this._options.initialRatio || 0,
        minWidthOrHeight: 0,
        callback,
      }
      const observer = exparser.Observer.create(evt => {
        if (evt.status === 'attached') {
          this._exparserNode._listenInfoMap[id] = listenerInfo
          window.requestAnimationFrame(() => {
            if (!this._disconnected) IntersectionObserver.updateTargetIntersection(listenerInfo)
          })
        } else if (evt.status === 'detached') {
          delete this._exparserNode._listenInfoMap[id]
          observer.disconnect()
        }
      })
      observer.observe(targetNode, {attachStatus: true})
      if (exparser.Element.isAttached(targetNode)) {
        this._exparserNode._listenInfoMap[id] = listenerInfo
        window.requestAnimationFrame(() => {
          if (!this._disconnected) IntersectionObserver.updateTargetIntersection(listenerInfo)
        })
      }

      this._observers.push(observer)
    })
  }

  relativeTo(selector, margins = {}) {
    this._relativeInfo.push({
      selector,
      margins,
    })
    return this
  }

  relativeToViewport(margins = {}) {
    this._relativeInfo.push({
      selector: null,
      margins,
    })
    return this
  }
}

module.exports = IntersectionObserver


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _supportsColor = _interopRequireDefault(__webpack_require__(74));

var _chalk = _interopRequireDefault(__webpack_require__(75));

var _terminalHighlight = _interopRequireDefault(__webpack_require__(76));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * The CSS parser throws this error for broken CSS.
 *
 * Custom parsers can throw this error for broken custom syntax using
 * the {@link Node#error} method.
 *
 * PostCSS will use the input source map to detect the original error location.
 * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
 * PostCSS will show the original position in the Sass file.
 *
 * If you need the position in the PostCSS input
 * (e.g., to debug the previous compiler), use `error.input.file`.
 *
 * @example
 * // Catching and checking syntax error
 * try {
 *   postcss.parse('a{')
 * } catch (error) {
 *   if (error.name === 'CssSyntaxError') {
 *     error //=> CssSyntaxError
 *   }
 * }
 *
 * @example
 * // Raising error from plugin
 * throw node.error('Unknown variable', { plugin: 'postcss-vars' })
 */
var CssSyntaxError =
/*#__PURE__*/
function (_Error) {
  _inheritsLoose(CssSyntaxError, _Error);

  /**
   * @param {string} message  Error message.
   * @param {number} [line]   Source line of the error.
   * @param {number} [column] Source column of the error.
   * @param {string} [source] Source code of the broken file.
   * @param {string} [file]   Absolute path to the broken file.
   * @param {string} [plugin] PostCSS plugin name, if error came from plugin.
   */
  function CssSyntaxError(message, line, column, source, file, plugin) {
    var _this;

    _this = _Error.call(this, message) || this;
    /**
     * Always equal to `'CssSyntaxError'`. You should always check error type
     * by `error.name === 'CssSyntaxError'`
     * instead of `error instanceof CssSyntaxError`,
     * because npm could have several PostCSS versions.
     *
     * @type {string}
     *
     * @example
     * if (error.name === 'CssSyntaxError') {
     *   error //=> CssSyntaxError
     * }
     */

    _this.name = 'CssSyntaxError';
    /**
     * Error message.
     *
     * @type {string}
     *
     * @example
     * error.message //=> 'Unclosed block'
     */

    _this.reason = message;

    if (file) {
      /**
       * Absolute path to the broken file.
       *
       * @type {string}
       *
       * @example
       * error.file       //=> 'a.sass'
       * error.input.file //=> 'a.css'
       */
      _this.file = file;
    }

    if (source) {
      /**
       * Source code of the broken file.
       *
       * @type {string}
       *
       * @example
       * error.source       //=> 'a { b {} }'
       * error.input.column //=> 'a b { }'
       */
      _this.source = source;
    }

    if (plugin) {
      /**
       * Plugin name, if error came from plugin.
       *
       * @type {string}
       *
       * @example
       * error.plugin //=> 'postcss-vars'
       */
      _this.plugin = plugin;
    }

    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
      /**
       * Source line of the error.
       *
       * @type {number}
       *
       * @example
       * error.line       //=> 2
       * error.input.line //=> 4
       */
      _this.line = line;
      /**
       * Source column of the error.
       *
       * @type {number}
       *
       * @example
       * error.column       //=> 1
       * error.input.column //=> 4
       */

      _this.column = column;
    }

    _this.setMessage();

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), CssSyntaxError);
    }

    return _this;
  }

  var _proto = CssSyntaxError.prototype;

  _proto.setMessage = function setMessage() {
    /**
     * Full error text in the GNU error format
     * with plugin, file, line and column.
     *
     * @type {string}
     *
     * @example
     * error.message //=> 'a.css:1:1: Unclosed block'
     */
    this.message = this.plugin ? this.plugin + ': ' : '';
    this.message += this.file ? this.file : '<css input>';

    if (typeof this.line !== 'undefined') {
      this.message += ':' + this.line + ':' + this.column;
    }

    this.message += ': ' + this.reason;
  }
  /**
   * Returns a few lines of CSS source that caused the error.
   *
   * If the CSS has an input source map without `sourceContent`,
   * this method will return an empty string.
   *
   * @param {boolean} [color] Whether arrow will be colored red by terminal
   *                          color codes. By default, PostCSS will detect
   *                          color support by `process.stdout.isTTY`
   *                          and `process.env.NODE_DISABLE_COLORS`.
   *
   * @example
   * error.showSourceCode() //=> "  4 | }
   *                        //      5 | a {
   *                        //    > 6 |   bad
   *                        //        |   ^
   *                        //      7 | }
   *                        //      8 | b {"
   *
   * @return {string} Few lines of CSS source that caused the error.
   */
  ;

  _proto.showSourceCode = function showSourceCode(color) {
    var _this2 = this;

    if (!this.source) return '';
    var css = this.source;

    if (_terminalHighlight.default) {
      if (typeof color === 'undefined') color = _supportsColor.default.stdout;
      if (color) css = (0, _terminalHighlight.default)(css);
    }

    var lines = css.split(/\r?\n/);
    var start = Math.max(this.line - 3, 0);
    var end = Math.min(this.line + 2, lines.length);
    var maxWidth = String(end).length;

    function mark(text) {
      if (color && _chalk.default.red) {
        return _chalk.default.red.bold(text);
      }

      return text;
    }

    function aside(text) {
      if (color && _chalk.default.gray) {
        return _chalk.default.gray(text);
      }

      return text;
    }

    return lines.slice(start, end).map(function (line, index) {
      var number = start + 1 + index;
      var gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';

      if (number === _this2.line) {
        var spacing = aside(gutter.replace(/\d/g, ' ')) + line.slice(0, _this2.column - 1).replace(/[^\t]/g, ' ');
        return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^');
      }

      return ' ' + aside(gutter) + line;
    }).join('\n');
  }
  /**
   * Returns error position, message and source code of the broken part.
   *
   * @example
   * error.toString() //=> "CssSyntaxError: app.css:1:1: Unclosed block
   *                  //    > 1 | a {
   *                  //        | ^"
   *
   * @return {string} Error position, message and source code.
   */
  ;

  _proto.toString = function toString() {
    var code = this.showSourceCode();

    if (code) {
      code = '\n\n' + code + '\n';
    }

    return this.name + ': ' + this.message + code;
  }
  /**
   * @memberof CssSyntaxError#
   * @member {Input} input Input object with PostCSS internal information
   *                       about input file. If input has source map
   *                       from previous tool, PostCSS will use origin
   *                       (for example, Sass) source. You can use this
   *                       object to get PostCSS input source.
   *
   * @example
   * error.input.file //=> 'a.css'
   * error.file       //=> 'a.sass'
   */
  ;

  return CssSyntaxError;
}(_wrapNativeSuper(Error));

var _default = CssSyntaxError;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNzcy1zeW50YXgtZXJyb3IuZXM2Il0sIm5hbWVzIjpbIkNzc1N5bnRheEVycm9yIiwibWVzc2FnZSIsImxpbmUiLCJjb2x1bW4iLCJzb3VyY2UiLCJmaWxlIiwicGx1Z2luIiwibmFtZSIsInJlYXNvbiIsInNldE1lc3NhZ2UiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwic2hvd1NvdXJjZUNvZGUiLCJjb2xvciIsImNzcyIsInRlcm1pbmFsSGlnaGxpZ2h0Iiwic3VwcG9ydHNDb2xvciIsInN0ZG91dCIsImxpbmVzIiwic3BsaXQiLCJzdGFydCIsIk1hdGgiLCJtYXgiLCJlbmQiLCJtaW4iLCJsZW5ndGgiLCJtYXhXaWR0aCIsIlN0cmluZyIsIm1hcmsiLCJ0ZXh0IiwiY2hhbGsiLCJyZWQiLCJib2xkIiwiYXNpZGUiLCJncmF5Iiwic2xpY2UiLCJtYXAiLCJpbmRleCIsIm51bWJlciIsImd1dHRlciIsInNwYWNpbmciLCJyZXBsYWNlIiwiam9pbiIsInRvU3RyaW5nIiwiY29kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMkJNQSxjOzs7OztBQUNKOzs7Ozs7OztBQVFBLDBCQUFhQyxPQUFiLEVBQXNCQyxJQUF0QixFQUE0QkMsTUFBNUIsRUFBb0NDLE1BQXBDLEVBQTRDQyxJQUE1QyxFQUFrREMsTUFBbEQsRUFBMEQ7QUFBQTs7QUFDeEQsOEJBQU1MLE9BQU47QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFhQSxVQUFLTSxJQUFMLEdBQVksZ0JBQVo7QUFDQTs7Ozs7Ozs7O0FBUUEsVUFBS0MsTUFBTCxHQUFjUCxPQUFkOztBQUVBLFFBQUlJLElBQUosRUFBVTtBQUNSOzs7Ozs7Ozs7QUFTQSxZQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFDRDs7QUFDRCxRQUFJRCxNQUFKLEVBQVk7QUFDVjs7Ozs7Ozs7O0FBU0EsWUFBS0EsTUFBTCxHQUFj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OztBQUNBLFVBQUlZLE1BQU0sS0FBSyxNQUFJLENBQUNwQyxJQUFwQixFQUEwQjtBQUN4QixZQUFJc0MsT0FBTyxHQUFHUCxLQUFLLENBQUNNLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLEtBQWYsRUFBc0IsR0FBdEIsQ0FBRCxDQUFMLEdBQ1p2QyxJQUFJLENBQUNpQyxLQUFMLENBQVcsQ0FBWCxFQUFjLE1BQUksQ0FBQ2hDLE1BQUwsR0FBYyxDQUE1QixFQUErQnNDLE9BQS9CLENBQXVDLFFBQXZDLEVBQWlELEdBQWpELENBREY7QUFFQSxlQUFPYixJQUFJLENBQUMsR0FBRCxDQUFKLEdBQVlLLEtBQUssQ0FBQ00sTUFBRCxDQUFqQixHQUE0QnJDLElBQTVCLEdBQW1DLEtBQW5DLEdBQTJDc0MsT0FBM0MsR0FBcURaLElBQUksQ0FBQyxHQUFELENBQWhFO0FBQ0Q7O0FBQ0QsYUFBTyxNQUFNSyxLQUFLLENBQUNNLE1BQUQsQ0FBWCxHQUFzQnJDLElBQTdCO0FBQ0QsS0FUTSxFQVNKd0MsSUFUSSxDQVNDLElBVEQsQ0FBUDtBQVVEO0FBRUQ7Ozs7Ozs7Ozs7OztTQVVBQyxRLEdBQUEsb0JBQVk7QUFDVixRQUFJQyxJQUFJLEdBQUcsS0FBS2hDLGNBQUwsRUFBWDs7QUFDQSxRQUFJZ0MsSUFBSixFQUFVO0FBQ1JBLE1BQUFBLElBQUksR0FBRyxTQUFTQSxJQUFULEdBQWdCLElBQXZCO0FBQ0Q7O0FBQ0QsV0FBTyxLQUFLckMsSUFBTCxHQUFZLElBQVosR0FBbUIsS0FBS04sT0FBeEIsR0FBa0MyQyxJQUF6QztBQUNEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7OzttQkF0TTJCbEMsSzs7ZUFvTmRWLGMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3VwcG9ydHNDb2xvciBmcm9tICdzdXBwb3J0cy1jb2xvcidcbmltcG9ydCBjaGFsayBmcm9tICdjaGFsaydcblxuaW1wb3J0IHRlcm1pbmFsSGlnaGxpZ2h0IGZyb20gJy4vdGVybWluYWwtaGlnaGxpZ2h0J1xuXG4vKipcbiAqIFRoZSBDU1MgcGFyc2VyIHRocm93cyB0aGlzIGVycm9yIGZvciBicm9rZW4gQ1NTLlxuICpcbiAqIEN1c3RvbSBwYXJzZXJzIGNhbiB0aHJvdyB0aGlzIGVycm9yIGZvciBicm9rZW4gY3VzdG9tIHN5bnRheCB1c2luZ1xuICogdGhlIHtAbGluayBOb2RlI2Vycm9yfSBtZXRob2QuXG4gKlxuICogUG9zdENTUyB3aWxsIHVzZSB0aGUgaW5wdXQgc291cmNlIG1hcCB0byBkZXRlY3QgdGhlIG9yaWdpbmFsIGVycm9yIGxvY2F0aW9uLlxuICogSWYgeW91IHdyb3RlIGEgU2FzcyBmaWxlLCBjb21waWxlZCBpdCB0byBDU1MgYW5kIHRoZW4gcGFyc2VkIGl0IHdpdGggUG9zdENTUyxcbiAqIFBvc3RDU1Mgd2lsbCBzaG93IHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpbiB0aGUgU2FzcyBmaWxlLlxuICpcbiAqIElmIHlvdSBuZWVkIHRoZSBwb3NpdGlvbiBpbiB0aGUgUG9zdENTUyBpbnB1dFxuICogKGUuZy4sIHRvIGRlYnVnIHRoZSBwcmV2aW91cyBjb21waWxlciksIHVzZSBgZXJyb3IuaW5wdXQuZmlsZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENhdGNoaW5nIGFuZCBjaGVja2luZyBzeW50YXggZXJyb3JcbiAqIHRyeSB7XG4gKiAgIHBvc3Rjc3MucGFyc2UoJ2F7JylcbiAqIH0gY2F0Y2ggKGVycm9yKSB7XG4gKiAgIGlmIChlcnJvci5uYW1lID09PSAnQ3NzU3ludGF4RXJyb3InKSB7XG4gKiAgICAgZXJyb3IgLy89PiBDc3NTeW50YXhFcnJvclxuICogICB9XG4gKiB9XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJhaXNpbmcgZXJyb3IgZnJvbSBwbHVnaW5cbiAqIHRocm93IG5vZGUuZXJyb3IoJ1Vua25vd24gdmFyaWFibGUnLCB7IHBsdWdpbjogJ3Bvc3Rjc3MtdmFycycgfSlcbiAqL1xuY2xhc3MgQ3NzU3ludGF4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAgRXJyb3IgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW5lXSAgIFNvdXJjZSBsaW5lIG9mIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2x1bW5dIFNvdXJjZSBjb2x1bW4gb2YgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZV0gU291cmNlIGNvZGUgb2YgdGhlIGJyb2tlbiBmaWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZpbGVdICAgQWJzb2x1dGUgcGF0aCB0byB0aGUgYnJva2VuIGZpbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGx1Z2luXSBQb3N0Q1NTIHBsdWdpbiBuYW1lLCBpZiBlcnJvciBjYW1lIGZyb20gcGx1Z2luLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgc291cmNlLCBmaWxlLCBwbHVnaW4pIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuXG4gICAgLyoqXG4gICAgICogQWx3YXlzIGVxdWFsIHRvIGAnQ3NzU3ludGF4RXJyb3InYC4gWW91IHNob3VsZCBhbHdheXMgY2hlY2sgZXJyb3IgdHlwZVxuICAgICAqIGJ5IGBlcnJvci5uYW1lID09PSAnQ3NzU3ludGF4RXJyb3InYFxuICAgICAqIGluc3RlYWQgb2YgYGVycm9yIGluc3RhbmNlb2YgQ3NzU3ludGF4RXJyb3JgLFxuICAgICAqIGJlY2F1c2UgbnBtIGNvdWxkIGhhdmUgc2V2ZXJhbCBQb3N0Q1NTIHZlcnNpb25zLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaWYgKGVycm9yLm5hbWUgPT09ICdDc3NTeW50YXhFcnJvcicpIHtcbiAgICAgKiAgIGVycm9yIC8vPT4gQ3NzU3ludGF4RXJyb3JcbiAgICAgKiB9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gJ0Nzc1N5bnRheEVycm9yJ1xuICAgIC8qKlxuICAgICAqIEVycm9yIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBlcnJvci5tZXNzYWdlIC8vPT4gJ1VuY2xvc2VkIGJsb2NrJ1xuICAgICAqL1xuICAgIHRoaXMucmVhc29uID0gbWVzc2FnZVxuXG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIC8qKlxuICAgICAgICogQWJzb2x1dGUgcGF0aCB0byB0aGUgYnJva2VuIGZpbGUuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogZXJyb3IuZmlsZSAgICAgICAvLz0+ICdhLnNhc3MnXG4gICAgICAgKiBlcnJvci5pbnB1dC5maWxlIC8vPT4gJ2EuY3NzJ1xuICAgICAgICovXG4gICAgICB0aGlzLmZpbGUgPSBmaWxlXG4gICAgfVxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIC8qKlxuICAgICAgICogU291cmNlIGNvZGUgb2YgdGhlIGJyb2tlbiBmaWxlLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGVycm9yLnNvdXJjZSAgICAgICAvLz0+ICdhIHsgYiB7fSB9J1xuICAgICAgICogZXJyb3IuaW5wdXQuY29sdW1uIC8vPT4gJ2EgYiB7IH0nXG4gICAgICAgKi9cbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlXG4gICAgfVxuICAgIGlmIChwbHVnaW4pIHtcbiAgICAgIC8qKlxuICAgICAgICogUGx1Z2luIG5hbWUsIGlmIGVycm9yIGNhbWUgZnJvbSBwbHVnaW4uXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogZXJyb3IucGx1Z2luIC8vPT4gJ3Bvc3Rjc3MtdmFycydcbiAgICAgICAqL1xuICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW5cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsaW5lICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29sdW1uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLyoqXG4gICAgICAgKiBTb3VyY2UgbGluZSBvZiB0aGUgZXJyb3IuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogZXJyb3IubGluZSAgICAgICAvLz0+IDJcbiAgICAgICAqIGVycm9yLmlucHV0LmxpbmUgLy89PiA0XG4gICAgICAgKi9cbiAgICAgIHRoaXMubGluZSA9IGxpbmVcbiAgICAgIC8qKlxuICAgICAgICogU291cmNlIGNvbHVtbiBvZiB0aGUgZXJyb3IuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogZXJyb3IuY29sdW1uICAgICAgIC8vPT4gMVxuICAgICAgICogZXJyb3IuaW5wdXQuY29sdW1uIC8vPT4gNFxuICAgICAgICovXG4gICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtblxuICAgIH1cblxuICAgIHRoaXMuc2V0TWVzc2FnZSgpXG5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENzc1N5bnRheEVycm9yKVxuICAgIH1cbiAgfVxuXG4gIHNldE1lc3NhZ2UgKCkge1xuICAgIC8qKlxuICAgICAqIEZ1bGwgZXJyb3IgdGV4dCBpbiB0aGUgR05VIGVycm9yIGZvcm1hdFxuICAgICAqIHdpdGggcGx1Z2luLCBmaWxlLCBsaW5lIGFuZCBjb2x1bW4uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBlcnJvci5tZXNzYWdlIC8vPT4gJ2EuY3NzOjE6MTogVW5jbG9zZWQgYmxvY2snXG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5wbHVnaW4gPyB0aGlzLnBsdWdpbiArICc6ICcgOiAnJ1xuICAgIHRoaXMubWVzc2FnZSArPSB0aGlzLmZpbGUgPyB0aGlzLmZpbGUgOiAnPGNzcyBpbnB1dD4nXG4gICAgaWYgKHR5cGVvZiB0aGlzLmxpbmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgKz0gJzonICsgdGhpcy5saW5lICsgJzonICsgdGhpcy5jb2x1bW5cbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlICs9ICc6ICcgKyB0aGlzLnJlYXNvblxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmZXcgbGluZXMgb2YgQ1NTIHNvdXJjZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IuXG4gICAqXG4gICAqIElmIHRoZSBDU1MgaGFzIGFuIGlucHV0IHNvdXJjZSBtYXAgd2l0aG91dCBgc291cmNlQ29udGVudGAsXG4gICAqIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGFuIGVtcHR5IHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbY29sb3JdIFdoZXRoZXIgYXJyb3cgd2lsbCBiZSBjb2xvcmVkIHJlZCBieSB0ZXJtaW5hbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgY29kZXMuIEJ5IGRlZmF1bHQsIFBvc3RDU1Mgd2lsbCBkZXRlY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yIHN1cHBvcnQgYnkgYHByb2Nlc3Muc3Rkb3V0LmlzVFRZYFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGBwcm9jZXNzLmVudi5OT0RFX0RJU0FCTEVfQ09MT1JTYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZXJyb3Iuc2hvd1NvdXJjZUNvZGUoKSAvLz0+IFwiICA0IHwgfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgNSB8IGEge1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgID4gNiB8ICAgYmFkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgIHwgICBeXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICA3IHwgfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgOCB8IGIge1wiXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gRmV3IGxpbmVzIG9mIENTUyBzb3VyY2UgdGhhdCBjYXVzZWQgdGhlIGVycm9yLlxuICAgKi9cbiAgc2hvd1NvdXJjZUNvZGUgKGNvbG9yKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZSkgcmV0dXJuICcnXG5cbiAgICBsZXQgY3NzID0gdGhpcy5zb3VyY2VcbiAgICBpZiAodGVybWluYWxIaWdobGlnaHQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICd1bmRlZmluZWQnKSBjb2xvciA9IHN1cHBvcnRzQ29sb3Iuc3Rkb3V0XG4gICAgICBpZiAoY29sb3IpIGNzcyA9IHRlcm1pbmFsSGlnaGxpZ2h0KGNzcylcbiAgICB9XG5cbiAgICBsZXQgbGluZXMgPSBjc3Muc3BsaXQoL1xccj9cXG4vKVxuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHRoaXMubGluZSAtIDMsIDApXG4gICAgbGV0IGVuZCA9IE1hdGgubWluKHRoaXMubGluZSArIDIsIGxpbmVzLmxlbmd0aClcblxuICAgIGxldCBtYXhXaWR0aCA9IFN0cmluZyhlbmQpLmxlbmd0aFxuXG4gICAgZnVuY3Rpb24gbWFyayAodGV4dCkge1xuICAgICAgaWYgKGNvbG9yICYmIGNoYWxrLnJlZCkge1xuICAgICAgICByZXR1cm4gY2hhbGsucmVkLmJvbGQodGV4dClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzaWRlICh0ZXh0KSB7XG4gICAgICBpZiAoY29sb3IgJiYgY2hhbGsuZ3JheSkge1xuICAgICAgICByZXR1cm4gY2hhbGsuZ3JheSh0ZXh0KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHRcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IG51bWJlciA9IHN0YXJ0ICsgMSArIGluZGV4XG4gICAgICBsZXQgZ3V0dGVyID0gJyAnICsgKCcgJyArIG51bWJlcikuc2xpY2UoLW1heFdpZHRoKSArICcgfCAnXG4gICAgICBpZiAobnVtYmVyID09PSB0aGlzLmxpbmUpIHtcbiAgICAgICAgbGV0IHNwYWNpbmcgPSBhc2lkZShndXR0ZXIucmVwbGFjZSgvXFxkL2csICcgJykpICtcbiAgICAgICAgICBsaW5lLnNsaWNlKDAsIHRoaXMuY29sdW1uIC0gMSkucmVwbGFjZSgvW15cXHRdL2csICcgJylcbiAgICAgICAgcmV0dXJuIG1hcmsoJz4nKSArIGFzaWRlKGd1dHRlcikgKyBsaW5lICsgJ1xcbiAnICsgc3BhY2luZyArIG1hcmsoJ14nKVxuICAgICAgfVxuICAgICAgcmV0dXJuICcgJyArIGFzaWRlKGd1dHRlcikgKyBsaW5lXG4gICAgfSkuam9pbignXFxuJylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVycm9yIHBvc2l0aW9uLCBtZXNzYWdlIGFuZCBzb3VyY2UgY29kZSBvZiB0aGUgYnJva2VuIHBhcnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVycm9yLnRvU3RyaW5nKCkgLy89PiBcIkNzc1N5bnRheEVycm9yOiBhcHAuY3NzOjE6MTogVW5jbG9zZWQgYmxvY2tcbiAgICogICAgICAgICAgICAgICAgICAvLyAgICA+IDEgfCBhIHtcbiAgICogICAgICAgICAgICAgICAgICAvLyAgICAgICAgfCBeXCJcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBFcnJvciBwb3NpdGlvbiwgbWVzc2FnZSBhbmQgc291cmNlIGNvZGUuXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgbGV0IGNvZGUgPSB0aGlzLnNob3dTb3VyY2VDb2RlKClcbiAgICBpZiAoY29kZSkge1xuICAgICAgY29kZSA9ICdcXG5cXG4nICsgY29kZSArICdcXG4nXG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5hbWUgKyAnOiAnICsgdGhpcy5tZXNzYWdlICsgY29kZVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBDc3NTeW50YXhFcnJvciNcbiAgICogQG1lbWJlciB7SW5wdXR9IGlucHV0IElucHV0IG9iamVjdCB3aXRoIFBvc3RDU1MgaW50ZXJuYWwgaW5mb3JtYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgIGFib3V0IGlucHV0IGZpbGUuIElmIGlucHV0IGhhcyBzb3VyY2UgbWFwXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHByZXZpb3VzIHRvb2wsIFBvc3RDU1Mgd2lsbCB1c2Ugb3JpZ2luXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAoZm9yIGV4YW1wbGUsIFNhc3MpIHNvdXJjZS4gWW91IGNhbiB1c2UgdGhpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHRvIGdldCBQb3N0Q1NTIGlucHV0IHNvdXJjZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZXJyb3IuaW5wdXQuZmlsZSAvLz0+ICdhLmNzcydcbiAgICogZXJyb3IuZmlsZSAgICAgICAvLz0+ICdhLnNhc3MnXG4gICAqL1xufVxuXG5leHBvcnQgZGVmYXVsdCBDc3NTeW50YXhFcnJvclxuIl0sImZpbGUiOiJjc3Mtc3ludGF4LWVycm9yLmpzIn0=


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;
var DEFAULT_RAW = {
  colon: ': ',
  indent: '    ',
  beforeDecl: '\n',
  beforeRule: '\n',
  beforeOpen: ' ',
  beforeClose: '\n',
  beforeComment: '\n',
  after: '\n',
  emptyBody: '',
  commentLeft: ' ',
  commentRight: ' ',
  semicolon: false
};

function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}

var Stringifier =
/*#__PURE__*/
function () {
  function Stringifier(builder) {
    this.builder = builder;
  }

  var _proto = Stringifier.prototype;

  _proto.stringify = function stringify(node, semicolon) {
    this[node.type](node, semicolon);
  };

  _proto.root = function root(node) {
    this.body(node);
    if (node.raws.after) this.builder(node.raws.after);
  };

  _proto.comment = function comment(node) {
    var left = this.raw(node, 'left', 'commentLeft');
    var right = this.raw(node, 'right', 'commentRight');
    this.builder('/*' + left + node.text + right + '*/', node);
  };

  _proto.decl = function decl(node, semicolon) {
    var between = this.raw(node, 'between', 'colon');
    var string = node.prop + between + this.rawValue(node, 'value');

    if (node.important) {
      string += node.raws.important || ' !important';
    }

    if (semicolon) string += ';';
    this.builder(string, node);
  };

  _proto.rule = function rule(node) {
    this.block(node, this.rawValue(node, 'selector'));

    if (node.raws.ownSemicolon) {
      this.builder(node.raws.ownSemicolon, node, 'end');
    }
  };

  _proto.atrule = function atrule(node, semicolon) {
    var name = '@' + node.name;
    var params = node.params ? this.rawValue(node, 'params') : '';

    if (typeof node.raws.afterName !== 'undefined') {
      name += node.raws.afterName;
    } else if (params) {
      name += ' ';
    }

    if (node.nodes) {
      this.block(node, name + params);
    } else {
      var end = (node.raws.between || '') + (semicolon ? ';' : '');
      this.builder(name + params + end, node);
    }
  };

  _proto.body = function body(node) {
    var last = node.nodes.length - 1;

    while (last > 0) {
      if (node.nodes[last].type !== 'comment') break;
      last -= 1;
    }

    var semicolon = this.raw(node, 'semicolon');

    for (var i = 0; i < node.nodes.length; i++) {
      var child = node.nodes[i];
      var before = this.raw(child, 'before');
      if (before) this.builder(before);
      this.stringify(child, last !== i || semicolon);
    }
  };

  _proto.block = function block(node, start) {
    var between = this.raw(node, 'between', 'beforeOpen');
    this.builder(start + between + '{', node, 'start');
    var after;

    if (node.nodes && node.nodes.length) {
      this.body(node);
      after = this.raw(node, 'after');
    } else {
      after = this.raw(node, 'after', 'emptyBody');
    }

    if (after) this.builder(after);
    this.builder('}', node, 'end');
  };

  _proto.raw = function raw(node, own, detect) {
    var value;
    if (!detect) detect = own; // Already had

    if (own) {
      value = node.raws[own];
      if (typeof value !== 'undefined') return value;
    }

    var parent = node.parent; // Hack for first rule in CSS

    if (detect === 'before') {
      if (!parent || parent.type === 'root' && parent.first === node) {
        return '';
      }
    } // Floating child without parent


    if (!parent) return DEFAULT_RAW[detect]; // Detect style by other nodes

    var root = node.root();
    if (!root.rawCache) root.rawCache = {};

    if (typeof root.rawCache[detect] !== 'undefined') {
      return root.rawCache[detect];
    }

    if (detect === 'before' || detect === 'after') {
      return this.beforeAfter(node, detect);
    } else {
      var method = 'raw' + capitalize(detect);

      if (this[method]) {
        value = this[method](root, node);
      } else {
        root.walk(function (i) {
          value = i.raws[own];
          if (typeof value !== 'undefined') return false;
        });
      }
    }

    if (typeof value === 'undefined') value = DEFAULT_RAW[detect];
    root.rawCache[detect] = value;
    return value;
  };

  _proto.rawSemicolon = function rawSemicolon(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
        value = i.raws.semicolon;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  };

  _proto.rawEmptyBody = function rawEmptyBody(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && i.nodes.length === 0) {
        value = i.raws.after;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  };

  _proto.rawIndent = function rawIndent(root) {
    if (root.raws.indent) return root.raws.indent;
    var value;
    root.walk(function (i) {
      var p = i.parent;

      if (p && p !== root && p.parent && p.parent === root) {
        if (typeof i.raws.before !== 'undefined') {
          var parts = i.raws.before.split('\n');
          value = parts[parts.length - 1];
          value = value.replace(/[^\s]/g, '');
          return false;
        }
      }
    });
    return value;
  };

  _proto.rawBeforeComment = function rawBeforeComment(root, node) {
    var value;
    root.walkComments(function (i) {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before;

        if (value.indexOf('\n') !== -1) {
          value = value.replace(/[^\n]+$/, '');
        }

        return false;
      }
    });

    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeDecl');
    } else if (value) {
      value = value.replace(/[^\s]/g, '');
    }

    return value;
  };

  _proto.rawBeforeDecl = function rawBeforeDecl(root, node) {
    var value;
    root.walkDecls(function (i) {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before;

        if (value.indexOf('\n') !== -1) {
          value = value.replace(/[^\n]+$/, '');
        }

        return false;
      }
    });

    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeRule');
    } else if (value) {
      value = value.replace(/[^\s]/g, '');
    }

    return value;
  };

  _proto.rawBeforeRule = function rawBeforeRule(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && (i.parent !== root || root.first !== i)) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before;

          if (value.indexOf('\n') !== -1) {
            value = value.replace(/[^\n]+$/, '');
          }

          return false;
        }
      }
    });
    if (value) value = value.replace(/[^\s]/g, '');
    return value;
  };

  _proto.rawBeforeClose = function rawBeforeClose(root) {
    var value;
    root.walk(function (i) {
      if (i.nodes && i.nodes.length > 0) {
        if (typeof i.raws.after !== 'undefined') {
          value = i.raws.after;

          if (value.indexOf('\n') !== -1) {
            value = value.replace(/[^\n]+$/, '');
          }

          return false;
        }
      }
    });
    if (value) value = value.replace(/[^\s]/g, '');
    return value;
  };

  _proto.rawBeforeOpen = function rawBeforeOpen(root) {
    var value;
    root.walk(function (i) {
      if (i.type !== 'decl') {
        value = i.raws.between;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  };

  _proto.rawColon = function rawColon(root) {
    var value;
    root.walkDecls(function (i) {
      if (typeof i.raws.between !== 'undefined') {
        value = i.raws.between.replace(/[^\s:]/g, '');
        return false;
      }
    });
    return value;
  };

  _proto.beforeAfter = function beforeAfter(node, detect) {
    var value;

    if (node.type === 'decl') {
      value = this.raw(node, null, 'beforeDecl');
    } else if (node.type === 'comment') {
      value = this.raw(node, null, 'beforeComment');
    } else if (detect === 'before') {
      value = this.raw(node, null, 'beforeRule');
    } else {
      value = this.raw(node, null, 'beforeClose');
    }

    var buf = node.parent;
    var depth = 0;

    while (buf && buf.type !== 'root') {
      depth += 1;
      buf = buf.parent;
    }

    if (value.indexOf('\n') !== -1) {
      var indent = this.raw(node, null, 'indent');

      if (indent.length) {
        for (var step = 0; step < depth; step++) {
          value += indent;
        }
      }
    }

    return value;
  };

  _proto.rawValue = function rawValue(node, prop) {
    var value = node[prop];
    var raw = node.raws[prop];

    if (raw && raw.value === value) {
      return raw.raw;
    }

    return value;
  };

  return Stringifier;
}();

var _default = Stringifier;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInN0cmluZ2lmaWVyLmVzNiJdLCJuYW1lcyI6WyJERUZBVUxUX1JBVyIsImNvbG9uIiwiaW5kZW50IiwiYmVmb3JlRGVjbCIsImJlZm9yZVJ1bGUiLCJiZWZvcmVPcGVuIiwiYmVmb3JlQ2xvc2UiLCJiZWZvcmVDb21tZW50IiwiYWZ0ZXIiLCJlbXB0eUJvZHkiLCJjb21tZW50TGVmdCIsImNvbW1lbnRSaWdodCIsInNlbWljb2xvbiIsImNhcGl0YWxpemUiLCJzdHIiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiU3RyaW5naWZpZXIiLCJidWlsZGVyIiwic3RyaW5naWZ5Iiwibm9kZSIsInR5cGUiLCJyb290IiwiYm9keSIsInJhd3MiLCJjb21tZW50IiwibGVmdCIsInJhdyIsInJpZ2h0IiwidGV4dCIsImRlY2wiLCJiZXR3ZWVuIiwic3RyaW5nIiwicHJvcCIsInJhd1ZhbHVlIiwiaW1wb3J0YW50IiwicnVsZSIsImJsb2NrIiwib3duU2VtaWNvbG9uIiwiYXRydWxlIiwibmFtZSIsInBhcmFtcyIsImFmdGVyTmFtZSIsIm5vZGVzIiwiZW5kIiwibGFzdCIsImxlbmd0aCIsImkiLCJjaGlsZCIsImJlZm9yZSIsInN0YXJ0Iiwib3duIiwiZGV0ZWN0IiwidmFsdWUiLCJwYXJlbnQiLCJmaXJzdCIsInJhd0NhY2hlIiwiYmVmb3JlQWZ0ZXIiLCJtZXRob2QiLCJ3YWxrIiwicmF3U2VtaWNvbG9uIiwicmF3RW1wdHlCb2R5IiwicmF3SW5kZW50IiwicCIsInBhcnRzIiwic3BsaXQiLCJyZXBsYWNlIiwicmF3QmVmb3JlQ29tbWVudCIsIndhbGtDb21tZW50cyIsImluZGV4T2YiLCJyYXdCZWZvcmVEZWNsIiwid2Fsa0RlY2xzIiwicmF3QmVmb3JlUnVsZSIsInJhd0JlZm9yZUNsb3NlIiwicmF3QmVmb3JlT3BlbiIsInJhd0NvbG9uIiwiYnVmIiwiZGVwdGgiLCJzdGVwIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBTUEsV0FBVyxHQUFHO0FBQ2xCQyxFQUFB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UjtBQUNEOztBQUVELFFBQUl3RCxHQUFHLEdBQUd4RCxJQUFJLENBQUNrQyxNQUFmO0FBQ0EsUUFBSXVCLEtBQUssR0FBRyxDQUFaOztBQUNBLFdBQU9ELEdBQUcsSUFBSUEsR0FBRyxDQUFDdkQsSUFBSixLQUFhLE1BQTNCLEVBQW1DO0FBQ2pDd0QsTUFBQUEsS0FBSyxJQUFJLENBQVQ7QUFDQUQsTUFBQUEsR0FBRyxHQUFHQSxHQUFHLENBQUN0QixNQUFWO0FBQ0Q7O0FBRUQsUUFBSUQsS0FBSyxDQUFDZ0IsT0FBTixDQUFjLElBQWQsTUFBd0IsQ0FBQyxDQUE3QixFQUFnQztBQUM5QixVQUFJbkUsTUFBTSxHQUFHLEtBQUt5QixHQUFMLENBQVNQLElBQVQsRUFBZSxJQUFmLEVBQXFCLFFBQXJCLENBQWI7O0FBQ0EsVUFBSWxCLE1BQU0sQ0FBQzRDLE1BQVgsRUFBbUI7QUFDakIsYUFBSyxJQUFJZ0MsSUFBSSxHQUFHLENBQWhCLEVBQW1CQSxJQUFJLEdBQUdELEtBQTFCLEVBQWlDQyxJQUFJLEVBQXJDO0FBQXlDekIsVUFBQUEsS0FBSyxJQUFJbkQsTUFBVDtBQUF6QztBQUNEO0FBQ0Y7O0FBRUQsV0FBT21ELEtBQVA7QUFDRCxHOztTQUVEbkIsUSxHQUFBLGtCQUFVZCxJQUFWLEVBQWdCYSxJQUFoQixFQUFzQjtBQUNwQixRQUFJb0IsS0FBSyxHQUFHakMsSUFBSSxDQUFDYSxJQUFELENBQWhCO0FBQ0EsUUFBSU4sR0FBRyxHQUFHUCxJQUFJLENBQUNJLElBQUwsQ0FBVVMsSUFBVixDQUFWOztBQUNBLFFBQUlOLEdBQUcsSUFBSUEsR0FBRyxDQUFDMEIsS0FBSixLQUFjQSxLQUF6QixFQUFnQztBQUM5QixhQUFPMUIsR0FBRyxDQUFDQSxHQUFYO0FBQ0Q7O0FBRUQsV0FBTzBCLEtBQVA7QUFDRCxHOzs7OztlQUdZcEMsVyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IERFRkFVTFRfUkFXID0ge1xuICBjb2xvbjogJzogJyxcbiAgaW5kZW50OiAnICAgICcsXG4gIGJlZm9yZURlY2w6ICdcXG4nLFxuICBiZWZvcmVSdWxlOiAnXFxuJyxcbiAgYmVmb3JlT3BlbjogJyAnLFxuICBiZWZvcmVDbG9zZTogJ1xcbicsXG4gIGJlZm9yZUNvbW1lbnQ6ICdcXG4nLFxuICBhZnRlcjogJ1xcbicsXG4gIGVtcHR5Qm9keTogJycsXG4gIGNvbW1lbnRMZWZ0OiAnICcsXG4gIGNvbW1lbnRSaWdodDogJyAnLFxuICBzZW1pY29sb246IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUgKHN0cikge1xuICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn1cblxuY2xhc3MgU3RyaW5naWZpZXIge1xuICBjb25zdHJ1Y3RvciAoYnVpbGRlcikge1xuICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXJcbiAgfVxuXG4gIHN0cmluZ2lmeSAobm9kZSwgc2VtaWNvbG9uKSB7XG4gICAgdGhpc1tub2RlLnR5cGVdKG5vZGUsIHNlbWljb2xvbilcbiAgfVxuXG4gIHJvb3QgKG5vZGUpIHtcbiAgICB0aGlzLmJvZHkobm9kZSlcbiAgICBpZiAobm9kZS5yYXdzLmFmdGVyKSB0aGlzLmJ1aWxkZXIobm9kZS5yYXdzLmFmdGVyKVxuICB9XG5cbiAgY29tbWVudCAobm9kZSkge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5yYXcobm9kZSwgJ2xlZnQnLCAnY29tbWVudExlZnQnKVxuICAgIGxldCByaWdodCA9IHRoaXMucmF3KG5vZGUsICdyaWdodCcsICdjb21tZW50UmlnaHQnKVxuICAgIHRoaXMuYnVpbGRlcignLyonICsgbGVmdCArIG5vZGUudGV4dCArIHJpZ2h0ICsgJyovJywgbm9kZSlcbiAgfVxuXG4gIGRlY2wgKG5vZGUsIHNlbWljb2xvbikge1xuICAgIGxldCBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZSwgJ2JldHdlZW4nLCAnY29sb24nKVxuICAgIGxldCBzdHJpbmcgPSBub2RlLnByb3AgKyBiZXR3ZWVuICsgdGhpcy5yYXdWYWx1ZShub2RlLCAndmFsdWUnKVxuXG4gICAgaWYgKG5vZGUuaW1wb3J0YW50KSB7XG4gICAgICBzdHJpbmcgKz0gbm9kZS5yYXdzLmltcG9ydGFudCB8fCAnICFpbXBvcnRhbnQnXG4gICAgfVxuXG4gICAgaWYgKHNlbWljb2xvbikgc3RyaW5nICs9ICc7J1xuICAgIHRoaXMuYnVpbGRlcihzdHJpbmcsIG5vZGUpXG4gIH1cblxuICBydWxlIChub2RlKSB7XG4gICAgdGhpcy5ibG9jayhub2RlLCB0aGlzLnJhd1ZhbHVlKG5vZGUsICdzZWxlY3RvcicpKVxuICAgIGlmIChub2RlLnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICB0aGlzLmJ1aWxkZXIobm9kZS5yYXdzLm93blNlbWljb2xvbiwgbm9kZSwgJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgYXRydWxlIChub2RlLCBzZW1pY29sb24pIHtcbiAgICBsZXQgbmFtZSA9ICdAJyArIG5vZGUubmFtZVxuICAgIGxldCBwYXJhbXMgPSBub2RlLnBhcmFtcyA/IHRoaXMucmF3VmFsdWUobm9kZSwgJ3BhcmFtcycpIDogJydcblxuICAgIGlmICh0eXBlb2Ygbm9kZS5yYXdzLmFmdGVyTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5hbWUgKz0gbm9kZS5yYXdzLmFmdGVyTmFtZVxuICAgIH0gZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICBuYW1lICs9ICcgJ1xuICAgIH1cblxuICAgIGlmIChub2RlLm5vZGVzKSB7XG4gICAgICB0aGlzLmJsb2NrKG5vZGUsIG5hbWUgKyBwYXJhbXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbmQgPSAobm9kZS5yYXdzLmJldHdlZW4gfHwgJycpICsgKHNlbWljb2xvbiA/ICc7JyA6ICcnKVxuICAgICAgdGhpcy5idWlsZGVyKG5hbWUgKyBwYXJhbXMgKyBlbmQsIG5vZGUpXG4gICAgfVxuICB9XG5cbiAgYm9keSAobm9kZSkge1xuICAgIGxldCBsYXN0ID0gbm9kZS5ub2Rlcy5sZW5ndGggLSAxXG4gICAgd2hpbGUgKGxhc3QgPiAwKSB7XG4gICAgICBpZiAobm9kZS5ub2Rlc1tsYXN0XS50eXBlICE9PSAnY29tbWVudCcpIGJyZWFrXG4gICAgICBsYXN0IC09IDFcbiAgICB9XG5cbiAgICBsZXQgc2VtaWNvbG9uID0gdGhpcy5yYXcobm9kZSwgJ3NlbWljb2xvbicpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY2hpbGQgPSBub2RlLm5vZGVzW2ldXG4gICAgICBsZXQgYmVmb3JlID0gdGhpcy5yYXcoY2hpbGQsICdiZWZvcmUnKVxuICAgICAgaWYgKGJlZm9yZSkgdGhpcy5idWlsZGVyKGJlZm9yZSlcbiAgICAgIHRoaXMuc3RyaW5naWZ5KGNoaWxkLCBsYXN0ICE9PSBpIHx8IHNlbWljb2xvbilcbiAgICB9XG4gIH1cblxuICBibG9jayAobm9kZSwgc3RhcnQpIHtcbiAgICBsZXQgYmV0d2VlbiA9IHRoaXMucmF3KG5vZGUsICdiZXR3ZWVuJywgJ2JlZm9yZU9wZW4nKVxuICAgIHRoaXMuYnVpbGRlcihzdGFydCArIGJldHdlZW4gKyAneycsIG5vZGUsICdzdGFydCcpXG5cbiAgICBsZXQgYWZ0ZXJcbiAgICBpZiAobm9kZS5ub2RlcyAmJiBub2RlLm5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5ib2R5KG5vZGUpXG4gICAgICBhZnRlciA9IHRoaXMucmF3KG5vZGUsICdhZnRlcicpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZSwgJ2FmdGVyJywgJ2VtcHR5Qm9keScpXG4gICAgfVxuXG4gICAgaWYgKGFmdGVyKSB0aGlzLmJ1aWxkZXIoYWZ0ZXIpXG4gICAgdGhpcy5idWlsZGVyKCd9Jywgbm9kZSwgJ2VuZCcpXG4gIH1cblxuICByYXcgKG5vZGUsIG93biwgZGV0ZWN0KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgaWYgKCFkZXRlY3QpIGRldGVjdCA9IG93blxuXG4gICAgLy8gQWxyZWFkeSBoYWRcbiAgICBpZiAob3duKSB7XG4gICAgICB2YWx1ZSA9IG5vZGUucmF3c1tvd25dXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50XG5cbiAgICAvLyBIYWNrIGZvciBmaXJzdCBydWxlIGluIENTU1xuICAgIGlmIChkZXRlY3QgPT09ICdiZWZvcmUnKSB7XG4gICAgICBpZiAoIXBhcmVudCB8fCAocGFyZW50LnR5cGUgPT09ICdyb290JyAmJiBwYXJlbnQuZmlyc3QgPT09IG5vZGUpKSB7XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZsb2F0aW5nIGNoaWxkIHdpdGhvdXQgcGFyZW50XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybiBERUZBVUxUX1JBV1tkZXRlY3RdXG5cbiAgICAvLyBEZXRlY3Qgc3R5bGUgYnkgb3RoZXIgbm9kZXNcbiAgICBsZXQgcm9vdCA9IG5vZGUucm9vdCgpXG4gICAgaWYgKCFyb290LnJhd0NhY2hlKSByb290LnJhd0NhY2hlID0geyB9XG4gICAgaWYgKHR5cGVvZiByb290LnJhd0NhY2hlW2RldGVjdF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gcm9vdC5yYXdDYWNoZVtkZXRlY3RdXG4gICAgfVxuXG4gICAgaWYgKGRldGVjdCA9PT0gJ2JlZm9yZScgfHwgZGV0ZWN0ID09PSAnYWZ0ZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5iZWZvcmVBZnRlcihub2RlLCBkZXRlY3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtZXRob2QgPSAncmF3JyArIGNhcGl0YWxpemUoZGV0ZWN0KVxuICAgICAgaWYgKHRoaXNbbWV0aG9kXSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXNbbWV0aG9kXShyb290LCBub2RlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC53YWxrKGkgPT4ge1xuICAgICAgICAgIHZhbHVlID0gaS5yYXdzW293bl1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHZhbHVlID0gREVGQVVMVF9SQVdbZGV0ZWN0XVxuXG4gICAgcm9vdC5yYXdDYWNoZVtkZXRlY3RdID0gdmFsdWVcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd1NlbWljb2xvbiAocm9vdCkge1xuICAgIGxldCB2YWx1ZVxuICAgIHJvb3Qud2FsayhpID0+IHtcbiAgICAgIGlmIChpLm5vZGVzICYmIGkubm9kZXMubGVuZ3RoICYmIGkubGFzdC50eXBlID09PSAnZGVjbCcpIHtcbiAgICAgICAgdmFsdWUgPSBpLnJhd3Muc2VtaWNvbG9uXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3RW1wdHlCb2R5IChyb290KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrKGkgPT4ge1xuICAgICAgaWYgKGkubm9kZXMgJiYgaS5ub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBpLnJhd3MuYWZ0ZXJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByYXdJbmRlbnQgKHJvb3QpIHtcbiAgICBpZiAocm9vdC5yYXdzLmluZGVudCkgcmV0dXJuIHJvb3QucmF3cy5pbmRlbnRcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGsoaSA9PiB7XG4gICAgICBsZXQgcCA9IGkucGFyZW50XG4gICAgICBpZiAocCAmJiBwICE9PSByb290ICYmIHAucGFyZW50ICYmIHAucGFyZW50ID09PSByb290KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaS5yYXdzLmJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsZXQgcGFydHMgPSBpLnJhd3MuYmVmb3JlLnNwbGl0KCdcXG4nKVxuICAgICAgICAgIHZhbHVlID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV1cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxzXS9nLCAnJylcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByYXdCZWZvcmVDb21tZW50IChyb290LCBub2RlKSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrQ29tbWVudHMoaSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkucmF3cy5iZWZvcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbHVlID0gaS5yYXdzLmJlZm9yZVxuICAgICAgICBpZiAodmFsdWUuaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sICcnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZSwgbnVsbCwgJ2JlZm9yZURlY2wnKVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXHNdL2csICcnKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0JlZm9yZURlY2wgKHJvb3QsIG5vZGUpIHtcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGtEZWNscyhpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaS5yYXdzLmJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFsdWUgPSBpLnJhd3MuYmVmb3JlXG4gICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgJycpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlLCBudWxsLCAnYmVmb3JlUnVsZScpXG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcc10vZywgJycpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3QmVmb3JlUnVsZSAocm9vdCkge1xuICAgIGxldCB2YWx1ZVxuICAgIHJvb3Qud2FsayhpID0+IHtcbiAgICAgIGlmIChpLm5vZGVzICYmIChpLnBhcmVudCAhPT0gcm9vdCB8fCByb290LmZpcnN0ICE9PSBpKSkge1xuICAgICAgICBpZiAodHlwZW9mIGkucmF3cy5iZWZvcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFsdWUgPSBpLnJhd3MuYmVmb3JlXG4gICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJ1xcbicpICE9PSAtMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sICcnKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxzXS9nLCAnJylcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0JlZm9yZUNsb3NlIChyb290KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrKGkgPT4ge1xuICAgICAgaWYgKGkubm9kZXMgJiYgaS5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaS5yYXdzLmFmdGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhbHVlID0gaS5yYXdzLmFmdGVyXG4gICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJ1xcbicpICE9PSAtMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sICcnKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxzXS9nLCAnJylcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0JlZm9yZU9wZW4gKHJvb3QpIHtcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGsoaSA9PiB7XG4gICAgICBpZiAoaS50eXBlICE9PSAnZGVjbCcpIHtcbiAgICAgICAgdmFsdWUgPSBpLnJhd3MuYmV0d2VlblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0NvbG9uIChyb290KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrRGVjbHMoaSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkucmF3cy5iZXR3ZWVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWx1ZSA9IGkucmF3cy5iZXR3ZWVuLnJlcGxhY2UoL1teXFxzOl0vZywgJycpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBiZWZvcmVBZnRlciAobm9kZSwgZGV0ZWN0KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2RlY2wnKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUsIG51bGwsICdiZWZvcmVEZWNsJylcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUsIG51bGwsICdiZWZvcmVDb21tZW50JylcbiAgICB9IGVsc2UgaWYgKGRldGVjdCA9PT0gJ2JlZm9yZScpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZSwgbnVsbCwgJ2JlZm9yZVJ1bGUnKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUsIG51bGwsICdiZWZvcmVDbG9zZScpXG4gICAgfVxuXG4gICAgbGV0IGJ1ZiA9IG5vZGUucGFyZW50XG4gICAgbGV0IGRlcHRoID0gMFxuICAgIHdoaWxlIChidWYgJiYgYnVmLnR5cGUgIT09ICdyb290Jykge1xuICAgICAgZGVwdGggKz0gMVxuICAgICAgYnVmID0gYnVmLnBhcmVudFxuICAgIH1cblxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAgIGxldCBpbmRlbnQgPSB0aGlzLnJhdyhub2RlLCBudWxsLCAnaW5kZW50JylcbiAgICAgIGlmIChpbmRlbnQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IHN0ZXAgPSAwOyBzdGVwIDwgZGVwdGg7IHN0ZXArKykgdmFsdWUgKz0gaW5kZW50XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByYXdWYWx1ZSAobm9kZSwgcHJvcCkge1xuICAgIGxldCB2YWx1ZSA9IG5vZGVbcHJvcF1cbiAgICBsZXQgcmF3ID0gbm9kZS5yYXdzW3Byb3BdXG4gICAgaWYgKHJhdyAmJiByYXcudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmF3LnJhd1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0cmluZ2lmaWVyXG4iXSwiZmlsZSI6InN0cmluZ2lmaWVyLmpzIn0=


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _lazyResult = _interopRequireDefault(__webpack_require__(38));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * @example
 * const processor = postcss([autoprefixer, precss])
 * processor.process(css1).then(result => console.log(result.css))
 * processor.process(css2).then(result => console.log(result.css))
 */
var Processor =
/*#__PURE__*/
function () {
  /**
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
   *        See {@link Processor#use} for plugin format.
   */
  function Processor(plugins) {
    if (plugins === void 0) {
      plugins = [];
    }

    /**
     * Current PostCSS version.
     *
     * @type {string}
     *
     * @example
     * if (result.processor.version.split('.')[0] !== '6') {
     *   throw new Error('This plugin works only with PostCSS 6')
     * }
     */
    this.version = '7.0.32';
    /**
     * Plugins added to this processor.
     *
     * @type {pluginFunction[]}
     *
     * @example
     * const processor = postcss([autoprefixer, precss])
     * processor.plugins.length //=> 2
     */

    this.plugins = this.normalize(plugins);
  }
  /**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin created by {@link postcss.plugin} method.
   * * A function. PostCSS will pass the function a @{link Root}
   *   as the first argument and current {@link Result} instance
   *   as the second.
   * * An object with a `postcss` method. PostCSS will use that method
   *   as described in #2.
   * * Another {@link Processor} instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * @param {Plugin|pluginFunction|Processor} plugin PostCSS plugin
   *                                                 or {@link Processor}
   *                                                 with plugins.
   *
   * @example
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(precss)
   *
   * @return {Processes} Current processor to make methods chain.
   */


  var _proto = Processor.prototype;

  _proto.use = function use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]));
    return this;
  }
  /**
   * Parses source CSS and returns a {@link LazyResult} Promise proxy.
   * Because some plugins can be asynchronous it doesn’t make
   * any transformations. Transformations will be applied
   * in the {@link LazyResult} methods.
   *
   * @param {string|toString|Result} css String with input CSS or any object
   *                                     with a `toString()` method,
   *                                     like a Buffer. Optionally, send
   *                                     a {@link Result} instance
   *                                     and the processor will take
   *                                     the {@link Root} from it.
   * @param {processOptions} [opts]      Options.
   *
   * @return {LazyResult} Promise proxy.
   *
   * @example
   * processor.process(css, { from: 'a.css', to: 'a.out.css' })
   *   .then(result => {
   *      console.log(result.css)
   *   })
   */
  ;

  _proto.process = function (_process) {
    function process(_x) {
      return _process.apply(this, arguments);
    }

    process.toString = function () {
      return _process.toString();
    };

    return process;
  }(function (css, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (this.plugins.length === 0 && opts.parser === opts.stringifier) {
      if (false) {}
    }

    return new _lazyResult.default(this, css, opts);
  });

  _proto.normalize = function normalize(plugins) {
    var normalized = [];

    for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var i = _ref;
      if (i.postcss) i = i.postcss;

      if (typeof i === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins);
      } else if (typeof i === 'function') {
        normalized.push(i);
      } else if (typeof i === 'object' && (i.parse || i.stringify)) {
        if (false) {}
      } else {
        throw new Error(i + ' is not a PostCSS plugin');
      }
    }

    return normalized;
  };

  return Processor;
}();

var _default = Processor;
/**
 * @callback builder
 * @param {string} part          Part of generated CSS connected to this node.
 * @param {Node}   node          AST node.
 * @param {"start"|"end"} [type] Node’s part type.
 */

/**
 * @callback parser
 *
 * @param {string|toString} css   String with input CSS or any object
 *                                with toString() method, like a Buffer.
 * @param {processOptions} [opts] Options with only `from` and `map` keys.
 *
 * @return {Root} PostCSS AST
 */

/**
 * @callback stringifier
 *
 * @param {Node} node       Start node for stringifing. Usually {@link Root}.
 * @param {builder} builder Function to concatenate CSS from node’s parts
 *                          or generate string and source map.
 *
 * @return {void}
 */

/**
 * @typedef {object} syntax
 * @property {parser} parse          Function to generate AST by string.
 * @property {stringifier} stringify Function to generate string by AST.
 */

/**
 * @typedef {object} toString
 * @property {function} toString
 */

/**
 * @callback pluginFunction
 * @param {Root} root     Parsed input CSS.
 * @param {Result} result Result to set warnings or check other plugins.
 */

/**
 * @typedef {object} Plugin
 * @property {function} postcss PostCSS plugin function.
 */

/**
 * @typedef {object} processOptions
 * @property {string} from             The path of the CSS source file.
 *                                     You should always set `from`,
 *                                     because it is used in source map
 *                                     generation and syntax error messages.
 * @property {string} to               The path where you’ll put the output
 *                                     CSS file. You should always set `to`
 *                                     to generate correct source maps.
 * @property {parser} parser           Function to generate AST by string.
 * @property {stringifier} stringifier Class to generate string by AST.
 * @property {syntax} syntax           Object with `parse` and `stringify`.
 * @property {object} map              Source map options.
 * @property {boolean} map.inline                    Does source map should
 *                                                   be embedded in the output
 *                                                   CSS as a base64-encoded
 *                                                   comment.
 * @property {string|object|false|function} map.prev Source map content
 *                                                   from a previous
 *                                                   processing step
 *                                                   (for example, Sass).
 *                                                   PostCSS will try to find
 *                                                   previous map automatically,
 *                                                   so you could disable it by
 *                                                   `false` value.
 * @property {boolean} map.sourcesContent            Does PostCSS should set
 *                                                   the origin content to map.
 * @property {string|false} map.annotation           Does PostCSS should set
 *                                                   annotation comment to map.
 * @property {string} map.from                       Override `from` in map’s
 *                                                   sources`.
 */

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByb2Nlc3Nvci5lczYiXSwibmFtZXMiOlsiUHJvY2Vzc29yIiwicGx1Z2lucyIsInZlcnNpb24iLCJub3JtYWxpemUiLCJ1c2UiLCJwbHVnaW4iLCJjb25jYXQiLCJwcm9jZXNzIiwiY3NzIiwib3B0cyIsImxlbmd0aCIsInBhcnNlciIsInN0cmluZ2lmaWVyIiwiZW52IiwiTk9ERV9FTlYiLCJjb25zb2xlIiwid2FybiIsIkxhenlSZXN1bHQiLCJub3JtYWxpemVkIiwiaSIsInBvc3Rjc3MiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7OztBQUVBOzs7Ozs7Ozs7SUFTTUEsUzs7O0FBQ0o7Ozs7QUFJQSxxQkFBYUMsT0FBYixFQUEyQjtBQUFBLFFBQWRBLE9BQWM7QUFBZEEsTUFBQUEsT0FBYyxHQUFKLEVBQUk7QUFBQTs7QUFDekI7Ozs7Ozs7Ozs7QUFVQSxTQUFLQyxPQUFMLEdBQWUsUUFBZjtBQUNBOzs7Ozs7Ozs7O0FBU0EsU0FBS0QsT0FBTCxHQUFlLEtBQUtFLFNBQUwsQ0FBZUYsT0FBZixDQUFmO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBNkJBRyxHLEdBQUEsYUFBS0MsTUFBTCxFQUFhO0FBQ1gsU0FBS0osT0FBTCxHQUFlLEtBQUtBLE9BQUwsQ0FBYUssTUFBYixDQUFvQixLQUFLSCxTQUFMLENBQWUsQ0FBQ0UsTUFBRCxDQUFmLENBQXBCLENBQWY7QUFDQSxXQUFPLElBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FzQkFFLE87Ozs7Ozs7Ozs7SUFBQSxVQUFTQyxHQUFULEVBQWNDLElBQWQsRUFBMEI7QUFBQSxRQUFaQSxJQUFZO0FBQVpBLE1BQUFBLElBQVksR0FBTCxFQUFLO0FBQUE7O0FBQ3hCLFFBQUksS0FBS1IsT0FBTCxDQUFhUyxNQUFiLEtBQXdCLENBQXhCLElBQTZCRCxJQUFJLENBQUNFLE1BQUwsS0FBZ0JGLElBQUksQ0FBQ0csV0FBdEQsRUFBbUU7QUFDakUsVUFBSUwsT0FBTyxDQUFDTSxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsWUFBSSxPQUFPQyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDQSxPQUFPLENBQUNDLElBQTlDLEVBQW9EO0FBQ2xERCxVQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FDRSwwREFDQSw4REFEQSxHQUVBLGtFQUhGO0FBS0Q7QUFDRjtBQUNGOztBQUNELFdBQU8sSUFBSUMsbUJBQUosQ0FBZSxJQUFmLEVBQXFCVCxHQUFyQixFQUEwQkMsSUFBMUIsQ0FBUDtBQUNELEc7O1NBRUROLFMsR0FBQSxtQkFBV0YsT0FBWCxFQUFvQjtBQUNsQixRQUFJaUIsVUFBVSxHQUFHLEVBQWpCOztBQUNBLHlCQUFjakIsT0FBZCxrSEFBdUI7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBLFVBQWRrQixDQUFjO0FBQ3JCLFVBQUlBLENBQUMsQ0FBQ0MsT0FBTixFQUFlRCxDQUFDLEdBQUdBLENBQUMsQ0FBQ0MsT0FBTjs7QUFFZixVQUFJLE9BQU9ELENBQVAsS0FBYSxRQUFiLElBQXlCRSxLQUFLLENBQUNDLE9BQU4sQ0FBY0gsQ0FBQyxDQUFDbEIsT0FBaEIsQ0FBN0IsRUFBdUQ7QUFDckRpQixRQUFBQSxVQUFVLEdBQUdBLFVBQVUsQ0FBQ1osTUFBWCxDQUFrQmEsQ0FBQyxDQUFDbEIsT0FBcEIsQ0FBYjtBQUNELE9BRkQsTUFFTyxJQUFJLE9BQU9rQixDQUFQLEtBQWEsVUFBakIsRUFBNkI7QUFDbENELFFBQUFBLFVBQVUsQ0FBQ0ssSUFBWCxDQUFnQkosQ0FBaEI7QUFDRCxPQUZNLE1BRUEsSUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBYixLQUEwQkEsQ0FBQyxDQUFDSyxLQUFGLElBQVdMLENBQUMsQ0FBQ00sU0FBdkMsQ0FBSixFQUF1RDtBQUM1RCxZQUFJbEIsT0FBTyxDQUFDTSxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsZ0JBQU0sSUFBSVksS0FBSixDQUNKLHFFQUNBLDJEQURBLEdBRUEsdUNBSEksQ0FBTjtBQUtEO0FBQ0YsT0FSTSxNQVFBO0FBQ0wsY0FBTSxJQUFJQSxLQUFKLENBQVVQLENBQUMsR0FBRywwQkFBZCxDQUFOO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPRCxVQUFQO0FBQ0QsRzs7Ozs7ZUFHWWxCLFM7QUFFZjs7Ozs7OztBQU9BOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7QUFVQTs7Ozs7O0FBTUE7Ozs7O0FBS0E7Ozs7OztBQU1BOzs7OztBQUtBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExhenlSZXN1bHQgZnJvbSAnLi9sYXp5LXJlc3VsdCdcblxuLyoqXG4gKiBDb250YWlucyBwbHVnaW5zIHRvIHByb2Nlc3MgQ1NTLiBDcmVhdGUgb25lIGBQcm9jZXNzb3JgIGluc3RhbmNlLFxuICogaW5pdGlhbGl6ZSBpdHMgcGx1Z2lucywgYW5kIHRoZW4gdXNlIHRoYXQgaW5zdGFuY2Ugb24gbnVtZXJvdXMgQ1NTIGZpbGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwcm9jZXNzb3IgPSBwb3N0Y3NzKFthdXRvcHJlZml4ZXIsIHByZWNzc10pXG4gKiBwcm9jZXNzb3IucHJvY2Vzcyhjc3MxKS50aGVuKHJlc3VsdCA9PiBjb25zb2xlLmxvZyhyZXN1bHQuY3NzKSlcbiAqIHByb2Nlc3Nvci5wcm9jZXNzKGNzczIpLnRoZW4ocmVzdWx0ID0+IGNvbnNvbGUubG9nKHJlc3VsdC5jc3MpKVxuICovXG5jbGFzcyBQcm9jZXNzb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48UGx1Z2lufHBsdWdpbkZ1bmN0aW9uPnxQcm9jZXNzb3J9IHBsdWdpbnMgUG9zdENTUyBwbHVnaW5zLlxuICAgKiAgICAgICAgU2VlIHtAbGluayBQcm9jZXNzb3IjdXNlfSBmb3IgcGx1Z2luIGZvcm1hdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChwbHVnaW5zID0gW10pIHtcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IFBvc3RDU1MgdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlmIChyZXN1bHQucHJvY2Vzc29yLnZlcnNpb24uc3BsaXQoJy4nKVswXSAhPT0gJzYnKSB7XG4gICAgICogICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgcGx1Z2luIHdvcmtzIG9ubHkgd2l0aCBQb3N0Q1NTIDYnKVxuICAgICAqIH1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnNpb24gPSAnNy4wLjMyJ1xuICAgIC8qKlxuICAgICAqIFBsdWdpbnMgYWRkZWQgdG8gdGhpcyBwcm9jZXNzb3IuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7cGx1Z2luRnVuY3Rpb25bXX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgcHJvY2Vzc29yID0gcG9zdGNzcyhbYXV0b3ByZWZpeGVyLCBwcmVjc3NdKVxuICAgICAqIHByb2Nlc3Nvci5wbHVnaW5zLmxlbmd0aCAvLz0+IDJcbiAgICAgKi9cbiAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLm5vcm1hbGl6ZShwbHVnaW5zKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBwbHVnaW4gdG8gYmUgdXNlZCBhcyBhIENTUyBwcm9jZXNzb3IuXG4gICAqXG4gICAqIFBvc3RDU1MgcGx1Z2luIGNhbiBiZSBpbiA0IGZvcm1hdHM6XG4gICAqICogQSBwbHVnaW4gY3JlYXRlZCBieSB7QGxpbmsgcG9zdGNzcy5wbHVnaW59IG1ldGhvZC5cbiAgICogKiBBIGZ1bmN0aW9uLiBQb3N0Q1NTIHdpbGwgcGFzcyB0aGUgZnVuY3Rpb24gYSBAe2xpbmsgUm9vdH1cbiAgICogICBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIGN1cnJlbnQge0BsaW5rIFJlc3VsdH0gaW5zdGFuY2VcbiAgICogICBhcyB0aGUgc2Vjb25kLlxuICAgKiAqIEFuIG9iamVjdCB3aXRoIGEgYHBvc3Rjc3NgIG1ldGhvZC4gUG9zdENTUyB3aWxsIHVzZSB0aGF0IG1ldGhvZFxuICAgKiAgIGFzIGRlc2NyaWJlZCBpbiAjMi5cbiAgICogKiBBbm90aGVyIHtAbGluayBQcm9jZXNzb3J9IGluc3RhbmNlLiBQb3N0Q1NTIHdpbGwgY29weSBwbHVnaW5zXG4gICAqICAgZnJvbSB0aGF0IGluc3RhbmNlIGludG8gdGhpcyBvbmUuXG4gICAqXG4gICAqIFBsdWdpbnMgY2FuIGFsc28gYmUgYWRkZWQgYnkgcGFzc2luZyB0aGVtIGFzIGFyZ3VtZW50cyB3aGVuIGNyZWF0aW5nXG4gICAqIGEgYHBvc3Rjc3NgIGluc3RhbmNlIChzZWUgW2Bwb3N0Y3NzKHBsdWdpbnMpYF0pLlxuICAgKlxuICAgKiBBc3luY2hyb25vdXMgcGx1Z2lucyBzaG91bGQgcmV0dXJuIGEgYFByb21pc2VgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsdWdpbnxwbHVnaW5GdW5jdGlvbnxQcm9jZXNzb3J9IHBsdWdpbiBQb3N0Q1NTIHBsdWdpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciB7QGxpbmsgUHJvY2Vzc29yfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBsdWdpbnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHByb2Nlc3NvciA9IHBvc3Rjc3MoKVxuICAgKiAgIC51c2UoYXV0b3ByZWZpeGVyKVxuICAgKiAgIC51c2UocHJlY3NzKVxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9jZXNzZXN9IEN1cnJlbnQgcHJvY2Vzc29yIHRvIG1ha2UgbWV0aG9kcyBjaGFpbi5cbiAgICovXG4gIHVzZSAocGx1Z2luKSB7XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmNvbmNhdCh0aGlzLm5vcm1hbGl6ZShbcGx1Z2luXSkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgc291cmNlIENTUyBhbmQgcmV0dXJucyBhIHtAbGluayBMYXp5UmVzdWx0fSBQcm9taXNlIHByb3h5LlxuICAgKiBCZWNhdXNlIHNvbWUgcGx1Z2lucyBjYW4gYmUgYXN5bmNocm9ub3VzIGl0IGRvZXNu4oCZdCBtYWtlXG4gICAqIGFueSB0cmFuc2Zvcm1hdGlvbnMuIFRyYW5zZm9ybWF0aW9ucyB3aWxsIGJlIGFwcGxpZWRcbiAgICogaW4gdGhlIHtAbGluayBMYXp5UmVzdWx0fSBtZXRob2RzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3x0b1N0cmluZ3xSZXN1bHR9IGNzcyBTdHJpbmcgd2l0aCBpbnB1dCBDU1Mgb3IgYW55IG9iamVjdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIGEgYHRvU3RyaW5nKClgIG1ldGhvZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlrZSBhIEJ1ZmZlci4gT3B0aW9uYWxseSwgc2VuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHtAbGluayBSZXN1bHR9IGluc3RhbmNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgcHJvY2Vzc29yIHdpbGwgdGFrZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUge0BsaW5rIFJvb3R9IGZyb20gaXQuXG4gICAqIEBwYXJhbSB7cHJvY2Vzc09wdGlvbnN9IFtvcHRzXSAgICAgIE9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4ge0xhenlSZXN1bHR9IFByb21pc2UgcHJveHkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHByb2Nlc3Nvci5wcm9jZXNzKGNzcywgeyBmcm9tOiAnYS5jc3MnLCB0bzogJ2Eub3V0LmNzcycgfSlcbiAgICogICAudGhlbihyZXN1bHQgPT4ge1xuICAgKiAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC5jc3MpXG4gICAqICAgfSlcbiAgICovXG4gIHByb2Nlc3MgKGNzcywgb3B0cyA9IHsgfSkge1xuICAgIGlmICh0aGlzLnBsdWdpbnMubGVuZ3RoID09PSAwICYmIG9wdHMucGFyc2VyID09PSBvcHRzLnN0cmluZ2lmaWVyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdZb3UgZGlkIG5vdCBzZXQgYW55IHBsdWdpbnMsIHBhcnNlciwgb3Igc3RyaW5naWZpZXIuICcgK1xuICAgICAgICAgICAgJ1JpZ2h0IG5vdywgUG9zdENTUyBkb2VzIG5vdGhpbmcuIFBpY2sgcGx1Z2lucyBmb3IgeW91ciBjYXNlICcgK1xuICAgICAgICAgICAgJ29uIGh0dHBzOi8vd3d3LnBvc3Rjc3MucGFydHMvIGFuZCB1c2UgdGhlbSBpbiBwb3N0Y3NzLmNvbmZpZy5qcy4nXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGF6eVJlc3VsdCh0aGlzLCBjc3MsIG9wdHMpXG4gIH1cblxuICBub3JtYWxpemUgKHBsdWdpbnMpIHtcbiAgICBsZXQgbm9ybWFsaXplZCA9IFtdXG4gICAgZm9yIChsZXQgaSBvZiBwbHVnaW5zKSB7XG4gICAgICBpZiAoaS5wb3N0Y3NzKSBpID0gaS5wb3N0Y3NzXG5cbiAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheShpLnBsdWdpbnMpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLmNvbmNhdChpLnBsdWdpbnMpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQucHVzaChpKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaSA9PT0gJ29iamVjdCcgJiYgKGkucGFyc2UgfHwgaS5zdHJpbmdpZnkpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1Bvc3RDU1Mgc3ludGF4ZXMgY2Fubm90IGJlIHVzZWQgYXMgcGx1Z2lucy4gSW5zdGVhZCwgcGxlYXNlIHVzZSAnICtcbiAgICAgICAgICAgICdvbmUgb2YgdGhlIHN5bnRheC9wYXJzZXIvc3RyaW5naWZpZXIgb3B0aW9ucyBhcyBvdXRsaW5lZCAnICtcbiAgICAgICAgICAgICdpbiB5b3VyIFBvc3RDU1MgcnVubmVyIGRvY3VtZW50YXRpb24uJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGkgKyAnIGlzIG5vdCBhIFBvc3RDU1MgcGx1Z2luJylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcm9jZXNzb3JcblxuLyoqXG4gKiBAY2FsbGJhY2sgYnVpbGRlclxuICogQHBhcmFtIHtzdHJpbmd9IHBhcnQgICAgICAgICAgUGFydCBvZiBnZW5lcmF0ZWQgQ1NTIGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gKiBAcGFyYW0ge05vZGV9ICAgbm9kZSAgICAgICAgICBBU1Qgbm9kZS5cbiAqIEBwYXJhbSB7XCJzdGFydFwifFwiZW5kXCJ9IFt0eXBlXSBOb2Rl4oCZcyBwYXJ0IHR5cGUuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgcGFyc2VyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8dG9TdHJpbmd9IGNzcyAgIFN0cmluZyB3aXRoIGlucHV0IENTUyBvciBhbnkgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0b1N0cmluZygpIG1ldGhvZCwgbGlrZSBhIEJ1ZmZlci5cbiAqIEBwYXJhbSB7cHJvY2Vzc09wdGlvbnN9IFtvcHRzXSBPcHRpb25zIHdpdGggb25seSBgZnJvbWAgYW5kIGBtYXBgIGtleXMuXG4gKlxuICogQHJldHVybiB7Um9vdH0gUG9zdENTUyBBU1RcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBzdHJpbmdpZmllclxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgICAgICBTdGFydCBub2RlIGZvciBzdHJpbmdpZmluZy4gVXN1YWxseSB7QGxpbmsgUm9vdH0uXG4gKiBAcGFyYW0ge2J1aWxkZXJ9IGJ1aWxkZXIgRnVuY3Rpb24gdG8gY29uY2F0ZW5hdGUgQ1NTIGZyb20gbm9kZeKAmXMgcGFydHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBnZW5lcmF0ZSBzdHJpbmcgYW5kIHNvdXJjZSBtYXAuXG4gKlxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IHN5bnRheFxuICogQHByb3BlcnR5IHtwYXJzZXJ9IHBhcnNlICAgICAgICAgIEZ1bmN0aW9uIHRvIGdlbmVyYXRlIEFTVCBieSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge3N0cmluZ2lmaWVyfSBzdHJpbmdpZnkgRnVuY3Rpb24gdG8gZ2VuZXJhdGUgc3RyaW5nIGJ5IEFTVC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IHRvU3RyaW5nXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSB0b1N0cmluZ1xuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIHBsdWdpbkZ1bmN0aW9uXG4gKiBAcGFyYW0ge1Jvb3R9IHJvb3QgICAgIFBhcnNlZCBpbnB1dCBDU1MuXG4gKiBAcGFyYW0ge1Jlc3VsdH0gcmVzdWx0IFJlc3VsdCB0byBzZXQgd2FybmluZ3Mgb3IgY2hlY2sgb3RoZXIgcGx1Z2lucy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFBsdWdpblxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcG9zdGNzcyBQb3N0Q1NTIHBsdWdpbiBmdW5jdGlvbi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IHByb2Nlc3NPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZnJvbSAgICAgICAgICAgICBUaGUgcGF0aCBvZiB0aGUgQ1NTIHNvdXJjZSBmaWxlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWW91IHNob3VsZCBhbHdheXMgc2V0IGBmcm9tYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlY2F1c2UgaXQgaXMgdXNlZCBpbiBzb3VyY2UgbWFwXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uIGFuZCBzeW50YXggZXJyb3IgbWVzc2FnZXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdG8gICAgICAgICAgICAgICBUaGUgcGF0aCB3aGVyZSB5b3XigJlsbCBwdXQgdGhlIG91dHB1dFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1NTIGZpbGUuIFlvdSBzaG91bGQgYWx3YXlzIHNldCBgdG9gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBnZW5lcmF0ZSBjb3JyZWN0IHNvdXJjZSBtYXBzLlxuICogQHByb3BlcnR5IHtwYXJzZXJ9IHBhcnNlciAgICAgICAgICAgRnVuY3Rpb24gdG8gZ2VuZXJhdGUgQVNUIGJ5IHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5naWZpZXJ9IHN0cmluZ2lmaWVyIENsYXNzIHRvIGdlbmVyYXRlIHN0cmluZyBieSBBU1QuXG4gKiBAcHJvcGVydHkge3N5bnRheH0gc3ludGF4ICAgICAgICAgICBPYmplY3Qgd2l0aCBgcGFyc2VgIGFuZCBgc3RyaW5naWZ5YC5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBtYXAgICAgICAgICAgICAgIFNvdXJjZSBtYXAgb3B0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFwLmlubGluZSAgICAgICAgICAgICAgICAgICAgRG9lcyBzb3VyY2UgbWFwIHNob3VsZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBlbWJlZGRlZCBpbiB0aGUgb3V0cHV0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENTUyBhcyBhIGJhc2U2NC1lbmNvZGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xvYmplY3R8ZmFsc2V8ZnVuY3Rpb259IG1hcC5wcmV2IFNvdXJjZSBtYXAgY29udGVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIGEgcHJldmlvdXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZyBzdGVwXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmb3IgZXhhbXBsZSwgU2FzcykuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3RDU1Mgd2lsbCB0cnkgdG8gZmluZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyBtYXAgYXV0b21hdGljYWxseSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc28geW91IGNvdWxkIGRpc2FibGUgaXQgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGZhbHNlYCB2YWx1ZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFwLnNvdXJjZXNDb250ZW50ICAgICAgICAgICAgRG9lcyBQb3N0Q1NTIHNob3VsZCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9yaWdpbiBjb250ZW50IHRvIG1hcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGZhbHNlfSBtYXAuYW5ub3RhdGlvbiAgICAgICAgICAgRG9lcyBQb3N0Q1NTIHNob3VsZCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbiBjb21tZW50IHRvIG1hcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYXAuZnJvbSAgICAgICAgICAgICAgICAgICAgICAgT3ZlcnJpZGUgYGZyb21gIGluIG1hcOKAmXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlc2AuXG4gKi9cbiJdLCJmaWxlIjoicHJvY2Vzc29yLmpzIn0=


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _mapGenerator = _interopRequireDefault(__webpack_require__(77));

var _stringify2 = _interopRequireDefault(__webpack_require__(17));

var _warnOnce = _interopRequireDefault(__webpack_require__(87));

var _result = _interopRequireDefault(__webpack_require__(88));

var _parse = _interopRequireDefault(__webpack_require__(19));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function isPromise(obj) {
  return typeof obj === 'object' && typeof obj.then === 'function';
}
/**
 * A Promise proxy for the result of PostCSS transformations.
 *
 * A `LazyResult` instance is returned by {@link Processor#process}.
 *
 * @example
 * const lazy = postcss([autoprefixer]).process(css)
 */


var LazyResult =
/*#__PURE__*/
function () {
  function LazyResult(processor, css, opts) {
    this.stringified = false;
    this.processed = false;
    var root;

    if (typeof css === 'object' && css !== null && css.type === 'root') {
      root = css;
    } else if (css instanceof LazyResult || css instanceof _result.default) {
      root = css.root;

      if (css.map) {
        if (typeof opts.map === 'undefined') opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css.map;
      }
    } else {
      var parser = _parse.default;
      if (opts.syntax) parser = opts.syntax.parse;
      if (opts.parser) parser = opts.parser;
      if (parser.parse) parser = parser.parse;

      try {
        root = parser(css, opts);
      } catch (error) {
        this.error = error;
      }
    }

    this.result = new _result.default(processor, root, opts);
  }
  /**
   * Returns a {@link Processor} instance, which will be used
   * for CSS transformations.
   *
   * @type {Processor}
   */


  var _proto = LazyResult.prototype;

  /**
   * Processes input CSS through synchronous plugins
   * and calls {@link Result#warnings()}.
   *
   * @return {Warning[]} Warnings from plugins.
   */
  _proto.warnings = function warnings() {
    return this.sync().warnings();
  }
  /**
   * Alias for the {@link LazyResult#css} property.
   *
   * @example
   * lazy + '' === lazy.css
   *
   * @return {string} Output CSS.
   */
  ;

  _proto.toString = function toString() {
    return this.css;
  }
  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls `onFulfilled` with a Result instance. If a plugin throws
   * an error, the `onRejected` callback will be executed.
   *
   * It implements standard Promise API.
   *
   * @param {onFulfilled} onFulfilled Callback will be executed
   *                                  when all plugins will finish work.
   * @param {onRejected}  onRejected  Callback will be executed on any error.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {
   *   console.log(result.css)
   * })
   */
  ;

  _proto.then = function then(onFulfilled, onRejected) {
    if (false) {}

    return this.async().then(onFulfilled, onRejected);
  }
  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onRejected for each error thrown in any plugin.
   *
   * It implements standard Promise API.
   *
   * @param {onRejected} onRejected Callback will be executed on any error.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css).then(result => {
   *   console.log(result.css)
   * }).catch(error => {
   *   console.error(error)
   * })
   */
  ;

  _proto.catch = function _catch(onRejected) {
    return this.async().catch(onRejected);
  }
  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onFinally on any error or when all plugins will finish work.
   *
   * It implements standard Promise API.
   *
   * @param {onFinally} onFinally Callback will be executed on any error or
   *                              when all plugins will finish work.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css).finally(() => {
   *   console.log('processing ended')
   * })
   */
  ;

  _proto.finally = function _finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  };

  _proto.handleError = function handleError(error, plugin) {
    try {
      this.error = error;

      if (error.name === 'CssSyntaxError' && !error.plugin) {
        error.plugin = plugin.postcssPlugin;
        error.setMessage();
      } else if (plugin.postcssVersion) {
        if (false) { var b, a, runtimeVer, pluginVer, pluginName; }
      }
    } catch (err) {
      if (console && console.error) console.error(err);
    }
  };

  _proto.asyncTick = function asyncTick(resolve, reject) {
    var _this = this;

    if (this.plugin >= this.processor.plugins.length) {
      this.processed = true;
      return resolve();
    }

    try {
      var plugin = this.processor.plugins[this.plugin];
      var promise = this.run(plugin);
      this.plugin += 1;

      if (isPromise(promise)) {
        promise.then(function () {
          _this.asyncTick(resolve, reject);
        }).catch(function (error) {
          _this.handleError(error, plugin);

          _this.processed = true;
          reject(error);
        });
      } else {
        this.asyncTick(resolve, reject);
      }
    } catch (error) {
      this.processed = true;
      reject(error);
    }
  };

  _proto.async = function async() {
    var _this2 = this;

    if (this.processed) {
      return new Promise(function (resolve, reject) {
        if (_this2.error) {
          reject(_this2.error);
        } else {
          resolve(_this2.stringify());
        }
      });
    }

    if (this.processing) {
      return this.processing;
    }

    this.processing = new Promise(function (resolve, reject) {
      if (_this2.error) return reject(_this2.error);
      _this2.plugin = 0;

      _this2.asyncTick(resolve, reject);
    }).then(function () {
      _this2.processed = true;
      return _this2.stringify();
    });
    return this.processing;
  };

  _proto.sync = function sync() {
    if (this.processed) return this.result;
    this.processed = true;

    if (this.processing) {
      throw new Error('Use process(css).then(cb) to work with async plugins');
    }

    if (this.error) throw this.error;

    for (var _iterator = this.result.processor.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var plugin = _ref;
      var promise = this.run(plugin);

      if (isPromise(promise)) {
        throw new Error('Use process(css).then(cb) to work with async plugins');
      }
    }

    return this.result;
  };

  _proto.run = function run(plugin) {
    this.result.lastPlugin = plugin;

    try {
      return plugin(this.result.root, this.result);
    } catch (error) {
      this.handleError(error, plugin);
      throw error;
    }
  };

  _proto.stringify = function stringify() {
    if (this.stringified) return this.result;
    this.stringified = true;
    this.sync();
    var opts = this.result.opts;
    var str = _stringify2.default;
    if (opts.syntax) str = opts.syntax.stringify;
    if (opts.stringifier) str = opts.stringifier;
    if (str.stringify) str = str.stringify;
    var map = new _mapGenerator.default(str, this.result.root, this.result.opts);
    var data = map.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  };

  _createClass(LazyResult, [{
    key: "processor",
    get: function get() {
      return this.result.processor;
    }
    /**
     * Options from the {@link Processor#process} call.
     *
     * @type {processOptions}
     */

  }, {
    key: "opts",
    get: function get() {
      return this.result.opts;
    }
    /**
     * Processes input CSS through synchronous plugins, converts `Root`
     * to a CSS string and returns {@link Result#css}.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {string}
     * @see Result#css
     */

  }, {
    key: "css",
    get: function get() {
      return this.stringify().css;
    }
    /**
     * An alias for the `css` property. Use it with syntaxes
     * that generate non-CSS output.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {string}
     * @see Result#content
     */

  }, {
    key: "content",
    get: function get() {
      return this.stringify().content;
    }
    /**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#map}.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {SourceMapGenerator}
     * @see Result#map
     */

  }, {
    key: "map",
    get: function get() {
      return this.stringify().map;
    }
    /**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#root}.
     *
     * This property will only work with synchronous plugins. If the processor
     * contains any asynchronous plugins it will throw an error.
     *
     * This is why this method is only for debug purpose,
     * you should always use {@link LazyResult#then}.
     *
     * @type {Root}
     * @see Result#root
     */

  }, {
    key: "root",
    get: function get() {
      return this.sync().root;
    }
    /**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#messages}.
     *
     * This property will only work with synchronous plugins. If the processor
     * contains any asynchronous plugins it will throw an error.
     *
     * This is why this method is only for debug purpose,
     * you should always use {@link LazyResult#then}.
     *
     * @type {Message[]}
     * @see Result#messages
     */

  }, {
    key: "messages",
    get: function get() {
      return this.sync().messages;
    }
  }]);

  return LazyResult;
}();

var _default = LazyResult;
/**
 * @callback onFulfilled
 * @param {Result} result
 */

/**
 * @callback onRejected
 * @param {Error} error
 */

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxhenktcmVzdWx0LmVzNiJdLCJuYW1lcyI6WyJpc1Byb21pc2UiLCJvYmoiLCJ0aGVuIiwiTGF6eVJlc3VsdCIsInByb2Nlc3NvciIsImNzcyIsIm9wdHMiLCJzdHJpbmdpZmllZCIsInByb2Nlc3NlZCIsInJvb3QiLCJ0eXBlIiwiUmVzdWx0IiwibWFwIiwiaW5saW5lIiwicHJldiIsInBhcnNlciIsInBhcnNlIiwic3ludGF4IiwiZXJyb3IiLCJyZXN1bHQiLCJ3YXJuaW5ncyIsInN5bmMiLCJ0b1N0cmluZyIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImFzeW5jIiwiY2F0Y2giLCJmaW5hbGx5Iiwib25GaW5hbGx5IiwiaGFuZGxlRXJyb3IiLCJwbHVnaW4iLCJuYW1lIiwicG9zdGNzc1BsdWdpbiIsInNldE1lc3NhZ2UiLCJwb3N0Y3NzVmVyc2lvbiIsInBsdWdpbk5hbWUiLCJwbHVnaW5WZXIiLCJydW50aW1lVmVyIiwidmVyc2lvbiIsImEiLCJzcGxpdCIsImIiLCJwYXJzZUludCIsImNvbnNvbGUiLCJlcnIiLCJhc3luY1RpY2siLCJyZXNvbHZlIiwicmVqZWN0IiwicGx1Z2lucyIsImxlbmd0aCIsInByb21pc2UiLCJydW4iLCJQcm9taXNlIiwic3RyaW5naWZ5IiwicHJvY2Vzc2luZyIsIkVycm9yIiwibGFzdFBsdWdpbiIsInN0ciIsInN0cmluZ2lmaWVyIiwiTWFwR2VuZXJhdG9yIiwiZGF0YSIsImdlbmVyYXRlIiwiY29udGVudCIsIm1lc3NhZ2VzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQUVBLFNBQVNBLFNBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO0FBQ3ZCLFNBQU8sT0FBT0EsR0FBUCxLQUFlLFFBQWYsSUFBMkIsT0FBT0EsR0FBRyxDQUFDQyxJQUFYLEtBQW9CLFVBQXREO0FBQ0Q7QUFFRDs7Ozs7Ozs7OztJQVFNQyxV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QUdBLEdBQUcsQ0FBQ0osU0FBVjtBQUVuQixRQUFJNUMsR0FBRyxHQUFHLElBQUlrRCxxQkFBSixDQUFpQkYsR0FBakIsRUFBc0IsS0FBS3pDLE1BQUwsQ0FBWVYsSUFBbEMsRUFBd0MsS0FBS1UsTUFBTCxDQUFZYixJQUFwRCxDQUFWO0FBQ0EsUUFBSXlELElBQUksR0FBR25ELEdBQUcsQ0FBQ29ELFFBQUosRUFBWDtBQUNBLFNBQUs3QyxNQUFMLENBQVlkLEdBQVosR0FBa0IwRCxJQUFJLENBQUMsQ0FBRCxDQUF0QjtBQUNBLFNBQUs1QyxNQUFMLENBQVlQLEdBQVosR0FBa0JtRCxJQUFJLENBQUMsQ0FBRCxDQUF0QjtBQUVBLFdBQU8sS0FBSzVDLE1BQVo7QUFDRCxHOzs7O3dCQWpVZ0I7QUFDZixhQUFPLEtBQUtBLE1BQUwsQ0FBWWYsU0FBbkI7QUFDRDtBQUVEOzs7Ozs7Ozt3QkFLWTtBQUNWLGFBQU8sS0FBS2UsTUFBTCxDQUFZYixJQUFuQjtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozt3QkFZVztBQUNULGFBQU8sS0FBS2tELFNBQUwsR0FBaUJuRCxHQUF4QjtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozt3QkFZZTtBQUNiLGFBQU8sS0FBS21ELFNBQUwsR0FBaUJTLE9BQXhCO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O3dCQVlXO0FBQ1QsYUFBTyxLQUFLVCxTQUFMLEdBQWlCNUMsR0FBeEI7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O3dCQWFZO0FBQ1YsYUFBTyxLQUFLUyxJQUFMLEdBQVlaLElBQW5CO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFhZ0I7QUFDZCxhQUFPLEtBQUtZLElBQUwsR0FBWTZDLFFBQW5CO0FBQ0Q7Ozs7OztlQXVPWS9ELFU7QUFFZjs7Ozs7QUFLQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNYXBHZW5lcmF0b3IgZnJvbSAnLi9tYXAtZ2VuZXJhdG9yJ1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeSdcbmltcG9ydCB3YXJuT25jZSBmcm9tICcuL3dhcm4tb25jZSdcbmltcG9ydCBSZXN1bHQgZnJvbSAnLi9yZXN1bHQnXG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZSdcblxuZnVuY3Rpb24gaXNQcm9taXNlIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG4vKipcbiAqIEEgUHJvbWlzZSBwcm94eSBmb3IgdGhlIHJlc3VsdCBvZiBQb3N0Q1NTIHRyYW5zZm9ybWF0aW9ucy5cbiAqXG4gKiBBIGBMYXp5UmVzdWx0YCBpbnN0YW5jZSBpcyByZXR1cm5lZCBieSB7QGxpbmsgUHJvY2Vzc29yI3Byb2Nlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBsYXp5ID0gcG9zdGNzcyhbYXV0b3ByZWZpeGVyXSkucHJvY2Vzcyhjc3MpXG4gKi9cbmNsYXNzIExhenlSZXN1bHQge1xuICBjb25zdHJ1Y3RvciAocHJvY2Vzc29yLCBjc3MsIG9wdHMpIHtcbiAgICB0aGlzLnN0cmluZ2lmaWVkID0gZmFsc2VcbiAgICB0aGlzLnByb2Nlc3NlZCA9IGZhbHNlXG5cbiAgICBsZXQgcm9vdFxuICAgIGlmICh0eXBlb2YgY3NzID09PSAnb2JqZWN0JyAmJiBjc3MgIT09IG51bGwgJiYgY3NzLnR5cGUgPT09ICdyb290Jykge1xuICAgICAgcm9vdCA9IGNzc1xuICAgIH0gZWxzZSBpZiAoY3NzIGluc3RhbmNlb2YgTGF6eVJlc3VsdCB8fCBjc3MgaW5zdGFuY2VvZiBSZXN1bHQpIHtcbiAgICAgIHJvb3QgPSBjc3Mucm9vdFxuICAgICAgaWYgKGNzcy5tYXApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1hcCA9PT0gJ3VuZGVmaW5lZCcpIG9wdHMubWFwID0geyB9XG4gICAgICAgIGlmICghb3B0cy5tYXAuaW5saW5lKSBvcHRzLm1hcC5pbmxpbmUgPSBmYWxzZVxuICAgICAgICBvcHRzLm1hcC5wcmV2ID0gY3NzLm1hcFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFyc2VyID0gcGFyc2VcbiAgICAgIGlmIChvcHRzLnN5bnRheCkgcGFyc2VyID0gb3B0cy5zeW50YXgucGFyc2VcbiAgICAgIGlmIChvcHRzLnBhcnNlcikgcGFyc2VyID0gb3B0cy5wYXJzZXJcbiAgICAgIGlmIChwYXJzZXIucGFyc2UpIHBhcnNlciA9IHBhcnNlci5wYXJzZVxuXG4gICAgICB0cnkge1xuICAgICAgICByb290ID0gcGFyc2VyKGNzcywgb3B0cylcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvclxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdChwcm9jZXNzb3IsIHJvb3QsIG9wdHMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHtAbGluayBQcm9jZXNzb3J9IGluc3RhbmNlLCB3aGljaCB3aWxsIGJlIHVzZWRcbiAgICogZm9yIENTUyB0cmFuc2Zvcm1hdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtQcm9jZXNzb3J9XG4gICAqL1xuICBnZXQgcHJvY2Vzc29yICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yXG4gIH1cblxuICAvKipcbiAgICogT3B0aW9ucyBmcm9tIHRoZSB7QGxpbmsgUHJvY2Vzc29yI3Byb2Nlc3N9IGNhbGwuXG4gICAqXG4gICAqIEB0eXBlIHtwcm9jZXNzT3B0aW9uc31cbiAgICovXG4gIGdldCBvcHRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0c1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBpbnB1dCBDU1MgdGhyb3VnaCBzeW5jaHJvbm91cyBwbHVnaW5zLCBjb252ZXJ0cyBgUm9vdGBcbiAgICogdG8gYSBDU1Mgc3RyaW5nIGFuZCByZXR1cm5zIHtAbGluayBSZXN1bHQjY3NzfS5cbiAgICpcbiAgICogVGhpcyBwcm9wZXJ0eSB3aWxsIG9ubHkgd29yayB3aXRoIHN5bmNocm9ub3VzIHBsdWdpbnMuXG4gICAqIElmIHRoZSBwcm9jZXNzb3IgY29udGFpbnMgYW55IGFzeW5jaHJvbm91cyBwbHVnaW5zXG4gICAqIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuIFRoaXMgaXMgd2h5IHRoaXMgbWV0aG9kIGlzIG9ubHlcbiAgICogZm9yIGRlYnVnIHB1cnBvc2UsIHlvdSBzaG91bGQgYWx3YXlzIHVzZSB7QGxpbmsgTGF6eVJlc3VsdCN0aGVufS5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHNlZSBSZXN1bHQjY3NzXG4gICAqL1xuICBnZXQgY3NzICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jc3NcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBhbGlhcyBmb3IgdGhlIGBjc3NgIHByb3BlcnR5LiBVc2UgaXQgd2l0aCBzeW50YXhlc1xuICAgKiB0aGF0IGdlbmVyYXRlIG5vbi1DU1Mgb3V0cHV0LlxuICAgKlxuICAgKiBUaGlzIHByb3BlcnR5IHdpbGwgb25seSB3b3JrIHdpdGggc3luY2hyb25vdXMgcGx1Z2lucy5cbiAgICogSWYgdGhlIHByb2Nlc3NvciBjb250YWlucyBhbnkgYXN5bmNocm9ub3VzIHBsdWdpbnNcbiAgICogaXQgd2lsbCB0aHJvdyBhbiBlcnJvci4gVGhpcyBpcyB3aHkgdGhpcyBtZXRob2QgaXMgb25seVxuICAgKiBmb3IgZGVidWcgcHVycG9zZSwgeW91IHNob3VsZCBhbHdheXMgdXNlIHtAbGluayBMYXp5UmVzdWx0I3RoZW59LlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAc2VlIFJlc3VsdCNjb250ZW50XG4gICAqL1xuICBnZXQgY29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY29udGVudFxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBpbnB1dCBDU1MgdGhyb3VnaCBzeW5jaHJvbm91cyBwbHVnaW5zXG4gICAqIGFuZCByZXR1cm5zIHtAbGluayBSZXN1bHQjbWFwfS5cbiAgICpcbiAgICogVGhpcyBwcm9wZXJ0eSB3aWxsIG9ubHkgd29yayB3aXRoIHN5bmNocm9ub3VzIHBsdWdpbnMuXG4gICAqIElmIHRoZSBwcm9jZXNzb3IgY29udGFpbnMgYW55IGFzeW5jaHJvbm91cyBwbHVnaW5zXG4gICAqIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuIFRoaXMgaXMgd2h5IHRoaXMgbWV0aG9kIGlzIG9ubHlcbiAgICogZm9yIGRlYnVnIHB1cnBvc2UsIHlvdSBzaG91bGQgYWx3YXlzIHVzZSB7QGxpbmsgTGF6eVJlc3VsdCN0aGVufS5cbiAgICpcbiAgICogQHR5cGUge1NvdXJjZU1hcEdlbmVyYXRvcn1cbiAgICogQHNlZSBSZXN1bHQjbWFwXG4gICAqL1xuICBnZXQgbWFwICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5tYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgaW5wdXQgQ1NTIHRocm91Z2ggc3luY2hyb25vdXMgcGx1Z2luc1xuICAgKiBhbmQgcmV0dXJucyB7QGxpbmsgUmVzdWx0I3Jvb3R9LlxuICAgKlxuICAgKiBUaGlzIHByb3BlcnR5IHdpbGwgb25seSB3b3JrIHdpdGggc3luY2hyb25vdXMgcGx1Z2lucy4gSWYgdGhlIHByb2Nlc3NvclxuICAgKiBjb250YWlucyBhbnkgYXN5bmNocm9ub3VzIHBsdWdpbnMgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICpcbiAgICogVGhpcyBpcyB3aHkgdGhpcyBtZXRob2QgaXMgb25seSBmb3IgZGVidWcgcHVycG9zZSxcbiAgICogeW91IHNob3VsZCBhbHdheXMgdXNlIHtAbGluayBMYXp5UmVzdWx0I3RoZW59LlxuICAgKlxuICAgKiBAdHlwZSB7Um9vdH1cbiAgICogQHNlZSBSZXN1bHQjcm9vdFxuICAgKi9cbiAgZ2V0IHJvb3QgKCkge1xuICAgIHJldHVybiB0aGlzLnN5bmMoKS5yb290XG4gIH1cblxuICAvKipcbiAgICogUHJvY2Vzc2VzIGlucHV0IENTUyB0aHJvdWdoIHN5bmNocm9ub3VzIHBsdWdpbnNcbiAgICogYW5kIHJldHVybnMge0BsaW5rIFJlc3VsdCNtZXNzYWdlc30uXG4gICAqXG4gICAqIFRoaXMgcHJvcGVydHkgd2lsbCBvbmx5IHdvcmsgd2l0aCBzeW5jaHJvbm91cyBwbHVnaW5zLiBJZiB0aGUgcHJvY2Vzc29yXG4gICAqIGNvbnRhaW5zIGFueSBhc3luY2hyb25vdXMgcGx1Z2lucyBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgKlxuICAgKiBUaGlzIGlzIHdoeSB0aGlzIG1ldGhvZCBpcyBvbmx5IGZvciBkZWJ1ZyBwdXJwb3NlLFxuICAgKiB5b3Ugc2hvdWxkIGFsd2F5cyB1c2Uge0BsaW5rIExhenlSZXN1bHQjdGhlbn0uXG4gICAqXG4gICAqIEB0eXBlIHtNZXNzYWdlW119XG4gICAqIEBzZWUgUmVzdWx0I21lc3NhZ2VzXG4gICAqL1xuICBnZXQgbWVzc2FnZXMgKCkge1xuICAgIHJldHVybiB0aGlzLnN5bmMoKS5tZXNzYWdlc1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBpbnB1dCBDU1MgdGhyb3VnaCBzeW5jaHJvbm91cyBwbHVnaW5zXG4gICAqIGFuZCBjYWxscyB7QGxpbmsgUmVzdWx0I3dhcm5pbmdzKCl9LlxuICAgKlxuICAgKiBAcmV0dXJuIHtXYXJuaW5nW119IFdhcm5pbmdzIGZyb20gcGx1Z2lucy5cbiAgICovXG4gIHdhcm5pbmdzICgpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jKCkud2FybmluZ3MoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciB0aGUge0BsaW5rIExhenlSZXN1bHQjY3NzfSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbGF6eSArICcnID09PSBsYXp5LmNzc1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE91dHB1dCBDU1MuXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3NzXG4gIH1cblxuICAvKipcbiAgICogUHJvY2Vzc2VzIGlucHV0IENTUyB0aHJvdWdoIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXMgcGx1Z2luc1xuICAgKiBhbmQgY2FsbHMgYG9uRnVsZmlsbGVkYCB3aXRoIGEgUmVzdWx0IGluc3RhbmNlLiBJZiBhIHBsdWdpbiB0aHJvd3NcbiAgICogYW4gZXJyb3IsIHRoZSBgb25SZWplY3RlZGAgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZC5cbiAgICpcbiAgICogSXQgaW1wbGVtZW50cyBzdGFuZGFyZCBQcm9taXNlIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHtvbkZ1bGZpbGxlZH0gb25GdWxmaWxsZWQgQ2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIGFsbCBwbHVnaW5zIHdpbGwgZmluaXNoIHdvcmsuXG4gICAqIEBwYXJhbSB7b25SZWplY3RlZH0gIG9uUmVqZWN0ZWQgIENhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgb24gYW55IGVycm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIEFQSSB0byBtYWtlIHF1ZXVlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBwb3N0Y3NzKFthdXRvcHJlZml4ZXJdKS5wcm9jZXNzKGNzcywgeyBmcm9tOiBjc3NQYXRoIH0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhyZXN1bHQuY3NzKVxuICAgKiB9KVxuICAgKi9cbiAgdGhlbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEoJ2Zyb20nIGluIHRoaXMub3B0cykpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgJ1dpdGhvdXQgYGZyb21gIG9wdGlvbiBQb3N0Q1NTIGNvdWxkIGdlbmVyYXRlIHdyb25nIHNvdXJjZSBtYXAgJyArXG4gICAgICAgICAgJ2FuZCB3aWxsIG5vdCBmaW5kIEJyb3dzZXJzbGlzdCBjb25maWcuIFNldCBpdCB0byBDU1MgZmlsZSBwYXRoICcgK1xuICAgICAgICAgICdvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy4nXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBpbnB1dCBDU1MgdGhyb3VnaCBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzIHBsdWdpbnNcbiAgICogYW5kIGNhbGxzIG9uUmVqZWN0ZWQgZm9yIGVhY2ggZXJyb3IgdGhyb3duIGluIGFueSBwbHVnaW4uXG4gICAqXG4gICAqIEl0IGltcGxlbWVudHMgc3RhbmRhcmQgUHJvbWlzZSBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSB7b25SZWplY3RlZH0gb25SZWplY3RlZCBDYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9uIGFueSBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSBBUEkgdG8gbWFrZSBxdWV1ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcyhbYXV0b3ByZWZpeGVyXSkucHJvY2Vzcyhjc3MpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhyZXN1bHQuY3NzKVxuICAgKiB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAqICAgY29uc29sZS5lcnJvcihlcnJvcilcbiAgICogfSlcbiAgICovXG4gIGNhdGNoIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKVxuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgaW5wdXQgQ1NTIHRocm91Z2ggc3luY2hyb25vdXMgYW5kIGFzeW5jaHJvbm91cyBwbHVnaW5zXG4gICAqIGFuZCBjYWxscyBvbkZpbmFsbHkgb24gYW55IGVycm9yIG9yIHdoZW4gYWxsIHBsdWdpbnMgd2lsbCBmaW5pc2ggd29yay5cbiAgICpcbiAgICogSXQgaW1wbGVtZW50cyBzdGFuZGFyZCBQcm9taXNlIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHtvbkZpbmFsbHl9IG9uRmluYWxseSBDYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9uIGFueSBlcnJvciBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gYWxsIHBsdWdpbnMgd2lsbCBmaW5pc2ggd29yay5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSBBUEkgdG8gbWFrZSBxdWV1ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcyhbYXV0b3ByZWZpeGVyXSkucHJvY2Vzcyhjc3MpLmZpbmFsbHkoKCkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKCdwcm9jZXNzaW5nIGVuZGVkJylcbiAgICogfSlcbiAgICovXG4gIGZpbmFsbHkgKG9uRmluYWxseSkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksIG9uRmluYWxseSlcbiAgfVxuXG4gIGhhbmRsZUVycm9yIChlcnJvciwgcGx1Z2luKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJvclxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdDc3NTeW50YXhFcnJvcicgJiYgIWVycm9yLnBsdWdpbikge1xuICAgICAgICBlcnJvci5wbHVnaW4gPSBwbHVnaW4ucG9zdGNzc1BsdWdpblxuICAgICAgICBlcnJvci5zZXRNZXNzYWdlKClcbiAgICAgIH0gZWxzZSBpZiAocGx1Z2luLnBvc3Rjc3NWZXJzaW9uKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgbGV0IHBsdWdpbk5hbWUgPSBwbHVnaW4ucG9zdGNzc1BsdWdpblxuICAgICAgICAgIGxldCBwbHVnaW5WZXIgPSBwbHVnaW4ucG9zdGNzc1ZlcnNpb25cbiAgICAgICAgICBsZXQgcnVudGltZVZlciA9IHRoaXMucmVzdWx0LnByb2Nlc3Nvci52ZXJzaW9uXG4gICAgICAgICAgbGV0IGEgPSBwbHVnaW5WZXIuc3BsaXQoJy4nKVxuICAgICAgICAgIGxldCBiID0gcnVudGltZVZlci5zcGxpdCgnLicpXG5cbiAgICAgICAgICBpZiAoYVswXSAhPT0gYlswXSB8fCBwYXJzZUludChhWzFdKSA+IHBhcnNlSW50KGJbMV0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnVW5rbm93biBlcnJvciBmcm9tIFBvc3RDU1MgcGx1Z2luLiBZb3VyIGN1cnJlbnQgUG9zdENTUyAnICtcbiAgICAgICAgICAgICAgJ3ZlcnNpb24gaXMgJyArIHJ1bnRpbWVWZXIgKyAnLCBidXQgJyArIHBsdWdpbk5hbWUgKyAnIHVzZXMgJyArXG4gICAgICAgICAgICAgIHBsdWdpblZlciArICcuIFBlcmhhcHMgdGhpcyBpcyB0aGUgc291cmNlIG9mIHRoZSBlcnJvciBiZWxvdy4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSBjb25zb2xlLmVycm9yKGVycilcbiAgICB9XG4gIH1cblxuICBhc3luY1RpY2sgKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmICh0aGlzLnBsdWdpbiA+PSB0aGlzLnByb2Nlc3Nvci5wbHVnaW5zLmxlbmd0aCkge1xuICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlXG4gICAgICByZXR1cm4gcmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnByb2Nlc3Nvci5wbHVnaW5zW3RoaXMucGx1Z2luXVxuICAgICAgbGV0IHByb21pc2UgPSB0aGlzLnJ1bihwbHVnaW4pXG4gICAgICB0aGlzLnBsdWdpbiArPSAxXG5cbiAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmFzeW5jVGljayhyZXNvbHZlLCByZWplY3QpXG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBwbHVnaW4pXG4gICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlXG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hc3luY1RpY2socmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWVcbiAgICAgIHJlamVjdChlcnJvcilcbiAgICB9XG4gIH1cblxuICBhc3luYyAoKSB7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgICAgIHJlamVjdCh0aGlzLmVycm9yKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUodGhpcy5zdHJpbmdpZnkoKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZykge1xuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc2luZ1xuICAgIH1cblxuICAgIHRoaXMucHJvY2Vzc2luZyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmVycm9yKSByZXR1cm4gcmVqZWN0KHRoaXMuZXJyb3IpXG4gICAgICB0aGlzLnBsdWdpbiA9IDBcbiAgICAgIHRoaXMuYXN5bmNUaWNrKHJlc29sdmUsIHJlamVjdClcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZVxuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc2luZ1xuICB9XG5cbiAgc3luYyAoKSB7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gdGhpcy5yZXN1bHRcbiAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWVcblxuICAgIGlmICh0aGlzLnByb2Nlc3NpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VzZSBwcm9jZXNzKGNzcykudGhlbihjYikgdG8gd29yayB3aXRoIGFzeW5jIHBsdWdpbnMnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yXG5cbiAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5yZXN1bHQucHJvY2Vzc29yLnBsdWdpbnMpIHtcbiAgICAgIGxldCBwcm9taXNlID0gdGhpcy5ydW4ocGx1Z2luKVxuICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1VzZSBwcm9jZXNzKGNzcykudGhlbihjYikgdG8gd29yayB3aXRoIGFzeW5jIHBsdWdpbnMnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlc3VsdFxuICB9XG5cbiAgcnVuIChwbHVnaW4pIHtcbiAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luXG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHBsdWdpbih0aGlzLnJlc3VsdC5yb290LCB0aGlzLnJlc3VsdClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgcGx1Z2luKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBzdHJpbmdpZnkgKCkge1xuICAgIGlmICh0aGlzLnN0cmluZ2lmaWVkKSByZXR1cm4gdGhpcy5yZXN1bHRcbiAgICB0aGlzLnN0cmluZ2lmaWVkID0gdHJ1ZVxuXG4gICAgdGhpcy5zeW5jKClcblxuICAgIGxldCBvcHRzID0gdGhpcy5yZXN1bHQub3B0c1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnlcbiAgICBpZiAob3B0cy5zeW50YXgpIHN0ciA9IG9wdHMuc3ludGF4LnN0cmluZ2lmeVxuICAgIGlmIChvcHRzLnN0cmluZ2lmaWVyKSBzdHIgPSBvcHRzLnN0cmluZ2lmaWVyXG4gICAgaWYgKHN0ci5zdHJpbmdpZnkpIHN0ciA9IHN0ci5zdHJpbmdpZnlcblxuICAgIGxldCBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yKHN0ciwgdGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQub3B0cylcbiAgICBsZXQgZGF0YSA9IG1hcC5nZW5lcmF0ZSgpXG4gICAgdGhpcy5yZXN1bHQuY3NzID0gZGF0YVswXVxuICAgIHRoaXMucmVzdWx0Lm1hcCA9IGRhdGFbMV1cblxuICAgIHJldHVybiB0aGlzLnJlc3VsdFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExhenlSZXN1bHRcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25GdWxmaWxsZWRcbiAqIEBwYXJhbSB7UmVzdWx0fSByZXN1bHRcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblJlamVjdGVkXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICovXG4iXSwiZmlsZSI6ImxhenktcmVzdWx0LmpzIn0=


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(40).SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(83).SourceMapConsumer;
exports.SourceNode = __webpack_require__(86).SourceNode;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(41);
var util = __webpack_require__(8);
var ArraySet = __webpack_require__(42).ArraySet;
var MappingList = __webpack_require__(82).MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(81);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(8);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/**
 * Contains helpers for safely splitting lists of CSS values,
 * preserving parentheses and quotes.
 *
 * @example
 * const list = postcss.list
 *
 * @namespace list
 */
var list = {
  split: function split(string, separators, last) {
    var array = [];
    var current = '';
    var split = false;
    var func = 0;
    var quote = false;
    var escape = false;

    for (var i = 0; i < string.length; i++) {
      var letter = string[i];

      if (quote) {
        if (escape) {
          escape = false;
        } else if (letter === '\\') {
          escape = true;
        } else if (letter === quote) {
          quote = false;
        }
      } else if (letter === '"' || letter === '\'') {
        quote = letter;
      } else if (letter === '(') {
        func += 1;
      } else if (letter === ')') {
        if (func > 0) func -= 1;
      } else if (func === 0) {
        if (separators.indexOf(letter) !== -1) split = true;
      }

      if (split) {
        if (current !== '') array.push(current.trim());
        current = '';
        split = false;
      } else {
        current += letter;
      }
    }

    if (last || current !== '') array.push(current.trim());
    return array;
  },

  /**
   * Safely splits space-separated values (such as those for `background`,
   * `border-radius`, and other shorthand properties).
   *
   * @param {string} string Space-separated values.
   *
   * @return {string[]} Split values.
   *
   * @example
   * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
   */
  space: function space(string) {
    var spaces = [' ', '\n', '\t'];
    return list.split(string, spaces);
  },

  /**
   * Safely splits comma-separated values (such as those for `transition-*`
   * and `background` properties).
   *
   * @param {string} string Comma-separated values.
   *
   * @return {string[]} Split values.
   *
   * @example
   * postcss.list.comma('black, linear-gradient(white, black)')
   * //=> ['black', 'linear-gradient(white, black)']
   */
  comma: function comma(string) {
    return list.split(string, [','], true);
  }
};
var _default = list;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpc3QuZXM2Il0sIm5hbWVzIjpbImxpc3QiLCJzcGxpdCIsInN0cmluZyIsInNlcGFyYXRvcnMiLCJsYXN0IiwiYXJyYXkiLCJjdXJyZW50IiwiZnVuYyIsInF1b3RlIiwiZXNjYXBlIiwiaSIsImxlbmd0aCIsImxldHRlciIsImluZGV4T2YiLCJwdXNoIiwidHJpbSIsInNwYWNlIiwic3BhY2VzIiwiY29tbWEiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7OztBQVNBLElBQUlBLElBQUksR0FBRztBQUVUQyxFQUFBQSxLQUZTLGlCQUVGQyxNQUZFLEVBRU1DLFVBRk4sRUFFa0JDLElBRmxCLEVBRXdCO0FBQy9CLFFBQUlDLEtBQUssR0FBRyxFQUFaO0FBQ0EsUUFBSUMsT0FBTyxHQUFHLEVBQWQ7QUFDQSxRQUFJTCxLQUFLLEdBQUcsS0FBWjtBQUVBLFFBQUlNLElBQUksR0FBRyxDQUFYO0FBQ0EsUUFBSUMsS0FBSyxHQUFHLEtBQVo7QUFDQSxRQUFJQyxNQUFNLEdBQUcsS0FBYjs7QUFFQSxTQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdSLE1BQU0sQ0FBQ1MsTUFBM0IsRUFBbUNELENBQUMsRUFBcEMsRUFBd0M7QUFDdEMsVUFBSUUsTUFBTSxHQUFHVixNQUFNLENBQUNRLENBQUQsQ0FBbkI7O0FBRUEsVUFBSUYsS0FBSixFQUFXO0FBQ1QsWUFBSUMsTUFBSixFQUFZO0FBQ1ZBLFVBQUFBLE1BQU0sR0FBRyxLQUFUO0FBQ0QsU0FGRCxNQUVPLElBQUlHLE1BQU0sS0FBSyxJQUFmLEVBQXFCO0FBQzFCSCxVQUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNELFNBRk0sTUFFQSxJQUFJRyxNQUFNLEtBQUtKLEtBQWYsRUFBc0I7QUFDM0JBLFVBQUFBLEtBQUssR0FBRyxLQUFSO0FBQ0Q7QUFDRixPQVJELE1BUU8sSUFBSUksTUFBTSxLQUFLLEdBQVgsSUFBa0JBLE1BQU0sS0FBSyxJQUFqQyxFQUF1QztBQUM1Q0osUUFBQUEsS0FBSyxHQUFHSSxNQUFSO0FBQ0QsT0FGTSxNQUVBLElBQUlBLE1BQU0sS0FBSyxHQUFmLEVBQW9CO0FBQ3pCTCxRQUFBQSxJQUFJLElBQUksQ0FBUjtBQUNELE9BRk0sTUFFQSxJQUFJSyxNQUFNLEtBQUssR0FBZixFQUFvQjtBQUN6QixZQUFJTCxJQUFJLEdBQUcsQ0FBWCxFQUFjQSxJQUFJLElBQUksQ0FBUjtBQUNmLE9BRk0sTUFFQSxJQUFJQSxJQUFJLEtBQUssQ0FBYixFQUFnQjtBQUNyQixZQUFJSixVQUFVLENBQUNVLE9BQVgsQ0FBbUJELE1BQW5CLE1BQStCLENBQUMsQ0FBcEMsRUFBdUNYLEtBQUssR0FBRyxJQUFSO0FBQ3hDOztBQUVELFVBQUlBLEtBQUosRUFBVztBQUNULFlBQUlLLE9BQU8sS0FBSyxFQUFoQixFQUFvQkQsS0FBSyxDQUFDUyxJQUFOLENBQVdSLE9BQU8sQ0FBQ1MsSUFBUixFQUFYO0FBQ3BCVCxRQUFBQSxPQUFPLEdBQUcsRUFBVjtBQUNBTCxRQUFBQSxLQUFLLEdBQUcsS0FBUjtBQUNELE9BSkQsTUFJTztBQUNMSyxRQUFBQSxPQUFPLElBQUlNLE1BQVg7QUFDRDtBQUNGOztBQUVELFFBQUlSLElBQUksSUFBSUUsT0FBTyxLQUFLLEVBQXhCLEVBQTRCRCxLQUFLLENBQUNTLElBQU4sQ0FBV1IsT0FBTyxDQUFDUyxJQUFSLEVBQVg7QUFDNUIsV0FBT1YsS0FBUDtBQUNELEdBM0NROztBQTZDVDs7Ozs7Ozs7Ozs7QUFXQVcsRUFBQUEsS0F4RFMsaUJBd0RGZCxNQXhERSxFQXdETTtBQUNiLFFBQUllLE1BQU0sR0FBRyxDQUFDLEdBQUQsRUFBTSxJQUFOLEVBQVksSUFBWixDQUFiO0FBQ0EsV0FBT2pCLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxNQUFYLEVBQW1CZSxNQUFuQixDQUFQO0FBQ0QsR0EzRFE7O0FBNkRUOzs7Ozs7Ozs7Ozs7QUFZQUMsRUFBQUEsS0F6RVMsaUJBeUVGaEIsTUF6RUUsRUF5RU07QUFDYixXQUFPRixJQUFJLENBQUNDLEtBQUwsQ0FBV0MsTUFBWCxFQUFtQixDQUFDLEdBQUQsQ0FBbkIsRUFBMEIsSUFBMUIsQ0FBUDtBQUNEO0FBM0VRLENBQVg7ZUErRWVGLEkiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRhaW5zIGhlbHBlcnMgZm9yIHNhZmVseSBzcGxpdHRpbmcgbGlzdHMgb2YgQ1NTIHZhbHVlcyxcbiAqIHByZXNlcnZpbmcgcGFyZW50aGVzZXMgYW5kIHF1b3Rlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbGlzdCA9IHBvc3Rjc3MubGlzdFxuICpcbiAqIEBuYW1lc3BhY2UgbGlzdFxuICovXG5sZXQgbGlzdCA9IHtcblxuICBzcGxpdCAoc3RyaW5nLCBzZXBhcmF0b3JzLCBsYXN0KSB7XG4gICAgbGV0IGFycmF5ID0gW11cbiAgICBsZXQgY3VycmVudCA9ICcnXG4gICAgbGV0IHNwbGl0ID0gZmFsc2VcblxuICAgIGxldCBmdW5jID0gMFxuICAgIGxldCBxdW90ZSA9IGZhbHNlXG4gICAgbGV0IGVzY2FwZSA9IGZhbHNlXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGxldHRlciA9IHN0cmluZ1tpXVxuXG4gICAgICBpZiAocXVvdGUpIHtcbiAgICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICAgIGVzY2FwZSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSAnXFxcXCcpIHtcbiAgICAgICAgICBlc2NhcGUgPSB0cnVlXG4gICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBxdW90ZSkge1xuICAgICAgICAgIHF1b3RlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICdcIicgfHwgbGV0dGVyID09PSAnXFwnJykge1xuICAgICAgICBxdW90ZSA9IGxldHRlclxuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICcoJykge1xuICAgICAgICBmdW5jICs9IDFcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSAnKScpIHtcbiAgICAgICAgaWYgKGZ1bmMgPiAwKSBmdW5jIC09IDFcbiAgICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gMCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9ycy5pbmRleE9mKGxldHRlcikgIT09IC0xKSBzcGxpdCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSAnJykgYXJyYXkucHVzaChjdXJyZW50LnRyaW0oKSlcbiAgICAgICAgY3VycmVudCA9ICcnXG4gICAgICAgIHNwbGl0ID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgKz0gbGV0dGVyXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgfHwgY3VycmVudCAhPT0gJycpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpXG4gICAgcmV0dXJuIGFycmF5XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhZmVseSBzcGxpdHMgc3BhY2Utc2VwYXJhdGVkIHZhbHVlcyAoc3VjaCBhcyB0aG9zZSBmb3IgYGJhY2tncm91bmRgLFxuICAgKiBgYm9yZGVyLXJhZGl1c2AsIGFuZCBvdGhlciBzaG9ydGhhbmQgcHJvcGVydGllcykuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3BhY2Utc2VwYXJhdGVkIHZhbHVlcy5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nW119IFNwbGl0IHZhbHVlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcy5saXN0LnNwYWNlKCcxcHggY2FsYygxMCUgKyAxcHgpJykgLy89PiBbJzFweCcsICdjYWxjKDEwJSArIDFweCknXVxuICAgKi9cbiAgc3BhY2UgKHN0cmluZykge1xuICAgIGxldCBzcGFjZXMgPSBbJyAnLCAnXFxuJywgJ1xcdCddXG4gICAgcmV0dXJuIGxpc3Quc3BsaXQoc3RyaW5nLCBzcGFjZXMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhZmVseSBzcGxpdHMgY29tbWEtc2VwYXJhdGVkIHZhbHVlcyAoc3VjaCBhcyB0aG9zZSBmb3IgYHRyYW5zaXRpb24tKmBcbiAgICogYW5kIGBiYWNrZ3JvdW5kYCBwcm9wZXJ0aWVzKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBDb21tYS1zZXBhcmF0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gU3BsaXQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBwb3N0Y3NzLmxpc3QuY29tbWEoJ2JsYWNrLCBsaW5lYXItZ3JhZGllbnQod2hpdGUsIGJsYWNrKScpXG4gICAqIC8vPT4gWydibGFjaycsICdsaW5lYXItZ3JhZGllbnQod2hpdGUsIGJsYWNrKSddXG4gICAqL1xuICBjb21tYSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGxpc3Quc3BsaXQoc3RyaW5nLCBbJywnXSwgdHJ1ZSlcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RcbiJdLCJmaWxlIjoibGlzdC5qcyJ9


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _container = _interopRequireDefault(__webpack_require__(22));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Represents a CSS file and contains all its parsed nodes.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{color:black} b{z-index:2}')
 * root.type         //=> 'root'
 * root.nodes.length //=> 2
 */
var Root =
/*#__PURE__*/
function (_Container) {
  _inheritsLoose(Root, _Container);

  function Root(defaults) {
    var _this;

    _this = _Container.call(this, defaults) || this;
    _this.type = 'root';
    if (!_this.nodes) _this.nodes = [];
    return _this;
  }

  var _proto = Root.prototype;

  _proto.removeChild = function removeChild(child, ignore) {
    var index = this.index(child);

    if (!ignore && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before;
    }

    return _Container.prototype.removeChild.call(this, child);
  };

  _proto.normalize = function normalize(child, sample, type) {
    var nodes = _Container.prototype.normalize.call(this, child);

    if (sample) {
      if (type === 'prepend') {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var node = _ref;
          node.raws.before = sample.raws.before;
        }
      }
    }

    return nodes;
  }
  /**
   * Returns a {@link Result} instance representing the root’s CSS.
   *
   * @param {processOptions} [opts] Options with only `to` and `map` keys.
   *
   * @return {Result} Result with current root’s CSS.
   *
   * @example
   * const root1 = postcss.parse(css1, { from: 'a.css' })
   * const root2 = postcss.parse(css2, { from: 'b.css' })
   * root1.append(root2)
   * const result = root1.toResult({ to: 'all.css', map: true })
   */
  ;

  _proto.toResult = function toResult(opts) {
    if (opts === void 0) {
      opts = {};
    }

    var LazyResult = __webpack_require__(38);

    var Processor = __webpack_require__(37);

    var lazy = new LazyResult(new Processor(), this, opts);
    return lazy.stringify();
  }
  /**
   * @memberof Root#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `after`: the space symbols after the last child to the end of file.
   * * `semicolon`: is the last child has an (optional) semicolon.
   *
   * @example
   * postcss.parse('a {}\n').raws //=> { after: '\n' }
   * postcss.parse('a {}').raws   //=> { after: '' }
   */
  ;

  return Root;
}(_container.default);

var _default = Root;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJvb3QuZXM2Il0sIm5hbWVzIjpbIlJvb3QiLCJkZWZhdWx0cyIsInR5cGUiLCJub2RlcyIsInJlbW92ZUNoaWxkIiwiY2hpbGQiLCJpZ25vcmUiLCJpbmRleCIsImxlbmd0aCIsInJhd3MiLCJiZWZvcmUiLCJub3JtYWxpemUiLCJzYW1wbGUiLCJmaXJzdCIsIm5vZGUiLCJ0b1Jlc3VsdCIsIm9wdHMiLCJMYXp5UmVzdWx0IiwicmVxdWlyZSIsIlByb2Nlc3NvciIsImxhenkiLCJzdHJpbmdpZnkiLCJDb250YWluZXIiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7OztBQUVBOzs7Ozs7Ozs7O0lBVU1BLEk7Ozs7O0FBQ0osZ0JBQWFDLFFBQWIsRUFBdUI7QUFBQTs7QUFDckIsa0NBQU1BLFFBQU47QUFDQSxVQUFLQyxJQUFMLEdBQVksTUFBWjtBQUNBLFFBQUksQ0FBQyxNQUFLQyxLQUFWLEVBQWlCLE1BQUtBLEtBQUwsR0FBYSxFQUFiO0FBSEk7QUFJdEI7Ozs7U0FFREMsVyxHQUFBLHFCQUFhQyxLQUFiLEVBQW9CQyxNQUFwQixFQUE0QjtBQUMxQixRQUFJQyxLQUFLLEdBQUcsS0FBS0EsS0FBTCxDQUFXRixLQUFYLENBQVo7O0FBRUEsUUFBSSxDQUFDQyxNQUFELElBQVdDLEtBQUssS0FBSyxDQUFyQixJQUEwQixLQUFLSixLQUFMLENBQVdLLE1BQVgsR0FBb0IsQ0FBbEQsRUFBcUQ7QUFDbkQsV0FBS0wsS0FBTCxDQUFXLENBQVgsRUFBY00sSUFBZCxDQUFtQkMsTUFBbkIsR0FBNEIsS0FBS1AsS0FBTCxDQUFXSSxLQUFYLEVBQWtCRSxJQUFsQixDQUF1QkMsTUFBbkQ7QUFDRDs7QUFFRCxnQ0FBYU4sV0FBYixZQUF5QkMsS0FBekI7QUFDRCxHOztTQUVETSxTLEdBQUEsbUJBQVdOLEtBQVgsRUFBa0JPLE1BQWxCLEVBQTBCVixJQUExQixFQUFnQztBQUM5QixRQUFJQyxLQUFLLHdCQUFTUSxTQUFULFlBQW1CTixLQUFuQixDQUFUOztBQUVBLFFBQUlPLE1BQUosRUFBWTtBQUNWLFVBQUlWLElBQUksS0FBSyxTQUFiLEVBQXdCO0FBQ3RCLFlBQUksS0FBS0MsS0FBTCxDQUFXSyxNQUFYLEdBQW9CLENBQXhCLEVBQTJCO0FBQ3pCSSxVQUFBQSxNQUFNLENBQUNILElBQVAsQ0FBWUMsTUFBWixHQUFxQixLQUFLUCxLQUFMLENBQVcsQ0FBWCxFQUFjTSxJQUFkLENBQW1CQyxNQUF4QztBQUNELFNBRkQsTUFFTztBQUNMLGlCQUFPRSxNQUFNLENBQUNILElBQVAsQ0FBWUMsTUFBbkI7QUFDRDtBQUNGLE9BTkQsTUFNTyxJQUFJLEtBQUtHLEtBQUwsS0FBZUQsTUFBbkIsRUFBMkI7QUFDaEMsNkJBQWlCVCxLQUFqQixrSEFBd0I7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBLGNBQWZXLElBQWU7QUFDdEJBLFVBQUFBLElBQUksQ0FBQ0wsSUFBTCxDQUFVQyxNQUFWLEdBQW1CRSxNQUFNLENBQUNILElBQVAsQ0FBWUMsTUFBL0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBT1AsS0FBUDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztTQWFBWSxRLEdBQUEsa0JBQVVDLElBQVYsRUFBc0I7QUFBQSxRQUFaQSxJQUFZO0FBQVpBLE1BQUFBLElBQVksR0FBTCxFQUFLO0FBQUE7O0FBQ3BCLFFBQUlDLFVBQVUsR0FBR0MsT0FBTyxDQUFDLGVBQUQsQ0FBeEI7O0FBQ0EsUUFBSUMsU0FBUyxHQUFHRCxPQUFPLENBQUMsYUFBRCxDQUF2Qjs7QUFFQSxRQUFJRSxJQUFJLEdBQUcsSUFBSUgsVUFBSixDQUFlLElBQUlFLFNBQUosRUFBZixFQUFnQyxJQUFoQyxFQUFzQ0gsSUFBdEMsQ0FBWDtBQUNBLFdBQU9JLElBQUksQ0FBQ0MsU0FBTCxFQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMURpQkMsa0I7O2VBMkVKdEIsSSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9jb250YWluZXInXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIENTUyBmaWxlIGFuZCBjb250YWlucyBhbGwgaXRzIHBhcnNlZCBub2Rlcy5cbiAqXG4gKiBAZXh0ZW5kcyBDb250YWluZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2F7Y29sb3I6YmxhY2t9IGJ7ei1pbmRleDoyfScpXG4gKiByb290LnR5cGUgICAgICAgICAvLz0+ICdyb290J1xuICogcm9vdC5ub2Rlcy5sZW5ndGggLy89PiAyXG4gKi9cbmNsYXNzIFJvb3QgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3RvciAoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cylcbiAgICB0aGlzLnR5cGUgPSAncm9vdCdcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXVxuICB9XG5cbiAgcmVtb3ZlQ2hpbGQgKGNoaWxkLCBpZ25vcmUpIHtcbiAgICBsZXQgaW5kZXggPSB0aGlzLmluZGV4KGNoaWxkKVxuXG4gICAgaWYgKCFpZ25vcmUgJiYgaW5kZXggPT09IDAgJiYgdGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1tpbmRleF0ucmF3cy5iZWZvcmVcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlQ2hpbGQoY2hpbGQpXG4gIH1cblxuICBub3JtYWxpemUgKGNoaWxkLCBzYW1wbGUsIHR5cGUpIHtcbiAgICBsZXQgbm9kZXMgPSBzdXBlci5ub3JtYWxpemUoY2hpbGQpXG5cbiAgICBpZiAoc2FtcGxlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ3ByZXBlbmQnKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzYW1wbGUucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHNhbXBsZS5yYXdzLmJlZm9yZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3QgIT09IHNhbXBsZSkge1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgbm9kZS5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHtAbGluayBSZXN1bHR9IGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGUgcm9vdOKAmXMgQ1NTLlxuICAgKlxuICAgKiBAcGFyYW0ge3Byb2Nlc3NPcHRpb25zfSBbb3B0c10gT3B0aW9ucyB3aXRoIG9ubHkgYHRvYCBhbmQgYG1hcGAga2V5cy5cbiAgICpcbiAgICogQHJldHVybiB7UmVzdWx0fSBSZXN1bHQgd2l0aCBjdXJyZW50IHJvb3TigJlzIENTUy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdDEgPSBwb3N0Y3NzLnBhcnNlKGNzczEsIHsgZnJvbTogJ2EuY3NzJyB9KVxuICAgKiBjb25zdCByb290MiA9IHBvc3Rjc3MucGFyc2UoY3NzMiwgeyBmcm9tOiAnYi5jc3MnIH0pXG4gICAqIHJvb3QxLmFwcGVuZChyb290MilcbiAgICogY29uc3QgcmVzdWx0ID0gcm9vdDEudG9SZXN1bHQoeyB0bzogJ2FsbC5jc3MnLCBtYXA6IHRydWUgfSlcbiAgICovXG4gIHRvUmVzdWx0IChvcHRzID0geyB9KSB7XG4gICAgbGV0IExhenlSZXN1bHQgPSByZXF1aXJlKCcuL2xhenktcmVzdWx0JylcbiAgICBsZXQgUHJvY2Vzc29yID0gcmVxdWlyZSgnLi9wcm9jZXNzb3InKVxuXG4gICAgbGV0IGxhenkgPSBuZXcgTGF6eVJlc3VsdChuZXcgUHJvY2Vzc29yKCksIHRoaXMsIG9wdHMpXG4gICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KClcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgUm9vdCNcbiAgICogQG1lbWJlciB7b2JqZWN0fSByYXdzIEluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGJ5dGUtdG8tYnl0ZSBlcXVhbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgbm9kZSBzdHJpbmcgYXMgaXQgd2FzIGluIHRoZSBvcmlnaW4gaW5wdXQuXG4gICAqXG4gICAqIEV2ZXJ5IHBhcnNlciBzYXZlcyBpdHMgb3duIHByb3BlcnRpZXMsXG4gICAqIGJ1dCB0aGUgZGVmYXVsdCBDU1MgcGFyc2VyIHVzZXM6XG4gICAqXG4gICAqICogYGFmdGVyYDogdGhlIHNwYWNlIHN5bWJvbHMgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQgdG8gdGhlIGVuZCBvZiBmaWxlLlxuICAgKiAqIGBzZW1pY29sb25gOiBpcyB0aGUgbGFzdCBjaGlsZCBoYXMgYW4gKG9wdGlvbmFsKSBzZW1pY29sb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHBvc3Rjc3MucGFyc2UoJ2Ege31cXG4nKS5yYXdzIC8vPT4geyBhZnRlcjogJ1xcbicgfVxuICAgKiBwb3N0Y3NzLnBhcnNlKCdhIHt9JykucmF3cyAgIC8vPT4geyBhZnRlcjogJycgfVxuICAgKi9cbn1cblxuZXhwb3J0IGRlZmF1bHQgUm9vdFxuIl0sImZpbGUiOiJyb290LmpzIn0=


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var constants = __webpack_require__(25);
var PUNCTUATION = constants.PUNCTUATION;
var STOP_URL_RAW = constants.STOP_URL_RAW;
var TYPE = constants.TYPE;
var FULLSTOP = TYPE.FullStop;
var PLUSSIGN = TYPE.PlusSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var PUNCTUATOR = TYPE.Punctuator;
var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;
var BACK_SLASH = 92;
var E = 101; // 'e'.charCodeAt(0)

function firstCharOffset(source) {
    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
    if (source.charCodeAt(0) === 0xFEFF ||  // UTF-16BE
        source.charCodeAt(0) === 0xFFFE) {  // UTF-16LE
        return 1;
    }

    return 0;
}

function isHex(code) {
    return (code >= 48 && code <= 57) || // 0 .. 9
           (code >= 65 && code <= 70) || // A .. F
           (code >= 97 && code <= 102);  // a .. f
}

function isNumber(code) {
    return code >= 48 && code <= 57;
}

function isWhiteSpace(code) {
    return code === SPACE || code === TAB || isNewline(code);
}

function isNewline(code) {
    return code === R || code === N || code === F;
}

function getNewlineLength(source, offset, code) {
    if (isNewline(code)) {
        if (code === R && offset + 1 < source.length && source.charCodeAt(offset + 1) === N) {
            return 2;
        }

        return 1;
    }

    return 0;
}

function cmpChar(testStr, offset, referenceCode) {
    var code = testStr.charCodeAt(offset);

    // code.toLowerCase() for A..Z
    if (code >= 65 && code <= 90) {
        code = code | 32;
    }

    return code === referenceCode;
}

function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start < 0 || end > testStr.length) {
        return false;
    }

    for (var i = start; i < end; i++) {
        var testCode = testStr.charCodeAt(i);
        var refCode = referenceStr.charCodeAt(i - start);

        // testCode.toLowerCase() for A..Z
        if (testCode >= 65 && testCode <= 90) {
            testCode = testCode | 32;
        }

        if (testCode !== refCode) {
            return false;
        }
    }

    return true;
}

function findWhiteSpaceStart(source, offset) {
    while (offset >= 0 && isWhiteSpace(source.charCodeAt(offset))) {
        offset--;
    }

    return offset + 1;
}

function findWhiteSpaceEnd(source, offset) {
    while (offset < source.length && isWhiteSpace(source.charCodeAt(offset))) {
        offset++;
    }

    return offset;
}

function findCommentEnd(source, offset) {
    var commentEnd = source.indexOf('*/', offset);

    if (commentEnd === -1) {
        return source.length;
    }

    return commentEnd + 2;
}

function findStringEnd(source, offset, quote) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // TODO: bad string
        if (code === BACK_SLASH) {
            offset++;
        } else if (code === quote) {
            offset++;
            break;
        }
    }

    return offset;
}

function findDecimalNumberEnd(source, offset) {
    while (offset < source.length && isNumber(source.charCodeAt(offset))) {
        offset++;
    }

    return offset;
}

function findNumberEnd(source, offset, allowFraction) {
    var code;

    offset = findDecimalNumberEnd(source, offset);

    // fraction: .\d+
    if (allowFraction && offset + 1 < source.length && source.charCodeAt(offset) === FULLSTOP) {
        code = source.charCodeAt(offset + 1);

        if (isNumber(code)) {
            offset = findDecimalNumberEnd(source, offset + 1);
        }
    }

    // exponent: e[+-]\d+
    if (offset + 1 < source.length) {
        if ((source.charCodeAt(offset) | 32) === E) { // case insensitive check for `e`
            code = source.charCodeAt(offset + 1);

            if (code === PLUSSIGN || code === HYPHENMINUS) {
                if (offset + 2 < source.length) {
                    code = source.charCodeAt(offset + 2);
                }
            }

            if (isNumber(code)) {
                offset = findDecimalNumberEnd(source, offset + 2);
            }
        }
    }

    return offset;
}

// skip escaped unicode sequence that can ends with space
// [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
function findEscapeEnd(source, offset) {
    for (var i = 0; i < 7 && offset + i < source.length; i++) {
        var code = source.charCodeAt(offset + i);

        if (i !== 6 && isHex(code)) {
            continue;
        }

        if (i > 0) {
            offset += i - 1 + getNewlineLength(source, offset + i, code);
            if (code === SPACE || code === TAB) {
                offset++;
            }
        }

        break;
    }

    return offset;
}

function findIdentifierEnd(source, offset) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code === BACK_SLASH) {
            offset = findEscapeEnd(source, offset + 1);
        } else if (code < 0x80 && PUNCTUATION[code] === PUNCTUATOR) {
            break;
        }
    }

    return offset;
}

function findUrlRawEnd(source, offset) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code === BACK_SLASH) {
            offset = findEscapeEnd(source, offset + 1);
        } else if (code < 0x80 && STOP_URL_RAW[code] === 1) {
            break;
        }
    }

    return offset;
}

module.exports = {
    firstCharOffset: firstCharOffset,

    isHex: isHex,
    isNumber: isNumber,
    isWhiteSpace: isWhiteSpace,
    isNewline: isNewline,
    getNewlineLength: getNewlineLength,

    cmpChar: cmpChar,
    cmpStr: cmpStr,

    findWhiteSpaceStart: findWhiteSpaceStart,
    findWhiteSpaceEnd: findWhiteSpaceEnd,
    findCommentEnd: findCommentEnd,
    findStringEnd: findStringEnd,
    findDecimalNumberEnd: findDecimalNumberEnd,
    findNumberEnd: findNumberEnd,
    findEscapeEnd: findEscapeEnd,
    findIdentifierEnd: findIdentifierEnd,
    findUrlRawEnd: findUrlRawEnd
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createCustomError = __webpack_require__(24);
var generateGrammar = __webpack_require__(26);

function fromMatchResult(matchResult) {
    var tokens = matchResult.tokens;
    var longestMatch = matchResult.longestMatch;
    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
    var mismatchOffset = 0;
    var entries = 0;
    var css = '';

    for (var i = 0; i < tokens.length; i++) {
        if (i === longestMatch) {
            mismatchOffset = css.length;
        }

        if (node !== null && tokens[i].node === node) {
            if (i <= longestMatch) {
                entries++;
            } else {
                entries = 0;
            }
        }

        css += tokens[i].value;
    }

    if (node === null) {
        mismatchOffset = css.length;
    }

    return {
        node: node,
        css: css,
        mismatchOffset: mismatchOffset,
        last: node === null || entries > 1
    };
}

function getLocation(node, point) {
    var loc = node && node.loc && node.loc[point];

    if (loc) {
        return {
            offset: loc.offset,
            line: loc.line,
            column: loc.column
        };
    }

    return null;
}

var SyntaxReferenceError = function(type, referenceName) {
    var error = createCustomError(
        'SyntaxReferenceError',
        type + (referenceName ? ' `' + referenceName + '`' : '')
    );

    error.reference = referenceName;

    return error;
};

var MatchError = function(message, lexer, syntax, node, matchResult) {
    var error = createCustomError('SyntaxMatchError', message);
    var details = fromMatchResult(matchResult);
    var mismatchOffset = details.mismatchOffset || 0;
    var badNode = details.node || node;
    var end = getLocation(badNode, 'end');
    var start = details.last ? end : getLocation(badNode, 'start');
    var css = details.css;

    error.rawMessage = message;
    error.syntax = syntax ? generateGrammar(syntax) : '<generic>';
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.loc = {
        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
        start: start,
        end: end
    };
    error.line = start ? start.line : undefined;
    error.column = start ? start.column : undefined;
    error.offset = start ? start.offset : undefined;
    error.message = message + '\n' +
        '  syntax: ' + error.syntax + '\n' +
        '   value: ' + (error.css || '<empty string>') + '\n' +
        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

    return error;
};

module.exports = {
    SyntaxReferenceError: SyntaxReferenceError,
    MatchError: MatchError
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var createCustomError = __webpack_require__(24);

var SyntaxParseError = function(message, input, offset) {
    var error = createCustomError('SyntaxParseError', message);

    error.input = input;
    error.offset = offset;
    error.rawMessage = message;
    error.message = error.rawMessage + '\n' +
        '  ' + error.input + '\n' +
        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

    return error;
};

module.exports = {
    SyntaxParseError: SyntaxParseError
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

module.exports = function(node, options, context) {
    function walk(node) {
        enter.call(context, node);

        switch (node.type) {
            case 'Group':
                node.terms.forEach(walk);
                break;

            case 'Multiplier':
                walk(node.term);
                break;

            case 'Type':
            case 'Property':
            case 'Keyword':
            case 'AtKeyword':
            case 'Function':
            case 'String':
            case 'Token':
            case 'Comma':
                break;

            default:
                throw new Error('Unknown type: ' + node.type);
        }

        leave.call(context, node);
    }

    var enter = noop;
    var leave = noop;

    if (typeof options === 'function') {
        enter = options;
    } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
    }

    if (enter === noop && leave === noop) {
        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    }

    walk(node, context);
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(28);

var MATCH = { type: 'Match' };
var MISMATCH = { type: 'Mismatch' };
var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
var LEFTPARENTHESIS = 40;  // (
var RIGHTPARENTHESIS = 41; // )

function createCondition(match, thenBranch, elseBranch) {
    // reduce node count
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
        return match;
    }

    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
        return match;
    }

    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
        thenBranch = match.then;
        match = match.match;
    }

    return {
        type: 'If',
        match: match,
        then: thenBranch,
        else: elseBranch
    };
}

function isFunctionType(name) {
    return (
        name.length > 2 &&
        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&
        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS
    );
}

function isEnumCapatible(term) {
    return (
        term.type === 'Keyword' ||
        term.type === 'AtKeyword' ||
        term.type === 'Function' ||
        term.type === 'Type' && isFunctionType(term.name)
    );
}

function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
        case ' ':
            // Juxtaposing components means that all of them must occur, in the given order.
            //
            // a b c
            // =
            // match a
            //   then match b
            //     then match c
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            //   else MISMATCH
            var result = MATCH;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];

                result = createCondition(
                    term,
                    result,
                    MISMATCH
                );
            };

            return result;

        case '|':
            // A bar (|) separates two or more alternatives: exactly one of them must occur.
            //
            // a | b | c
            // =
            // match a
            //   then MATCH
            //   else match b
            //     then MATCH
            //     else match c
            //       then MATCH
            //       else MISMATCH

            var result = MISMATCH;
            var map = null;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];

                // reduce sequence of keywords into a Enum
                if (isEnumCapatible(term)) {
                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                        map = Object.create(null);
                        result = createCondition(
                            {
                                type: 'Enum',
                                map: map
                            },
                            MATCH,
                            result
                        );
                    }

                    if (map !== null) {
                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                        if (key in map === false) {
                            map[key] = term;
                            continue;
                        }
                    }
                }

                map = null;

                // create a new conditonal node
                result = createCondition(
                    term,
                    MATCH,
                    result
                );
            };

            return result;

        case '&&':
            // A double ampersand (&&) separates two or more components,
            // all of which must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since &&-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms: terms,
                    all: true
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a && b && c
            // =
            // match a
            //   then [b && c]
            //   else match b
            //     then [a && c]
            //     else match c
            //       then [a && b]
            //       else MISMATCH
            //
            // a && b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MISMATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            var result = MISMATCH;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];
                var thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        false
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            };

            return result;

        case '||':
            // A double bar (||) separates two or more options:
            // one or more of them must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since ||-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms: terms,
                    all: false
                };;
            }

            // Use a combination tree for groups with small number of terms
            //
            // a || b || c
            // =
            // match a
            //   then [b || c]
            //   else match b
            //     then [a || c]
            //     else match c
            //       then [a || b]
            //       else MISMATCH
            //
            // a || b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MATCH
            //     else MISMATCH
            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

            for (var i = terms.length - 1; i >= 0; i--) {
                var term = terms[i];
                var thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        true
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            };

            return result;
    }
}

function buildMultiplierMatchGraph(node) {
    var result = MATCH;
    var matchTerm = buildMatchGraph(node.term);

    if (node.max === 0) {
        // disable repeating of empty match to prevent infinite loop
        matchTerm = createCondition(
            matchTerm,
            DISALLOW_EMPTY,
            MISMATCH
        );

        // an occurrence count is not limited, make a cycle;
        // to collect more terms on each following matching mismatch
        result = createCondition(
            matchTerm,
            null, // will be a loop
            MISMATCH
        );

        result.then = createCondition(
            MATCH,
            MATCH,
            result // make a loop
        );

        if (node.comma) {
            result.then.else = createCondition(
                { type: 'Comma', syntax: node },
                result,
                MISMATCH
            );
        }
    } else {
        // create a match node chain for [min .. max] interval with optional matches
        for (var i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                createCondition(
                    MATCH,
                    MATCH,
                    result
                ),
                MISMATCH
            );
        }
    }

    if (node.min === 0) {
        // allow zero match
        result = createCondition(
            MATCH,
            MATCH,
            result
        );
    } else {
        // create a match node chain to collect [0 ... min - 1] required matches
        for (var i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                result,
                MISMATCH
            );
        }
    }

    return result;
}

function buildMatchGraph(node) {
    if (typeof node === 'function') {
        return {
            type: 'Generic',
            fn: node
        };
    }

    switch (node.type) {
        case 'Group':
            var result = buildGroupMatchGraph(
                node.combinator,
                node.terms.map(buildMatchGraph),
                false
            );

            if (node.disallowEmpty) {
                result = createCondition(
                    result,
                    DISALLOW_EMPTY,
                    MISMATCH
                );
            }

            return result;

        case 'Multiplier':
            return buildMultiplierMatchGraph(node);

        case 'Type':
        case 'Property':
            return {
                type: node.type,
                name: node.name,
                syntax: node
            };

        case 'Keyword':
            return {
                type: node.type,
                name: node.name.toLowerCase(),
                syntax: node
            };

        case 'AtKeyword':
            return {
                type: node.type,
                name: '@' + node.name.toLowerCase(),
                syntax: node
            };

        case 'Function':
            return {
                type: node.type,
                name: node.name.toLowerCase() + '(',
                syntax: node
            };

        case 'String':
            // convert a one char length String to a Token
            if (node.value.length === 3) {
                return {
                    type: 'Token',
                    value: node.value.charAt(1),
                    syntax: node
                };
            }

            // otherwise use it as is
            return {
                type: node.type,
                value: node.value,
                syntax: node
            };

        case 'Token':
            return {
                type: node.type,
                value: node.value,
                syntax: node
            };

        case 'Comma':
            return {
                type: node.type,
                syntax: node
            };

        default:
            throw new Error('Unknown node type:', node.type);
    }
}

module.exports = {
    MATCH: MATCH,
    MISMATCH: MISMATCH,
    DISALLOW_EMPTY: DISALLOW_EMPTY,
    buildMatchGraph: function(syntaxTree, ref) {
        if (typeof syntaxTree === 'string') {
            syntaxTree = parse(syntaxTree);
        }

        return {
            type: 'MatchGraph',
            match: buildMatchGraph(syntaxTree),
            syntax: ref || null,
            source: syntaxTree
        };
    }
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(51);
var util = __webpack_require__(9);
var ArraySet = __webpack_require__(52).ArraySet;
var MappingList = __webpack_require__(117).MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(116);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(9);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var cmpChar = __webpack_require__(0).cmpChar;
var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var STRING = TYPE.String;
var NUMBER = TYPE.Number;
var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var NUMBERSIGN = TYPE.NumberSign;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var PLUSSIGN = TYPE.PlusSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var COMMA = TYPE.Comma;
var SOLIDUS = TYPE.Solidus;
var ASTERISK = TYPE.Asterisk;
var PERCENTSIGN = TYPE.PercentSign;
var BACKSLASH = TYPE.Backslash;
var U = 117; // 'u'.charCodeAt(0)

module.exports = function defaultRecognizer(context) {
    switch (this.scanner.tokenType) {
        case NUMBERSIGN:
            return this.HexColor();

        case COMMA:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Operator();

        case SOLIDUS:
        case ASTERISK:
        case PLUSSIGN:
        case HYPHENMINUS:
            return this.Operator();

        case LEFTPARENTHESIS:
            return this.Parentheses(this.readSequence, context.recognizer);

        case LEFTSQUAREBRACKET:
            return this.Brackets(this.readSequence, context.recognizer);

        case STRING:
            return this.String();

        case NUMBER:
            switch (this.scanner.lookupType(1)) {
                case PERCENTSIGN:
                    return this.Percentage();

                case IDENTIFIER:
                    // edge case: number with folowing \0 and \9 hack shouldn't to be a Dimension
                    if (cmpChar(this.scanner.source, this.scanner.tokenEnd, BACKSLASH)) {
                        return this.Number();
                    } else {
                        return this.Dimension();
                    }

                default:
                    return this.Number();
            }

        case FUNCTION:
            return this.Function(this.readSequence, context.recognizer);

        case URL:
            return this.Url();

        case IDENTIFIER:
            // check for unicode range, it should start with u+ or U+
            if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) &&
                cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
                return this.UnicodeRange();
            } else {
                return this.Identifier();
            }
    }
};


/***/ }),
/* 54 */
/***/ (function(module, exports) {

// https://drafts.csswg.org/css-images-4/#element-notation
// https://developer.mozilla.org/en-US/docs/Web/CSS/element
module.exports = function() {
    this.scanner.skipSC();

    var children = this.createSingleNodeList(
        this.IdSelector()
    );

    this.scanner.skipSC();

    return children;
};


/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = {
    parse: function selectorList() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};


/***/ }),
/* 56 */
/***/ (function(module, exports) {

var ALLOW_OF_CLAUSE = true;

module.exports = {
    parse: function nthWithOfClause() {
        return this.createSingleNodeList(
            this.Nth(ALLOW_OF_CLAUSE)
        );
    }
};


/***/ }),
/* 57 */
/***/ (function(module, exports) {

var DISALLOW_OF_CLAUSE = false;

module.exports = {
    parse: function nth() {
        return this.createSingleNodeList(
            this.Nth(DISALLOW_OF_CLAUSE)
        );
    }
};


/***/ }),
/* 58 */
/***/ (function(module, exports) {

function removeItemAndRedundantWhiteSpace(list, item) {
    var prev = item.prev;
    var next = item.next;

    if (next !== null) {
        if (next.data.type === 'WhiteSpace' && (prev === null || prev.data.type === 'WhiteSpace')) {
            list.remove(next);
        }
    } else if (prev !== null && prev.data.type === 'WhiteSpace') {
        list.remove(prev);
    }

    list.remove(item);
}

module.exports = function compressBorder(node) {
    node.children.each(function(node, item, list) {
        if (node.type === 'Identifier' && node.name.toLowerCase() === 'none') {
            if (list.head === list.tail) {
                // replace `none` for zero when `none` is a single term
                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: '0'
                };
            } else {
                removeItemAndRedundantWhiteSpace(list, item);
            }
        }
    });
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(60)


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/* global Event */
const path = __webpack_require__(3)
const jComponent = __webpack_require__(32)

const _ = __webpack_require__(10)
const wxss = __webpack_require__(72)
const compile = __webpack_require__(228)
const injectPolyfill = __webpack_require__(229)
const injectDefinition = __webpack_require__(230)

const componentMap = {}
let nowLoad = null

/**
 * 自定义组件构造器
 */
global.Component = options => {
    const component = nowLoad
    const pathToIdMap = component.pathToIdMap
    const definition = Object.assign({
        id: component.id,
        path: component.path,
        template: component.wxml,
        usingComponents: component.json.usingComponents,
        tagName: component.tagName,
    }, options)
    definition.options = Object.assign({
        classPrefix: component.tagName,
    }, definition.options || {})

    // 处理 relations
    if (definition.relations) {
        Object.keys(definition.relations).forEach(key => {
            const value = definition.relations[key]
            const componentPath = _.isAbsolute(key) ? key : path.join(path.dirname(component.path), key)
            const id = pathToIdMap[componentPath]
            if (id) {
                // 将涉及到的自定义组件路径转成 id
                value.target = id
                definition.relations[id] = value
                delete definition.relations[key]
            }
        })
    }

    jComponent.register(definition)
}

/**
 * behavior 构造器
 */
global.Behavior = definition => jComponent.behavior(definition)

/**
 * 加载 behavior
 */
function behavior(definition) {
    if (typeof definition !== 'object') {
        throw new Error('definition must be a object')
    }

    return jComponent.behavior(definition)
}

/* eslint-disable complexity */
/**
 * 注册自定义组件
 */
function register(componentPath, tagName, cache, hasRegisterCache) {
    // 用于 wcc 编译器使用
    window.__webview_engine_version__ = 0.02

    if (typeof componentPath === 'object') {
        // 直接传入定义对象
        const definition = componentPath

        return jComponent.register(definition)
    }

    if (typeof componentPath !== 'string') {
        throw new Error('componentPath must be a string')
    }

    if (!tagName || typeof tagName !== 'string') {
        tagName = 'main' // 默认标签名
    }

    const id = _.getId()

    if (hasRegisterCache[componentPath]) return hasRegisterCache[componentPath]
    hasRegisterCache[componentPath] = id

    const component = {
        id,
        path: componentPath,
        tagName,
        json: _.readJson(`${componentPath}.json`),
    }

    if (!component.json) {
        throw new Error(`invalid componentPath: ${componentPath}`)
    }

    // 先加载 using components
    const rootPath = cache.options.rootPath
    const usingComponents = component.json.usingComponents || {}
    const overrideUsingComponents = cache.options.usingComponents || {}
    const usingComponentKeys = Object.keys(usingComponents)
    for (let i = 0, len = usingComponentKeys.length; i < len; i++) {
        const key = usingComponentKeys[i]

        if (Object.prototype.hasOwnProperty.call(overrideUsingComponents, key)) continue // 被 override 的跳过

        const value = usingComponents[key]
        const usingPath = _.isAbsolute(value) ? path.join(rootPath, value) : path.join(path.dirname(componentPath), value)
        const id = register(usingPath, key, cache, hasRegisterCache)

        usingComponents[key] = id
    }
    Object.assign(usingComponents, overrideUsingComponents)

    // 读取自定义组件的静态内容
    component.wxml = compile.getWxml(componentPath, cache.options)
    component.wxss = wxss.getContent(`${componentPath}.wxss`)

    // 存入需要执行的自定义组件 js
    cache.needRunJsList.push([componentPath, component])

    // 保存追加了已编译的 wxss
    cache.wxss.push(wxss.compile(component.wxss, {
        prefix: tagName,
        ...cache.options,
    }))

    return component.id
}

/**
 * 加载自定义组件
 */
function load(componentPath, tagName, options = {}) {
    if (typeof tagName === 'object') {
        options = tagName
        tagName = ''
    }

    if (typeof componentPath === 'string') {
        options = Object.assign({
            compiler: 'official', // official - 官方编译器、simulate - 纯 js 实现的模拟编译器
            rootPath: path.dirname(componentPath), // 项目根路径
        }, options)
    } else {
        options = Object.assign({
            compiler: 'simulate',
            rootPath: '',
        }, options)
    }

    const cache = {
        wxss: [],
        options,
        needRunJsList: [],
    }
    const hasRegisterCache = {}
    const id = register(componentPath, tagName, cache, hasRegisterCache)

    // 执行自定义组件 js
    cache.needRunJsList.forEach(item => {
        const oldLoad = nowLoad

        nowLoad = item[1] // nowLoad 用于执行用户代码调用 Component 构造器时注入额外的参数给 j-component
        nowLoad.pathToIdMap = hasRegisterCache
        _.runJs(item[0])

        nowLoad = oldLoad
    })

    // 存入缓存
    componentMap[id] = cache

    return id
}

/**
 * 渲染自定义组件
 */
function render(id, properties) {
    if (!id) throw new Error('you need to pass the componentId')

    const cache = componentMap[id]

    if (cache) {
        // 注入 wxss
        wxss.insert(cache.wxss, id)
    }

    return jComponent.create(id, properties)
}

/**
 * 比较 dom 节点是否符合某个 html 结构
 */
function match(dom, html) {
    if (!(dom instanceof window.Element) || !html || typeof html !== 'string') return false

    // 干掉一些换行符，以免生成不必要的 TextNode
    html = html.trim()
        .replace(/(>)[\n\r\s\t]+(<)/g, '$1$2')

    const a = dom.cloneNode()
    const b = dom.cloneNode()

    a.innerHTML = dom.innerHTML
    b.innerHTML = html

    return a.isEqualNode(b)
}

/**
 * 让线程等待一段时间再执行
 */
function sleep(time = 0) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve()
        }, time)
    })
}

/**
 * 模拟滚动
 */
function scroll(comp, destOffset = 0, times = 20, propName = 'scrollTop') {
    if (!comp || !comp.dom) throw new Error('invalid params')
    if (typeof times !== 'number' || times <= 0) times = 1

    destOffset = destOffset < 0 ? 0 : destOffset

    const dom = comp.dom
    const delta = destOffset - dom[propName]
    // eslint-disable-next-line no-bitwise
    const unit = ~~(delta / times)
    const env = _.getEnv()

    if (env === 'nodejs') {
        for (let i = 0; i < times; i++) {
            // nodejs 环境
            setTimeout(() => {
                if (i === times - 1) dom[propName] = destOffset
                else dom[propName] += unit

                // 模拟异步触发
                dom.dispatchEvent(new Event('scroll', {bubbles: true, cancelable: false}))
            }, 0)
        }
    } else {
        // 浏览器
        dom[propName] = destOffset
    }
}


injectPolyfill()
injectDefinition()

module.exports = {
    behavior,
    load,
    render,
    match,
    sleep,
    scroll,
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const exparser = __webpack_require__(4)
const ComponentManager = __webpack_require__(62)
const RootComponent = __webpack_require__(70)
const _ = __webpack_require__(5)

module.exports = {
  /**
   * 注册组件
   */
  register(definition = {}) {
    const componentManager = new ComponentManager(definition)

    return componentManager.id
  },

  /**
   * 注册 behavior
   */
  behavior(definition) {
    definition.is = _.getId(true)
    definition.options = {
      lazyRegistration: true,
      publicProperties: true,
    }

    _.adjustExparserDefinition(definition)
    exparser.registerBehavior(definition)

    return definition.is
  },

  /**
   * 创建组件实例
   */
  create(id, properties) {
    const componentManager = _.cache(id)

    if (!componentManager) return

    return new RootComponent(componentManager, properties)
  },
}

global.wxFormField = module.exports.behavior({
  id: 'wx://form-field',
  properties: {
    name: {
      type: String
    },
    value: {
      type: null
    }
  }
})

global.wxFormFieldButton = module.exports.behavior({
  is: 'wx://form-field-button',
  listeners: {
    formSubmit(data) {
      this.triggerEvent('formSubmit', data, {bubbles: true})
    },
    formReset(data) {
      this.triggerEvent('formReset', data, {bubbles: true})
    },
  }
})

global.wxComponentExport = module.exports.behavior({
  is: 'wx://component-export',
  definitionFilter(def) {
    if (typeof def.export === 'function') {
      if (typeof def.methods === 'object') {
        def.methods.__export__ = def.export
      } else {
        def.methods = {
          __export__: def.export,
        }
      }
    }
  }
})

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const exparser = __webpack_require__(4)
const compile = __webpack_require__(63)
const transform = __webpack_require__(67)
const diff = __webpack_require__(68)
const render = __webpack_require__(13)
const _ = __webpack_require__(5)
const SelectorQuery = __webpack_require__(69)
const IntersectionObserver = __webpack_require__(34)

const PATH_TO_ID_MAP = []

class ComponentManager {
  constructor(definition) {
    this.id = definition.id || _.getId(true)
    this.path = _.normalizeAbsolute(definition.path)
    this.definition = definition

    if (definition.tagName) _.setTagName(this.id, definition.tagName) // 保存标签名
    if (this.path) PATH_TO_ID_MAP[this.path] = this.id // 保存 path 到 id 的映射

    const template = definition.template

    this.data = {}
    this.generateFunc = typeof template === 'function' ? transform(template, definition.usingComponents || {}) : compile(template, this.data, definition.usingComponents || {}) // 解析编译模板
    this.exparserDef = this.registerToExparser()

    _.cache(this.id, this)
  }

  /**
   * 注册 exparser 组件
   */
  registerToExparser() {
    const definition = this.definition
    const options = definition.options || {}
    const usingComponents = definition.usingComponents || {}
    const using = Object.keys(usingComponents).map(key => usingComponents[key])
    let methods = {}

    definition.behaviors = definition.behaviors || []
    definition.behaviors = definition.behaviors.map((item) => {
      // 支持内置 behavior
      if (item === 'wx://component-export') {
        return global.wxComponentExport
      }
      if (item === 'wx://form-field') {
        return global.wxFormField
      }
      if (item === 'wx://form-field-button') {
        return global.wxFormFieldButton
      }

      return item
    })

    _.adjustExparserDefinition(definition)

    const path = this.path
    const definitionFilter = exparser.Behavior.callDefinitionFilter(definition)
    const exparserDef = {
      is: this.id,
      using,
      generics: [], // TODO
      template: {
        func: this.generateFunc,
        data: this.data,
      },
      properties: definition.properties,
      data: definition.data,
      methods: definition.methods,
      behaviors: definition.behaviors,
      created: definition.created,
      attached: definition.attached,
      ready: definition.ready,
      moved: definition.moved,
      detached: definition.detached,
      saved: definition.saved,
      restored: definition.restored,
      relations: definition.relations,
      externalClasses: definition.externalClasses,
      options: {
        domain: `${options.writeOnly ? 'wo://' : ''}/`,
        writeOnly: options.writeOnly || false,
        allowInWriteOnly: false,
        lazyRegistration: true,
        classPrefix: options.classPrefix || '',
        addGlobalClass: false,
        templateEngine: TemplateEngine,
        renderingMode: 'full',
        multipleSlots: options.multipleSlots || false,
        publicProperties: true,
        reflectToAttributes: false,
        writeFieldsToNode: false,
        writeIdToDOM: false,
        virtualHost: options.virtualHost || undefined,
      },
      lifetimes: definition.lifetimes,
      pageLifetimes: definition.pageLifetimes,
      observers: definition.observers,
      definitionFilter,
      initiator() {
        // 更新方法调用者，即自定义组件中的 this
        const caller = Object.create(this)
        const originalSetData = caller.setData
        const getSelectComponentResult = selected => {
          const selectedFilter = exparser.Component.getMethod(selected, '__export__')
          const defaultResult = exparser.Element.getMethodCaller(selected)
          if (selectedFilter) {
            const res = selectedFilter.call(exparser.Element.getMethodCaller(selected), caller)
            return res === undefined ? defaultResult : res
          }
          return defaultResult
        }

        caller._exparserNode = this // 存入原本对应的 exparserNode 实例
        caller.data = this.data
        caller.properties = caller.data
        caller.selectComponent = selector => {
          const exparserNode = this.shadowRoot.querySelector(selector)
          return getSelectComponentResult(exparserNode)
        }
        caller.selectAllComponents = selector => {
          const exparserNodes = this.shadowRoot.querySelectorAll(selector)
          return exparserNodes.map(item => getSelectComponentResult(item))
        }
        caller.createSelectorQuery = () => new SelectorQuery(caller)
        caller.createIntersectionObserver = options => new IntersectionObserver(caller, options)
        caller.setData = (data, callback) => {
          if (!originalSetData || typeof originalSetData !== 'function') return

          originalSetData.call(this, data)

          if (typeof callback === 'function') {
            // 模拟异步情况
            Promise.resolve().then(callback).catch(console.error)
          }
        }
        caller.getRelationNodes = relationKey => {
          if (!path || !relationKey) return null

          const id = PATH_TO_ID_MAP[_.relativeToAbsolute(path, relationKey)]
          if (!id) return null

          const res = this.getRelationNodes(id)
          if (!res) return null
          return res.map(exparserNode => exparser.Element.getMethodCaller(exparserNode))
        }

        Object.keys(methods).forEach(name => caller[name] = methods[name])
        exparser.Element.setMethodCaller(this, caller)
      },
    }

    const exparserReg = exparser.registerElement(exparserDef)
    exparser.Behavior.prepare(exparserReg.behavior)
    methods = exparserReg.behavior.methods

    return exparserReg
  }
}

/**
 * exparser 的模板引擎封装
 */
class TemplateEngine {
  static create(behavior, initValues) {
    const templateEngine = new TemplateEngine()
    const data = Object.assign({}, initValues, behavior.template.data)

    templateEngine._data = data
    templateEngine._generateFunc = behavior.template.func

    return templateEngine
  }

  static collectIdMapAndSlots(exparserNode, idMap, slots) {
    const children = exparserNode.childNodes

    for (const child of children) {
      if (child instanceof exparser.TextNode) continue
      if (child.__id) idMap[child.__id] = child
      if (child.__slotName !== undefined) slots[child.__slotName] = child

      TemplateEngine.collectIdMapAndSlots(child, idMap, slots)
    }
  }

  createInstance(exparserNode, properties = {}) {
    this._data = Object.assign(this._data, properties)
    this._vt = this._generateFunc({data: this._data}) // 生成虚拟树

    const instance = new TemplateEngineInstance()
    instance._generateFunc = this._generateFunc
    instance._vt = this._vt

    instance.data = _.copy(this._data)
    instance.idMap = {}
    instance.slots = {}
    instance.shadowRoot = render.renderExparserNode(instance._vt, exparserNode, null) // 渲染成 exparser 树
    instance.shadowRoot._vt = instance._vt
    instance.listeners = []

    TemplateEngine.collectIdMapAndSlots(instance.shadowRoot, instance.idMap, instance.slots)

    return instance
  }
}

/**
 * exparser 的模板引擎实例
 */
class TemplateEngineInstance {
  /**
   * 当遇到组件更新时，会触发此方法
   */
  updateValues(exparserNode, data, changedPaths, changedValues, changes) {
    const newVt = this._generateFunc({data}) // 生成新虚拟树

    // 合并到方法调用者的 data 中
    const callerData = exparser.Element.getMethodCaller(exparserNode).data
    const hasOwnProperty = Object.prototype.hasOwnProperty
    for (const changeInfo of changes) {
      if (!changeInfo) continue

      const path = changeInfo[0]
      const newData = changeInfo[1]
      let currentData = callerData
      let currentPath = path[0]

      // 检查更新路径
      for (let i = 1, len = path.length; i < len; i++) {
        const nextPath = path[i]
        const currentValue = currentData[currentPath]

        if (!hasOwnProperty.call(currentData, currentPath)) {
          // 不存在，则进行初始化
          if (typeof nextPath === 'number' && isFinite(nextPath)) {
            // 数组
            if (!Array.isArray(currentValue)) currentData[currentPath] = []
          } else if (currentValue === null || typeof currentValue !== 'object' || Array.isArray(currentValue)) {
            // 对象
            currentData[currentPath] = {}
          }
        }

        currentData = currentData[currentPath]
        currentPath = nextPath
      }

      const oldData = currentData[currentPath]
      currentData[currentPath] = _.copy(newData)
      changedValues = [currentData[currentPath], oldData]
    }

    // 应用更新
    diff.diffVt(this._vt, newVt)
    this._vt = newVt
  }
}

module.exports = ComponentManager

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

const parse = __webpack_require__(64)
const VirtualNode = __webpack_require__(65)
const expr = __webpack_require__(33)
const _ = __webpack_require__(5)
const CONSTANT = __webpack_require__(6)

/**
 * 过滤属性
 */
function filterAttrs(attrs) {
  const statement = {}
  const event = {}
  const normalAttrs = []

  for (const attr of attrs) {
    const name = attr.name
    const value = attr.value || ''

    if (name === 'wx:if') {
      statement.if = expr.getExpression(value)
    } else if (name === 'wx:elif') {
      statement.elif = expr.getExpression(value)
    } else if (name === 'wx:else') {
      statement.else = true
    } else if (name === 'wx:for') {
      statement.for = expr.getExpression(value)
    } else if (name === 'wx:for-item') {
      statement.forItem = value
    } else if (name === 'wx:for-index') {
      statement.forIndex = value
    } else if (name === 'wx:key') {
      statement.forKey = value
    } else {
      const eventObj = _.parseEvent(name, value)

      if (eventObj) {
        // 事件绑定
        event[eventObj.name] = eventObj
      } else {
        // 普通属性
        normalAttrs.push(attr)
      }
    }
  }

  return {
    statement,
    event,
    normalAttrs,
  }
}

module.exports = function (template, data, usingComponents) {
  if (!template || typeof template !== 'string' || !template.trim()) throw new Error('invalid template')
  template = template.trim()

  // 根节点
  const rootNode = new VirtualNode({
    type: CONSTANT.TYPE_ROOT,
    componentManager: this,
    data,
  })
  const stack = [rootNode]

  stack.last = function () {
    return this[this.length - 1]
  }

  parse(template, {
    start: (tagName, attrs, unary) => {
      let type
      let componentManager
      let id = ''

      if (tagName === 'slot') {
        type = CONSTANT.TYPE_SLOT
      } else if (tagName === 'template') {
        type = CONSTANT.TYPE_TEMPLATE
        tagName = 'virtual'
      } else if (tagName === 'block') {
        type = CONSTANT.TYPE_BLOCK
      } else if (tagName === 'import') {
        type = CONSTANT.TYPE_IMPORT
      } else if (tagName === 'include') {
        type = CONSTANT.TYPE_INCLUDE
      } else if (tagName === 'wxs') {
        type = CONSTANT.TYPE_WXS
      } else if (_.isHtmlTag(tagName)) {
        type = CONSTANT.TYPE_NATIVE
        id = tagName
      } else {
        type = CONSTANT.TYPE_COMPONENT
        id = usingComponents[tagName]
        componentManager = id ? _.cache(id) : _.cache(tagName)

        if (!componentManager) throw new Error(`component ${tagName} not found`)
        else id = componentManager.id
      }

      const {statement, event, normalAttrs} = filterAttrs(attrs)

      const parent = stack.last()
      const node = new VirtualNode({
        type,
        tagName,
        componentId: id,
        attrs: normalAttrs,
        event,
        generics: {}, // TODO
        componentManager,
        root: rootNode,
      })
      let appendNode = node

      // for 语句
      if (statement.for) {
        const itemNode = new VirtualNode({
          type: CONSTANT.TYPE_FORITEM,
          tagName: 'virtual',
          statement: {
            forItem: statement.forItem || 'item',
            forIndex: statement.forIndex || 'index',
            forKey: statement.forKey,
          },
          children: [node],
          root: rootNode,
        })
        node.setParent(itemNode, 0) // 更新父节点

        const forNode = new VirtualNode({
          type: CONSTANT.TYPE_FOR,
          tagName: 'wx:for',
          statement: {
            for: statement.for,
          },
          children: [itemNode],
          root: rootNode,
        })
        itemNode.setParent(forNode, 0) // 更新父节点

        appendNode = forNode
      }

      // 条件语句
      if (statement.if || statement.elif || statement.else) {
        const ifNode = new VirtualNode({
          type: CONSTANT.TYPE_IF,
          tagName: 'wx:if',
          statement: {
            if: statement.if,
            elif: statement.elif,
            else: statement.else,
          },
          children: [node],
          root: rootNode,
        })
        node.setParent(ifNode, 0) // 更新父节点

        appendNode = ifNode
      }

      if (!unary) {
        stack.push(node)
      }

      appendNode.setParent(parent, parent.children.length) // 更新父节点
      parent.appendChild(appendNode)
    },
    // eslint-disable-next-line no-unused-vars
    end: tagName => {
      stack.pop()
    },
    text: content => {
      content = content.trim()
      if (!content) return

      const parent = stack.last()
      if (parent.type === CONSTANT.TYPE_WXS) {
        // wxs 节点
        parent.setWxsContent(content)
      } else {
        // 文本节点
        parent.appendChild(new VirtualNode({
          type: CONSTANT.TYPE_TEXT,
          content: content.replace(/[\n\r\t\s]+/g, ' '),
          parent,
          index: parent.children.length,
          componentManager: this,
          root: rootNode,
        }))
      }
    },
  })

  if (stack.length !== 1) throw new Error(`build ast error: ${template}`)

  return rootNode.generate.bind(rootNode)
}


/***/ }),
/* 64 */
/***/ (function(module, exports) {

/**
 * 感谢 John Resig
 * 源码：https://johnresig.com/files/htmlparser.js
 */

const startTagReg = /^<([-A-Za-z0-9_]+)((?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/
const endTagReg = /^<\/([-A-Za-z0-9_]+)[^>]*>/
const attrReg = /([-A-Za-z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g

module.exports = function (content, handler = {}) {
  const stack = []
  let last = content

  stack.last = function () {
    return this[this.length - 1]
  }

  while (content) {
    let isText = true

    if (!stack.last() || stack.last() !== 'wxs') {
      if (content.indexOf('<!--') === 0) {
        // 注释
        const index = content.indexOf('-->')

        if (index >= 0) {
          content = content.substring(index + 3)
          isText = false
        }
      } else if (content.indexOf('</') === 0) {
        // 结束标签
        const match = content.match(endTagReg)

        if (match) {
          content = content.substring(match[0].length)
          match[0].replace(endTagReg, parseEndTag)
          isText = false
        }
      } else if (content.indexOf('<') === 0) {
        // 开始标签
        const match = content.match(startTagReg)

        if (match) {
          content = content.substring(match[0].length)
          match[0].replace(startTagReg, parseStartTag)
          isText = false
        }
      }

      if (isText) {
        const index = content.indexOf('<')

        const text = index < 0 ? content : content.substring(0, index)
        content = index < 0 ? '' : content.substring(index)

        if (handler.text) handler.text(text)
      }
    } else {
      const execRes = (new RegExp(`</${stack.last()}[^>]*>`)).exec(content)

      if (execRes) {
        let text = content.substring(0, execRes.index)
        content = content.substring(execRes.index + execRes[0].length)

        text = text.replace(/<!--(.*?)-->/g, '')
        if (text && handler.text) handler.text(text)
      }

      parseEndTag('', stack.last())
    }


    if (content === last) throw new Error(`parse error: ${content}`)
    last = content
  }

  // 清空保留的标签
  parseEndTag()

  function parseStartTag(tag, tagName, rest, unary) {
    unary = !!unary

    if (!unary) stack.push(tagName)

    if (handler.start) {
      const attrs = []

      rest.replace(attrReg, (all, $1, $2, $3, $4) => {
        attrs.push({
          name: $1,
          value: $2 !== undefined ? $2 : $3 !== undefined ? $3 : $4 !== undefined ? $4 : true,
        })
      })

      if (handler.start) handler.start(tagName, attrs, unary)
    }
  }

  function parseEndTag(tag, tagName) {
    let pos

    if (!tagName) {
      pos = 0
    } else {
      // 找到最近的同类型开始标签
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos] === tagName) break
      }
    }

    if (pos >= 0) {
      // 关闭所有的开始标签，并让其出栈
      for (let i = stack.length - 1; i >= pos; i--) {
        if (handler.end) handler.end(stack[i])
      }

      stack.length = pos
    }
  }
}


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

const expr = __webpack_require__(33)
const CONSTANT = __webpack_require__(6)

class VirtualNode {
  constructor(options = {}) {
    this.type = options.type
    this.tagName = options.tagName || ''
    this.componentId = options.componentId
    this.root = options.root || this // 根节点的 root 是自己
    this.parent = options.parent
    this.index = options.index || 0
    this.content = options.content && expr.getExpression(options.content)
    this.attrs = options.attrs || []
    this.event = options.event || {}
    this.statement = options.statement || {} // if/for 语句
    this.children = options.children || []
    this.generics = options.generics
    this.componentManager = options.componentManager // 所属的 componentManager 实例

    // 根节点用
    this.data = options.data || {}

    // wxs 节点用
    this.wxsModuleName = ''

    // slot 节点用
    this.slotName = ''

    this.checkAttrs()
  }

  /**
   * 检查属性
   */
  checkAttrs() {
    const type = this.type
    const attrs = this.attrs
    const filterAttrs = []

    for (const attr of attrs) {
      const name = attr.name
      const value = attr.value

      if (type === CONSTANT.TYPE_WXS && name === 'module') {
        // wxs 模块
        this.wxsModuleName = value || ''
      } else if (type === CONSTANT.TYPE_SLOT && name === 'name') {
        // slot 名
        this.slotName = value || ''
      } else {
        if (value && typeof value === 'string') attr.value = expr.getExpression(value)
        filterAttrs.push(attr)
      }
    }

    this.attrs = filterAttrs
  }

  /**
   * 设置父节点
   */
  setParent(parent, index = 0) {
    if (!parent) return

    this.parent = parent
    this.index = index
  }

  /**
   * 添加子节点
   */
  appendChild(node) {
    this.children.push(node)
  }

  /**
   * 设置 wxs 内容并转换成函数
   */
  setWxsContent(content) {
    if (!this.wxsModuleName) return

    // eslint-disable-next-line no-new-func
    const func = new Function('require', 'module', content)
    const req = () => {} // require function
    const mod = {exports: {}} // modules

    func.call(null, req, mod)

    this.root.data[this.wxsModuleName] = mod.exports // set in root's data
  }

  /**
   * 获取下一个兄弟节点
   */
  nextSibling() {
    return this.parent && this.parent.children[this.index + 1]
  }

  /**
   * 获取前一个兄弟节点
   */
  previousSibling() {
    return this.parent && this.parent.children[this.index - 1]
  }

  /**
   * 检查 if 语句
   */
  checkIf(data) {
    const statement = this.statement

    if (!statement.if) return true

    return expr.calcExpression(statement.if, data)
  }

  /**
   * 检查 elif 语句
   */
  checkElif(data) {
    const statement = this.statement

    if (!statement.elif) return true

    return this.checkPreviousCondition(data) ? false : expr.calcExpression(statement.elif, data)
  }

  /**
   * 检查 else 语句
   */
  checkElse(data) {
    const statement = this.statement

    if (!statement.else) return true

    return !this.checkPreviousCondition(data)
  }

  /**
   * 检查前一个条件语句
   */
  checkPreviousCondition(data) {
    let previousSibling = this.previousSibling()

    while (previousSibling) {
      const statement = previousSibling.statement

      if (previousSibling.type !== CONSTANT.TYPE_IF) return false // not if node
      if (!statement.if && !statement.elif) return false // not have condition statement
      if (statement.if) return previousSibling.checkIf(data)

      if (statement.elif) {
        if (!previousSibling.checkElif(data)) {
          previousSibling = previousSibling.previousSibling()
        } else {
          return true
        }
      }
    }

    return false
  }

  /**
   * 生成虚拟树
   */
  generate(options = {}) {
    const data = options.data || {}
    const statement = this.statement
    let key = options.key || ''

    options.data = data

    delete options.key // 不能跨组件传递

    // 检查 include 节点
    if (this.type === CONSTANT.TYPE_INCLUDE) {
      return null
    }

    // 检查 import 节点
    if (this.type === CONSTANT.TYPE_IMPORT) {
      return null
    }

    // 检查 template 节点
    if (this.type === CONSTANT.TYPE_TEMPLATE) {
      return null
    }

    // 检查 wxs 节点
    if (this.type === CONSTANT.TYPE_WXS) {
      return null
    }

    // 检查 if / elif / else 语句
    if (this.type === CONSTANT.TYPE_IF && (!this.checkIf(data) || !this.checkElif(data) || !this.checkElse(data))) {
      return null
    }

    let children = []

    // 检查子节点
    if (this.children && this.children.length) {
      if (this.type === CONSTANT.TYPE_FOR) {
        // 检查 for 语句
        const list = expr.calcExpression(statement.for, data)
        options.extra = options.extra || {}

        for (let i = 0, len = list.length; i < len; i++) {
          const {forItem: bakItem, forIndex: bakIndex} = options.extra

          options.extra.forItem = list[i]
          options.extra.forIndex = i

          // eslint-disable-next-line no-loop-func
          this.children.forEach(node => {
            const vt = node.generate(options)
            children.push(vt)
          })

          options.extra.forItem = bakItem
          options.extra.forIndex = bakIndex
        }
      } else if (this.type === CONSTANT.TYPE_FORITEM) {
        // 检查 for 子节点
        options.extra = options.extra || {}
        const {forItem, forIndex} = options.extra
        const {forItem: bakItem, forIndex: bakIndex} = data
        data[statement.forItem] = forItem // list item
        data[statement.forIndex] = forIndex // list index
        if (statement.forKey) key = statement.forKey === '*this' ? forItem : forItem[statement.forKey] // list key

        children = this.children.map(node => node.generate(options))

        data[statement.forItem] = bakItem
        data[statement.forIndex] = bakIndex
      } else {
        // 其他节点
        children = this.children.map(node => node.generate(options))
      }
    }

    // 过滤子节点
    const filterChildren = []
    for (const child of children) {
      if (!child) continue

      if (child.type === CONSTANT.TYPE_BLOCK) {
        // block 节点
        const grandChildren = child.children
        for (const grandChild of grandChildren) {
          filterChildren.push(grandChild)
        }
      } else {
        filterChildren.push(child)
      }
    }

    // 检查属性
    const attrs = []
    for (const {name, value} of this.attrs) {
      attrs.push({
        name,
        value: value ? expr.calcExpression(value, data) : value,
      })
    }

    // 计算内容
    let content = expr.calcExpression(this.content, data)
    content = content !== undefined ? String(content) : ''

    return {
      type: this.type,
      tagName: this.tagName,
      componentId: this.componentId,
      content, // 文本节点的内容
      key, // 节点的 key，diff 用
      children: filterChildren,
      generics: this.generics,
      attrs,
      event: this.event,
      slotName: this.slotName, // slot 节点的 name 属性
    }
  }
}

module.exports = VirtualNode


/***/ }),
/* 66 */
/***/ (function(module, exports) {

const ESCAPE = {
  'n': '\n',
  'f': '\f',
  'r': '\r',
  't': '\t',
  'v': '\v',
};

const CONSTANTS = {
  'null': data => null,
  'true': data => true,
  'false': data => false,
  'undefined': data => undefined,
}

const OPERATORS = {
  '+': (data, a, b) => a(data) + b(data),
  '-': (data, a, b) => a(data) - b(data),
  '*': (data, a, b) => a(data) * b(data),
  '/': (data, a, b) => a(data) / b(data),
  '%': (data, a, b) => a(data) % b(data),
  '===': (data, a, b) => a(data) === b(data),
  '!==': (data, a, b) => a(data) !== b(data),
  '==': (data, a, b) => a(data) == b(data),
  '!=': (data, a, b) => a(data) != b(data),
  '<': (data, a, b) => a(data) < b(data),
  '>': (data, a, b) => a(data) > b(data),
  '<=': (data, a, b) => a(data) <= b(data),
  '>=': (data, a, b) => a(data) >= b(data),
  '&&': (data, a, b) => a(data) && b(data),
  '||': (data, a, b) => a(data) || b(data),
  '!': (data, a) => !a(data),
};

function isNumber(char) {
  return char >= '0' && char <= '9' && typeof char === 'string';
}

function isExpOperator(char) {
  return (char === '-' || char === '+' || isNumber(char));
}

function isIdent(char) {
  return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' || char === '_' || char === '$';
}

class Expression {
  constructor(content) {
    if (!content) throw new Error('invalid expression');

    this.content = content;
  }

  lex() {
    let content = this.content;
    let length = content.length;
    let index = 0;
    let tokens = [];

    while (index < length) {
      let char = content.charAt(index);

      if (char === '"' || char === '\'') {
        // 字符串
        let start = ++index;
        let escape = false;
        let value = '';
        let token;

        while (index < length) {
          let c = content.charAt(index);

          if (escape) {
            if (c === 'u') {
              let hex = content.substring(index + 1, index + 5);
              if (!hex.match(/[\da-f]{4}/i)) {
                throw new Error(`invalid expression: ${content}, invalid unicode escape [\\u${hex}]`);
              }
              index += 4;
              value += String.fromCharCode(parseInt(hex, 16));
            } else {
              let rep = ESCAPE[c];
              value = value + (rep || c);
            }
            escape = false;
          } else if (c === '\\') {
            escape = true;
          } else if (c === char) {
            index++;
            token = {
              index: start,
              constant: true,
              text: char + value + char,
              value,
            };
            break;
          } else {
            value += c;
          }

          index++;
        }

        if (!token) {
          throw new Error(`invalid expression: ${content}`);
        } else {
          tokens.push(token);
        }
      } else if (isNumber(char) || (char === '.' && isNumber(content.charAt(index + 1)))) {
        // 数字
        let start = index;
        let value = '';

        while (index < length) {
          let c = content.charAt(index).toLowerCase();
          if (c === '.' || isNumber(c)) {
            value += c;
          } else {
            let c2 = content.charAt(index + 1);
            if (c === 'e' && isExpOperator(c2)) {
              value += c;
            } else if (isExpOperator(c) && c2 && isNumber(c2) && value.charAt(value.length - 1) === 'e') {
              value += c;
            } else if (isExpOperator(c) && (!c2 || !isNumber(c2)) && value.charAt(value.length - 1) == 'e') {
              throw new Error(`invalid expression: ${content}`);
            } else {
              break;
            }
          }
          index++;
        }

        tokens.push({
          index: start,
          constant: true,
          text: value,
          value: Number(value),
        })
      } else if (isIdent(char)) {
        // 标识符
        let start = index;
        while (index < length) {
          let c = content.charAt(index);
          if (!(isIdent(c) || isNumber(c))) {
            break;
          }
          index++;
        }

        tokens.push({
          index: start,
          text: content.slice(start, index),
          identifier: true
        });
      } else if ('(){}[].,;:?'.indexOf(char) >= 0) {
        // 边界
        tokens.push({
          index,
          text: char
        });

        index++;
      } else if (char === ' ' || char === '\r' || char === '\t' || char === '\n' || char === '\v' || char === '\u00A0') {
        // 空格
        index++;
      } else {
        // 操作符
        let char2 = char + content.charAt(index + 1);
        let char3 = char2 + content.charAt(index + 2);
        let op1 = OPERATORS[char];
        let op2 = OPERATORS[char2];
        let op3 = OPERATORS[char3];
        if (op1 || op2 || op3) {
          let text = op3 ? char3 : op2 ? char2 : char;

          tokens.push({
            index: index,
            text,
            operator: true
          });

          index += text.length;
        } else {
          throw new Error(`invalid expression: ${content}`);
        }
      }
    }

    this.tokens = tokens;
    return tokens;
  }

  parse() {
    let tokens = this.lex();

    let func;
    let token = tokens[0];
    let text = token.text;

    if (tokens.length > 0 && text !== '}' && text !== ')' && text !== ']') {
      func = this.expression();
    }

    return data => func && func(data);
  }

  expect(text) {
    let tokens = this.tokens;
    let token = tokens[0];

    if (!text || text === (token && token.text)) {
      return tokens.shift();
    }
  }

  consume(text) {
    if (!this.tokens.length) throw new Error(`parse expression error: ${this.content}`);

    let token = this.expect(text);
    if (!token) throw new Error(`parse expression error: ${this.content}`);

    return token;
  }

  expression() {
    return this.ternary();
  }

  ternary() {
    let left = this.logicalOR();
    let token;

    if (token = this.expect('?')) {
      let middle = this.expression();

      this.consume(':')
      let right = this.expression();

      return data => left(data) ? middle(data) : right(data);
    }

    return left;
  }

  binary(left, op, right) {
    let fn = OPERATORS[op];

    return data => fn(data, left, right);
  }

  unary() {
    let token;

    if (this.expect('+')) {
      return this.primary();
    } else if (token = this.expect('-')) {
      return this.binary(data => 0, token.text, this.unary());
    } else if (token = this.expect('!')) {
      let fn = OPERATORS[token.text];
      let right = this.unary();

      return data => fn(data, right); 
    } else {
      return this.primary();
    }
  }

  logicalOR() {
    let left = this.logicalAND();
    let token;

    while (token = this.expect('||')) {
      left = this.binary(left, token.text, this.logicalAND());
    }

    return left;
  }

  logicalAND() {
    let left = this.equality();
    let token;

    while (token = this.expect('&&')) {
      left = this.binary(left, token.text, this.equality());
    }

    return left;
  }

  equality() {
    let left = this.relational();
    let token;

    while (token = this.expect('==') || this.expect('!=') || this.expect('===') || this.expect('!==')) {
      left = this.binary(left, token.text, this.relational());
    }

    return left;
  }

  relational() {
    let left = this.additive();
    let token;

    while (token = this.expect('<') || this.expect('>') || this.expect('<=') || this.expect('>=')) {
      left = this.binary(left, token.text, this.additive());
    }

    return left;
  }

  additive() {
    let left = this.multiplicative();
    let token;

    while (token = this.expect('+') || this.expect('-')) {
      left = this.binary(left, token.text, this.multiplicative());
    }

    return left;
  }

  multiplicative() {
    let left = this.unary();
    let token;

    while (token = this.expect('*') || this.expect('/') || this.expect('%')) {
      left = this.binary(left, token.text, this.unary());
    }

    return left;
  }

  primary() {
    let token = this.tokens[0];
    let primary;

    if (this.expect('(')) {
      primary = this.expression();
      this.consume(')');
    } else if (this.expect('[')) {
      primary = this.array();
    } else if (this.expect('{')) {
      primary = this.object();
    } else if (token.identifier && token.text in CONSTANTS) {
      primary = CONSTANTS[this.consume().text];
    } else if (token.identifier) {
      primary = this.identifier();
    } else if (token.constant) {
      primary = this.constant();
    } else {
      throw new Error(`parse expression error: ${this.content}`);
    }

    let next;
    let context;
    while (next = this.expect('(') || this.expect('[') || this.expect('.')) {
      if (next.text === '(') {
        primary = this.functionCall(primary, context);
        context = null;
      } else if (next.text === '[') {
        context = primary;
        primary = this.objectIndex(primary);
      } else {
        context = primary;
        primary = this.fieldAccess(primary);
      }
    }
    return primary;
  }

  fieldAccess(object) {
    let getter = this.identifier();

    return data => {
      let o = object(data);
      return o && getter(o);
    };
  }

  objectIndex(object) {
    let indexFn = this.expression();

    this.consume(']');

    return data => {
      let o = object(data);
      let key = indexFn(data) + '';

      return o && o[key];
    };
  }

  functionCall(func, context) {
    let args = [];

    if (this.tokens[0].text !== ')') {
      do {
        args.push(this.expression());
      } while (this.expect(','));
    }

    this.consume(')');

    return data => {
      let callContext = context && context(data);
      let fn = func(data, callContext);

      return fn && fn.apply(callContext, args.length ? args.map(arg => arg(data)) : null);
    };
  }

  array() {
    let elements = [];
    let token = this.tokens[0];

    if (token.text !== ']') {
      do {
        if (this.tokens[0].text === ']') break;

        elements.push(this.expression());
      } while (this.expect(','));
    }

    this.consume(']');

    return data => elements.map(element => element(data));
  }

  object() {
    let keys = [];
    let values = [];
    let token = this.tokens[0];

    if (token.text !== '}') {
      do {
        token = this.tokens[0];
        if (token.text === '}') break;

        token = this.consume();
        if (token.constant) {
          keys.push(token.value);
        } else if (token.identifier) {
          keys.push(token.text);
        } else {
          throw new Error(`parse expression error: ${this.content}`);
        }

        this.consume(':');
        values.push(this.expression());
      } while (this.expect(','));
    }

    this.consume('}');

    return data => {
      let object = {};
      for (let i = 0, length = values.length; i < length; i++) {
        object[keys[i]] = values[i](data);
      }
      return object;
    };
  }

  identifier() {
    let id = this.consume().text;

    let token = this.tokens[0];
    let token2 = this.tokens[1];
    let token3 = this.tokens[2];

    // 连续读取 . 操作符后的非函数调用标识符
    while (token && token.text === '.' && token2 && token2.identifier && token3 && token3.text !== '(') {
      id += this.consume().text + this.consume().text;

      token = this.tokens[0];
      token2 = this.tokens[1];
      token3 = this.tokens[2];
    }

    return data => {
      let elements = id.split('.');
      let key;

      for (let i = 0; elements.length > 1; i++) {
        key = elements.shift();
        data = data[key];

        if (!data) break;
      }

      key = elements.shift();

      return data && data[key];
    };
  }

  constant() {
    let value = this.consume().value;

    return data => value;
  }
}

module.exports = Expression;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

const CONSTANT = __webpack_require__(6)
const _ = __webpack_require__(5)

/**
 * 过滤属性
 */
function filterAttrs(attrs = {}) {
  const event = {}
  const normalAttrs = []
  let slotName = ''

  const attrsKeyList = Object.keys(attrs)

  for (const name of attrsKeyList) {
    const value = attrs[name] === undefined ? '' : attrs[name]
    const eventObj = _.parseEvent(name, value)

    if (eventObj) {
      // 事件绑定
      event[eventObj.name] = eventObj
    } else {
      // 普通属性
      if (name === 'name') slotName = value

      normalAttrs.push({name, value})
    }
  }

  return {
    event,
    normalAttrs,
    slotName,
  }
}

/**
 * 将 wcc 输出转化成 j-component 需要的结构
 */
function transformCompileResTree(obj, parent, usingComponents) {
  let node = null

  // 特别注意：使用 wcc 编译，不会产生 import、block、include、wxs、native（小程序不支持 div 等标签）；template 节点会当作 if 节点处理

  if (typeof obj === 'string' || (typeof obj === 'number' && obj % 1 === 0)) {
    // 文本节点
    node = {
      type: CONSTANT.TYPE_TEXT,
      tagName: '',
      componentId: '',
      content: '' + obj, // 文本节点的内容
      key: '', // 节点的 key，diff 用
      children: [],
      generics: [],
      attrs: [],
      event: {},
      slotName: '', // slot 节点的 name 属性
    }
  } else {
    // 其他节点
    const children = []
    const {
      tag, wxKey, wxXCkey, attr
    } = obj
    const tagName = tag.indexOf('wx-') === 0 && (tag === 'wx-slot' || !_.isOfficialTag(tag)) ? tag.substr(3) : tag
    const key = wxKey !== undefined && wxKey !== null ? '' + wxKey : undefined
    const {event, normalAttrs, slotName} = filterAttrs(attr)
    const isIf = wxXCkey === 1 || wxXCkey === 3
    const isFor = wxXCkey === 2 || wxXCkey === 4
    const isSlot = tagName === 'slot'
    const isRoot = tagName === 'shadow'
    let type = isRoot ? CONSTANT.TYPE_ROOT : isIf ? CONSTANT.TYPE_IF : isFor ? CONSTANT.TYPE_FOR : isSlot ? CONSTANT.TYPE_SLOT : CONSTANT.TYPE_COMPONENT

    if (parent && parent.type === CONSTANT.TYPE_FOR) {
      type = CONSTANT.TYPE_FORITEM
    }

    node = {
      type,
      tagName,
      componentId: usingComponents[tagName] || tagName,
      content: '', // 文本节点的内容
      key, // 节点的 key，diff 用
      children,
      generics: obj.generics,
      attrs: normalAttrs,
      event,
      slotName: isSlot ? slotName : '', // slot 节点的 name 属性
    }

    obj.children.forEach(child => children.push(transformCompileResTree(child, node, usingComponents)))
  }

  return node
}

module.exports = function (generateFunc, usingComponents) {
  return function (options = {}) {
    const data = options.data || {}
    const compileRes = generateFunc(data)

    if (compileRes.type !== CONSTANT.TYPE_ROOT && (compileRes.tag === 'wx-page' || compileRes.tag === 'shadow')) {
      // 进行 wcc 编译结果的转化
      compileRes.tag = 'shadow'
      return transformCompileResTree(compileRes, null, usingComponents)
    } else {
      return compileRes
    }
  }
}


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

const exparser = __webpack_require__(4)
const render = __webpack_require__(13)
const CONSTANT = __webpack_require__(6)

/**
 * diff 两棵虚拟树
 */
function diffVt(oldVt, newVt) {
  const node = oldVt.exparserNode
  const parent = node.parentNode

  newVt.exparserNode = node // 更新新虚拟树的 exparser 节点

  if (!newVt) {
    // 删除
    if (parent) parent.removeChild(node)
  } else if (oldVt.type === CONSTANT.TYPE_TEXT) {
    // 更新文本节点
    if (newVt.type !== CONSTANT.TYPE_TEXT || newVt.content !== oldVt.content) {
      if (parent) {
        const newNode = render.renderExparserNode(newVt, null, parent.ownerShadowRoot)
        newNode._vt = newVt
        parent.replaceChild(newNode, node)
      }
    }
  } else {
    // 更新其他节点
    // eslint-disable-next-line no-lonely-if
    if (newVt.type === CONSTANT.TYPE_TEXT) {
      // 新节点是文本节点
      if (parent) {
        const newNode = render.renderExparserNode(newVt, null, parent.ownerShadowRoot)
        newNode._vt = newVt
        parent.replaceChild(newNode, node)
      }
    } else if (newVt.type === oldVt.type && newVt.componentId === oldVt.componentId && newVt.key === oldVt.key) {
      // 检查属性
      const attrs = diffAttrs(oldVt.attrs, newVt.attrs)
      if (attrs) {
        // 更新属性
        newVt.attrs = attrs
        render.updateAttrs(node, attrs)
      }

      // 检查事件
      Object.keys(oldVt.event).forEach(key => {
        const {name, isCapture, id} = oldVt.event[key]

        exparser.removeListenerFromElement(node, name, id, {capture: isCapture})
      })
      render.updateEvent(node, newVt.event)

      // 检查子节点
      const oldChildren = oldVt.children
      const newChildren = newVt.children
      const diffs = diffList(oldChildren, newChildren)

      // diff 子节点树
      for (let i = 0, len = oldChildren.length; i < len; i++) {
        const oldChild = oldChildren[i]
        const newChild = diffs.children[i]

        if (newChild) diffVt(oldChild, newChild)
      }
      if (diffs.moves) {
        // 子节点的删除/插入/重排
        let {inserts} = diffs.moves
        const {removes} = diffs.moves
        const children = node.childNodes

        inserts = inserts.map(({oldIndex, index}) => {
          const newNode = children[oldIndex] || render.renderExparserNode(newChildren[index], null, node.ownerShadowRoot)
          newNode._vt = newChildren[index]

          return {
            newNode,
            index,
          }
        })

        removes.forEach(index => node.removeChild(children[index]))
        inserts.forEach(({newNode, index}) => node.insertBefore(newNode, children[index]))
      }
      node._vt = newVt
    } else if (parent) {
      const newNode = render.renderExparserNode(newVt, null, parent.ownerShadowRoot)
      newNode._vt = newVt
      parent.replaceChild(newNode, node)
    }
  }
}

/**
 * diff 属性
 */
function diffAttrs(oldAttrs, newAttrs) {
  const oldAttrsMap = {}
  const newAttrsMap = {}
  const retAttrs = []
  let isChange = false

  oldAttrs.forEach(attr => oldAttrsMap[attr.name] = attr.value)

  for (const attr of newAttrs) {
    // 添加/更新
    newAttrsMap[attr.name] = attr.value
    retAttrs.push(attr)

    if (oldAttrsMap[attr.name] === undefined || oldAttrsMap[attr.name] !== attr.value) isChange = true
  }

  for (const attr of oldAttrs) {
    if (newAttrsMap[attr.name] === undefined) {
      // 删除
      attr.value = undefined
      retAttrs.push(attr)

      isChange = true
    }
  }

  return isChange ? retAttrs : false
}

/**
 * diff 列表
 */
function diffList(oldList, newList) {
  const oldKeyMap = {} // 旧列表的 key-index 映射表
  const newKeyMap = {} // 新列表的 key-index 映射表
  const oldFreeList = [] // 旧列表中没有 key 的项的 index 列表
  const newFreeList = [] // 新列表中没有 key 的项的 index 列表

  oldList.forEach((item, index) => {
    if (item.key) {
      // 拥有 key
      if (Object.prototype.hasOwnProperty.call(oldKeyMap, item.key)) item.key = ''
      else oldKeyMap[item.key] = index
    } else {
      // 没有 key
      oldFreeList.push(index)
    }
  })
  newList.forEach((item, index) => {
    if (item.key) {
      // 拥有 key
      if (Object.prototype.hasOwnProperty.call(newKeyMap, item.key)) newFreeList.push(index)
      else newKeyMap[item.key] = index
    } else {
      // 没有 key
      newFreeList.push(index)
    }
  })

  const children = []
  let removes = []
  const inserts = []

  // 检查旧列表
  for (let i = 0, j = 0; i < oldList.length; i++) {
    const item = oldList[i]
    const key = item.key

    if (key) {
      if (Object.prototype.hasOwnProperty.call(newKeyMap, key)) {
        // 在新列表中存在
        children.push(newList[newKeyMap[key]])
      } else {
        // 需要从新列表中删除
        removes.push(i)
        children.push(null)
      }
    } else if (j < newFreeList.length) {
      // 在新列表中存在
      children.push(newList[newFreeList[j++]])
    } else {
      // 需要从新列表中删除
      removes.push(i)
      children.push(null)
    }
  }
  removes = removes.reverse() // 从尾往头进行删除

  // 检查新列表
  const hasCheckIndexMap = {}
  for (let i = 0, j = 0, k = 0, len = newList.length; i < len; i++) {
    const item = newList[i]
    const key = item.key

    while (children[j] === null || hasCheckIndexMap[j]) j++ // 跳过已被删除/检查的项

    if (key) {
      if (Object.prototype.hasOwnProperty.call(oldKeyMap, key) && children[j]) {
        // 在旧列表中存在
        if (children[j].key === key) {
          // 拥有同样的 key
          j++
        } else {
          // 拥有不同的 key
          const oldIndex = oldKeyMap[key]
          hasCheckIndexMap[oldIndex] = true
          if (oldIndex !== i) inserts.push({oldIndex, index: i})
        }
      } else {
        // 插入新项
        inserts.push({oldIndex: -1, index: i})
      }
    } else if (k < oldFreeList.length) {
      // 在旧列表中存在
      const oldIndex = oldFreeList[k++]
      hasCheckIndexMap[oldIndex] = true
      if (oldIndex !== i) inserts.push({oldIndex, index: i})
    } else {
      // 插入新项
      inserts.push({oldIndex: -1, index: i})
    }
  }

  return {
    children,
    moves: {removes, inserts},
  }
}

module.exports = {
  diffVt,
  diffAttrs,
  diffList,
}


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

const exparser = __webpack_require__(4)

class NodesRef {
  constructor(selectorQuery, exparserNode, selector, isSelectSingle) {
    this._selectorQuery = selectorQuery
    this._exparserNode = exparserNode
    this._selector = selector
    this._isSelectSingle = isSelectSingle
  }

  boundingClientRect(callback) {
    return this._selectorQuery._push(this._selector, this._exparserNode, this._isSelectSingle, {
      id: true,
      dataset: true,
      rect: true,
      size: true,
    }, callback)
  }

  scrollOffset(callback) {
    return this._selectorQuery._push(this._selector, this._exparserNode, this._isSelectSingle, {
      id: true,
      dataset: true,
      scrollOffset: true,
    }, callback)
  }

  context(callback) {
    return this._selectorQuery._push(this._selector, this._exparserNode, this._isSelectSingle, {
      context: true,
    }, callback)
  }

  fields(fields, callback) {
    return this._selectorQuery._push(this._selector, this._exparserNode, this._isSelectSingle, fields, callback)
  }
}

class SelectorQuery {
  constructor(compInst) {
    this._exparserNode = compInst && compInst._exparserNode || null
    this._queue = []
    this._queueCallback = []
  }

  _push(selector, exparserNode, isSelectSingle, fields, callback) {
    this._queue.push({
      selector,
      exparserNode,
      isSelectSingle,
      fields,
    })
    this._queueCallback.push(callback || null)

    return this
  }

  in(compInst) {
    if (!compInst || typeof compInst !== 'object') {
      throw new Error('invalid params')
    }

    this._exparserNode = compInst._exparserNode

    return this
  }

  select(selector) {
    return new NodesRef(this, this._exparserNode, selector, true)
  }

  selectAll(selector) {
    return new NodesRef(this, this._exparserNode, selector, false)
  }

  selectViewport() {
    return new NodesRef(this, 0, '', false)
  }

  exec(callback) {
    Promise.resolve().then(() => {
      const res = []

      this._queue.forEach((item, index) => {
        const {
          selector, exparserNode, isSelectSingle, fields
        } = item

        if (exparserNode === 0) {
          const itemRes = {}

          if (fields.id) {
            itemRes.id = ''
          }
          if (fields.dataset) {
            itemRes.dataset = {}
          }
          if (fields.rect) {
            itemRes.left = 0
            itemRes.right = 0
            itemRes.top = 0
            itemRes.bottom = 0
          }
          if (fields.size) {
            itemRes.width = document.documentElement.clientWidth
            itemRes.height = document.documentElement.clientHeight
          }
          if (fields.scrollOffset) {
            itemRes.scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft || 0
            itemRes.scrollTop = document.documentElement.scrollTop || document.body.scrollTop || 0
          }

          res.push(itemRes)
        } else {
          const shadowRoot = exparserNode.shadowRoot
          const nodes = isSelectSingle ? [shadowRoot.querySelector(selector)] : shadowRoot.querySelectorAll(selector)
          const itemResList = []

          for (const node of nodes) {
            const itemRes = {}

            if (fields.id) {
              itemRes.id = node.id || ''
            }
            if (fields.dataset) {
              itemRes.dataset = Object.assign({}, node.dataset || {})
            }
            if (fields.rect || fields.size) {
              const rect = node.$$.getBoundingClientRect()

              if (fields.rect) {
                itemRes.left = rect.left
                itemRes.right = rect.right
                itemRes.top = rect.top
                itemRes.bottom = rect.bottom
              }
              if (fields.size) {
                itemRes.width = rect.width
                itemRes.height = rect.height
              }
            }
            if (fields.properties) {
              fields.properties.forEach(name => {
                name = name.replace(/-([a-z])/g, (all, $1) => $1.toUpperCase())

                if (exparser.Component.hasPublicProperty(node, name)) {
                  itemRes[name] = node.data[name]
                }
              })
            }
            if (fields.scrollOffset) {
              itemRes.scrollLeft = node.$$.scrollLeft || 0
              itemRes.scrollTop = node.$$.scrollTop || 0
            }
            if (fields.computedStyle && fields.computedStyle.length) {
              const style = window.getComputedStyle(node.$$)

              fields.computedStyle.forEach(key => {
                if (key && style[key] !== undefined) itemRes[key] = style[key]
              })
            }
            if (fields.context) {
              itemRes.context = {} // TODO
            }

            itemResList.push(itemRes)
          }

          res.push(isSelectSingle ? itemResList[0] : itemResList)
        }

        if (typeof this._queueCallback[index] === 'function') this._queueCallback[index].call(this, res[index])
      })

      if (typeof callback === 'function') callback.call(this, res)

      // reset
      this._queue = []
      this._queueCallback = []
    }).catch(console.error)
  }
}

module.exports = SelectorQuery


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

const exparser = __webpack_require__(4)
const _ = __webpack_require__(5)
const IntersectionObserver = __webpack_require__(34)
const CONSTANT = __webpack_require__(6)
const render = __webpack_require__(13)

const MOVE_DELTA = 10
const LONGPRESS_TIME = 350
const SCROLL_PROTECTED = 150
const NATIVE_TOUCH_EVENT = ['touchstart', 'touchmove', 'touchend', 'touchcancel']

/**
 * 遍历 exparser 树
 */
function dfsExparserTree(node, callback, fromTopToBottom) {
  if (node instanceof exparser.Component) {
    if (fromTopToBottom) callback(node)
    if (node.shadowRoot instanceof exparser.Element) dfsExparserTree(node.shadowRoot, callback, fromTopToBottom)
    if (!fromTopToBottom) callback(node)
  }
  node.childNodes.forEach(child => {
    if (child instanceof exparser.Element) dfsExparserTree(child, callback, fromTopToBottom)
  })
}

/**
 * 用于 miniprogram-simulate/jest-snapshot-plugin 的识别
 */
const JSONSymbol = typeof Symbol === 'function' && Symbol.for ? Symbol.for('j-component.json') : 0xd846fe

/**
 * 序列化 exparser 树节点上绑定的事件监听
 */
function exparserNodeEventToJSON(node) {
  return node._vt ? node._vt.event : {}
}

/**
 * 序列化 exparser 树节点的属性
 */
function exparserNodeAttrsToJSON(node) {
  const attrs = []
  const vt = node._vt

  if (vt) {
    vt.attrs.forEach(attr => {
      if (!exparser.Component.hasPublicProperty(node, _.dashToCamelCase(attr.name))) {
        attrs.push(attr)
      }
    })
  }
  return attrs
}

/**
 * 将 exparser 树转换为 JSON 对象
 */
function exparserTreeToJSON(node) {
  const _inner = (node, array) => {
    let children = array
    const vt = node._vt

    if (vt) {
      if (vt.type === CONSTANT.TYPE_TEXT) {
        array.push(vt.content)
      } else if (vt.type === CONSTANT.TYPE_NATIVE || vt.type === CONSTANT.TYPE_COMPONENT) {
        children = []
        const child = {
          tagName: _.getTagName(vt.componentId || vt.tagName) || vt.tagName,
          event: exparserNodeEventToJSON(node),
          attrs: exparserNodeAttrsToJSON(node),
          children,
        }
        Object.defineProperty(child, '$$typeof', {
          get() {
            return JSONSymbol
          }
        })
        array.push(child)
      }
    }

    (node.__wxSlotChildren || []).forEach(child => _inner(child, children))

    return array
  }

  return _inner(node, [])[0]
}

class Component {
  constructor(exparserNode) {
    this._exparserNode = exparserNode
  }

  get dom() {
    return this._exparserNode.$$
  }

  get data() {
    const caller = exparser.Element.getMethodCaller(this._exparserNode)

    return caller && caller.data
  }

  get instance() {
    return exparser.Element.getMethodCaller(this._exparserNode)
  }

  /**
   * 触发事件
   */
  dispatchEvent(eventName, options = {}) {
    const dom = this.dom

    if (NATIVE_TOUCH_EVENT.indexOf(eventName) >= 0) {
      // native touch event
      let touches = options.touches
      let changedTouches = options.changedTouches

      if (eventName === 'touchstart' || eventName === 'touchmove') {
        touches = touches || [{x: 0, y: 0}]
        changedTouches = changedTouches || [{x: 0, y: 0}]
      } else if (eventName === 'touchend' || eventName === 'touchcancel') {
        touches = touches || []
        changedTouches = changedTouches || [{x: 0, y: 0}]
      }

      const touchEvent = new TouchEvent(eventName, {
        cancelable: true,
        bubbles: true,
        touches: touches.map(touch => new Touch({
          identifier: _.getId(),
          target: dom,
          clientX: touch.x,
          clientY: touch.y,
          pageX: touch.x,
          pageY: touch.y,
        })),
        targetTouches: [],
        changedTouches: changedTouches.map(touch => new Touch({
          identifier: _.getId(),
          target: dom,
          clientX: touch.x,
          clientY: touch.y,
          pageX: touch.x,
          pageY: touch.y,
        })),
      })

      // 模拟异步情况
      Promise.resolve().then(() => {
        dom.dispatchEvent(touchEvent)
      }).catch(console.error)
    } else {
      // 自定义事件
      const customEvent = new CustomEvent(eventName, options)

      // 模拟异步情况
      Promise.resolve().then(() => {
        dom.dispatchEvent(customEvent)

        if (customEvent.target.__wxElement) {
          exparser.Event.dispatchEvent(customEvent.target.__wxElement, exparser.Event.create(eventName, options.detail || {}, {
            originalEvent: customEvent,
            bubbles: true,
            capturePhase: true,
            composed: true,
            extraFields: {
              touches: options.touches || {},
              changedTouches: options.changedTouches || {},
            },
          }))
        }
      }).catch(console.error)
    }
  }

  /**
   * 选取第一个符合的子组件节点
   */
  querySelector(selector) {
    const shadowRoot = this._exparserNode.shadowRoot
    const selExparserNode = shadowRoot && shadowRoot.querySelector(selector)

    if (selExparserNode) {
      return selExparserNode.__componentNode__ ? selExparserNode.__componentNode__ : new Component(selExparserNode)
    }
  }

  /**
   * 选取所有符合的子组件节点
   */
  querySelectorAll(selector) {
    const shadowRoot = this._exparserNode.shadowRoot
    const selExparserNodes = shadowRoot.querySelectorAll(selector) || []

    return selExparserNodes.map(selExparserNode => (selExparserNode.__componentNode__ ? selExparserNode.__componentNode__ : new Component(selExparserNode)))
  }

  /**
   * 小程序自定义组件的 setData 方法
   */
  setData(data, callback) {
    const caller = exparser.Element.getMethodCaller(this._exparserNode)

    if (caller && typeof caller.setData === 'function') caller.setData(data)
    if (typeof callback === 'function') {
      // 模拟异步情况
      Promise.resolve().then(callback).catch(console.error)
    }
  }

  /**
   * 触发生命周期
   */
  triggerLifeTime(lifeTime) {
    this._exparserNode.triggerLifeTime(lifeTime)
  }

  /**
   * 生成JSON
   */
  toJSON() {
    return exparserTreeToJSON(this._exparserNode)
  }
}

class RootComponent extends Component {
  constructor(componentManager, properties) {
    super()

    const id = componentManager.id
    const tagName = _.getTagName(id)
    const exparserDef = componentManager.exparserDef
    this._exparserNode = exparser.createElement(tagName || id, exparserDef) // create exparser node and render
    this._isTapCancel = false
    this._lastScrollTime = 0

    const attrs = Object.keys(properties || {}).map(key => ({name: key, value: properties[key]}))
    if (attrs.length) {
      // 对齐 observer 逻辑，走 updateAttr 来更新 property
      render.updateAttrs(this._exparserNode, attrs)
    }

    this._exparserNode._vt = {
      type: CONSTANT.TYPE_COMPONENT,
      tagName: tagName || 'main',
      attrs,
      event: {},
      children: []
    }

    this.parentNode = null

    this._bindEvent()
  }

  get dom() {
    return this._exparserNode.$$
  }

  /**
   * 初始化事件
   */
  _bindEvent() {
    const dom = this.dom

    // touch 事件
    dom.addEventListener('touchstart', evt => {
      this._triggerExparserEvent(evt, 'touchstart')

      if (this._touchstartEvt || evt.defaultPrevented) return
      if (evt.touches.length === 1) {
        if (this._longpressTimer) this._longpressTimer = clearTimeout(this._longpressTimer)

        this._touchstartX = evt.touches[0].pageX
        this._touchstartY = evt.touches[0].pageY
        this._touchstartEvt = evt

        if ((+new Date()) - this._lastScrollTime < SCROLL_PROTECTED) {
          // 滚动中
          this._isTapCancel = true
          this._lastScrollTime = 0 // 只检查一次
        } else {
          this._isTapCancel = false
          this._longpressTimer = setTimeout(() => {
            this._isTapCancel = true // 取消后续的 tap
            this._triggerExparserEvent(evt, 'longpress', {x: this._touchstartX, y: this._touchstartY})
          }, LONGPRESS_TIME)
        }
      }
    }, {capture: true, passive: false})

    dom.addEventListener('touchmove', evt => {
      this._triggerExparserEvent(evt, 'touchmove')

      if (!this._touchstartEvt) return
      if (evt.touches.length === 1) {
        if (!(Math.abs(evt.touches[0].pageX - this._touchstartX) < MOVE_DELTA && Math.abs(evt.touches[0].pageY - this._touchstartY) < MOVE_DELTA)) {
          // is moving
          if (this._longpressTimer) this._longpressTimer = clearTimeout(this._longpressTimer)
          this._isTapCancel = true
        }
      }
    }, {capture: true, passive: false})

    dom.addEventListener('touchend', evt => {
      this._triggerExparserEvent(evt, 'touchend')

      if (!this._touchstartEvt) return
      if (evt.touches.length === 0) {
        if (this._longpressTimer) this._longpressTimer = clearTimeout(this._longpressTimer)
        if (!this._isTapCancel) this._triggerExparserEvent(this._touchstartEvt, 'tap', {x: evt.changedTouches[0].pageX, y: evt.changedTouches[0].pageY})
      }

      this._touchstartEvt = null // 重置 touchStart 事件
    }, {capture: true, passive: false})

    dom.addEventListener('touchcancel', evt => {
      this._triggerExparserEvent(evt, 'touchcancel')

      if (!this._touchstartEvt) return
      if (this._longpressTimer) this._longpressTimer = clearTimeout(this._longpressTimer)

      this._touchstartEvt = null // 重置 touchStart 事件
    }, {capture: true, passive: false})

    // 其他事件
    dom.addEventListener('scroll', evt => {
      // 触发 intersectionObserver
      const listenInfoMap = this._exparserNode._listenInfoMap || {}
      Object.keys(listenInfoMap).forEach(key => {
        const listenInfo = listenInfoMap[key]
        IntersectionObserver.updateTargetIntersection(listenInfo)
      })

      this._lastScrollTime = +new Date()
      this._triggerExparserEvent(evt, 'scroll')
    }, {capture: true, passive: false})

    // eslint-disable-next-line no-unused-vars
    dom.addEventListener('blur', evt => {
      if (this._longpressTimer) this._longpressTimer = clearTimeout(this._longpressTimer)
    }, {capture: true, passive: false})
  }

  /**
   * 触发 exparser 节点事件
   */
  _triggerExparserEvent(evt, name, detail = {}) {
    Promise.resolve().then(() => {
      exparser.Event.dispatchEvent(evt.target, exparser.Event.create(name, detail, {
        originalEvent: evt,
        bubbles: true,
        capturePhase: true,
        composed: true,
        extraFields: {
          touches: evt.touches || {},
          changedTouches: evt.changedTouches || {},
        },
      }))
    }).catch(console.error)
  }

  /**
   * 添加
   */
  attach(parent) {
    parent.appendChild(this.dom)
    this.parentNode = parent

    exparser.Element.pretendAttached(this._exparserNode)
    dfsExparserTree(this._exparserNode, node => node.triggerLifeTime('ready'))
  }

  /**
   * 移除
   */
  detach() {
    if (!this.parentNode) return

    this.parentNode.removeChild(this.dom)
    this.parentNode = null

    exparser.Element.pretendDetached(this._exparserNode)
  }
}

module.exports = RootComponent


/***/ }),
/* 71 */
/***/ (function(module, exports) {



/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

const postcss = __webpack_require__(73)
const path = __webpack_require__(3)
const less = __webpack_require__(96)
const csso = __webpack_require__(97)

const _ = __webpack_require__(10)

const wxssCache = {}

/**
 * 追加 class 前缀插件
 */
const addClassPrefixPlugin = function(prefix = '') {
    return postcss.plugin('addClassPrefix', () => root => {
        // eslint-disable-next-line consistent-return
        root.walk(child => {
            if (child.type === 'rule') {
                const selectors = []

                child.selectors.forEach(selector => {
                    // 处理 class 选择器
                    selectors.push(selector.replace(/(.)?\.([-_a-zA-Z0-9]+)/igs, (all, $1, $2) => (/\d/.test($1) ? all : `${$1 || ''}.${prefix}--${$2}`)))
                })

                child.selectors = selectors
            }
        })
    })
}

/**
 * 获取 import 列表
 */
function getImportList(wxss, filePath) {
    const reg = /@import\s+(?:(?:"([^"]+)")|(?:'([^']+)'));/ig
    const importList = []
    let execRes = reg.exec(wxss)

    while (execRes && (execRes[1] || execRes[2])) {
        importList.push({
            code: execRes[0],
            path: path.join(path.dirname(filePath), execRes[1] || execRes[2]),
        })
        execRes = reg.exec(wxss)
    }

    return importList
}

/**
 * 获取 wxss 内容
 */
function getContent(filePath) {
    // 判断缓存
    if (wxssCache[filePath]) {
        return wxssCache[filePath]
    }

    let wxss = _.readFile(filePath)

    if (wxss) {
        const importList = getImportList(wxss, filePath)

        importList.forEach(item => {
            wxss = wxss.replace(item.code, getContent(item.path))
        })
    }

    // 缓存 wxss
    wxssCache[filePath] = wxss || ''

    return wxssCache[filePath]
}

/**
 * 编译 wxss
 */
function compile(wxss, options = {}) {
    if (options.less) {
        less.render(wxss, (err, output) => {
            if (!err) wxss = output.css
        })
    }

    wxss = postcss([addClassPrefixPlugin(options.prefix)]).process(wxss, {
        from: undefined, // 主要是不想看到那个 warning
        map: null,
    }).css

    // 压缩
    return csso.minify(wxss, {restructure: false}).css
}

/**
 * 插入 wxss
 */
function insert(wxss, id) {
    if (!Array.isArray(wxss)) {
        wxss = [wxss]
    }

    // 删除已插入的
    document.querySelectorAll(`style#${id}`).forEach(style => {
        style.parentNode.removeChild(style)
    })

    const style = document.createElement('style')
    style.type = 'text/css'
    style.id = id
    style.innerHTML = _.transformRpx(wxss.join(''))

    const head = document.getElementsByTagName('head')
    if (head && head.length) head.item(0).appendChild(style)
}


module.exports = {
    getContent,
    compile,
    insert,
}


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _declaration = _interopRequireDefault(__webpack_require__(15));

var _processor = _interopRequireDefault(__webpack_require__(37));

var _stringify = _interopRequireDefault(__webpack_require__(17));

var _comment = _interopRequireDefault(__webpack_require__(20));

var _atRule = _interopRequireDefault(__webpack_require__(21));

var _vendor = _interopRequireDefault(__webpack_require__(95));

var _parse = _interopRequireDefault(__webpack_require__(19));

var _list = _interopRequireDefault(__webpack_require__(43));

var _rule = _interopRequireDefault(__webpack_require__(23));

var _root = _interopRequireDefault(__webpack_require__(44));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create a new {@link Processor} instance that will apply `plugins`
 * as CSS processors.
 *
 * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
 *        See {@link Processor#use} for plugin format.
 *
 * @return {Processor} Processor to process multiple CSS.
 *
 * @example
 * import postcss from 'postcss'
 *
 * postcss(plugins).process(css, { from, to }).then(result => {
 *   console.log(result.css)
 * })
 *
 * @namespace postcss
 */
function postcss() {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }

  return new _processor.default(plugins);
}
/**
 * Creates a PostCSS plugin with a standard API.
 *
 * The newly-wrapped function will provide both the name and PostCSS
 * version of the plugin.
 *
 * ```js
 * const processor = postcss([replace])
 * processor.plugins[0].postcssPlugin  //=> 'postcss-replace'
 * processor.plugins[0].postcssVersion //=> '6.0.0'
 * ```
 *
 * The plugin function receives 2 arguments: {@link Root}
 * and {@link Result} instance. The function should mutate the provided
 * `Root` node. Alternatively, you can create a new `Root` node
 * and override the `result.root` property.
 *
 * ```js
 * const cleaner = postcss.plugin('postcss-cleaner', () => {
 *   return (root, result) => {
 *     result.root = postcss.root()
 *   }
 * })
 * ```
 *
 * As a convenience, plugins also expose a `process` method so that you can use
 * them as standalone tools.
 *
 * ```js
 * cleaner.process(css, processOpts, pluginOpts)
 * // This is equivalent to:
 * postcss([ cleaner(pluginOpts) ]).process(css, processOpts)
 * ```
 *
 * Asynchronous plugins should return a `Promise` instance.
 *
 * ```js
 * postcss.plugin('postcss-import', () => {
 *   return (root, result) => {
 *     return new Promise( (resolve, reject) => {
 *       fs.readFile('base.css', (base) => {
 *         root.prepend(base)
 *         resolve()
 *       })
 *     })
 *   }
 * })
 * ```
 *
 * Add warnings using the {@link Node#warn} method.
 * Send data to other plugins using the {@link Result#messages} array.
 *
 * ```js
 * postcss.plugin('postcss-caniuse-test', () => {
 *   return (root, result) => {
 *     root.walkDecls(decl => {
 *       if (!caniuse.support(decl.prop)) {
 *         decl.warn(result, 'Some browsers do not support ' + decl.prop)
 *       }
 *     })
 *   }
 * })
 * ```
 *
 * @param {string} name          PostCSS plugin name. Same as in `name`
 *                               property in `package.json`. It will be saved
 *                               in `plugin.postcssPlugin` property.
 * @param {function} initializer Will receive plugin options
 *                               and should return {@link pluginFunction}
 *
 * @return {Plugin} PostCSS plugin.
 */


postcss.plugin = function plugin(name, initializer) {
  function creator() {
    var transformer = initializer.apply(void 0, arguments);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new _processor.default().version;
    return transformer;
  }

  var cache;
  Object.defineProperty(creator, 'postcss', {
    get: function get() {
      if (!cache) cache = creator();
      return cache;
    }
  });

  creator.process = function (css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts);
  };

  return creator;
};
/**
 * Default function to convert a node tree into a CSS string.
 *
 * @param {Node} node       Start node for stringifing. Usually {@link Root}.
 * @param {builder} builder Function to concatenate CSS from node’s parts
 *                          or generate string and source map.
 *
 * @return {void}
 *
 * @function
 */


postcss.stringify = _stringify.default;
/**
 * Parses source css and returns a new {@link Root} node,
 * which contains the source CSS nodes.
 *
 * @param {string|toString} css   String with input CSS or any object
 *                                with toString() method, like a Buffer
 * @param {processOptions} [opts] Options with only `from` and `map` keys.
 *
 * @return {Root} PostCSS AST.
 *
 * @example
 * // Simple CSS concatenation with source map support
 * const root1 = postcss.parse(css1, { from: file1 })
 * const root2 = postcss.parse(css2, { from: file2 })
 * root1.append(root2).toResult().css
 *
 * @function
 */

postcss.parse = _parse.default;
/**
 * Contains the {@link vendor} module.
 *
 * @type {vendor}
 *
 * @example
 * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']
 */

postcss.vendor = _vendor.default;
/**
 * Contains the {@link list} module.
 *
 * @member {list}
 *
 * @example
 * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']
 */

postcss.list = _list.default;
/**
 * Creates a new {@link Comment} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Comment} New comment node
 *
 * @example
 * postcss.comment({ text: 'test' })
 */

postcss.comment = function (defaults) {
  return new _comment.default(defaults);
};
/**
 * Creates a new {@link AtRule} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {AtRule} new at-rule node
 *
 * @example
 * postcss.atRule({ name: 'charset' }).toString() //=> "@charset"
 */


postcss.atRule = function (defaults) {
  return new _atRule.default(defaults);
};
/**
 * Creates a new {@link Declaration} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Declaration} new declaration node
 *
 * @example
 * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> "color: red"
 */


postcss.decl = function (defaults) {
  return new _declaration.default(defaults);
};
/**
 * Creates a new {@link Rule} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Rule} new rule node
 *
 * @example
 * postcss.rule({ selector: 'a' }).toString() //=> "a {\n}"
 */


postcss.rule = function (defaults) {
  return new _rule.default(defaults);
};
/**
 * Creates a new {@link Root} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Root} new root node.
 *
 * @example
 * postcss.root({ after: '\n' }).toString() //=> "\n"
 */


postcss.root = function (defaults) {
  return new _root.default(defaults);
};

var _default = postcss;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBvc3Rjc3MuZXM2Il0sIm5hbWVzIjpbInBvc3Rjc3MiLCJwbHVnaW5zIiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwiUHJvY2Vzc29yIiwicGx1Z2luIiwibmFtZSIsImluaXRpYWxpemVyIiwiY3JlYXRvciIsInRyYW5zZm9ybWVyIiwicG9zdGNzc1BsdWdpbiIsInBvc3Rjc3NWZXJzaW9uIiwidmVyc2lvbiIsImNhY2hlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJwcm9jZXNzIiwiY3NzIiwicHJvY2Vzc09wdHMiLCJwbHVnaW5PcHRzIiwic3RyaW5naWZ5IiwicGFyc2UiLCJ2ZW5kb3IiLCJsaXN0IiwiY29tbWVudCIsImRlZmF1bHRzIiwiQ29tbWVudCIsImF0UnVsZSIsIkF0UnVsZSIsImRlY2wiLCJEZWNsYXJhdGlvbiIsInJ1bGUiLCJSdWxlIiwicm9vdCIsIlJvb3QiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBLFNBQVNBLE9BQVQsR0FBOEI7QUFBQSxvQ0FBVEMsT0FBUztBQUFUQSxJQUFBQSxPQUFTO0FBQUE7O0FBQzVCLE1BQUlBLE9BQU8sQ0FBQ0MsTUFBUixLQUFtQixDQUFuQixJQUF3QkMsS0FBSyxDQUFDQyxPQUFOLENBQWNILE9BQU8sQ0FBQyxDQUFELENBQXJCLENBQTVCLEVBQXVEO0FBQ3JEQSxJQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQyxDQUFELENBQWpCO0FBQ0Q7O0FBQ0QsU0FBTyxJQUFJSSxrQkFBSixDQUFjSixPQUFkLENBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdFQUQsT0FBTyxDQUFDTSxNQUFSLEdBQWlCLFNBQVNBLE1BQVQsQ0FBaUJDLElBQWpCLEVBQXVCQyxXQUF2QixFQUFvQztBQUNuRCxXQUFTQyxPQUFULEdBQTJCO0FBQ3pCLFFBQUlDLFdBQVcsR0FBR0YsV0FBVyxNQUFYLG1CQUFsQjtBQUNBRSxJQUFBQSxXQUFXLENBQUNDLGFBQVosR0FBNEJKLElBQTVCO0FBQ0FHLElBQUFBLFdBQVcsQ0FBQ0UsY0FBWixHQUE4QixJQUFJUCxrQkFBSixFQUFELENBQWtCUSxPQUEvQztBQUNBLFdBQU9ILFdBQVA7QUFDRDs7QUFFRCxNQUFJSSxLQUFKO0FBQ0FDLEVBQUFBLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQlAsT0FBdEIsRUFBK0IsU0FBL0IsRUFBMEM7QUFDeENRLElBQUFBLEdBRHdDLGlCQUNqQztBQUNMLFVBQUksQ0FBQ0gsS0FBTCxFQUFZQSxLQUFLLEdBQUdMLE9BQU8sRUFBZjtBQUNaLGFBQU9LLEtBQVA7QUFDRDtBQUp1QyxHQUExQzs7QUFPQUwsRUFBQUEsT0FBTyxDQUFDUyxPQUFSLEdBQWtCLFVBQVVDLEdBQVYsRUFBZUMsV0FBZixFQUE0QkMsVUFBNUIsRUFBd0M7QUFDeEQsV0FBT3JCLE9BQU8sQ0FBQyxDQUFDUyxPQUFPLENBQUNZLFVBQUQsQ0FBUixDQUFELENBQVAsQ0FBK0JILE9BQS9CLENBQXVDQyxHQUF2QyxFQUE0Q0MsV0FBNUMsQ0FBUDtBQUNELEdBRkQ7O0FBSUEsU0FBT1gsT0FBUDtBQUNELENBckJEO0FBdUJBOzs7Ozs7Ozs7Ozs7O0FBV0FULE9BQU8sQ0FBQ3NCLFNBQVIsR0FBb0JBLGtCQUFwQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBdEIsT0FBTyxDQUFDdUIsS0FBUixHQUFnQkEsY0FBaEI7QUFFQTs7Ozs7Ozs7O0FBUUF2QixPQUFPLENBQUN3QixNQUFSLEdBQWlCQSxlQUFqQjtBQUVBOzs7Ozs7Ozs7QUFRQXhCLE9BQU8sQ0FBQ3lCLElBQVIsR0FBZUEsYUFBZjtBQUVBOzs7Ozs7Ozs7OztBQVVBekIsT0FBTyxDQUFDMEIsT0FBUixHQUFrQixVQUFBQyxRQUFRO0FBQUEsU0FBSSxJQUFJQyxnQkFBSixDQUFZRCxRQUFaLENBQUo7QUFBQSxDQUExQjtBQUVBOzs7Ozs7Ozs7Ozs7QUFVQTNCLE9BQU8sQ0FBQzZCLE1BQVIsR0FBaUIsVUFBQUYsUUFBUTtBQUFBLFNBQUksSUFBSUcsZUFBSixDQUFXSCxRQUFYLENBQUo7QUFBQSxDQUF6QjtBQUVBOzs7Ozs7Ozs7Ozs7QUFVQTNCLE9BQU8sQ0FBQytCLElBQVIsR0FBZSxVQUFBSixRQUFRO0FBQUEsU0FBSSxJQUFJSyxvQkFBSixDQUFnQkwsUUFBaEIsQ0FBSjtBQUFBLENBQXZCO0FBRUE7Ozs7Ozs7Ozs7OztBQVVBM0IsT0FBTyxDQUFDaUMsSUFBUixHQUFlLFVBQUFOLFFBQVE7QUFBQSxTQUFJLElBQUlPLGFBQUosQ0FBU1AsUUFBVCxDQUFKO0FBQUEsQ0FBdkI7QUFFQTs7Ozs7Ozs7Ozs7O0FBVUEzQixPQUFPLENBQUNtQyxJQUFSLEdBQWUsVUFBQVIsUUFBUTtBQUFBLFNBQUksSUFBSVMsYUFBSixDQUFTVCxRQUFULENBQUo7QUFBQSxDQUF2Qjs7ZUFFZTNCLE8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGVjbGFyYXRpb24gZnJvbSAnLi9kZWNsYXJhdGlvbidcbmltcG9ydCBQcm9jZXNzb3IgZnJvbSAnLi9wcm9jZXNzb3InXG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5J1xuaW1wb3J0IENvbW1lbnQgZnJvbSAnLi9jb21tZW50J1xuaW1wb3J0IEF0UnVsZSBmcm9tICcuL2F0LXJ1bGUnXG5pbXBvcnQgdmVuZG9yIGZyb20gJy4vdmVuZG9yJ1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UnXG5pbXBvcnQgbGlzdCBmcm9tICcuL2xpc3QnXG5pbXBvcnQgUnVsZSBmcm9tICcuL3J1bGUnXG5pbXBvcnQgUm9vdCBmcm9tICcuL3Jvb3QnXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHtAbGluayBQcm9jZXNzb3J9IGluc3RhbmNlIHRoYXQgd2lsbCBhcHBseSBgcGx1Z2luc2BcbiAqIGFzIENTUyBwcm9jZXNzb3JzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPFBsdWdpbnxwbHVnaW5GdW5jdGlvbj58UHJvY2Vzc29yfSBwbHVnaW5zIFBvc3RDU1MgcGx1Z2lucy5cbiAqICAgICAgICBTZWUge0BsaW5rIFByb2Nlc3NvciN1c2V9IGZvciBwbHVnaW4gZm9ybWF0LlxuICpcbiAqIEByZXR1cm4ge1Byb2Nlc3Nvcn0gUHJvY2Vzc29yIHRvIHByb2Nlc3MgbXVsdGlwbGUgQ1NTLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgcG9zdGNzcyBmcm9tICdwb3N0Y3NzJ1xuICpcbiAqIHBvc3Rjc3MocGx1Z2lucykucHJvY2Vzcyhjc3MsIHsgZnJvbSwgdG8gfSkudGhlbihyZXN1bHQgPT4ge1xuICogICBjb25zb2xlLmxvZyhyZXN1bHQuY3NzKVxuICogfSlcbiAqXG4gKiBAbmFtZXNwYWNlIHBvc3Rjc3NcbiAqL1xuZnVuY3Rpb24gcG9zdGNzcyAoLi4ucGx1Z2lucykge1xuICBpZiAocGx1Z2lucy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShwbHVnaW5zWzBdKSkge1xuICAgIHBsdWdpbnMgPSBwbHVnaW5zWzBdXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9jZXNzb3IocGx1Z2lucylcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgUG9zdENTUyBwbHVnaW4gd2l0aCBhIHN0YW5kYXJkIEFQSS5cbiAqXG4gKiBUaGUgbmV3bHktd3JhcHBlZCBmdW5jdGlvbiB3aWxsIHByb3ZpZGUgYm90aCB0aGUgbmFtZSBhbmQgUG9zdENTU1xuICogdmVyc2lvbiBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwcm9jZXNzb3IgPSBwb3N0Y3NzKFtyZXBsYWNlXSlcbiAqIHByb2Nlc3Nvci5wbHVnaW5zWzBdLnBvc3Rjc3NQbHVnaW4gIC8vPT4gJ3Bvc3Rjc3MtcmVwbGFjZSdcbiAqIHByb2Nlc3Nvci5wbHVnaW5zWzBdLnBvc3Rjc3NWZXJzaW9uIC8vPT4gJzYuMC4wJ1xuICogYGBgXG4gKlxuICogVGhlIHBsdWdpbiBmdW5jdGlvbiByZWNlaXZlcyAyIGFyZ3VtZW50czoge0BsaW5rIFJvb3R9XG4gKiBhbmQge0BsaW5rIFJlc3VsdH0gaW5zdGFuY2UuIFRoZSBmdW5jdGlvbiBzaG91bGQgbXV0YXRlIHRoZSBwcm92aWRlZFxuICogYFJvb3RgIG5vZGUuIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gY3JlYXRlIGEgbmV3IGBSb290YCBub2RlXG4gKiBhbmQgb3ZlcnJpZGUgdGhlIGByZXN1bHQucm9vdGAgcHJvcGVydHkuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGNsZWFuZXIgPSBwb3N0Y3NzLnBsdWdpbigncG9zdGNzcy1jbGVhbmVyJywgKCkgPT4ge1xuICogICByZXR1cm4gKHJvb3QsIHJlc3VsdCkgPT4ge1xuICogICAgIHJlc3VsdC5yb290ID0gcG9zdGNzcy5yb290KClcbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEFzIGEgY29udmVuaWVuY2UsIHBsdWdpbnMgYWxzbyBleHBvc2UgYSBgcHJvY2Vzc2AgbWV0aG9kIHNvIHRoYXQgeW91IGNhbiB1c2VcbiAqIHRoZW0gYXMgc3RhbmRhbG9uZSB0b29scy5cbiAqXG4gKiBgYGBqc1xuICogY2xlYW5lci5wcm9jZXNzKGNzcywgcHJvY2Vzc09wdHMsIHBsdWdpbk9wdHMpXG4gKiAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG86XG4gKiBwb3N0Y3NzKFsgY2xlYW5lcihwbHVnaW5PcHRzKSBdKS5wcm9jZXNzKGNzcywgcHJvY2Vzc09wdHMpXG4gKiBgYGBcbiAqXG4gKiBBc3luY2hyb25vdXMgcGx1Z2lucyBzaG91bGQgcmV0dXJuIGEgYFByb21pc2VgIGluc3RhbmNlLlxuICpcbiAqIGBgYGpzXG4gKiBwb3N0Y3NzLnBsdWdpbigncG9zdGNzcy1pbXBvcnQnLCAoKSA9PiB7XG4gKiAgIHJldHVybiAocm9vdCwgcmVzdWx0KSA9PiB7XG4gKiAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gKiAgICAgICBmcy5yZWFkRmlsZSgnYmFzZS5jc3MnLCAoYmFzZSkgPT4ge1xuICogICAgICAgICByb290LnByZXBlbmQoYmFzZSlcbiAqICAgICAgICAgcmVzb2x2ZSgpXG4gKiAgICAgICB9KVxuICogICAgIH0pXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBBZGQgd2FybmluZ3MgdXNpbmcgdGhlIHtAbGluayBOb2RlI3dhcm59IG1ldGhvZC5cbiAqIFNlbmQgZGF0YSB0byBvdGhlciBwbHVnaW5zIHVzaW5nIHRoZSB7QGxpbmsgUmVzdWx0I21lc3NhZ2VzfSBhcnJheS5cbiAqXG4gKiBgYGBqc1xuICogcG9zdGNzcy5wbHVnaW4oJ3Bvc3Rjc3MtY2FuaXVzZS10ZXN0JywgKCkgPT4ge1xuICogICByZXR1cm4gKHJvb3QsIHJlc3VsdCkgPT4ge1xuICogICAgIHJvb3Qud2Fsa0RlY2xzKGRlY2wgPT4ge1xuICogICAgICAgaWYgKCFjYW5pdXNlLnN1cHBvcnQoZGVjbC5wcm9wKSkge1xuICogICAgICAgICBkZWNsLndhcm4ocmVzdWx0LCAnU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCAnICsgZGVjbC5wcm9wKVxuICogICAgICAgfVxuICogICAgIH0pXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgICAgICBQb3N0Q1NTIHBsdWdpbiBuYW1lLiBTYW1lIGFzIGluIGBuYW1lYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgaW4gYHBhY2thZ2UuanNvbmAuIEl0IHdpbGwgYmUgc2F2ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIGBwbHVnaW4ucG9zdGNzc1BsdWdpbmAgcHJvcGVydHkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpbml0aWFsaXplciBXaWxsIHJlY2VpdmUgcGx1Z2luIG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzaG91bGQgcmV0dXJuIHtAbGluayBwbHVnaW5GdW5jdGlvbn1cbiAqXG4gKiBAcmV0dXJuIHtQbHVnaW59IFBvc3RDU1MgcGx1Z2luLlxuICovXG5wb3N0Y3NzLnBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbiAobmFtZSwgaW5pdGlhbGl6ZXIpIHtcbiAgZnVuY3Rpb24gY3JlYXRvciAoLi4uYXJncykge1xuICAgIGxldCB0cmFuc2Zvcm1lciA9IGluaXRpYWxpemVyKC4uLmFyZ3MpXG4gICAgdHJhbnNmb3JtZXIucG9zdGNzc1BsdWdpbiA9IG5hbWVcbiAgICB0cmFuc2Zvcm1lci5wb3N0Y3NzVmVyc2lvbiA9IChuZXcgUHJvY2Vzc29yKCkpLnZlcnNpb25cbiAgICByZXR1cm4gdHJhbnNmb3JtZXJcbiAgfVxuXG4gIGxldCBjYWNoZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRvciwgJ3Bvc3Rjc3MnLCB7XG4gICAgZ2V0ICgpIHtcbiAgICAgIGlmICghY2FjaGUpIGNhY2hlID0gY3JlYXRvcigpXG4gICAgICByZXR1cm4gY2FjaGVcbiAgICB9XG4gIH0pXG5cbiAgY3JlYXRvci5wcm9jZXNzID0gZnVuY3Rpb24gKGNzcywgcHJvY2Vzc09wdHMsIHBsdWdpbk9wdHMpIHtcbiAgICByZXR1cm4gcG9zdGNzcyhbY3JlYXRvcihwbHVnaW5PcHRzKV0pLnByb2Nlc3MoY3NzLCBwcm9jZXNzT3B0cylcbiAgfVxuXG4gIHJldHVybiBjcmVhdG9yXG59XG5cbi8qKlxuICogRGVmYXVsdCBmdW5jdGlvbiB0byBjb252ZXJ0IGEgbm9kZSB0cmVlIGludG8gYSBDU1Mgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgICAgICBTdGFydCBub2RlIGZvciBzdHJpbmdpZmluZy4gVXN1YWxseSB7QGxpbmsgUm9vdH0uXG4gKiBAcGFyYW0ge2J1aWxkZXJ9IGJ1aWxkZXIgRnVuY3Rpb24gdG8gY29uY2F0ZW5hdGUgQ1NTIGZyb20gbm9kZeKAmXMgcGFydHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBnZW5lcmF0ZSBzdHJpbmcgYW5kIHNvdXJjZSBtYXAuXG4gKlxuICogQHJldHVybiB7dm9pZH1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xucG9zdGNzcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnlcblxuLyoqXG4gKiBQYXJzZXMgc291cmNlIGNzcyBhbmQgcmV0dXJucyBhIG5ldyB7QGxpbmsgUm9vdH0gbm9kZSxcbiAqIHdoaWNoIGNvbnRhaW5zIHRoZSBzb3VyY2UgQ1NTIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHRvU3RyaW5nfSBjc3MgICBTdHJpbmcgd2l0aCBpbnB1dCBDU1Mgb3IgYW55IG9iamVjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdG9TdHJpbmcoKSBtZXRob2QsIGxpa2UgYSBCdWZmZXJcbiAqIEBwYXJhbSB7cHJvY2Vzc09wdGlvbnN9IFtvcHRzXSBPcHRpb25zIHdpdGggb25seSBgZnJvbWAgYW5kIGBtYXBgIGtleXMuXG4gKlxuICogQHJldHVybiB7Um9vdH0gUG9zdENTUyBBU1QuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNpbXBsZSBDU1MgY29uY2F0ZW5hdGlvbiB3aXRoIHNvdXJjZSBtYXAgc3VwcG9ydFxuICogY29uc3Qgcm9vdDEgPSBwb3N0Y3NzLnBhcnNlKGNzczEsIHsgZnJvbTogZmlsZTEgfSlcbiAqIGNvbnN0IHJvb3QyID0gcG9zdGNzcy5wYXJzZShjc3MyLCB7IGZyb206IGZpbGUyIH0pXG4gKiByb290MS5hcHBlbmQocm9vdDIpLnRvUmVzdWx0KCkuY3NzXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbnBvc3Rjc3MucGFyc2UgPSBwYXJzZVxuXG4vKipcbiAqIENvbnRhaW5zIHRoZSB7QGxpbmsgdmVuZG9yfSBtb2R1bGUuXG4gKlxuICogQHR5cGUge3ZlbmRvcn1cbiAqXG4gKiBAZXhhbXBsZVxuICogcG9zdGNzcy52ZW5kb3IudW5wcmVmaXhlZCgnLW1vei10YWInKSAvLz0+IFsndGFiJ11cbiAqL1xucG9zdGNzcy52ZW5kb3IgPSB2ZW5kb3JcblxuLyoqXG4gKiBDb250YWlucyB0aGUge0BsaW5rIGxpc3R9IG1vZHVsZS5cbiAqXG4gKiBAbWVtYmVyIHtsaXN0fVxuICpcbiAqIEBleGFtcGxlXG4gKiBwb3N0Y3NzLmxpc3Quc3BhY2UoJzVweCBjYWxjKDEwJSArIDVweCknKSAvLz0+IFsnNXB4JywgJ2NhbGMoMTAlICsgNXB4KSddXG4gKi9cbnBvc3Rjc3MubGlzdCA9IGxpc3RcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBDb21tZW50fSBub2RlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbZGVmYXVsdHNdIFByb3BlcnRpZXMgZm9yIHRoZSBuZXcgbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHtDb21tZW50fSBOZXcgY29tbWVudCBub2RlXG4gKlxuICogQGV4YW1wbGVcbiAqIHBvc3Rjc3MuY29tbWVudCh7IHRleHQ6ICd0ZXN0JyB9KVxuICovXG5wb3N0Y3NzLmNvbW1lbnQgPSBkZWZhdWx0cyA9PiBuZXcgQ29tbWVudChkZWZhdWx0cylcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBBdFJ1bGV9IG5vZGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtkZWZhdWx0c10gUHJvcGVydGllcyBmb3IgdGhlIG5ldyBub2RlLlxuICpcbiAqIEByZXR1cm4ge0F0UnVsZX0gbmV3IGF0LXJ1bGUgbm9kZVxuICpcbiAqIEBleGFtcGxlXG4gKiBwb3N0Y3NzLmF0UnVsZSh7IG5hbWU6ICdjaGFyc2V0JyB9KS50b1N0cmluZygpIC8vPT4gXCJAY2hhcnNldFwiXG4gKi9cbnBvc3Rjc3MuYXRSdWxlID0gZGVmYXVsdHMgPT4gbmV3IEF0UnVsZShkZWZhdWx0cylcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBEZWNsYXJhdGlvbn0gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW2RlZmF1bHRzXSBQcm9wZXJ0aWVzIGZvciB0aGUgbmV3IG5vZGUuXG4gKlxuICogQHJldHVybiB7RGVjbGFyYXRpb259IG5ldyBkZWNsYXJhdGlvbiBub2RlXG4gKlxuICogQGV4YW1wbGVcbiAqIHBvc3Rjc3MuZGVjbCh7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAncmVkJyB9KS50b1N0cmluZygpIC8vPT4gXCJjb2xvcjogcmVkXCJcbiAqL1xucG9zdGNzcy5kZWNsID0gZGVmYXVsdHMgPT4gbmV3IERlY2xhcmF0aW9uKGRlZmF1bHRzKVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFJ1bGV9IG5vZGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtkZWZhdWx0c10gUHJvcGVydGllcyBmb3IgdGhlIG5ldyBub2RlLlxuICpcbiAqIEByZXR1cm4ge1J1bGV9IG5ldyBydWxlIG5vZGVcbiAqXG4gKiBAZXhhbXBsZVxuICogcG9zdGNzcy5ydWxlKHsgc2VsZWN0b3I6ICdhJyB9KS50b1N0cmluZygpIC8vPT4gXCJhIHtcXG59XCJcbiAqL1xucG9zdGNzcy5ydWxlID0gZGVmYXVsdHMgPT4gbmV3IFJ1bGUoZGVmYXVsdHMpXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUm9vdH0gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW2RlZmF1bHRzXSBQcm9wZXJ0aWVzIGZvciB0aGUgbmV3IG5vZGUuXG4gKlxuICogQHJldHVybiB7Um9vdH0gbmV3IHJvb3Qgbm9kZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogcG9zdGNzcy5yb290KHsgYWZ0ZXI6ICdcXG4nIH0pLnRvU3RyaW5nKCkgLy89PiBcIlxcblwiXG4gKi9cbnBvc3Rjc3Mucm9vdCA9IGRlZmF1bHRzID0+IG5ldyBSb290KGRlZmF1bHRzKVxuXG5leHBvcnQgZGVmYXVsdCBwb3N0Y3NzXG4iXSwiZmlsZSI6InBvc3Rjc3MuanMifQ==


/***/ }),
/* 74 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 75 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 76 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;
exports.default = void 0;

var _sourceMap = _interopRequireDefault(__webpack_require__(39));

var _path = _interopRequireDefault(__webpack_require__(3));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MapGenerator =
/*#__PURE__*/
function () {
  function MapGenerator(stringify, root, opts) {
    this.stringify = stringify;
    this.mapOpts = opts.map || {};
    this.root = root;
    this.opts = opts;
  }

  var _proto = MapGenerator.prototype;

  _proto.isMap = function isMap() {
    if (typeof this.opts.map !== 'undefined') {
      return !!this.opts.map;
    }

    return this.previous().length > 0;
  };

  _proto.previous = function previous() {
    var _this = this;

    if (!this.previousMaps) {
      this.previousMaps = [];
      this.root.walk(function (node) {
        if (node.source && node.source.input.map) {
          var map = node.source.input.map;

          if (_this.previousMaps.indexOf(map) === -1) {
            _this.previousMaps.push(map);
          }
        }
      });
    }

    return this.previousMaps;
  };

  _proto.isInline = function isInline() {
    if (typeof this.mapOpts.inline !== 'undefined') {
      return this.mapOpts.inline;
    }

    var annotation = this.mapOpts.annotation;

    if (typeof annotation !== 'undefined' && annotation !== true) {
      return false;
    }

    if (this.previous().length) {
      return this.previous().some(function (i) {
        return i.inline;
      });
    }

    return true;
  };

  _proto.isSourcesContent = function isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
      return this.mapOpts.sourcesContent;
    }

    if (this.previous().length) {
      return this.previous().some(function (i) {
        return i.withContent();
      });
    }

    return true;
  };

  _proto.clearAnnotation = function clearAnnotation() {
    if (this.mapOpts.annotation === false) return;
    var node;

    for (var i = this.root.nodes.length - 1; i >= 0; i--) {
      node = this.root.nodes[i];
      if (node.type !== 'comment') continue;

      if (node.text.indexOf('# sourceMappingURL=') === 0) {
        this.root.removeChild(i);
      }
    }
  };

  _proto.setSourcesContent = function setSourcesContent() {
    var _this2 = this;

    var already = {};
    this.root.walk(function (node) {
      if (node.source) {
        var from = node.source.input.from;

        if (from && !already[from]) {
          already[from] = true;

          var relative = _this2.relative(from);

          _this2.map.setSourceContent(relative, node.source.input.css);
        }
      }
    });
  };

  _proto.applyPrevMaps = function applyPrevMaps() {
    for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var prev = _ref;
      var from = this.relative(prev.file);

      var root = prev.root || _path.default.dirname(prev.file);

      var map = void 0;

      if (this.mapOpts.sourcesContent === false) {
        map = new _sourceMap.default.SourceMapConsumer(prev.text);

        if (map.sourcesContent) {
          map.sourcesContent = map.sourcesContent.map(function () {
            return null;
          });
        }
      } else {
        map = prev.consumer();
      }

      this.map.applySourceMap(map, from, this.relative(root));
    }
  };

  _proto.isAnnotation = function isAnnotation() {
    if (this.isInline()) {
      return true;
    }

    if (typeof this.mapOpts.annotation !== 'undefined') {
      return this.mapOpts.annotation;
    }

    if (this.previous().length) {
      return this.previous().some(function (i) {
        return i.annotation;
      });
    }

    return true;
  };

  _proto.toBase64 = function toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString('base64');
    }

    return window.btoa(unescape(encodeURIComponent(str)));
  };

  _proto.addAnnotation = function addAnnotation() {
    var content;

    if (this.isInline()) {
      content = 'data:application/json;base64,' + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === 'string') {
      content = this.mapOpts.annotation;
    } else {
      content = this.outputFile() + '.map';
    }

    var eol = '\n';
    if (this.css.indexOf('\r\n') !== -1) eol = '\r\n';
    this.css += eol + '/*# sourceMappingURL=' + content + ' */';
  };

  _proto.outputFile = function outputFile() {
    if (this.opts.to) {
      return this.relative(this.opts.to);
    }

    if (this.opts.from) {
      return this.relative(this.opts.from);
    }

    return 'to.css';
  };

  _proto.generateMap = function generateMap() {
    this.generateString();
    if (this.isSourcesContent()) this.setSourcesContent();
    if (this.previous().length > 0) this.applyPrevMaps();
    if (this.isAnnotation()) this.addAnnotation();

    if (this.isInline()) {
      return [this.css];
    }

    return [this.css, this.map];
  };

  _proto.relative = function relative(file) {
    if (file.indexOf('<') === 0) return file;
    if (/^\w+:\/\//.test(file)) return file;
    var from = this.opts.to ? _path.default.dirname(this.opts.to) : '.';

    if (typeof this.mapOpts.annotation === 'string') {
      from = _path.default.dirname(_path.default.resolve(from, this.mapOpts.annotation));
    }

    file = _path.default.relative(from, file);

    if (_path.default.sep === '\\') {
      return file.replace(/\\/g, '/');
    }

    return file;
  };

  _proto.sourcePath = function sourcePath(node) {
    if (this.mapOpts.from) {
      return this.mapOpts.from;
    }

    return this.relative(node.source.input.from);
  };

  _proto.generateString = function generateString() {
    var _this3 = this;

    this.css = '';
    this.map = new _sourceMap.default.SourceMapGenerator({
      file: this.outputFile()
    });
    var line = 1;
    var column = 1;
    var lines, last;
    this.stringify(this.root, function (str, node, type) {
      _this3.css += str;

      if (node && type !== 'end') {
        if (node.source && node.source.start) {
          _this3.map.addMapping({
            source: _this3.sourcePath(node),
            generated: {
              line: line,
              column: column - 1
            },
            original: {
              line: node.source.start.line,
              column: node.source.start.column - 1
            }
          });
        } else {
          _this3.map.addMapping({
            source: '<no source>',
            original: {
              line: 1,
              column: 0
            },
            generated: {
              line: line,
              column: column - 1
            }
          });
        }
      }

      lines = str.match(/\n/g);

      if (lines) {
        line += lines.length;
        last = str.lastIndexOf('\n');
        column = str.length - last;
      } else {
        column += str.length;
      }

      if (node && type !== 'start') {
        var p = node.parent || {
          raws: {}
        };

        if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {
          if (node.source && node.source.end) {
            _this3.map.addMapping({
              source: _this3.sourcePath(node),
              generated: {
                line: line,
                column: column - 2
              },
              original: {
                line: node.source.end.line,
                column: node.source.end.column - 1
              }
            });
          } else {
            _this3.map.addMapping({
              source: '<no source>',
              original: {
                line: 1,
                column: 0
              },
              generated: {
                line: line,
                column: column - 1
              }
            });
          }
        }
      }
    });
  };

  _proto.generate = function generate() {
    this.clearAnnotation();

    if (this.isMap()) {
      return this.generateMap();
    }

    var result = '';
    this.stringify(this.root, function (i) {
      result += i;
    });
    return [result];
  };

  return MapGenerator;
}();

var _default = MapGenerator;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1hcC1nZW5lcmF0b3IuZXM2Il0sIm5hbWVzIjpbIk1hcEdlbmVyYXRvciIsInN0cmluZ2lmeSIsInJvb3QiLCJvcHRzIiwibWFwT3B0cyIsIm1hcCIsImlzTWFwIiwicHJldmlvdXMiLCJsZW5ndGgiLCJwcmV2aW91c01hcHMiLCJ3YWxrIiwibm9kZSIsInNvdXJjZSIsImlucHV0IiwiaW5kZXhPZiIsInB1c2giLCJpc0lubGluZSIsImlubGluZSIsImFubm90YXRpb24iLCJzb21lIiwiaSIsImlzU291cmNlc0NvbnRlbnQiLCJzb3VyY2VzQ29udGVudCIsIndpdGhDb250ZW50IiwiY2xlYXJBbm5vdGF0aW9uIiwibm9kZXMiLCJ0eXBlIiwidGV4dCIsInJlbW92ZUNoaWxkIiwic2V0U291cmNlc0NvbnRlbnQiLCJhbHJlYWR5IiwiZnJvbSIsInJlbGF0aXZlIiwic2V0U291cmNlQ29udGVudCIsImNzcyIsImFwcGx5UHJldk1hcHMiLCJwcmV2IiwiZmlsZSIsInBhdGgiLCJkaXJuYW1lIiwibW96aWxsYSIsIlNvdXJjZU1hcENvbnN1bWVyIiwiY29uc3VtZXIiLCJhcHBseVNvdXJjZU1hcCIsImlzQW5ub3RhdGlvbiIsInRvQmFzZTY0Iiwic3RyIiwiQnVmZmVyIiwidG9TdHJpbmciLCJ3aW5kb3ciLCJidG9hIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJhZGRBbm5vdGF0aW9uIiwiY29udGVudCIsIm91dHB1dEZpbGUiLCJlb2wiLCJ0byIsImdlbmVyYXRlTWFwIiwiZ2VuZXJhdGVTdHJpbmciLCJ0ZXN0IiwicmVzb2x2ZSIsInNlcCIsInJlcGxhY2UiLCJzb3VyY2VQYXRoIiwiU291cmNlTWFwR2VuZXJhdG9yIiwibGluZSIsImNvbHVtbiIsImxpbmVzIiwibGFzdCIsInN0YXJ0IiwiYWRkTWFwcGluZyIsImdlbmVyYXRlZCIsIm9yaWdpbmFsIiwibWF0Y2giLCJsYXN0SW5kZXhPZiIsInAiLCJwYXJlbnQiLCJyYXdzIiwic2VtaWNv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QVFDLGdCQUFBQSxNQUFNLEVBQUVBLE1BQU0sR0FBRztBQUF6QjtBQUhPLGFBQXBCO0FBS0Q7QUFDRjtBQUNGO0FBQ0YsS0FwREQ7QUFxREQsRzs7U0FFRGMsUSxHQUFBLG9CQUFZO0FBQ1YsU0FBS3pELGVBQUw7O0FBRUEsUUFBSSxLQUFLbEIsS0FBTCxFQUFKLEVBQWtCO0FBQ2hCLGFBQU8sS0FBS29ELFdBQUwsRUFBUDtBQUNEOztBQUVELFFBQUl3QixNQUFNLEdBQUcsRUFBYjtBQUNBLFNBQUtqRixTQUFMLENBQWUsS0FBS0MsSUFBcEIsRUFBMEIsVUFBQWtCLENBQUMsRUFBSTtBQUM3QjhELE1BQUFBLE1BQU0sSUFBSTlELENBQVY7QUFDRCxLQUZEO0FBR0EsV0FBTyxDQUFDOEQsTUFBRCxDQUFQO0FBQ0QsRzs7Ozs7ZUFHWWxGLFkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW96aWxsYSBmcm9tICdzb3VyY2UtbWFwJ1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcblxuY2xhc3MgTWFwR2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3IgKHN0cmluZ2lmeSwgcm9vdCwgb3B0cykge1xuICAgIHRoaXMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5XG4gICAgdGhpcy5tYXBPcHRzID0gb3B0cy5tYXAgfHwgeyB9XG4gICAgdGhpcy5yb290ID0gcm9vdFxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgfVxuXG4gIGlzTWFwICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5tYXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gISF0aGlzLm9wdHMubWFwXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMFxuICB9XG5cbiAgcHJldmlvdXMgKCkge1xuICAgIGlmICghdGhpcy5wcmV2aW91c01hcHMpIHtcbiAgICAgIHRoaXMucHJldmlvdXNNYXBzID0gW11cbiAgICAgIHRoaXMucm9vdC53YWxrKG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS5zb3VyY2UgJiYgbm9kZS5zb3VyY2UuaW5wdXQubWFwKSB7XG4gICAgICAgICAgbGV0IG1hcCA9IG5vZGUuc291cmNlLmlucHV0Lm1hcFxuICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzTWFwcy5pbmRleE9mKG1hcCkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzTWFwcy5wdXNoKG1hcClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXNNYXBzXG4gIH1cblxuICBpc0lubGluZSAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuaW5saW5lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5pbmxpbmVcbiAgICB9XG5cbiAgICBsZXQgYW5ub3RhdGlvbiA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uXG4gICAgaWYgKHR5cGVvZiBhbm5vdGF0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBhbm5vdGF0aW9uICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKGkgPT4gaS5pbmxpbmUpXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpc1NvdXJjZXNDb250ZW50ICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnRcbiAgICB9XG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShpID0+IGkud2l0aENvbnRlbnQoKSlcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNsZWFyQW5ub3RhdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBmYWxzZSkgcmV0dXJuXG5cbiAgICBsZXQgbm9kZVxuICAgIGZvciAobGV0IGkgPSB0aGlzLnJvb3Qubm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIG5vZGUgPSB0aGlzLnJvb3Qubm9kZXNbaV1cbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdjb21tZW50JykgY29udGludWVcbiAgICAgIGlmIChub2RlLnRleHQuaW5kZXhPZignIyBzb3VyY2VNYXBwaW5nVVJMPScpID09PSAwKSB7XG4gICAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZChpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldFNvdXJjZXNDb250ZW50ICgpIHtcbiAgICBsZXQgYWxyZWFkeSA9IHsgfVxuICAgIHRoaXMucm9vdC53YWxrKG5vZGUgPT4ge1xuICAgICAgaWYgKG5vZGUuc291cmNlKSB7XG4gICAgICAgIGxldCBmcm9tID0gbm9kZS5zb3VyY2UuaW5wdXQuZnJvbVxuICAgICAgICBpZiAoZnJvbSAmJiAhYWxyZWFkeVtmcm9tXSkge1xuICAgICAgICAgIGFscmVhZHlbZnJvbV0gPSB0cnVlXG4gICAgICAgICAgbGV0IHJlbGF0aXZlID0gdGhpcy5yZWxhdGl2ZShmcm9tKVxuICAgICAgICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQocmVsYXRpdmUsIG5vZGUuc291cmNlLmlucHV0LmNzcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBhcHBseVByZXZNYXBzICgpIHtcbiAgICBmb3IgKGxldCBwcmV2IG9mIHRoaXMucHJldmlvdXMoKSkge1xuICAgICAgbGV0IGZyb20gPSB0aGlzLnJlbGF0aXZlKHByZXYuZmlsZSlcbiAgICAgIGxldCByb290ID0gcHJldi5yb290IHx8IHBhdGguZGlybmFtZShwcmV2LmZpbGUpXG4gICAgICBsZXQgbWFwXG5cbiAgICAgIGlmICh0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgIG1hcCA9IG5ldyBtb3ppbGxhLlNvdXJjZU1hcENvbnN1bWVyKHByZXYudGV4dClcbiAgICAgICAgaWYgKG1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IG1hcC5zb3VyY2VzQ29udGVudC5tYXAoKCkgPT4gbnVsbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwID0gcHJldi5jb25zdW1lcigpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFwLmFwcGx5U291cmNlTWFwKG1hcCwgZnJvbSwgdGhpcy5yZWxhdGl2ZShyb290KSlcbiAgICB9XG4gIH1cblxuICBpc0Fubm90YXRpb24gKCkge1xuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmFubm90YXRpb25cbiAgICB9XG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShpID0+IGkuYW5ub3RhdGlvbilcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHRvQmFzZTY0IChzdHIpIHtcbiAgICBpZiAoQnVmZmVyKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZygnYmFzZTY0JylcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSlcbiAgfVxuXG4gIGFkZEFubm90YXRpb24gKCkge1xuICAgIGxldCBjb250ZW50XG5cbiAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICBjb250ZW50ID0gJ2RhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArXG4gICAgICAgICAgICAgICAgdGhpcy50b0Jhc2U2NCh0aGlzLm1hcC50b1N0cmluZygpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLm91dHB1dEZpbGUoKSArICcubWFwJ1xuICAgIH1cblxuICAgIGxldCBlb2wgPSAnXFxuJ1xuICAgIGlmICh0aGlzLmNzcy5pbmRleE9mKCdcXHJcXG4nKSAhPT0gLTEpIGVvbCA9ICdcXHJcXG4nXG5cbiAgICB0aGlzLmNzcyArPSBlb2wgKyAnLyojIHNvdXJjZU1hcHBpbmdVUkw9JyArIGNvbnRlbnQgKyAnICovJ1xuICB9XG5cbiAgb3V0cHV0RmlsZSAoKSB7XG4gICAgaWYgKHRoaXMub3B0cy50bykge1xuICAgICAgcmV0dXJuIHRoaXMucmVsYXRpdmUodGhpcy5vcHRzLnRvKVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRzLmZyb20pIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbGF0aXZlKHRoaXMub3B0cy5mcm9tKVxuICAgIH1cbiAgICByZXR1cm4gJ3RvLmNzcydcbiAgfVxuXG4gIGdlbmVyYXRlTWFwICgpIHtcbiAgICB0aGlzLmdlbmVyYXRlU3RyaW5nKClcbiAgICBpZiAodGhpcy5pc1NvdXJjZXNDb250ZW50KCkpIHRoaXMuc2V0U291cmNlc0NvbnRlbnQoKVxuICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMCkgdGhpcy5hcHBseVByZXZNYXBzKClcbiAgICBpZiAodGhpcy5pc0Fubm90YXRpb24oKSkgdGhpcy5hZGRBbm5vdGF0aW9uKClcblxuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jc3NdXG4gICAgfVxuICAgIHJldHVybiBbdGhpcy5jc3MsIHRoaXMubWFwXVxuICB9XG5cbiAgcmVsYXRpdmUgKGZpbGUpIHtcbiAgICBpZiAoZmlsZS5pbmRleE9mKCc8JykgPT09IDApIHJldHVybiBmaWxlXG4gICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHJldHVybiBmaWxlXG5cbiAgICBsZXQgZnJvbSA9IHRoaXMub3B0cy50byA/IHBhdGguZGlybmFtZSh0aGlzLm9wdHMudG8pIDogJy4nXG5cbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgZnJvbSA9IHBhdGguZGlybmFtZShwYXRoLnJlc29sdmUoZnJvbSwgdGhpcy5tYXBPcHRzLmFubm90YXRpb24pKVxuICAgIH1cblxuICAgIGZpbGUgPSBwYXRoLnJlbGF0aXZlKGZyb20sIGZpbGUpXG4gICAgaWYgKHBhdGguc2VwID09PSAnXFxcXCcpIHtcbiAgICAgIHJldHVybiBmaWxlLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuICAgIH1cbiAgICByZXR1cm4gZmlsZVxuICB9XG5cbiAgc291cmNlUGF0aCAobm9kZSkge1xuICAgIGlmICh0aGlzLm1hcE9wdHMuZnJvbSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5mcm9tXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbGF0aXZlKG5vZGUuc291cmNlLmlucHV0LmZyb20pXG4gIH1cblxuICBnZW5lcmF0ZVN0cmluZyAoKSB7XG4gICAgdGhpcy5jc3MgPSAnJ1xuICAgIHRoaXMubWFwID0gbmV3IG1vemlsbGEuU291cmNlTWFwR2VuZXJhdG9yKHsgZmlsZTogdGhpcy5vdXRwdXRGaWxlKCkgfSlcblxuICAgIGxldCBsaW5lID0gMVxuICAgIGxldCBjb2x1bW4gPSAxXG5cbiAgICBsZXQgbGluZXMsIGxhc3RcbiAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIChzdHIsIG5vZGUsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMuY3NzICs9IHN0clxuXG4gICAgICBpZiAobm9kZSAmJiB0eXBlICE9PSAnZW5kJykge1xuICAgICAgICBpZiAobm9kZS5zb3VyY2UgJiYgbm9kZS5zb3VyY2Uuc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VQYXRoKG5vZGUpLFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7IGxpbmUsIGNvbHVtbjogY29sdW1uIC0gMSB9LFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogbm9kZS5zb3VyY2Uuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBub2RlLnNvdXJjZS5zdGFydC5jb2x1bW4gLSAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogJzxubyBzb3VyY2U+JyxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7IGxpbmU6IDEsIGNvbHVtbjogMCB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7IGxpbmUsIGNvbHVtbjogY29sdW1uIC0gMSB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuL2cpXG4gICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgbGluZSArPSBsaW5lcy5sZW5ndGhcbiAgICAgICAgbGFzdCA9IHN0ci5sYXN0SW5kZXhPZignXFxuJylcbiAgICAgICAgY29sdW1uID0gc3RyLmxlbmd0aCAtIGxhc3RcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbiArPSBzdHIubGVuZ3RoXG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlICYmIHR5cGUgIT09ICdzdGFydCcpIHtcbiAgICAgICAgbGV0IHAgPSBub2RlLnBhcmVudCB8fCB7IHJhd3M6IHsgfSB9XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdkZWNsJyB8fCBub2RlICE9PSBwLmxhc3QgfHwgcC5yYXdzLnNlbWljb2xvbikge1xuICAgICAgICAgIGlmIChub2RlLnNvdXJjZSAmJiBub2RlLnNvdXJjZS5lbmQpIHtcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlUGF0aChub2RlKSxcbiAgICAgICAgICAgICAgZ2VuZXJhdGVkOiB7IGxpbmUsIGNvbHVtbjogY29sdW1uIC0gMiB9LFxuICAgICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IG5vZGUuc291cmNlLmVuZC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogbm9kZS5zb3VyY2UuZW5kLmNvbHVtbiAtIDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICAgIHNvdXJjZTogJzxubyBzb3VyY2U+JyxcbiAgICAgICAgICAgICAgb3JpZ2luYWw6IHsgbGluZTogMSwgY29sdW1uOiAwIH0sXG4gICAgICAgICAgICAgIGdlbmVyYXRlZDogeyBsaW5lLCBjb2x1bW46IGNvbHVtbiAtIDEgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZ2VuZXJhdGUgKCkge1xuICAgIHRoaXMuY2xlYXJBbm5vdGF0aW9uKClcblxuICAgIGlmICh0aGlzLmlzTWFwKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlTWFwKClcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gJydcbiAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIGkgPT4ge1xuICAgICAgcmVzdWx0ICs9IGlcbiAgICB9KVxuICAgIHJldHVybiBbcmVzdWx0XVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEdlbmVyYXRvclxuIl0sImZpbGUiOiJtYXAtZ2VuZXJhdG9yLmpzIn0=

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18).Buffer))

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 79 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 80 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 81 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(8);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(8);
var binarySearch = __webpack_require__(84);
var ArraySet = __webpack_require__(42).ArraySet;
var base64VLQ = __webpack_require__(41);
var quickSort = __webpack_require__(85).quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),
/* 84 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),
/* 85 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __webpack_require__(40).SourceMapGenerator;
var util = __webpack_require__(8);

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = warnOnce;
var printed = {};

function warnOnce(message) {
  if (printed[message]) return;
  printed[message] = true;

  if (typeof console !== 'undefined' && console.warn) {
    console.warn(message);
  }
}

module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndhcm4tb25jZS5lczYiXSwibmFtZXMiOlsicHJpbnRlZCIsIndhcm5PbmNlIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsT0FBTyxHQUFHLEVBQWQ7O0FBRWUsU0FBU0MsUUFBVCxDQUFtQkMsT0FBbkIsRUFBNEI7QUFDekMsTUFBSUYsT0FBTyxDQUFDRSxPQUFELENBQVgsRUFBc0I7QUFDdEJGLEVBQUFBLE9BQU8sQ0FBQ0UsT0FBRCxDQUFQLEdBQW1CLElBQW5COztBQUVBLE1BQUksT0FBT0MsT0FBUCxLQUFtQixXQUFuQixJQUFrQ0EsT0FBTyxDQUFDQyxJQUE5QyxFQUFvRDtBQUNsREQsSUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWFGLE9BQWI7QUFDRDtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsibGV0IHByaW50ZWQgPSB7IH1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2Fybk9uY2UgKG1lc3NhZ2UpIHtcbiAgaWYgKHByaW50ZWRbbWVzc2FnZV0pIHJldHVyblxuICBwcmludGVkW21lc3NhZ2VdID0gdHJ1ZVxuXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpXG4gIH1cbn1cbiJdLCJmaWxlIjoid2Fybi1vbmNlLmpzIn0=


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _warning = _interopRequireDefault(__webpack_require__(89));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Provides the result of the PostCSS transformations.
 *
 * A Result instance is returned by {@link LazyResult#then}
 * or {@link Root#toResult} methods.
 *
 * @example
 * postcss([autoprefixer]).process(css).then(result => {
 *  console.log(result.css)
 * })
 *
 * @example
 * const result2 = postcss.parse(css).toResult()
 */
var Result =
/*#__PURE__*/
function () {
  /**
   * @param {Processor} processor Processor used for this transformation.
   * @param {Root}      root      Root node after all transformations.
   * @param {processOptions} opts Options from the {@link Processor#process}
   *                              or {@link Root#toResult}.
   */
  function Result(processor, root, opts) {
    /**
     * The Processor instance used for this transformation.
     *
     * @type {Processor}
     *
     * @example
     * for (const plugin of result.processor.plugins) {
     *   if (plugin.postcssPlugin === 'postcss-bad') {
     *     throw 'postcss-good is incompatible with postcss-bad'
     *   }
     * })
     */
    this.processor = processor;
    /**
     * Contains messages from plugins (e.g., warnings or custom messages).
     * Each message should have type and plugin properties.
     *
     * @type {Message[]}
     *
     * @example
     * postcss.plugin('postcss-min-browser', () => {
     *   return (root, result) => {
     *     const browsers = detectMinBrowsersByCanIUse(root)
     *     result.messages.push({
     *       type: 'min-browser',
     *       plugin: 'postcss-min-browser',
     *       browsers
     *     })
     *   }
     * })
     */

    this.messages = [];
    /**
     * Root node after all transformations.
     *
     * @type {Root}
     *
     * @example
     * root.toResult().root === root
     */

    this.root = root;
    /**
     * Options from the {@link Processor#process} or {@link Root#toResult} call
     * that produced this Result instance.
     *
     * @type {processOptions}
     *
     * @example
     * root.toResult(opts).opts === opts
     */

    this.opts = opts;
    /**
     * A CSS string representing of {@link Result#root}.
     *
     * @type {string}
     *
     * @example
     * postcss.parse('a{}').toResult().css //=> "a{}"
     */

    this.css = undefined;
    /**
     * An instance of `SourceMapGenerator` class from the `source-map` library,
     * representing changes to the {@link Result#root} instance.
     *
     * @type {SourceMapGenerator}
     *
     * @example
     * result.map.toJSON() //=> { version: 3, file: 'a.css', … }
     *
     * @example
     * if (result.map) {
     *   fs.writeFileSync(result.opts.to + '.map', result.map.toString())
     * }
     */

    this.map = undefined;
  }
  /**
   * Returns for @{link Result#css} content.
   *
   * @example
   * result + '' === result.css
   *
   * @return {string} String representing of {@link Result#root}.
   */


  var _proto = Result.prototype;

  _proto.toString = function toString() {
    return this.css;
  }
  /**
   * Creates an instance of {@link Warning} and adds it
   * to {@link Result#messages}.
   *
   * @param {string} text        Warning message.
   * @param {Object} [opts]      Warning options.
   * @param {Node}   opts.node   CSS node that caused the warning.
   * @param {string} opts.word   Word in CSS source that caused the warning.
   * @param {number} opts.index  Index in CSS node string that caused
   *                             the warning.
   * @param {string} opts.plugin Name of the plugin that created
   *                             this warning. {@link Result#warn} fills
   *                             this property automatically.
   *
   * @return {Warning} Created warning.
   */
  ;

  _proto.warn = function warn(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }

    var warning = new _warning.default(text, opts);
    this.messages.push(warning);
    return warning;
  }
  /**
     * Returns warnings from plugins. Filters {@link Warning} instances
     * from {@link Result#messages}.
     *
     * @example
     * result.warnings().forEach(warn => {
     *   console.warn(warn.toString())
     * })
     *
     * @return {Warning[]} Warnings from plugins.
     */
  ;

  _proto.warnings = function warnings() {
    return this.messages.filter(function (i) {
      return i.type === 'warning';
    });
  }
  /**
   * An alias for the {@link Result#css} property.
   * Use it with syntaxes that generate non-CSS output.
   *
   * @type {string}
   *
   * @example
   * result.css === result.content
   */
  ;

  _createClass(Result, [{
    key: "content",
    get: function get() {
      return this.css;
    }
  }]);

  return Result;
}();

var _default = Result;
/**
 * @typedef  {object} Message
 * @property {string} type   Message type.
 * @property {string} plugin Source PostCSS plugin name.
 */

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlc3VsdC5lczYiXSwibmFtZXMiOlsiUmVzdWx0IiwicHJvY2Vzc29yIiwicm9vdCIsIm9wdHMiLCJtZXNzYWdlcyIsImNzcyIsInVuZGVmaW5lZCIsIm1hcCIsInRvU3RyaW5nIiwid2FybiIsInRleHQiLCJwbHVnaW4iLCJsYXN0UGx1Z2luIiwicG9zdGNzc1BsdWdpbiIsIndhcm5pbmciLCJXYXJuaW5nIiwicHVzaCIsIndhcm5pbmdzIiwiZmlsdGVyIiwiaSIsInR5cGUiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0lBY01BLE07OztBQUNKOzs7Ozs7QUFNQSxrQkFBYUMsU0FBYixFQUF3QkMsSUFBeEIsRUFBOEJDLElBQTlCLEVBQW9DO0FBQ2xDOzs7Ozs7Ozs7Ozs7QUFZQSxTQUFLRixTQUFMLEdBQWlCQSxTQUFqQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBLFNBQUtHLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQTs7Ozs7Ozs7O0FBUUEsU0FBS0YsSUFBTCxHQUFZQSxJQUFaO0FBQ0E7Ozs7Ozs7Ozs7QUFTQSxTQUFLQyxJQUFMLEdBQVlBLElBQVo7QUFDQTs7Ozs7Ozs7O0FBUUEsU0FBS0UsR0FBTCxHQUFXQyxTQUFYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWNBLFNBQUtDLEdBQUwsR0FBV0QsU0FBWDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7OztTQVFBRSxRLEdBQUEsb0JBQVk7QUFDVixXQUFPLEtBQUtILEdBQVo7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FnQkFJLEksR0FBQSxjQUFNQyxJQUFOLEVBQVlQLElBQVosRUFBd0I7QUFBQSxRQUFaQSxJQUFZO0FBQVpBLE1BQUFBLElBQVksR0FBTCxFQUFLO0FBQUE7O0FBQ3RCLFFBQUksQ0FBQ0EsSUFBSSxDQUFDUSxNQUFWLEVBQWtCO0FBQ2hCLFVBQUksS0FBS0MsVUFBTCxJQUFtQixLQUFLQSxVQUFMLENBQWdCQyxhQUF2QyxFQUFzRDtBQUNwRFYsUUFBQUEsSUFBSSxDQUFDUSxNQUFMLEdBQWMsS0FBS0MsVUFBTCxDQUFnQkMsYUFBOUI7QUFDRDtBQUNGOztBQUVELFFBQUlDLE9BQU8sR0FBRyxJQUFJQyxnQkFBSixDQUFZTCxJQUFaLEVBQWtCUCxJQUFsQixDQUFkO0FBQ0EsU0FBS0MsUUFBTCxDQUFjWSxJQUFkLENBQW1CRixPQUFuQjtBQUVBLFdBQU9BLE9BQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7O1NBV0FHLFEsR0FBQSxvQkFBWTtBQUNWLFdBQU8sS0FBS2IsUUFBTCxDQUFjYyxNQUFkLENBQXFCLFVBQUFDLENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUNDLElBQUYsS0FBVyxTQUFmO0FBQUEsS0FBdEIsQ0FBUDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7d0JBU2U7QUFDYixhQUFPLEtBQUtmLEdBQVo7QUFDRDs7Ozs7O2VBR1lMLE07QUFFZiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXYXJuaW5nIGZyb20gJy4vd2FybmluZydcblxuLyoqXG4gKiBQcm92aWRlcyB0aGUgcmVzdWx0IG9mIHRoZSBQb3N0Q1NTIHRyYW5zZm9ybWF0aW9ucy5cbiAqXG4gKiBBIFJlc3VsdCBpbnN0YW5jZSBpcyByZXR1cm5lZCBieSB7QGxpbmsgTGF6eVJlc3VsdCN0aGVufVxuICogb3Ige0BsaW5rIFJvb3QjdG9SZXN1bHR9IG1ldGhvZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIHBvc3Rjc3MoW2F1dG9wcmVmaXhlcl0pLnByb2Nlc3MoY3NzKS50aGVuKHJlc3VsdCA9PiB7XG4gKiAgY29uc29sZS5sb2cocmVzdWx0LmNzcylcbiAqIH0pXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJlc3VsdDIgPSBwb3N0Y3NzLnBhcnNlKGNzcykudG9SZXN1bHQoKVxuICovXG5jbGFzcyBSZXN1bHQge1xuICAvKipcbiAgICogQHBhcmFtIHtQcm9jZXNzb3J9IHByb2Nlc3NvciBQcm9jZXNzb3IgdXNlZCBmb3IgdGhpcyB0cmFuc2Zvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtSb290fSAgICAgIHJvb3QgICAgICBSb290IG5vZGUgYWZ0ZXIgYWxsIHRyYW5zZm9ybWF0aW9ucy5cbiAgICogQHBhcmFtIHtwcm9jZXNzT3B0aW9uc30gb3B0cyBPcHRpb25zIGZyb20gdGhlIHtAbGluayBQcm9jZXNzb3IjcHJvY2Vzc31cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciB7QGxpbmsgUm9vdCN0b1Jlc3VsdH0uXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocHJvY2Vzc29yLCByb290LCBvcHRzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIFByb2Nlc3NvciBpbnN0YW5jZSB1c2VkIGZvciB0aGlzIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge1Byb2Nlc3Nvcn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZm9yIChjb25zdCBwbHVnaW4gb2YgcmVzdWx0LnByb2Nlc3Nvci5wbHVnaW5zKSB7XG4gICAgICogICBpZiAocGx1Z2luLnBvc3Rjc3NQbHVnaW4gPT09ICdwb3N0Y3NzLWJhZCcpIHtcbiAgICAgKiAgICAgdGhyb3cgJ3Bvc3Rjc3MtZ29vZCBpcyBpbmNvbXBhdGlibGUgd2l0aCBwb3N0Y3NzLWJhZCdcbiAgICAgKiAgIH1cbiAgICAgKiB9KVxuICAgICAqL1xuICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yXG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgbWVzc2FnZXMgZnJvbSBwbHVnaW5zIChlLmcuLCB3YXJuaW5ncyBvciBjdXN0b20gbWVzc2FnZXMpLlxuICAgICAqIEVhY2ggbWVzc2FnZSBzaG91bGQgaGF2ZSB0eXBlIGFuZCBwbHVnaW4gcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNZXNzYWdlW119XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHBvc3Rjc3MucGx1Z2luKCdwb3N0Y3NzLW1pbi1icm93c2VyJywgKCkgPT4ge1xuICAgICAqICAgcmV0dXJuIChyb290LCByZXN1bHQpID0+IHtcbiAgICAgKiAgICAgY29uc3QgYnJvd3NlcnMgPSBkZXRlY3RNaW5Ccm93c2Vyc0J5Q2FuSVVzZShyb290KVxuICAgICAqICAgICByZXN1bHQubWVzc2FnZXMucHVzaCh7XG4gICAgICogICAgICAgdHlwZTogJ21pbi1icm93c2VyJyxcbiAgICAgKiAgICAgICBwbHVnaW46ICdwb3N0Y3NzLW1pbi1icm93c2VyJyxcbiAgICAgKiAgICAgICBicm93c2Vyc1xuICAgICAqICAgICB9KVxuICAgICAqICAgfVxuICAgICAqIH0pXG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdXG4gICAgLyoqXG4gICAgICogUm9vdCBub2RlIGFmdGVyIGFsbCB0cmFuc2Zvcm1hdGlvbnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Um9vdH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogcm9vdC50b1Jlc3VsdCgpLnJvb3QgPT09IHJvb3RcbiAgICAgKi9cbiAgICB0aGlzLnJvb3QgPSByb290XG4gICAgLyoqXG4gICAgICogT3B0aW9ucyBmcm9tIHRoZSB7QGxpbmsgUHJvY2Vzc29yI3Byb2Nlc3N9IG9yIHtAbGluayBSb290I3RvUmVzdWx0fSBjYWxsXG4gICAgICogdGhhdCBwcm9kdWNlZCB0aGlzIFJlc3VsdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtwcm9jZXNzT3B0aW9uc31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogcm9vdC50b1Jlc3VsdChvcHRzKS5vcHRzID09PSBvcHRzXG4gICAgICovXG4gICAgdGhpcy5vcHRzID0gb3B0c1xuICAgIC8qKlxuICAgICAqIEEgQ1NTIHN0cmluZyByZXByZXNlbnRpbmcgb2Yge0BsaW5rIFJlc3VsdCNyb290fS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHBvc3Rjc3MucGFyc2UoJ2F7fScpLnRvUmVzdWx0KCkuY3NzIC8vPT4gXCJhe31cIlxuICAgICAqL1xuICAgIHRoaXMuY3NzID0gdW5kZWZpbmVkXG4gICAgLyoqXG4gICAgICogQW4gaW5zdGFuY2Ugb2YgYFNvdXJjZU1hcEdlbmVyYXRvcmAgY2xhc3MgZnJvbSB0aGUgYHNvdXJjZS1tYXBgIGxpYnJhcnksXG4gICAgICogcmVwcmVzZW50aW5nIGNoYW5nZXMgdG8gdGhlIHtAbGluayBSZXN1bHQjcm9vdH0gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U291cmNlTWFwR2VuZXJhdG9yfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiByZXN1bHQubWFwLnRvSlNPTigpIC8vPT4geyB2ZXJzaW9uOiAzLCBmaWxlOiAnYS5jc3MnLCDigKYgfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpZiAocmVzdWx0Lm1hcCkge1xuICAgICAqICAgZnMud3JpdGVGaWxlU3luYyhyZXN1bHQub3B0cy50byArICcubWFwJywgcmVzdWx0Lm1hcC50b1N0cmluZygpKVxuICAgICAqIH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZm9yIEB7bGluayBSZXN1bHQjY3NzfSBjb250ZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiByZXN1bHQgKyAnJyA9PT0gcmVzdWx0LmNzc1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRpbmcgb2Yge0BsaW5rIFJlc3VsdCNyb290fS5cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5jc3NcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHtAbGluayBXYXJuaW5nfSBhbmQgYWRkcyBpdFxuICAgKiB0byB7QGxpbmsgUmVzdWx0I21lc3NhZ2VzfS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgICAgICAgIFdhcm5pbmcgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAgICAgIFdhcm5pbmcgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtOb2RlfSAgIG9wdHMubm9kZSAgIENTUyBub2RlIHRoYXQgY2F1c2VkIHRoZSB3YXJuaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53b3JkICAgV29yZCBpbiBDU1Mgc291cmNlIHRoYXQgY2F1c2VkIHRoZSB3YXJuaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5pbmRleCAgSW5kZXggaW4gQ1NTIG5vZGUgc3RyaW5nIHRoYXQgY2F1c2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgd2FybmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMucGx1Z2luIE5hbWUgb2YgdGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2FybmluZy4ge0BsaW5rIFJlc3VsdCN3YXJufSBmaWxsc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBwcm9wZXJ0eSBhdXRvbWF0aWNhbGx5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtXYXJuaW5nfSBDcmVhdGVkIHdhcm5pbmcuXG4gICAqL1xuICB3YXJuICh0ZXh0LCBvcHRzID0geyB9KSB7XG4gICAgaWYgKCFvcHRzLnBsdWdpbikge1xuICAgICAgaWYgKHRoaXMubGFzdFBsdWdpbiAmJiB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbikge1xuICAgICAgICBvcHRzLnBsdWdpbiA9IHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHdhcm5pbmcgPSBuZXcgV2FybmluZyh0ZXh0LCBvcHRzKVxuICAgIHRoaXMubWVzc2FnZXMucHVzaCh3YXJuaW5nKVxuXG4gICAgcmV0dXJuIHdhcm5pbmdcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJldHVybnMgd2FybmluZ3MgZnJvbSBwbHVnaW5zLiBGaWx0ZXJzIHtAbGluayBXYXJuaW5nfSBpbnN0YW5jZXNcbiAgICAgKiBmcm9tIHtAbGluayBSZXN1bHQjbWVzc2FnZXN9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiByZXN1bHQud2FybmluZ3MoKS5mb3JFYWNoKHdhcm4gPT4ge1xuICAgICAqICAgY29uc29sZS53YXJuKHdhcm4udG9TdHJpbmcoKSlcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogQHJldHVybiB7V2FybmluZ1tdfSBXYXJuaW5ncyBmcm9tIHBsdWdpbnMuXG4gICAgICovXG4gIHdhcm5pbmdzICgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5maWx0ZXIoaSA9PiBpLnR5cGUgPT09ICd3YXJuaW5nJylcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBhbGlhcyBmb3IgdGhlIHtAbGluayBSZXN1bHQjY3NzfSBwcm9wZXJ0eS5cbiAgICogVXNlIGl0IHdpdGggc3ludGF4ZXMgdGhhdCBnZW5lcmF0ZSBub24tQ1NTIG91dHB1dC5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcmVzdWx0LmNzcyA9PT0gcmVzdWx0LmNvbnRlbnRcbiAgICovXG4gIGdldCBjb250ZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5jc3NcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZXN1bHRcblxuLyoqXG4gKiBAdHlwZWRlZiAge29iamVjdH0gTWVzc2FnZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgICBNZXNzYWdlIHR5cGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGx1Z2luIFNvdXJjZSBQb3N0Q1NTIHBsdWdpbiBuYW1lLlxuICovXG4iXSwiZmlsZSI6InJlc3VsdC5qcyJ9


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/**
 * Represents a plugin’s warning. It can be created using {@link Node#warn}.
 *
 * @example
 * if (decl.important) {
 *   decl.warn(result, 'Avoid !important', { word: '!important' })
 * }
 */
var Warning =
/*#__PURE__*/
function () {
  /**
   * @param {string} text        Warning message.
   * @param {Object} [opts]      Warning options.
   * @param {Node}   opts.node   CSS node that caused the warning.
   * @param {string} opts.word   Word in CSS source that caused the warning.
   * @param {number} opts.index  Index in CSS node string that caused
   *                             the warning.
   * @param {string} opts.plugin Name of the plugin that created
   *                             this warning. {@link Result#warn} fills
   *                             this property automatically.
   */
  function Warning(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    /**
     * Type to filter warnings from {@link Result#messages}.
     * Always equal to `"warning"`.
     *
     * @type {string}
     *
     * @example
     * const nonWarning = result.messages.filter(i => i.type !== 'warning')
     */
    this.type = 'warning';
    /**
     * The warning message.
     *
     * @type {string}
     *
     * @example
     * warning.text //=> 'Try to avoid !important'
     */

    this.text = text;

    if (opts.node && opts.node.source) {
      var pos = opts.node.positionBy(opts);
      /**
       * Line in the input file with this warning’s source.
       * @type {number}
       *
       * @example
       * warning.line //=> 5
       */

      this.line = pos.line;
      /**
       * Column in the input file with this warning’s source.
       *
       * @type {number}
       *
       * @example
       * warning.column //=> 6
       */

      this.column = pos.column;
    }

    for (var opt in opts) {
      this[opt] = opts[opt];
    }
  }
  /**
   * Returns a warning position and message.
   *
   * @example
   * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'
   *
   * @return {string} Warning position and message.
   */


  var _proto = Warning.prototype;

  _proto.toString = function toString() {
    if (this.node) {
      return this.node.error(this.text, {
        plugin: this.plugin,
        index: this.index,
        word: this.word
      }).message;
    }

    if (this.plugin) {
      return this.plugin + ': ' + this.text;
    }

    return this.text;
  }
  /**
   * @memberof Warning#
   * @member {string} plugin The name of the plugin that created
   *                         it will fill this property automatically.
   *                         this warning. When you call {@link Node#warn}
   *
   * @example
   * warning.plugin //=> 'postcss-important'
   */

  /**
   * @memberof Warning#
   * @member {Node} node Contains the CSS node that caused the warning.
   *
   * @example
   * warning.node.toString() //=> 'color: white !important'
   */
  ;

  return Warning;
}();

var _default = Warning;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndhcm5pbmcuZXM2Il0sIm5hbWVzIjpbIldhcm5pbmciLCJ0ZXh0Iiwib3B0cyIsInR5cGUiLCJub2RlIiwic291cmNlIiwicG9zIiwicG9zaXRpb25CeSIsImxpbmUiLCJjb2x1bW4iLCJvcHQiLCJ0b1N0cmluZyIsImVycm9yIiwicGx1Z2luIiwiaW5kZXgiLCJ3b3JkIiwibWVzc2FnZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Ozs7SUFRTUEsTzs7O0FBQ0o7Ozs7Ozs7Ozs7O0FBV0EsbUJBQWFDLElBQWIsRUFBbUJDLElBQW5CLEVBQStCO0FBQUEsUUFBWkEsSUFBWTtBQUFaQSxNQUFBQSxJQUFZLEdBQUwsRUFBSztBQUFBOztBQUM3Qjs7Ozs7Ozs7O0FBU0EsU0FBS0MsSUFBTCxHQUFZLFNBQVo7QUFDQTs7Ozs7Ozs7O0FBUUEsU0FBS0YsSUFBTCxHQUFZQSxJQUFaOztBQUVBLFFBQUlDLElBQUksQ0FBQ0UsSUFBTCxJQUFhRixJQUFJLENBQUNFLElBQUwsQ0FBVUMsTUFBM0IsRUFBbUM7QUFDakMsVUFBSUMsR0FBRyxHQUFHSixJQUFJLENBQUNFLElBQUwsQ0FBVUcsVUFBVixDQUFxQkwsSUFBckIsQ0FBVjtBQUNBOzs7Ozs7OztBQU9BLFdBQUtNLElBQUwsR0FBWUYsR0FBRyxDQUFDRSxJQUFoQjtBQUNBOzs7Ozs7Ozs7QUFRQSxXQUFLQyxNQUFMLEdBQWNILEdBQUcsQ0FBQ0csTUFBbEI7QUFDRDs7QUFFRCxTQUFLLElBQUlDLEdBQVQsSUFBZ0JSLElBQWhCO0FBQXNCLFdBQUtRLEdBQUwsSUFBWVIsSUFBSSxDQUFDUSxHQUFELENBQWhCO0FBQXRCO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7O1NBUUFDLFEsR0FBQSxvQkFBWTtBQUNWLFFBQUksS0FBS1AsSUFBVCxFQUFlO0FBQ2IsYUFBTyxLQUFLQSxJQUFMLENBQVVRLEtBQVYsQ0FBZ0IsS0FBS1gsSUFBckIsRUFBMkI7QUFDaENZLFFBQUFBLE1BQU0sRUFBRSxLQUFLQSxNQURtQjtBQUVoQ0MsUUFBQUEsS0FBSyxFQUFFLEtBQUtBLEtBRm9CO0FBR2hDQyxRQUFBQSxJQUFJLEVBQUUsS0FBS0E7QUFIcUIsT0FBM0IsRUFJSkMsT0FKSDtBQUtEOztBQUVELFFBQUksS0FBS0gsTUFBVCxFQUFpQjtBQUNmLGFBQU8sS0FBS0EsTUFBTCxHQUFjLElBQWQsR0FBcUIsS0FBS1osSUFBakM7QUFDRDs7QUFFRCxXQUFPLEtBQUtBLElBQVo7QUFDRDtBQUVEOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7OztlQVNhRCxPIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXByZXNlbnRzIGEgcGx1Z2lu4oCZcyB3YXJuaW5nLiBJdCBjYW4gYmUgY3JlYXRlZCB1c2luZyB7QGxpbmsgTm9kZSN3YXJufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaWYgKGRlY2wuaW1wb3J0YW50KSB7XG4gKiAgIGRlY2wud2FybihyZXN1bHQsICdBdm9pZCAhaW1wb3J0YW50JywgeyB3b3JkOiAnIWltcG9ydGFudCcgfSlcbiAqIH1cbiAqL1xuY2xhc3MgV2FybmluZyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAgICAgICAgV2FybmluZyBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdICAgICAgV2FybmluZyBvcHRpb25zLlxuICAgKiBAcGFyYW0ge05vZGV9ICAgb3B0cy5ub2RlICAgQ1NTIG5vZGUgdGhhdCBjYXVzZWQgdGhlIHdhcm5pbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndvcmQgICBXb3JkIGluIENTUyBzb3VyY2UgdGhhdCBjYXVzZWQgdGhlIHdhcm5pbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLmluZGV4ICBJbmRleCBpbiBDU1Mgbm9kZSBzdHJpbmcgdGhhdCBjYXVzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB3YXJuaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5wbHVnaW4gTmFtZSBvZiB0aGUgcGx1Z2luIHRoYXQgY3JlYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3YXJuaW5nLiB7QGxpbmsgUmVzdWx0I3dhcm59IGZpbGxzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHByb3BlcnR5IGF1dG9tYXRpY2FsbHkuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodGV4dCwgb3B0cyA9IHsgfSkge1xuICAgIC8qKlxuICAgICAqIFR5cGUgdG8gZmlsdGVyIHdhcm5pbmdzIGZyb20ge0BsaW5rIFJlc3VsdCNtZXNzYWdlc30uXG4gICAgICogQWx3YXlzIGVxdWFsIHRvIGBcIndhcm5pbmdcImAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBub25XYXJuaW5nID0gcmVzdWx0Lm1lc3NhZ2VzLmZpbHRlcihpID0+IGkudHlwZSAhPT0gJ3dhcm5pbmcnKVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9ICd3YXJuaW5nJ1xuICAgIC8qKlxuICAgICAqIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB3YXJuaW5nLnRleHQgLy89PiAnVHJ5IHRvIGF2b2lkICFpbXBvcnRhbnQnXG4gICAgICovXG4gICAgdGhpcy50ZXh0ID0gdGV4dFxuXG4gICAgaWYgKG9wdHMubm9kZSAmJiBvcHRzLm5vZGUuc291cmNlKSB7XG4gICAgICBsZXQgcG9zID0gb3B0cy5ub2RlLnBvc2l0aW9uQnkob3B0cylcbiAgICAgIC8qKlxuICAgICAgICogTGluZSBpbiB0aGUgaW5wdXQgZmlsZSB3aXRoIHRoaXMgd2FybmluZ+KAmXMgc291cmNlLlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogd2FybmluZy5saW5lIC8vPT4gNVxuICAgICAgICovXG4gICAgICB0aGlzLmxpbmUgPSBwb3MubGluZVxuICAgICAgLyoqXG4gICAgICAgKiBDb2x1bW4gaW4gdGhlIGlucHV0IGZpbGUgd2l0aCB0aGlzIHdhcm5pbmfigJlzIHNvdXJjZS5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiB3YXJuaW5nLmNvbHVtbiAvLz0+IDZcbiAgICAgICAqL1xuICAgICAgdGhpcy5jb2x1bW4gPSBwb3MuY29sdW1uXG4gICAgfVxuXG4gICAgZm9yIChsZXQgb3B0IGluIG9wdHMpIHRoaXNbb3B0XSA9IG9wdHNbb3B0XVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB3YXJuaW5nIHBvc2l0aW9uIGFuZCBtZXNzYWdlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB3YXJuaW5nLnRvU3RyaW5nKCkgLy89PiAncG9zdGNzcy1saW50OmEuY3NzOjEwOjE0OiBBdm9pZCAhaW1wb3J0YW50J1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFdhcm5pbmcgcG9zaXRpb24gYW5kIG1lc3NhZ2UuXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5lcnJvcih0aGlzLnRleHQsIHtcbiAgICAgICAgcGx1Z2luOiB0aGlzLnBsdWdpbixcbiAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgIHdvcmQ6IHRoaXMud29yZFxuICAgICAgfSkubWVzc2FnZVxuICAgIH1cblxuICAgIGlmICh0aGlzLnBsdWdpbikge1xuICAgICAgcmV0dXJuIHRoaXMucGx1Z2luICsgJzogJyArIHRoaXMudGV4dFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRleHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgV2FybmluZyNcbiAgICogQG1lbWJlciB7c3RyaW5nfSBwbHVnaW4gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBmaWxsIHRoaXMgcHJvcGVydHkgYXV0b21hdGljYWxseS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3YXJuaW5nLiBXaGVuIHlvdSBjYWxsIHtAbGluayBOb2RlI3dhcm59XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHdhcm5pbmcucGx1Z2luIC8vPT4gJ3Bvc3Rjc3MtaW1wb3J0YW50J1xuICAgKi9cblxuICAvKipcbiAgICogQG1lbWJlcm9mIFdhcm5pbmcjXG4gICAqIEBtZW1iZXIge05vZGV9IG5vZGUgQ29udGFpbnMgdGhlIENTUyBub2RlIHRoYXQgY2F1c2VkIHRoZSB3YXJuaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB3YXJuaW5nLm5vZGUudG9TdHJpbmcoKSAvLz0+ICdjb2xvcjogd2hpdGUgIWltcG9ydGFudCdcbiAgICovXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdhcm5pbmdcbiJdLCJmaWxlIjoid2FybmluZy5qcyJ9


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _declaration = _interopRequireDefault(__webpack_require__(15));

var _tokenize = _interopRequireDefault(__webpack_require__(91));

var _comment = _interopRequireDefault(__webpack_require__(20));

var _atRule = _interopRequireDefault(__webpack_require__(21));

var _root = _interopRequireDefault(__webpack_require__(44));

var _rule = _interopRequireDefault(__webpack_require__(23));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Parser =
/*#__PURE__*/
function () {
  function Parser(input) {
    this.input = input;
    this.root = new _root.default();
    this.current = this.root;
    this.spaces = '';
    this.semicolon = false;
    this.createTokenizer();
    this.root.source = {
      input: input,
      start: {
        line: 1,
        column: 1
      }
    };
  }

  var _proto = Parser.prototype;

  _proto.createTokenizer = function createTokenizer() {
    this.tokenizer = (0, _tokenize.default)(this.input);
  };

  _proto.parse = function parse() {
    var token;

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();

      switch (token[0]) {
        case 'space':
          this.spaces += token[1];
          break;

        case ';':
          this.freeSemicolon(token);
          break;

        case '}':
          this.end(token);
          break;

        case 'comment':
          this.comment(token);
          break;

        case 'at-word':
          this.atrule(token);
          break;

        case '{':
          this.emptyRule(token);
          break;

        default:
          this.other(token);
          break;
      }
    }

    this.endFile();
  };

  _proto.comment = function comment(token) {
    var node = new _comment.default();
    this.init(node, token[2], token[3]);
    node.source.end = {
      line: token[4],
      column: token[5]
    };
    var text = token[1].slice(2, -2);

    if (/^\s*$/.test(text)) {
      node.text = '';
      node.raws.left = text;
      node.raws.right = '';
    } else {
      var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
      node.text = match[2];
      node.raws.left = match[1];
      node.raws.right = match[3];
    }
  };

  _proto.emptyRule = function emptyRule(token) {
    var node = new _rule.default();
    this.init(node, token[2], token[3]);
    node.selector = '';
    node.raws.between = '';
    this.current = node;
  };

  _proto.other = function other(start) {
    var end = false;
    var type = null;
    var colon = false;
    var bracket = null;
    var brackets = [];
    var tokens = [];
    var token = start;

    while (token) {
      type = token[0];
      tokens.push(token);

      if (type === '(' || type === '[') {
        if (!bracket) bracket = token;
        brackets.push(type === '(' ? ')' : ']');
      } else if (brackets.length === 0) {
        if (type === ';') {
          if (colon) {
            this.decl(tokens);
            return;
          } else {
            break;
          }
        } else if (type === '{') {
          this.rule(tokens);
          return;
        } else if (type === '}') {
          this.tokenizer.back(tokens.pop());
          end = true;
          break;
        } else if (type === ':') {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0) bracket = null;
      }

      token = this.tokenizer.nextToken();
    }

    if (this.tokenizer.endOfFile()) end = true;
    if (brackets.length > 0) this.unclosedBracket(bracket);

    if (end && colon) {
      while (tokens.length) {
        token = tokens[tokens.length - 1][0];
        if (token !== 'space' && token !== 'comment') break;
        this.tokenizer.back(tokens.pop());
      }

      this.decl(tokens);
    } else {
      this.unknownWord(tokens);
    }
  };

  _proto.rule = function rule(tokens) {
    tokens.pop();
    var node = new _rule.default();
    this.init(node, tokens[0][2], tokens[0][3]);
    node.raws.between = this.spacesAndCommentsFromEnd(tokens);
    this.raw(node, 'selector', tokens);
    this.current = node;
  };

  _proto.decl = function decl(tokens) {
    var node = new _declaration.default();
    this.init(node);
    var last = tokens[tokens.length - 1];

    if (last[0] === ';') {
      this.semicolon = true;
      tokens.pop();
    }

    if (last[4]) {
      node.source.end = {
        line: last[4],
        column: last[5]
      };
    } else {
      node.source.end = {
        line: last[2],
        column: last[3]
      };
    }

    while (tokens[0][0] !== 'word') {
      if (tokens.length === 1) this.unknownWord(tokens);
      node.raws.before += tokens.shift()[1];
    }

    node.source.start = {
      line: tokens[0][2],
      column: tokens[0][3]
    };
    node.prop = '';

    while (tokens.length) {
      var type = tokens[0][0];

      if (type === ':' || type === 'space' || type === 'comment') {
        break;
      }

      node.prop += tokens.shift()[1];
    }

    node.raws.between = '';
    var token;

    while (tokens.length) {
      token = tokens.shift();

      if (token[0] === ':') {
        node.raws.between += token[1];
        break;
      } else {
        if (token[0] === 'word' && /\w/.test(token[1])) {
          this.unknownWord([token]);
        }

        node.raws.between += token[1];
      }
    }

    if (node.prop[0] === '_' || node.prop[0] === '*') {
      node.raws.before += node.prop[0];
      node.prop = node.prop.slice(1);
    }

    node.raws.between += this.spacesAndCommentsFromStart(tokens);
    this.precheckMissedSemicolon(tokens);

    for (var i = tokens.length - 1; i > 0; i--) {
      token = tokens[i];

      if (token[1].toLowerCase() === '!important') {
        node.important = true;
        var string = this.stringFrom(tokens, i);
        string = this.spacesFromEnd(tokens) + string;
        if (string !== ' !important') node.raws.important = string;
        break;
      } else if (token[1].toLowerCase() === 'important') {
        var cache = tokens.slice(0);
        var str = '';

        for (var j = i; j > 0; j--) {
          var _type = cache[j][0];

          if (str.trim().indexOf('!') === 0 && _type !== 'space') {
            break;
          }

          str = cache.pop()[1] + str;
        }

        if (str.trim().indexOf('!') === 0) {
          node.important = true;
          node.raws.important = str;
          tokens = cache;
        }
      }

      if (token[0] !== 'space' && token[0] !== 'comment') {
        break;
      }
    }

    this.raw(node, 'value', tokens);
    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);
  };

  _proto.atrule = function atrule(token) {
    var node = new _atRule.default();
    node.name = token[1].slice(1);

    if (node.name === '') {
      this.unnamedAtrule(node, token);
    }

    this.init(node, token[2], token[3]);
    var prev;
    var shift;
    var last = false;
    var open = false;
    var params = [];

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();

      if (token[0] === ';') {
        node.source.end = {
          line: token[2],
          column: token[3]
        };
        this.semicolon = true;
        break;
      } else if (token[0] === '{') {
        open = true;
        break;
      } else if (token[0] === '}') {
        if (params.length > 0) {
          shift = params.length - 1;
          prev = params[shift];

          while (prev && prev[0] === 'space') {
            prev = params[--shift];
          }

          if (prev) {
            node.source.end = {
              line: prev[4],
              column: prev[5]
            };
          }
        }

        this.end(token);
        break;
      } else {
        params.push(token);
      }

      if (this.tokenizer.endOfFile()) {
        last = true;
        break;
      }
    }

    node.raws.between = this.spacesAndCommentsFromEnd(params);

    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params);
      this.raw(node, 'params', params);

      if (last) {
        token = params[params.length - 1];
        node.source.end = {
          line: token[4],
          column: token[5]
        };
        this.spaces = node.raws.between;
        node.raws.between = '';
      }
    } else {
      node.raws.afterName = '';
      node.params = '';
    }

    if (open) {
      node.nodes = [];
      this.current = node;
    }
  };

  _proto.end = function end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }

    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
    this.spaces = '';

    if (this.current.parent) {
      this.current.source.end = {
        line: token[2],
        column: token[3]
      };
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token);
    }
  };

  _proto.endFile = function endFile() {
    if (this.current.parent) this.unclosedBlock();

    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }

    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
  };

  _proto.freeSemicolon = function freeSemicolon(token) {
    this.spaces += token[1];

    if (this.current.nodes) {
      var prev = this.current.nodes[this.current.nodes.length - 1];

      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = '';
      }
    }
  } // Helpers
  ;

  _proto.init = function init(node, line, column) {
    this.current.push(node);
    node.source = {
      start: {
        line: line,
        column: column
      },
      input: this.input
    };
    node.raws.before = this.spaces;
    this.spaces = '';
    if (node.type !== 'comment') this.semicolon = false;
  };

  _proto.raw = function raw(node, prop, tokens) {
    var token, type;
    var length = tokens.length;
    var value = '';
    var clean = true;
    var next, prev;
    var pattern = /^([.|#])?([\w])+/i;

    for (var i = 0; i < length; i += 1) {
      token = tokens[i];
      type = token[0];

      if (type === 'comment' && node.type === 'rule') {
        prev = tokens[i - 1];
        next = tokens[i + 1];

        if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {
          value += token[1];
        } else {
          clean = false;
        }

        continue;
      }

      if (type === 'comment' || type === 'space' && i === length - 1) {
        clean = false;
      } else {
        value += token[1];
      }
    }

    if (!clean) {
      var raw = tokens.reduce(function (all, i) {
        return all + i[1];
      }, '');
      node.raws[prop] = {
        value: value,
        raw: raw
      };
    }

    node[prop] = value;
  };

  _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {
    var lastTokenType;
    var spaces = '';

    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
      spaces = tokens.pop()[1] + spaces;
    }

    return spaces;
  };

  _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {
    var next;
    var spaces = '';

    while (tokens.length) {
      next = tokens[0][0];
      if (next !== 'space' && next !== 'comment') break;
      spaces += tokens.shift()[1];
    }

    return spaces;
  };

  _proto.spacesFromEnd = function spacesFromEnd(tokens) {
    var lastTokenType;
    var spaces = '';

    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== 'space') break;
      spaces = tokens.pop()[1] + spaces;
    }

    return spaces;
  };

  _proto.stringFrom = function stringFrom(tokens, from) {
    var result = '';

    for (var i = from; i < tokens.length; i++) {
      result += tokens[i][1];
    }

    tokens.splice(from, tokens.length - from);
    return result;
  };

  _proto.colon = function colon(tokens) {
    var brackets = 0;
    var token, type, prev;

    for (var i = 0; i < tokens.length; i++) {
      token = tokens[i];
      type = token[0];

      if (type === '(') {
        brackets += 1;
      }

      if (type === ')') {
        brackets -= 1;
      }

      if (brackets === 0 && type === ':') {
        if (!prev) {
          this.doubleColon(token);
        } else if (prev[0] === 'word' && prev[1] === 'progid') {
          continue;
        } else {
          return i;
        }
      }

      prev = token;
    }

    return false;
  } // Errors
  ;

  _proto.unclosedBracket = function unclosedBracket(bracket) {
    throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);
  };

  _proto.unknownWord = function unknownWord(tokens) {
    throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);
  };

  _proto.unexpectedClose = function unexpectedClose(token) {
    throw this.input.error('Unexpected }', token[2], token[3]);
  };

  _proto.unclosedBlock = function unclosedBlock() {
    var pos = this.current.source.start;
    throw this.input.error('Unclosed block', pos.line, pos.column);
  };

  _proto.doubleColon = function doubleColon(token) {
    throw this.input.error('Double colon', token[2], token[3]);
  };

  _proto.unnamedAtrule = function unnamedAtrule(node, token) {
    throw this.input.error('At-rule without name', token[2], token[3]);
  };

  _proto.precheckMissedSemicolon = function precheckMissedSemicolon()
  /* tokens */
  {// Hook for Safe Parser
  };

  _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
    var colon = this.colon(tokens);
    if (colon === false) return;
    var founded = 0;
    var token;

    for (var j = colon - 1; j >= 0; j--) {
      token = tokens[j];

      if (token[0] !== 'space') {
        founded += 1;
        if (founded === 2) break;
      }
    }

    throw this.input.error('Missed semicolon', token[2], token[3]);
  };

  return Parser;
}();

exports.default = Parser;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlci5lczYiXSwibmFtZXMiOlsiUGFyc2VyIiwiaW5wdXQiLCJyb290IiwiUm9vdCIsImN1cnJlbnQiLCJzcGFjZXMiLCJzZW1pY29sb24iLCJjcmVhdGVUb2tlbml6ZXIiLCJzb3VyY2UiLCJzdGFydCIsImxpbmUiLCJjb2x1bW4iLCJ0b2tlbml6ZXIiLCJwYXJzZSIsInRva2VuIiwiZW5kT2ZGaWxlIiwibmV4dFRva2VuIiwiZnJlZVNlbWljb2xvbiIsImVuZCIsImNvbW1lbnQiLCJhdHJ1bGUiLCJlbXB0eVJ1bGUiLCJvdGhlciIsImVuZEZpbGUiLCJub2RlIiwiQ29tbWVudCIsImluaXQiLCJ0ZXh0Iiwic2xpY2UiLCJ0ZXN0IiwicmF3cyIsImxlZnQiLCJyaWdodCIsIm1hdGNoIiwiUnVsZSIsInNlbGVjdG9yIiwiYmV0d2VlbiIsInR5cGUiLCJjb2xvbiIsImJyYWNrZXQiLCJicmFja2V0cyIsInRva2VucyIsInB1c2giLCJsZW5ndGgiLCJkZWNsIiwicnVsZSIsImJhY2siLCJwb3AiLCJ1bmNsb3NlZEJyYWNrZXQiLCJ1bmtub3duV29yZCIsInNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCIsInJhdyIsIkRlY2xhcmF0aW9uIiwibGFzdCIsImJlZm9yZSIsInNoaWZ0IiwicHJvcCIsInNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0IiwicHJlY2hlY2tNaXNzZWRTZW1pY29sb24iLCJpIiwidG9Mb3dlckNhc2UiLCJpbXBvcnRhbnQiLCJzdHJpbmciLCJzdHJpbmdGcm9tIiwic3BhY2VzRnJvbUVuZCIsImNhY2hlIiwic3RyIiwiaiIsInRyaW0iLCJpbmRleE9mIiwidmFsdWUiLCJjaGVja01pc3NlZFNlbWljb2xvbiIsIkF0UnVsZSIsIm5hbWUiLCJ1bm5hbWVkQXRydWxlIiwicHJldiIsIm9wZW4iLCJwYXJhbXMiLCJhZnRlck5hbWUiLCJub2RlcyIsImFmdGVyIiwicGFyZW50IiwidW5leHBlY3RlZENsb3NlIiwidW5jbG9zZWRCbG9jayIsIm93blNlbWljb2xvbiIsImNsZWFuIiwibmV4dCIsInBhdHRlcm4iLCJyZWR1Y2UiLCJhbGwiLCJsYXN0VG9rZW5UeXBlIiwiZnJvbSIsInJlc3VsdCIsInNwbGljZSIsImRvdWJsZUNvbG9uIiwiZXJyb3IiLCJwb3MiLCJmb3VuZGVkIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0lBRXFCQSxNOzs7QUFDbkIsa0JBQWFDLEtBQWIsRUFBb0I7QUFDbEIsU0FBS0EsS0FBTCxHQUFhQSxLQUFiO0FBRUEsU0FBS0MsSUFBTCxHQUFZLElBQUlDLGFBQUosRUFBWjtBQUNBLFNBQUtDLE9BQUwsR0FBZSxLQUFLRixJQUFwQjtBQUNBLFNBQUtHLE1BQUwsR0FBYyxFQUFkO0FBQ0EsU0FBS0MsU0FBTCxHQUFpQixLQUFqQjtBQUVBLFNBQUtDLGVBQUw7QUFDQSxTQUFLTCxJQUFMLENBQVVNLE1BQVYsR0FBbUI7QUFBRVAsTUFBQUEsS0FBSyxFQUFMQSxLQUFGO0FBQVNRLE1BQUFBLEtBQUssRUFBRTtBQUFFQyxRQUFBQSxJQUFJLEVBQUUsQ0FBUjtBQUFXQyxRQUFBQSxNQUFNLEVBQUU7QUFBbkI7QUFBaEIsS0FBbkI7QUFDRDs7OztTQUVESixlLEdBQUEsMkJBQW1CO0FBQ2pCLFNBQUtLLFNBQUwsR0FBaUIsdUJBQVUsS0FBS1gsS0FBZixDQUFqQjtBQUNELEc7O1NBRURZLEssR0FBQSxpQkFBUztBQUNQLFFBQUlDLEtBQUo7O0FBQ0EsV0FBTyxDQUFDLEtBQUtGLFNBQUwsQ0FBZUcsU0FBZixFQUFSLEVBQW9DO0FBQ2xDRCxNQUFBQSxLQUFLLEdBQUcsS0FBS0YsU0FBTCxDQUFlSSxTQUFmLEVBQVI7O0FBRUEsY0FBUUYsS0FBSyxDQUFDLENBQUQsQ0FBYjtBQUNFLGFBQUssT0FBTDtBQUNFLGVBQUtULE1BQUwsSUFBZVMsS0FBSyxDQUFDLENBQUQsQ0FBcEI7QUFDQTs7QUFFRixhQUFLLEdBQUw7QUFDRSxlQUFLRyxhQUFMLENBQW1CSCxLQUFuQjtB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QUssQ0FBaEIsRUFBbUI7QUFDcEI7QUFDRjs7QUFDRCxVQUFNLEtBQUtoRyxLQUFMLENBQVc4RixLQUFYLENBQWlCLGtCQUFqQixFQUFxQ2pGLEtBQUssQ0FBQyxDQUFELENBQTFDLEVBQStDQSxLQUFLLENBQUMsQ0FBRCxDQUFwRCxDQUFOO0FBQ0QsRyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEZWNsYXJhdGlvbiBmcm9tICcuL2RlY2xhcmF0aW9uJ1xuaW1wb3J0IHRva2VuaXplciBmcm9tICcuL3Rva2VuaXplJ1xuaW1wb3J0IENvbW1lbnQgZnJvbSAnLi9jb21tZW50J1xuaW1wb3J0IEF0UnVsZSBmcm9tICcuL2F0LXJ1bGUnXG5pbXBvcnQgUm9vdCBmcm9tICcuL3Jvb3QnXG5pbXBvcnQgUnVsZSBmcm9tICcuL3J1bGUnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yIChpbnB1dCkge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dFxuXG4gICAgdGhpcy5yb290ID0gbmV3IFJvb3QoKVxuICAgIHRoaXMuY3VycmVudCA9IHRoaXMucm9vdFxuICAgIHRoaXMuc3BhY2VzID0gJydcbiAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlXG5cbiAgICB0aGlzLmNyZWF0ZVRva2VuaXplcigpXG4gICAgdGhpcy5yb290LnNvdXJjZSA9IHsgaW5wdXQsIHN0YXJ0OiB7IGxpbmU6IDEsIGNvbHVtbjogMSB9IH1cbiAgfVxuXG4gIGNyZWF0ZVRva2VuaXplciAoKSB7XG4gICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXIodGhpcy5pbnB1dClcbiAgfVxuXG4gIHBhcnNlICgpIHtcbiAgICBsZXQgdG9rZW5cbiAgICB3aGlsZSAoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSB7XG4gICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpXG5cbiAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICc7JzpcbiAgICAgICAgICB0aGlzLmZyZWVTZW1pY29sb24odG9rZW4pXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICB0aGlzLmVuZCh0b2tlbilcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgIHRoaXMuY29tbWVudCh0b2tlbilcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2F0LXdvcmQnOlxuICAgICAgICAgIHRoaXMuYXRydWxlKHRva2VuKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgdGhpcy5lbXB0eVJ1bGUodG9rZW4pXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMub3RoZXIodG9rZW4pXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbmRGaWxlKClcbiAgfVxuXG4gIGNvbW1lbnQgKHRva2VuKSB7XG4gICAgbGV0IG5vZGUgPSBuZXcgQ29tbWVudCgpXG4gICAgdGhpcy5pbml0KG5vZGUsIHRva2VuWzJdLCB0b2tlblszXSlcbiAgICBub2RlLnNvdXJjZS5lbmQgPSB7IGxpbmU6IHRva2VuWzRdLCBjb2x1bW46IHRva2VuWzVdIH1cblxuICAgIGxldCB0ZXh0ID0gdG9rZW5bMV0uc2xpY2UoMiwgLTIpXG4gICAgaWYgKC9eXFxzKiQvLnRlc3QodGV4dCkpIHtcbiAgICAgIG5vZGUudGV4dCA9ICcnXG4gICAgICBub2RlLnJhd3MubGVmdCA9IHRleHRcbiAgICAgIG5vZGUucmF3cy5yaWdodCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtYXRjaCA9IHRleHQubWF0Y2goL14oXFxzKikoW15dKlteXFxzXSkoXFxzKikkLylcbiAgICAgIG5vZGUudGV4dCA9IG1hdGNoWzJdXG4gICAgICBub2RlLnJhd3MubGVmdCA9IG1hdGNoWzFdXG4gICAgICBub2RlLnJhd3MucmlnaHQgPSBtYXRjaFszXVxuICAgIH1cbiAgfVxuXG4gIGVtcHR5UnVsZSAodG9rZW4pIHtcbiAgICBsZXQgbm9kZSA9IG5ldyBSdWxlKClcbiAgICB0aGlzLmluaXQobm9kZSwgdG9rZW5bMl0sIHRva2VuWzNdKVxuICAgIG5vZGUuc2VsZWN0b3IgPSAnJ1xuICAgIG5vZGUucmF3cy5iZXR3ZWVuID0gJydcbiAgICB0aGlzLmN1cnJlbnQgPSBub2RlXG4gIH1cblxuICBvdGhlciAoc3RhcnQpIHtcbiAgICBsZXQgZW5kID0gZmFsc2VcbiAgICBsZXQgdHlwZSA9IG51bGxcbiAgICBsZXQgY29sb24gPSBmYWxzZVxuICAgIGxldCBicmFja2V0ID0gbnVsbFxuICAgIGxldCBicmFja2V0cyA9IFtdXG5cbiAgICBsZXQgdG9rZW5zID0gW11cbiAgICBsZXQgdG9rZW4gPSBzdGFydFxuICAgIHdoaWxlICh0b2tlbikge1xuICAgICAgdHlwZSA9IHRva2VuWzBdXG4gICAgICB0b2tlbnMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHR5cGUgPT09ICcoJyB8fCB0eXBlID09PSAnWycpIHtcbiAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW5cbiAgICAgICAgYnJhY2tldHMucHVzaCh0eXBlID09PSAnKCcgPyAnKScgOiAnXScpXG4gICAgICB9IGVsc2UgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJzsnKSB7XG4gICAgICAgICAgaWYgKGNvbG9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlY2wodG9rZW5zKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICAgIHRoaXMucnVsZSh0b2tlbnMpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ30nKSB7XG4gICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpXG4gICAgICAgICAgZW5kID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJzonKSB7XG4gICAgICAgICAgY29sb24gPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgYnJhY2tldHMucG9wKClcbiAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkgYnJhY2tldCA9IG51bGxcbiAgICAgIH1cblxuICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkgZW5kID0gdHJ1ZVxuICAgIGlmIChicmFja2V0cy5sZW5ndGggPiAwKSB0aGlzLnVuY2xvc2VkQnJhY2tldChicmFja2V0KVxuXG4gICAgaWYgKGVuZCAmJiBjb2xvbikge1xuICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdXG4gICAgICAgIGlmICh0b2tlbiAhPT0gJ3NwYWNlJyAmJiB0b2tlbiAhPT0gJ2NvbW1lbnQnKSBicmVha1xuICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSlcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVjbCh0b2tlbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5rbm93bldvcmQodG9rZW5zKVxuICAgIH1cbiAgfVxuXG4gIHJ1bGUgKHRva2Vucykge1xuICAgIHRva2Vucy5wb3AoKVxuXG4gICAgbGV0IG5vZGUgPSBuZXcgUnVsZSgpXG4gICAgdGhpcy5pbml0KG5vZGUsIHRva2Vuc1swXVsyXSwgdG9rZW5zWzBdWzNdKVxuXG4gICAgbm9kZS5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpXG4gICAgdGhpcy5yYXcobm9kZSwgJ3NlbGVjdG9yJywgdG9rZW5zKVxuICAgIHRoaXMuY3VycmVudCA9IG5vZGVcbiAgfVxuXG4gIGRlY2wgKHRva2Vucykge1xuICAgIGxldCBub2RlID0gbmV3IERlY2xhcmF0aW9uKClcbiAgICB0aGlzLmluaXQobm9kZSlcblxuICAgIGxldCBsYXN0ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVxuICAgIGlmIChsYXN0WzBdID09PSAnOycpIHtcbiAgICAgIHRoaXMuc2VtaWNvbG9uID0gdHJ1ZVxuICAgICAgdG9rZW5zLnBvcCgpXG4gICAgfVxuICAgIGlmIChsYXN0WzRdKSB7XG4gICAgICBub2RlLnNvdXJjZS5lbmQgPSB7IGxpbmU6IGxhc3RbNF0sIGNvbHVtbjogbGFzdFs1XSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc291cmNlLmVuZCA9IHsgbGluZTogbGFzdFsyXSwgY29sdW1uOiBsYXN0WzNdIH1cbiAgICB9XG5cbiAgICB3aGlsZSAodG9rZW5zWzBdWzBdICE9PSAnd29yZCcpIHtcbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB0aGlzLnVua25vd25Xb3JkKHRva2VucylcbiAgICAgIG5vZGUucmF3cy5iZWZvcmUgKz0gdG9rZW5zLnNoaWZ0KClbMV1cbiAgICB9XG4gICAgbm9kZS5zb3VyY2Uuc3RhcnQgPSB7IGxpbmU6IHRva2Vuc1swXVsyXSwgY29sdW1uOiB0b2tlbnNbMF1bM10gfVxuXG4gICAgbm9kZS5wcm9wID0gJydcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbGV0IHR5cGUgPSB0b2tlbnNbMF1bMF1cbiAgICAgIGlmICh0eXBlID09PSAnOicgfHwgdHlwZSA9PT0gJ3NwYWNlJyB8fCB0eXBlID09PSAnY29tbWVudCcpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIG5vZGUucHJvcCArPSB0b2tlbnMuc2hpZnQoKVsxXVxuICAgIH1cblxuICAgIG5vZGUucmF3cy5iZXR3ZWVuID0gJydcblxuICAgIGxldCB0b2tlblxuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICB0b2tlbiA9IHRva2Vucy5zaGlmdCgpXG5cbiAgICAgIGlmICh0b2tlblswXSA9PT0gJzonKSB7XG4gICAgICAgIG5vZGUucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodG9rZW5bMF0gPT09ICd3b3JkJyAmJiAvXFx3Ly50ZXN0KHRva2VuWzFdKSkge1xuICAgICAgICAgIHRoaXMudW5rbm93bldvcmQoW3Rva2VuXSlcbiAgICAgICAgfVxuICAgICAgICBub2RlLnJhd3MuYmV0d2VlbiArPSB0b2tlblsxXVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLnByb3BbMF0gPT09ICdfJyB8fCBub2RlLnByb3BbMF0gPT09ICcqJykge1xuICAgICAgbm9kZS5yYXdzLmJlZm9yZSArPSBub2RlLnByb3BbMF1cbiAgICAgIG5vZGUucHJvcCA9IG5vZGUucHJvcC5zbGljZSgxKVxuICAgIH1cbiAgICBub2RlLnJhd3MuYmV0d2VlbiArPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHRva2VucylcbiAgICB0aGlzLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2VucylcblxuICAgIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICAgIGlmICh0b2tlblsxXS50b0xvd2VyQ2FzZSgpID09PSAnIWltcG9ydGFudCcpIHtcbiAgICAgICAgbm9kZS5pbXBvcnRhbnQgPSB0cnVlXG4gICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnN0cmluZ0Zyb20odG9rZW5zLCBpKVxuICAgICAgICBzdHJpbmcgPSB0aGlzLnNwYWNlc0Zyb21FbmQodG9rZW5zKSArIHN0cmluZ1xuICAgICAgICBpZiAoc3RyaW5nICE9PSAnICFpbXBvcnRhbnQnKSBub2RlLnJhd3MuaW1wb3J0YW50ID0gc3RyaW5nXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09ICdpbXBvcnRhbnQnKSB7XG4gICAgICAgIGxldCBjYWNoZSA9IHRva2Vucy5zbGljZSgwKVxuICAgICAgICBsZXQgc3RyID0gJydcbiAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICBsZXQgdHlwZSA9IGNhY2hlW2pdWzBdXG4gICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZignIScpID09PSAwICYmIHR5cGUgIT09ICdzcGFjZScpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciA9IGNhY2hlLnBvcCgpWzFdICsgc3RyXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZignIScpID09PSAwKSB7XG4gICAgICAgICAgbm9kZS5pbXBvcnRhbnQgPSB0cnVlXG4gICAgICAgICAgbm9kZS5yYXdzLmltcG9ydGFudCA9IHN0clxuICAgICAgICAgIHRva2VucyA9IGNhY2hlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuWzBdICE9PSAnc3BhY2UnICYmIHRva2VuWzBdICE9PSAnY29tbWVudCcpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJhdyhub2RlLCAndmFsdWUnLCB0b2tlbnMpXG5cbiAgICBpZiAobm9kZS52YWx1ZS5pbmRleE9mKCc6JykgIT09IC0xKSB0aGlzLmNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2VucylcbiAgfVxuXG4gIGF0cnVsZSAodG9rZW4pIHtcbiAgICBsZXQgbm9kZSA9IG5ldyBBdFJ1bGUoKVxuICAgIG5vZGUubmFtZSA9IHRva2VuWzFdLnNsaWNlKDEpXG4gICAgaWYgKG5vZGUubmFtZSA9PT0gJycpIHtcbiAgICAgIHRoaXMudW5uYW1lZEF0cnVsZShub2RlLCB0b2tlbilcbiAgICB9XG4gICAgdGhpcy5pbml0KG5vZGUsIHRva2VuWzJdLCB0b2tlblszXSlcblxuICAgIGxldCBwcmV2XG4gICAgbGV0IHNoaWZ0XG4gICAgbGV0IGxhc3QgPSBmYWxzZVxuICAgIGxldCBvcGVuID0gZmFsc2VcbiAgICBsZXQgcGFyYW1zID0gW11cblxuICAgIHdoaWxlICghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIHtcbiAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKClcblxuICAgICAgaWYgKHRva2VuWzBdID09PSAnOycpIHtcbiAgICAgICAgbm9kZS5zb3VyY2UuZW5kID0geyBsaW5lOiB0b2tlblsyXSwgY29sdW1uOiB0b2tlblszXSB9XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmICh0b2tlblswXSA9PT0gJ3snKSB7XG4gICAgICAgIG9wZW4gPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRva2VuWzBdID09PSAnfScpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2hpZnQgPSBwYXJhbXMubGVuZ3RoIC0gMVxuICAgICAgICAgIHByZXYgPSBwYXJhbXNbc2hpZnRdXG4gICAgICAgICAgd2hpbGUgKHByZXYgJiYgcHJldlswXSA9PT0gJ3NwYWNlJykge1xuICAgICAgICAgICAgcHJldiA9IHBhcmFtc1stLXNoaWZ0XVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgbm9kZS5zb3VyY2UuZW5kID0geyBsaW5lOiBwcmV2WzRdLCBjb2x1bW46IHByZXZbNV0gfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZCh0b2tlbilcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIHtcbiAgICAgICAgbGFzdCA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHBhcmFtcylcbiAgICBpZiAocGFyYW1zLmxlbmd0aCkge1xuICAgICAgbm9kZS5yYXdzLmFmdGVyTmFtZSA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQocGFyYW1zKVxuICAgICAgdGhpcy5yYXcobm9kZSwgJ3BhcmFtcycsIHBhcmFtcylcbiAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgIHRva2VuID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXVxuICAgICAgICBub2RlLnNvdXJjZS5lbmQgPSB7IGxpbmU6IHRva2VuWzRdLCBjb2x1bW46IHRva2VuWzVdIH1cbiAgICAgICAgdGhpcy5zcGFjZXMgPSBub2RlLnJhd3MuYmV0d2VlblxuICAgICAgICBub2RlLnJhd3MuYmV0d2VlbiA9ICcnXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmF3cy5hZnRlck5hbWUgPSAnJ1xuICAgICAgbm9kZS5wYXJhbXMgPSAnJ1xuICAgIH1cblxuICAgIGlmIChvcGVuKSB7XG4gICAgICBub2RlLm5vZGVzID0gW11cbiAgICAgIHRoaXMuY3VycmVudCA9IG5vZGVcbiAgICB9XG4gIH1cblxuICBlbmQgKHRva2VuKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvblxuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlXG5cbiAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCAnJykgKyB0aGlzLnNwYWNlc1xuICAgIHRoaXMuc3BhY2VzID0gJydcblxuICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB7XG4gICAgICB0aGlzLmN1cnJlbnQuc291cmNlLmVuZCA9IHsgbGluZTogdG9rZW5bMl0sIGNvbHVtbjogdG9rZW5bM10gfVxuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnBhcmVudFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWRDbG9zZSh0b2tlbilcbiAgICB9XG4gIH1cblxuICBlbmRGaWxlICgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkgdGhpcy51bmNsb3NlZEJsb2NrKClcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uXG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gKHRoaXMuY3VycmVudC5yYXdzLmFmdGVyIHx8ICcnKSArIHRoaXMuc3BhY2VzXG4gIH1cblxuICBmcmVlU2VtaWNvbG9uICh0b2tlbikge1xuICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdXG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2Rlcykge1xuICAgICAgbGV0IHByZXYgPSB0aGlzLmN1cnJlbnQubm9kZXNbdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCAtIDFdXG4gICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09ICdydWxlJyAmJiAhcHJldi5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgICBwcmV2LnJhd3Mub3duU2VtaWNvbG9uID0gdGhpcy5zcGFjZXNcbiAgICAgICAgdGhpcy5zcGFjZXMgPSAnJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEhlbHBlcnNcblxuICBpbml0IChub2RlLCBsaW5lLCBjb2x1bW4pIHtcbiAgICB0aGlzLmN1cnJlbnQucHVzaChub2RlKVxuXG4gICAgbm9kZS5zb3VyY2UgPSB7IHN0YXJ0OiB7IGxpbmUsIGNvbHVtbiB9LCBpbnB1dDogdGhpcy5pbnB1dCB9XG4gICAgbm9kZS5yYXdzLmJlZm9yZSA9IHRoaXMuc3BhY2VzXG4gICAgdGhpcy5zcGFjZXMgPSAnJ1xuICAgIGlmIChub2RlLnR5cGUgIT09ICdjb21tZW50JykgdGhpcy5zZW1pY29sb24gPSBmYWxzZVxuICB9XG5cbiAgcmF3IChub2RlLCBwcm9wLCB0b2tlbnMpIHtcbiAgICBsZXQgdG9rZW4sIHR5cGVcbiAgICBsZXQgbGVuZ3RoID0gdG9rZW5zLmxlbmd0aFxuICAgIGxldCB2YWx1ZSA9ICcnXG4gICAgbGV0IGNsZWFuID0gdHJ1ZVxuICAgIGxldCBuZXh0LCBwcmV2XG4gICAgbGV0IHBhdHRlcm4gPSAvXihbLnwjXSk/KFtcXHddKSsvaVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICAgIHR5cGUgPSB0b2tlblswXVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ2NvbW1lbnQnICYmIG5vZGUudHlwZSA9PT0gJ3J1bGUnKSB7XG4gICAgICAgIHByZXYgPSB0b2tlbnNbaSAtIDFdXG4gICAgICAgIG5leHQgPSB0b2tlbnNbaSArIDFdXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByZXZbMF0gIT09ICdzcGFjZScgJiZcbiAgICAgICAgICBuZXh0WzBdICE9PSAnc3BhY2UnICYmXG4gICAgICAgICAgcGF0dGVybi50ZXN0KHByZXZbMV0pICYmXG4gICAgICAgICAgcGF0dGVybi50ZXN0KG5leHRbMV0pXG4gICAgICAgICkge1xuICAgICAgICAgIHZhbHVlICs9IHRva2VuWzFdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYW4gPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdjb21tZW50JyB8fCAodHlwZSA9PT0gJ3NwYWNlJyAmJiBpID09PSBsZW5ndGggLSAxKSkge1xuICAgICAgICBjbGVhbiA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSB0b2tlblsxXVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsZWFuKSB7XG4gICAgICBsZXQgcmF3ID0gdG9rZW5zLnJlZHVjZSgoYWxsLCBpKSA9PiBhbGwgKyBpWzFdLCAnJylcbiAgICAgIG5vZGUucmF3c1twcm9wXSA9IHsgdmFsdWUsIHJhdyB9XG4gICAgfVxuICAgIG5vZGVbcHJvcF0gPSB2YWx1ZVxuICB9XG5cbiAgc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kICh0b2tlbnMpIHtcbiAgICBsZXQgbGFzdFRva2VuVHlwZVxuICAgIGxldCBzcGFjZXMgPSAnJ1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXVxuICAgICAgaWYgKGxhc3RUb2tlblR5cGUgIT09ICdzcGFjZScgJiYgbGFzdFRva2VuVHlwZSAhPT0gJ2NvbW1lbnQnKSBicmVha1xuICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzXG4gICAgfVxuICAgIHJldHVybiBzcGFjZXNcbiAgfVxuXG4gIHNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0ICh0b2tlbnMpIHtcbiAgICBsZXQgbmV4dFxuICAgIGxldCBzcGFjZXMgPSAnJ1xuICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBuZXh0ID0gdG9rZW5zWzBdWzBdXG4gICAgICBpZiAobmV4dCAhPT0gJ3NwYWNlJyAmJiBuZXh0ICE9PSAnY29tbWVudCcpIGJyZWFrXG4gICAgICBzcGFjZXMgKz0gdG9rZW5zLnNoaWZ0KClbMV1cbiAgICB9XG4gICAgcmV0dXJuIHNwYWNlc1xuICB9XG5cbiAgc3BhY2VzRnJvbUVuZCAodG9rZW5zKSB7XG4gICAgbGV0IGxhc3RUb2tlblR5cGVcbiAgICBsZXQgc3BhY2VzID0gJydcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbGFzdFRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF1cbiAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSAnc3BhY2UnKSBicmVha1xuICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzXG4gICAgfVxuICAgIHJldHVybiBzcGFjZXNcbiAgfVxuXG4gIHN0cmluZ0Zyb20gKHRva2VucywgZnJvbSkge1xuICAgIGxldCByZXN1bHQgPSAnJ1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gdG9rZW5zW2ldWzFdXG4gICAgfVxuICAgIHRva2Vucy5zcGxpY2UoZnJvbSwgdG9rZW5zLmxlbmd0aCAtIGZyb20pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgY29sb24gKHRva2Vucykge1xuICAgIGxldCBicmFja2V0cyA9IDBcbiAgICBsZXQgdG9rZW4sIHR5cGUsIHByZXZcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICAgIHR5cGUgPSB0b2tlblswXVxuXG4gICAgICBpZiAodHlwZSA9PT0gJygnKSB7XG4gICAgICAgIGJyYWNrZXRzICs9IDFcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnKScpIHtcbiAgICAgICAgYnJhY2tldHMgLT0gMVxuICAgICAgfVxuICAgICAgaWYgKGJyYWNrZXRzID09PSAwICYmIHR5cGUgPT09ICc6Jykge1xuICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICB0aGlzLmRvdWJsZUNvbG9uKHRva2VuKVxuICAgICAgICB9IGVsc2UgaWYgKHByZXZbMF0gPT09ICd3b3JkJyAmJiBwcmV2WzFdID09PSAncHJvZ2lkJykge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2ID0gdG9rZW5cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBFcnJvcnNcblxuICB1bmNsb3NlZEJyYWNrZXQgKGJyYWNrZXQpIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKCdVbmNsb3NlZCBicmFja2V0JywgYnJhY2tldFsyXSwgYnJhY2tldFszXSlcbiAgfVxuXG4gIHVua25vd25Xb3JkICh0b2tlbnMpIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKCdVbmtub3duIHdvcmQnLCB0b2tlbnNbMF1bMl0sIHRva2Vuc1swXVszXSlcbiAgfVxuXG4gIHVuZXhwZWN0ZWRDbG9zZSAodG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKCdVbmV4cGVjdGVkIH0nLCB0b2tlblsyXSwgdG9rZW5bM10pXG4gIH1cblxuICB1bmNsb3NlZEJsb2NrICgpIHtcbiAgICBsZXQgcG9zID0gdGhpcy5jdXJyZW50LnNvdXJjZS5zdGFydFxuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoJ1VuY2xvc2VkIGJsb2NrJywgcG9zLmxpbmUsIHBvcy5jb2x1bW4pXG4gIH1cblxuICBkb3VibGVDb2xvbiAodG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKCdEb3VibGUgY29sb24nLCB0b2tlblsyXSwgdG9rZW5bM10pXG4gIH1cblxuICB1bm5hbWVkQXRydWxlIChub2RlLCB0b2tlbikge1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoJ0F0LXJ1bGUgd2l0aG91dCBuYW1lJywgdG9rZW5bMl0sIHRva2VuWzNdKVxuICB9XG5cbiAgcHJlY2hlY2tNaXNzZWRTZW1pY29sb24gKC8qIHRva2VucyAqLykge1xuICAgIC8vIEhvb2sgZm9yIFNhZmUgUGFyc2VyXG4gIH1cblxuICBjaGVja01pc3NlZFNlbWljb2xvbiAodG9rZW5zKSB7XG4gICAgbGV0IGNvbG9uID0gdGhpcy5jb2xvbih0b2tlbnMpXG4gICAgaWYgKGNvbG9uID09PSBmYWxzZSkgcmV0dXJuXG5cbiAgICBsZXQgZm91bmRlZCA9IDBcbiAgICBsZXQgdG9rZW5cbiAgICBmb3IgKGxldCBqID0gY29sb24gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbal1cbiAgICAgIGlmICh0b2tlblswXSAhPT0gJ3NwYWNlJykge1xuICAgICAgICBmb3VuZGVkICs9IDFcbiAgICAgICAgaWYgKGZvdW5kZWQgPT09IDIpIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoJ01pc3NlZCBzZW1pY29sb24nLCB0b2tlblsyXSwgdG9rZW5bM10pXG4gIH1cbn1cbiJdLCJmaWxlIjoicGFyc2VyLmpzIn0=


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = tokenizer;
var SINGLE_QUOTE = '\''.charCodeAt(0);
var DOUBLE_QUOTE = '"'.charCodeAt(0);
var BACKSLASH = '\\'.charCodeAt(0);
var SLASH = '/'.charCodeAt(0);
var NEWLINE = '\n'.charCodeAt(0);
var SPACE = ' '.charCodeAt(0);
var FEED = '\f'.charCodeAt(0);
var TAB = '\t'.charCodeAt(0);
var CR = '\r'.charCodeAt(0);
var OPEN_SQUARE = '['.charCodeAt(0);
var CLOSE_SQUARE = ']'.charCodeAt(0);
var OPEN_PARENTHESES = '('.charCodeAt(0);
var CLOSE_PARENTHESES = ')'.charCodeAt(0);
var OPEN_CURLY = '{'.charCodeAt(0);
var CLOSE_CURLY = '}'.charCodeAt(0);
var SEMICOLON = ';'.charCodeAt(0);
var ASTERISK = '*'.charCodeAt(0);
var COLON = ':'.charCodeAt(0);
var AT = '@'.charCodeAt(0);
var RE_AT_END = /[ \n\t\r\f{}()'"\\;/[\]#]/g;
var RE_WORD_END = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g;
var RE_BAD_BRACKET = /.[\\/("'\n]/;
var RE_HEX_ESCAPE = /[a-f0-9]/i;

function tokenizer(input, options) {
  if (options === void 0) {
    options = {};
  }

  var css = input.css.valueOf();
  var ignore = options.ignoreErrors;
  var code, next, quote, lines, last, content, escape;
  var nextLine, nextOffset, escaped, escapePos, prev, n, currentToken;
  var length = css.length;
  var offset = -1;
  var line = 1;
  var pos = 0;
  var buffer = [];
  var returned = [];

  function position() {
    return pos;
  }

  function unclosed(what) {
    throw input.error('Unclosed ' + what, line, pos - offset);
  }

  function endOfFile() {
    return returned.length === 0 && pos >= length;
  }

  function nextToken(opts) {
    if (returned.length) return returned.pop();
    if (pos >= length) return;
    var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code = css.charCodeAt(pos);

    if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {
      offset = pos;
      line += 1;
    }

    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED:
        next = pos;

        do {
          next += 1;
          code = css.charCodeAt(next);

          if (code === NEWLINE) {
            offset = next;
            line += 1;
          }
        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);

        currentToken = ['space', css.slice(pos, next)];
        pos = next - 1;
        break;

      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES:
        var controlChar = String.fromCharCode(code);
        currentToken = [controlChar, controlChar, line, pos - offset];
        break;

      case OPEN_PARENTHESES:
        prev = buffer.length ? buffer.pop()[1] : '';
        n = css.charCodeAt(pos + 1);

        if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
          next = pos;

          do {
            escaped = false;
            next = css.indexOf(')', next + 1);

            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos;
                break;
              } else {
                unclosed('bracket');
              }
            }

            escapePos = next;

            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);

          currentToken = ['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
          pos = next;
        } else {
          next = css.indexOf(')', pos + 1);
          content = css.slice(pos, next + 1);

          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ['(', '(', line, pos - offset];
          } else {
            currentToken = ['brackets', content, line, pos - offset, line, next - offset];
            pos = next;
          }
        }

        break;

      case SINGLE_QUOTE:
      case DOUBLE_QUOTE:
        quote = code === SINGLE_QUOTE ? '\'' : '"';
        next = pos;

        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);

          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1;
              break;
            } else {
              unclosed('string');
            }
          }

          escapePos = next;

          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);

        content = css.slice(pos, next + 1);
        lines = content.split('\n');
        last = lines.length - 1;

        if (last > 0) {
          nextLine = line + last;
          nextOffset = next - lines[last].length;
        } else {
          nextLine = line;
          nextOffset = offset;
        }

        currentToken = ['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset];
        offset = nextOffset;
        line = nextLine;
        pos = next;
        break;

      case AT:
        RE_AT_END.lastIndex = pos + 1;
        RE_AT_END.test(css);

        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1;
        } else {
          next = RE_AT_END.lastIndex - 2;
        }

        currentToken = ['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
        pos = next;
        break;

      case BACKSLASH:
        next = pos;
        escape = true;

        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1;
          escape = !escape;
        }

        code = css.charCodeAt(next + 1);

        if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
          next += 1;

          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1;
            }

            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1;
            }
          }
        }

        currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
        pos = next;
        break;

      default:
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf('*/', pos + 2) + 1;

          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length;
            } else {
              unclosed('comment');
            }
          }

          content = css.slice(pos, next + 1);
          lines = content.split('\n');
          last = lines.length - 1;

          if (last > 0) {
            nextLine = line + last;
            nextOffset = next - lines[last].length;
          } else {
            nextLine = line;
            nextOffset = offset;
          }

          currentToken = ['comment', content, line, pos - offset, nextLine, next - nextOffset];
          offset = nextOffset;
          line = nextLine;
          pos = next;
        } else {
          RE_WORD_END.lastIndex = pos + 1;
          RE_WORD_END.test(css);

          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_WORD_END.lastIndex - 2;
          }

          currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];
          buffer.push(currentToken);
          pos = next;
        }

        break;
    }

    pos++;
    return currentToken;
  }

  function back(token) {
    returned.push(token);
  }

  return {
    back: back,
    nextToken: nextToken,
    endOfFile: endOfFile,
    position: position
  };
}

module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRva2VuaXplLmVzNiJdLCJuYW1lcyI6WyJTSU5HTEVfUVVPVEUiLCJjaGFyQ29kZUF0IiwiRE9VQkxFX1FVT1RFIiwiQkFDS1NMQVNIIiwiU0xBU0giLCJORVdMSU5FIiwiU1BBQ0UiLCJGRUVEIiwiVEFCIiwiQ1IiLCJPUEVOX1NRVUFSRSIsIkNMT1NFX1NRVUFSRSIsIk9QRU5fUEFSRU5USEVTRVMiLCJDTE9TRV9QQVJFTlRIRVNFUyIsIk9QRU5fQ1VSTFkiLCJDTE9TRV9DVVJMWSIsIlNFTUlDT0xPTiIsIkFTVEVSSVNLIiwiQ09MT04iLCJBVCIsIlJFX0FUX0VORCIsIlJFX1dPUkRfRU5EIiwiUkVfQkFEX0JSQUNLRVQiLCJSRV9IRVhfRVNDQVBFIiwidG9rZW5pemVyIiwiaW5wdXQiLCJvcHRpb25zIiwiY3NzIiwidmFsdWVPZiIsImlnbm9yZSIsImlnbm9yZUVycm9ycyIsImNvZGUiLCJuZXh0IiwicXVvdGUiLCJsaW5lcyIsImxhc3QiLCJjb250ZW50IiwiZXNjYXBlIiwibmV4dExpbmUiLCJuZXh0T2Zmc2V0IiwiZXNjYXBlZCIsImVzY2FwZVBvcyIsInByZXYiLCJuIiwiY3VycmVudFRva2VuIiwibGVuZ3RoIiwib2Zmc2V0IiwibGluZSIsInBvcyIsImJ1ZmZlciIsInJldHVybmVkIiwicG9zaXRpb24iLCJ1bmNsb3NlZCIsIndoYXQiLCJlcnJvciIsImVuZE9mRmlsZSIsIm5leHRUb2tlbiIsIm9wdHMiLCJwb3AiLCJpZ25vcmVVbmNsb3NlZCIsInNsaWNlIiwiY29udHJvbENoYXIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJpbmRleE9mIiwidGVzdCIsInNwbGl0IiwibGFzdEluZGV4IiwiY2hhckF0IiwicHVzaCIsImJhY2siLCJ0b2tlbiJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQU1BLFlBQVksR0FBRyxLQUFLQyxVQUFMLENBQWdCLENBQWhCLENBQXJCO0FBQ0EsSUFBTUMsWUFBWSxHQUFHLElBQUlELFVBQUosQ0FBZSxDQUFmLENBQXJCO0FBQ0EsSUFBTUUsU0FBUyxHQUFHLEtBQUtGLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBbEI7QUFDQSxJQUFNRyxLQUFLLEdBQUcsSUFBSUgsVUFBSixDQUFlLENBQWYsQ0FBZDtBQUNBLElBQU1JLE9BQU8sR0FBRyxLQUFLSixVQUFMLENBQWdCLENBQWhCLENBQWhCO0FBQ0EsSUFBTUssS0FBSyxHQUFHLElBQUlMLFVBQUosQ0FBZSxDQUFmLENBQWQ7QUFDQSxJQUFNTSxJQUFJLEdBQUcsS0FBS04sVUFBTCxDQUFnQixDQUFoQixDQUFiO0FBQ0EsSUFBTU8sR0FBRyxHQUFHLEtBQUtQLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBWjtBQUNBLElBQU1RLEVBQUUsR0FBRyxLQUFLUixVQUFMLENBQWdCLENBQWhCLENBQVg7QUFDQSxJQUFNUyxXQUFXLEdBQUcsSUFBSVQsVUFBSixDQUFlLENBQWYsQ0FBcEI7QUFDQSxJQUFNVSxZQUFZLEdBQUcsSUFBSVYsVUFBSixDQUFlLENBQWYsQ0FBckI7QUFDQSxJQUFNVyxnQkFBZ0IsR0FBRyxJQUFJWCxVQUFKLENBQWUsQ0FBZixDQUF6QjtBQUNBLElBQU1ZLGlCQUFpQixHQUFHLElBQUlaLFVBQUosQ0FBZSxDQUFmLENBQTFCO0FBQ0EsSUFBTWEsVUFBVSxHQUFHLElBQUliLFVBQUosQ0FBZSxDQUFmLENBQW5CO0FBQ0EsSUFBTWMsV0FBVyxHQUFHLElBQUlkLFVBQUosQ0FBZSxDQUFmLENBQXBCO0FBQ0EsSUFBTWUsU0FBUyxHQUFHLElBQUlmLFVBQUosQ0FBZSxDQUFmLENBQWxCO0FBQ0EsSUFBTWdCLFFBQVEsR0FBRyxJQUFJaEIsVUFBSixDQUFlLENBQWYsQ0FBakI7QUFDQSxJQUFNaUIsS0FBSyxHQUFHLElBQUlqQixVQUFKLENBQWUsQ0FBZixDQUFkO0FBQ0EsSUFBTWtCLEVBQUUsR0FBRyxJQUFJbEIsVUFBSixDQUFlLENBQWYsQ0FBWDtBQUVBLElBQU1tQixTQUFTLEdBQUcsNEJBQWxCO0FBQ0EsSUFBTUMsV0FBVyxHQUFHLHVDQUFwQjtBQUNBLElBQU1DLGNBQWMsR0FBRyxhQUF2QjtBQUNBLElBQU1DLGFBQWEsR0FBRyxXQUF0Qjs7QUFFZSxTQUFTQyxTQUFULENBQW9CQyxLQUFwQixFQUEyQkMsT0FBM0IsRUFBeUM7QUFBQSxNQUFkQSxPQUFjO0FBQWRBLElBQUFBLE9BQWMsR0FBSixFQUFJO0FBQUE7O0FBQ3RELE1BQUlDLEdBQUcsR0FBR0YsS0FBSyxDQUFDRSxHQUFOLENBQVVDLE9BQVYsRUFBVjtBQUNBLE1BQUlDLE1BQU0sR0FBR0gsT0FBTyxDQUFDSSxZQUFyQjtBQUVBLE1BQUlDLElBQUosRUFBVUMsSUFBVixFQUFnQkMsS0FBaEIsRUFBdUJDLEtBQXZCLEVBQThCQyxJQUE5QixFQUFvQ0MsT0FBcEMsRUFBNkNDLE1BQTdDO0FBQ0EsTUFBSUMsUUFBSixFQUFjQyxVQUFkLEVBQTBCQyxPQUExQixFQUFtQ0MsU0FBbkMsRUFBOENDLElBQTlDLEVBQW9EQyxDQUFwRCxFQUF1REMsWUFBdkQ7QUFFQSxNQUFJQyxNQUFNLEdBQUdsQixHQUFHLENBQUNrQixNQUFqQjtBQUNBLE1BQUlDLE1BQU0sR0FBRyxDQUFDLENBQWQ7QUFDQSxNQUFJQyxJQUFJLEdBQUcsQ0FBWDtBQUNBLE1BQUlDLEdBQUcsR0FBRyxDQUFWO0FBQ0EsTUFBSUMsTUFBTSxHQUFHLEVBQWI7QUFDQSxNQUFJQyxRQUFRLEdBQUcsRUFBZjs7QUFFQSxXQUFTQyxRQUFULEdBQXFCO0FBQ25CLFdBQU9ILEdBQVA7QUFDRDs7QUFFRCxXQUFTSSxRQUFULENBQW1CQyxJQUFuQixFQUF5QjtBQUN2QixVQUFNNUIsS0FBSyxDQUFDNkIsS0FBTixDQUFZLGNBQWNELElBQTFCLEVBQWdDTixJQUFoQyxFQUFzQ0MsR0FBRyxHQUFHRixNQUE1QyxDQUFOO0FBQ0Q7O0FBRUQsV0FBU1MsU0FBVCxHQUFzQjtBQUNwQixXQUFPTCxRQUFRLENBQUNMLE1BQVQsS0FBb0IsQ0FBcEIsSUFBeUJHLEdBQUcsSUFBSUgsTUFBdkM7QUFDRDs7QUFFRCxXQUFTVyxTQUFULENBQW9CQyxJQUFwQixFQUEwQjtBQUN4QixRQUFJUCxRQUFRLENBQUNMLE1BQWIsRUFBcUIsT0FBT0ssUUFBUSxDQUFDUSxHQUFULEVBQVA7QUFDckIsUUFBSVYsR0FBRyxJQUFJSCxNQUFYLEVBQW1CO0FBRW5CLFFBQUljLGNBQWMsR0FBR0YsSUFBSSxHQUFHQSxJQUFJLENBQUNFLGNBQVIsR0FBeUIsS0FBbEQ7QUFFQTVCLElBQUFBLElBQUksR0FBR0osR0FBRyxDQUFDMUIsVUFBSixDQUFlK0MsR0FBZixDQUFQOztBQUNBLFFBQ0VqQixJQUFJLEtBQUsxQixPQUFULElBQW9CMEIsSUFBSSxLQUFLeEIsSUFBN0IsSUFDQ3dCLElBQUksS0FBS3RCLEVBQVQsSUFBZWtCLEdBQUcsQ0FBQzFCLFVBQUosQ0FBZStDLEdBQUcsR0FBRyxDQUFyQixNQUE0QjNDLE9BRjlDLEVBR0U7QUFDQXlDLE1BQUFBLE1BQU0sR0FBR0UsR0FBVDtBQUNBRCxNQUFBQSxJQUFJLElBQUksQ0FBUjtBQUNEOztBQUVELFlBQVFoQixJQUFSO0FBQ0UsV0FBSzFCLE9BQUw7QUFDQSxXQUFLQyxLQUFMO0FBQ0EsV0FBS0UsR0FBTDtBQUNBLFdBQUtDLEVBQUw7QUFDQSxXQUFLRixJQUFMO0FBQ0V5QixRQUFBQSxJQUFJLEdBQUdnQixHQUFQOztBQUNBLFdBQUc7QUFDRGhCLFVBQUFBLElBQUksSUFBSSxDQUFSO0FBQ0FELFVBQUFBLElBQUksR0FBR0osR0FBRyxDQUFDMUIsVUFBSixDQUFlK0IsSUFBZixDQUFQOztBQUNBLGNBQUlELElBQUksS0FBSzFCLE9BQWIsRUFBc0I7QUFDcEJ5QyxZQUFBQSxNQUFNLEdBQUdkLElBQVQ7QUFDQWUsWUFBQUEsSUFBSSxJQUFJLENBQVI7QUFDRDtBQUNGLFNBUEQsUUFRRWhCLElBQUksS0FBS3pCLEtBQVQsSUFDQXlCLElBQUksS0FBSzFCLE9BRFQsSUFFQTBCLElBQUksS0FBS3ZCLEdBRlQsSUFHQXVCLElBQUksS0FBS3RCLEVBSFQsSUFJQXNCLElBQUksS0FBS3hCLElBWlg7O0FBZUFxQyxRQUFBQSxZQUFZLEdBQUcsQ0FBQyxPQUFELEVBQVVqQixHQUFHLENBQUNpQyxLQUFKLENBQVVaLEdBQVYsRUFBZWhCLElBQWYsQ0FBVixDQUFmO0FBQ0FnQixRQUFBQSxHQUFHLEdBQUdoQixJQUFJLEdBQUcsQ0FBYjtBQUNBOztBQUVGLFdBQUt0QixXQUFMO0FBQ0EsV0FBS0MsWUFBTDtBQUNBLFdBQUtHLFVBQUw7QUFDQSxXQUFLQyxXQUFMO0FBQ0EsV0FBS0csS0FBTDtBQUNBLFdBQUtGLFNBQUw7QUFDQSxXQUFLSCxpQkFBTDtBQUNFLFlBQUlnRCxXQUFXLEdBQUdDLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQmhDLElBQXBCLENBQWxCO0FBQ0FhLFFBQUFBLFlBQVksR0FBRyxDQUFDaUIsV0FBRCxFQUFjQSxXQUFkLEVBQTJCZCxJQUEzQixFQUFpQ0MsR0FBRyxHQUFHRixNQUF2QyxDQUFmO0FBQ0E7O0FBRUYsV0FBS2xDLGdCQUFMO0FBQ0U4QixRQUFBQSxJQUFJLEdBQUdPLE1BQU0sQ0FBQ0osTUFBUCxHQUFnQkksTUFBTSxDQUFDUyxHQUFQLEdBQWEsQ0FBYixDQUFoQixHQUFrQyxFQUF6QztBQUNBZixRQUFBQSxDQUFDLEdBQUdoQixHQUFHLENBQUMxQixVQUFKLENBQWUrQyxHQUFHLEdBQUcsQ0FBckIsQ0FBSjs7QUFDQSxZQUNFTixJQUFJLEtBQUssS0FBVCxJQUNBQyxDQUFDLEtBQUszQyxZQUROLElBQ3NCMkMsQ0FBQyxLQUFLekMsWUFENUIsSUFFQXlDLENBQUMsS0FBS3JDLEtBRk4sSUFFZXFDLENBQUMsS0FBS3RDLE9BRnJCLElBRWdDc0MsQ0FBQyxLQUFLbkMsR0FGdEMsSUFHQW1DLENBQUMsS0FBS3BDLElBSE4sSUFHY29DLENBQUMsS0FBS2xDLEVBSnRCLEVBS0U7QUFDQXVCLFVBQUFBLElBQUksR0FBR2dCLEdBQVA7O0FBQ0EsYUFBRztBQUNEUixZQUFBQSxPQUFPLEdBQUcsS0FBVjtBQUNBUixZQUFBQSxJQUFJLEdBQUdMLEdBQUcsQ0FBQ3FDLE9BQUosQ0FBWSxHQUFaLEVBQWlCaEMsSUFBSSxHQUFHLENBQXhCLENBQVA7O0FBQ0EsZ0JBQUlBLElBQUksS0FBSyxDQUFDLENBQWQsRUFBaUI7QUFDZixrQkFBSUgsTUFBTSxJQUFJOEIsY0FBZCxFQUE4QjtBQUM1QjNCLGdCQUFBQSxJQUFJLEdBQUdnQixHQUFQO0FBQ0E7QUFDRCxlQUhELE1BR087QUFDTEksZ0JBQUFBLFFBQVEsQ0FBQyxTQUFELENBQVI7QUFDRDtBQUNGOztBQUNEWCxZQUFBQSxTQUFTLEdBQUdULElBQVo7O0FBQ0EsbUJBQU9MLEdBQUcsQ0FBQzFCLFVBQUosQ0FBZXdDLFNBQVMsR0FBRyxDQUEzQixNQUFrQ3RDLFNBQXpDLEVBQW9EO0FBQ2xEc0MsY0FBQUEsU0FBUyxJQUFJLENBQWI7QUFDQUQsY0FBQUEsT0FBTyxHQUFHLENBQUNBLE9BQVg7QUFDRDtBQUNGLFdBaEJELFFBZ0JTQSxPQWhCVDs7QUFrQkFJLFVBQUFBLFlBQVksR0FBRyxDQUFDLFVBQUQsRUFBYWpCLEdBQUcsQ0FBQ2lDLEtBQUosQ0FBVVosR0FBVixFQUFlaEIsSUFBSSxHQUFHLENBQXRCLENBQWIsRUFDYmUsSUFEYSxFQUNQQyxHQUFHLEdBQUdGLE1BREMsRUFFYkMsSUFGYSxFQUVQZixJQUFJLEdBQUdjLE1BRkEsQ0FBZjtBQUtBRSxVQUFBQSxHQUFHLEdBQUdoQixJQUFOO0FBQ0QsU0EvQkQsTUErQk87QUFDTEEsVUFBQUEsSUFBSSxHQUFHTCxHQUFHLENBQUNxQyxPQUFKLENBQVksR0FBWixFQUFpQmhCLEdBQUcsR0FBRyxDQUF2QixDQUFQO0FBQ0FaLFVBQUFBLE9BQU8sR0FBR1QsR0FBRyxDQUFDaUMsS0FBSixDQUFVWixHQUFWLEVBQWVoQixJQUFJLEdBQUcsQ0FBdEIsQ0FBVjs7QUFFQSxjQUFJQSxJQUFJLEtBQUssQ0FBQyxDQUFWLElBQWVWLGNBQWMsQ0FBQzJDLElBQWYsQ0FBb0I3QixPQUFwQixDQUFuQixFQUFpRDtBQUMvQ1EsWUFBQUEsWUFBWSxHQUFHLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBV0csSUFBWCxFQUFpQkMsR0FBRyxHQUFHRixNQUF2QixDQUFmO0FBQ0QsV0FGRCxNQUVPO0FBQ0xGLFlBQUFBLFlBQVksR0FBRyxDQUFDLFVBQUQsRUFBYVIsT0FBYixFQUNiVyxJQURhLEVBQ1BDLEdBQUcsR0FBR0YsTUFEQyxFQUViQyxJQUZhLEVBRVBmLElBQUksR0FBR2MsTUFGQSxDQUFmO0FBSUFFLFlBQUFBLEdBQUcsR0FBR2hCLElBQU47QUFDRDtBQUNGOztBQUVEOztBQUVGLFdBQUtoQyxZQUFMO0FBQ0EsV0FBS0UsWUFBTDtBQUNFK0IsUUFBQUEsS0FBSyxHQUFHRixJQUFJLEtBQUsvQixZQUFULEdBQXdCLElBQXhCLEdBQStCLEdBQXZDO0FBQ0FnQyxRQUFBQSxJQUFJLEdBQUdnQixHQUFQOztBQUNBLFdBQUc7QUFDRFIsVUFBQUEsT0FBTyxHQUFHLEtBQVY7QUFDQVIsVUFBQUEsSUFBSSxHQUFHTCxHQUFHLENBQUNxQyxPQUFKLENBQVkvQixLQUFaLEVBQW1CRCxJQUFJLEdBQUcsQ0FBMUIsQ0FBUDs7QUFDQSxjQUFJQSxJQUFJLEtBQUssQ0FBQyxDQUFkLEVBQWlCO0FBQ2YsZ0JBQUlILE1BQU0sSUFBSThCLGNBQWQsRUFBOEI7QUFDNUIzQixjQUFBQSxJQUFJLEdBQUdnQixHQUFHLEdBQUcsQ0FBYjtBQUNBO0FBQ0QsYUFIRCxNQUdPO0FBQ0xJLGNBQUFBLFFBQVEsQ0FBQyxRQUFELENBQVI7QUFDRDtBQUNGOztBQUNEWCxVQUFBQSxTQUFTLEdBQUdULElBQVo7O0FBQ0EsaUJBQU9MLEdBQUcsQ0FBQzFCLFVBQUosQ0FBZXdDLFNBQVMsR0FBRyxDQUEzQixNQUFrQ3RDLFNBQXpDLEVBQW9EO0FBQ2xEc0MsWUFBQUEsU0FBUyxJQUFJLENBQWI7QUFDQUQsWUFBQUEsT0FBTyxHQUFHLENBQUNBLE9BQVg7QUFDRDtBQUNGLFNBaEJELFFBZ0JTQSxPQWhCVDs7QUFrQkFKLFFBQUFBLE9BQU8sR0FBR1QsR0FBRyxDQUFDaUMsS0FBSixDQUFVWixHQUFWLEVBQWVoQixJQUFJLEdBQUcsQ0FBdEIsQ0FBVjtBQUNBRSxRQUFBQSxLQUFLLEdBQUdFLE9BQU8sQ0FBQzhCLEtBQVIsQ0FBYyxJQUFkLENBQVI7QUFDQS9CLFFBQUFBLElBQUksR0FBR0QsS0FBSyxDQUFDVyxNQUFOLEdBQWUsQ0FBdEI7O0FBRUEsWUFBSVYsSUFBSSxHQUFHLENBQVgsRUFBYztBQUNaRyxVQUFBQSxRQUFRLEdBQUdTLElBQUksR0FBR1osSUFBbEI7QUFDQUksVUFBQUEsVUFBVSxHQUFHUCxJQUFJLEdBQUdFLEtBQUssQ0FBQ0MsSUFBRCxDQUFMLENBQVlVLE1BQWhDO0FBQ0QsU0FIRCxNQUdPO0FBQ0xQLFVBQUFBLFFBQVEsR0FBR1MsSUFBWDtBQUNBUixVQUFBQSxVQUFVLEdBQUdPLE1BQWI7QUFDRDs7QUFFREYsUUFBQUEsWUFBWSxHQUFHLENBQUMsUUFBRCxFQUFXakIsR0FBRyxDQUFDaUMsS0FBSixDQUFVWixHQUFWLEVBQWVoQixJQUFJLEdBQUcsQ0FBdEIsQ0FBWCxFQUNiZSxJQURhLEVBQ1BDLEdBQUcsR0FBR0YsTUFEQyxFQUViUixRQUZhLEVBRUhOLElBQUksR0FBR08sVUFGSixDQUFmO0FBS0FPLFFBQUFBLE1BQU0sR0FBR1AsVUFBVDtBQUNBUSxRQUFBQSxJQUFJLEdBQUdULFFBQVA7QUFDQVUsUUFBQUEsR0FBRyxHQUFHaEIsSUFBTjtBQUNBOztBQUVGLFdBQUtiLEVBQUw7QUFDRUMsUUFBQUEsU0FBUyxDQUFDK0MsU0FBVixHQUFzQm5CLEdBQUcsR0FBRyxDQUE1QjtBQUNBNUIsUUFBQUEsU0FBUyxDQUFDNkMsSUFBVixDQUFldEMsR0FBZjs7QUFDQSxZQUFJUCxTQUFTLENBQUMrQyxTQUFWLEtBQXdCLENBQTVCLEVBQStCO0FBQzdCbkMsVUFBQUEsSUFBSSxHQUFHTCxHQUFHLENBQUNrQixNQUFKLEdBQWEsQ0FBcEI7QUFDRCxTQUZELE1BRU87QUFDTGIsVUFBQUEsSUFBSSxHQUFHWixTQUFTLENBQUMrQyxTQUFWLEdBQXNCLENBQTdCO0FBQ0Q7O0FBRUR2QixRQUFBQSxZQUFZLEdBQUcsQ0FBQyxTQUFELEVBQVlqQixHQUFHLENBQUNpQyxLQUFKLENBQVVaLEdBQVYsRUFBZWhCLElBQUksR0FBRyxDQUF0QixDQUFaLEVBQ2JlLElBRGEsRUFDUEMsR0FBRyxHQUFHRixNQURDLEVBRWJDLElBRmEsRUFFUGYsSUFBSSxHQUFHYyxNQUZBLENBQWY7QUFLQUUsUUFBQUEsR0FBRyxHQUFHaEIsSUFBTjtBQUNBOztBQUVGLFdBQUs3QixTQUFMO0FBQ0U2QixRQUFBQSxJQUFJLEdBQUdnQixHQUFQO0FBQ0FYLFFBQUFBLE1BQU0sR0FBRyxJQUFUOztBQUNBLGVBQU9WLEdBQUcsQ0FBQzFCLFVBQUosQ0FBZStCLElBQUksR0FBRyxDQUF0QixNQUE2QjdCLFNBQXBDLEVBQStDO0FBQzdDNkIsVUFBQUEsSUFBSSxJQUFJLENBQVI7QUFDQUssVUFBQUEsTUFBTSxHQUFHLENBQUNBLE1BQVY7QUFDRDs7QUFDRE4sUUFBQUEsSUFBSSxHQUFHSixHQUFHLENBQUMxQixVQUFKLENBQWUrQixJQUFJLEdBQUcsQ0FBdEIsQ0FBUDs7QUFDQSxZQUNFSyxNQUFNLElBQ05OLElBQUksS0FBSzNCLEtBRFQsSUFFQTJCLElBQUksS0FBS3pCLEtBRlQsSUFHQXlCLElBQUksS0FBSzFCLE9BSFQsSUFJQTBCLElBQUksS0FBS3ZCLEdBSlQsSUFLQXVCLElBQUksS0FBS3RCLEVBTFQsSUFNQXNCLElBQUksS0FBS3hCLElBUFgsRUFRRTtBQUNBeUIsVUFBQUEsSUFBSSxJQUFJLENBQVI7O0FBQ0EsY0FBSVQsYUFBYSxDQUFDMEMsSUFBZCxDQUFtQnRDLEdBQUcsQ0FBQ3lDLE1BQUosQ0FBV3BDLElBQVgsQ0FBbkIsQ0FBSixFQUEwQztBQUN4QyxtQkFBT1QsYUFBYSxDQUFDMEMsSUFBZCxDQUFtQnRDLEdBQUcsQ0FBQ3lDLE1BQUosQ0FBV3BDLElBQUksR0FBRyxDQUFsQixDQUFuQixDQUFQLEVBQWlEO0FBQy9DQSxjQUFBQSxJQUFJLElBQUksQ0FBUjtBQUNEOztBQUNELGdCQUFJTCxHQUFHLENBQUMxQixVQUFKLENBQWUrQixJQUFJLEdBQUcsQ0FBdEIsTUFBNkIxQixLQUFqQyxFQUF3QztBQUN0QzBCLGNBQUFBLElBQUksSUFBSSxDQUFSO0FBQ0Q7QUFDRjtBQUNGOztBQUVEWSxRQUFBQSxZQUFZLEdBQUcsQ0FBQyxNQUFELEVBQVNqQixHQUFHLENBQUNpQyxLQUFKLENBQVVaLEdBQVYsRUFBZWhCLElBQUksR0FBRyxDQUF0QixDQUFULEVBQ2JlLElBRGEsRUFDUEMsR0FBRyxHQUFHRixNQURDLEVBRWJDLElBRmEsRUFFUGYsSUFBSSxHQUFHYyxNQUZBLENBQWY7QUFLQUUsUUFBQUEsR0FBRyxHQUFHaEIsSUFBTjtBQUNBOztBQUVGO0FBQ0UsWUFBSUQsSUFBSSxLQUFLM0IsS0FBVCxJQUFrQnVCLEdBQUcsQ0FBQzFCLFVBQUosQ0FBZStDLEdBQUcsR0FBRyxDQUFyQixNQUE0Qi9CLFFBQWxELEVBQTREO0FBQzFEZSxVQUFBQSxJQUFJLEdBQUdMLEdBQUcsQ0FBQ3FDLE9BQUosQ0FBWSxJQUFaLEVBQWtCaEIsR0FBRyxHQUFHLENBQXhCLElBQTZCLENBQXBDOztBQUNBLGNBQUloQixJQUFJLEtBQUssQ0FBYixFQUFnQjtBQUNkLGdCQUFJSCxNQUFNLElBQUk4QixjQUFkLEVBQThCO0FBQzVCM0IsY0FBQUEsSUFBSSxHQUFHTCxHQUFHLENBQUNrQixNQUFYO0FBQ0QsYUFGRCxNQUVPO0FBQ0xPLGNBQUFBLFFBQVEsQ0FBQyxTQUFELENBQVI7QUFDRDtBQUNGOztBQUVEaEIsVUFBQUEsT0FBTyxHQUFHVCxHQUFHLENBQUNpQyxLQUFKLENBQVVaLEdBQVYsRUFBZWhCLElBQUksR0FBRyxDQUF0QixDQUFWO0FBQ0FFLFVBQUFBLEtBQUssR0FBR0UsT0FBTyxDQUFDOEIsS0FBUixDQUFjLElBQWQsQ0FBUjtBQUNBL0IsVUFBQUEsSUFBSSxHQUFHRCxLQUFLLENBQUNXLE1BQU4sR0FBZSxDQUF0Qjs7QUFFQSxjQUFJVixJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBQ1pHLFlBQUFBLFFBQVEsR0FBR1MsSUFBSSxHQUFHWixJQUFsQjtBQUNBSSxZQUFBQSxVQUFVLEdBQUdQLElBQUksR0FBR0UsS0FBSyxDQUFDQyxJQUFELENBQUwsQ0FBWVUsTUFBaEM7QUFDRCxXQUhELE1BR087QUFDTFAsWUFBQUEsUUFBUSxHQUFHUyxJQUFYO0FBQ0FSLFlBQUFBLFVBQVUsR0FBR08sTUFBYjtBQUNEOztBQUVERixVQUFBQSxZQUFZLEdBQUcsQ0FBQyxTQUFELEVBQVlSLE9BQVosRUFDYlcsSUFEYSxFQUNQQyxHQUFHLEdBQUdGLE1BREMsRUFFYlIsUUFGYSxFQUVITixJQUFJLEdBQUdPLFVBRkosQ0FBZjtBQUtBTyxVQUFBQSxNQUFNLEdBQUdQLFVBQVQ7QUFDQVEsVUFBQUEsSUFBSSxHQUFHVCxRQUFQO0FBQ0FVLFVBQUFBLEdBQUcsR0FBR2hCLElBQU47QUFDRCxTQTlCRCxNQThCTztBQUNMWCxVQUFBQSxXQUFXLENBQUM4QyxTQUFaLEdBQXdCbkIsR0FBRyxHQUFHLENBQTlCO0FBQ0EzQixVQUFBQSxXQUFXLENBQUM0QyxJQUFaLENBQWlCdEMsR0FBakI7O0FBQ0EsY0FBSU4sV0FBVyxDQUFDOEMsU0FBWixLQUEwQixDQUE5QixFQUFpQztBQUMvQm5DLFlBQUFBLElBQUksR0FBR0wsR0FBRyxDQUFDa0IsTUFBSixHQUFhLENBQXBCO0FBQ0QsV0FGRCxNQUVPO0FBQ0xiLFlBQUFBLElBQUksR0FBR1gsV0FBVyxDQUFDOEMsU0FBWixHQUF3QixDQUEvQjtBQUNEOztBQUVEdkIsVUFBQUEsWUFBWSxHQUFHLENBQUMsTUFBRCxFQUFTakIsR0FBRyxDQUFDaUMsS0FBSixDQUFVWixHQUFWLEVBQWVoQixJQUFJLEdBQUcsQ0FBdEIsQ0FBVCxFQUNiZSxJQURhLEVBQ1BDLEdBQUcsR0FBR0YsTUFEQyxFQUViQyxJQUZhLEVBRVBmLElBQUksR0FBR2MsTUFGQSxDQUFmO0FBS0FHLFVBQUFBLE1BQU0sQ0FBQ29CLElBQVAsQ0FBWXpCLFlBQVo7QUFFQUksVUFBQUEsR0FBRyxHQUFHaEIsSUFBTjtBQUNEOztBQUVEO0FBM09KOztBQThPQWdCLElBQUFBLEdBQUc7QUFDSCxXQUFPSixZQUFQO0FBQ0Q7O0FBRUQsV0FBUzBCLElBQVQsQ0FBZUMsS0FBZixFQUFzQjtBQUNwQnJCLElBQUFBLFFBQVEsQ0FBQ21CLElBQVQsQ0FBY0UsS0FBZDtBQUNEOztBQUVELFNBQU87QUFDTEQsSUFBQUEsSUFBSSxFQUFKQSxJQURLO0FBRUxkLElBQUFBLFNBQVMsRUFBVEEsU0FGSztBQUdMRCxJQUFBQSxTQUFTLEVBQVRBLFNBSEs7QUFJTEosSUFBQUEsUUFBUSxFQUFSQTtBQUpLLEdBQVA7QUFNRCIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNJTkdMRV9RVU9URSA9ICdcXCcnLmNoYXJDb2RlQXQoMClcbmNvbnN0IERPVUJMRV9RVU9URSA9ICdcIicuY2hhckNvZGVBdCgwKVxuY29uc3QgQkFDS1NMQVNIID0gJ1xcXFwnLmNoYXJDb2RlQXQoMClcbmNvbnN0IFNMQVNIID0gJy8nLmNoYXJDb2RlQXQoMClcbmNvbnN0IE5FV0xJTkUgPSAnXFxuJy5jaGFyQ29kZUF0KDApXG5jb25zdCBTUEFDRSA9ICcgJy5jaGFyQ29kZUF0KDApXG5jb25zdCBGRUVEID0gJ1xcZicuY2hhckNvZGVBdCgwKVxuY29uc3QgVEFCID0gJ1xcdCcuY2hhckNvZGVBdCgwKVxuY29uc3QgQ1IgPSAnXFxyJy5jaGFyQ29kZUF0KDApXG5jb25zdCBPUEVOX1NRVUFSRSA9ICdbJy5jaGFyQ29kZUF0KDApXG5jb25zdCBDTE9TRV9TUVVBUkUgPSAnXScuY2hhckNvZGVBdCgwKVxuY29uc3QgT1BFTl9QQVJFTlRIRVNFUyA9ICcoJy5jaGFyQ29kZUF0KDApXG5jb25zdCBDTE9TRV9QQVJFTlRIRVNFUyA9ICcpJy5jaGFyQ29kZUF0KDApXG5jb25zdCBPUEVOX0NVUkxZID0gJ3snLmNoYXJDb2RlQXQoMClcbmNvbnN0IENMT1NFX0NVUkxZID0gJ30nLmNoYXJDb2RlQXQoMClcbmNvbnN0IFNFTUlDT0xPTiA9ICc7Jy5jaGFyQ29kZUF0KDApXG5jb25zdCBBU1RFUklTSyA9ICcqJy5jaGFyQ29kZUF0KDApXG5jb25zdCBDT0xPTiA9ICc6Jy5jaGFyQ29kZUF0KDApXG5jb25zdCBBVCA9ICdAJy5jaGFyQ29kZUF0KDApXG5cbmNvbnN0IFJFX0FUX0VORCA9IC9bIFxcblxcdFxcclxcZnt9KCknXCJcXFxcOy9bXFxdI10vZ1xuY29uc3QgUkVfV09SRF9FTkQgPSAvWyBcXG5cXHRcXHJcXGYoKXt9OjtAISdcIlxcXFxcXF1bI118XFwvKD89XFwqKS9nXG5jb25zdCBSRV9CQURfQlJBQ0tFVCA9IC8uW1xcXFwvKFwiJ1xcbl0vXG5jb25zdCBSRV9IRVhfRVNDQVBFID0gL1thLWYwLTldL2lcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9rZW5pemVyIChpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBjc3MgPSBpbnB1dC5jc3MudmFsdWVPZigpXG4gIGxldCBpZ25vcmUgPSBvcHRpb25zLmlnbm9yZUVycm9yc1xuXG4gIGxldCBjb2RlLCBuZXh0LCBxdW90ZSwgbGluZXMsIGxhc3QsIGNvbnRlbnQsIGVzY2FwZVxuICBsZXQgbmV4dExpbmUsIG5leHRPZmZzZXQsIGVzY2FwZWQsIGVzY2FwZVBvcywgcHJldiwgbiwgY3VycmVudFRva2VuXG5cbiAgbGV0IGxlbmd0aCA9IGNzcy5sZW5ndGhcbiAgbGV0IG9mZnNldCA9IC0xXG4gIGxldCBsaW5lID0gMVxuICBsZXQgcG9zID0gMFxuICBsZXQgYnVmZmVyID0gW11cbiAgbGV0IHJldHVybmVkID0gW11cblxuICBmdW5jdGlvbiBwb3NpdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBvc1xuICB9XG5cbiAgZnVuY3Rpb24gdW5jbG9zZWQgKHdoYXQpIHtcbiAgICB0aHJvdyBpbnB1dC5lcnJvcignVW5jbG9zZWQgJyArIHdoYXQsIGxpbmUsIHBvcyAtIG9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9mRmlsZSAoKSB7XG4gICAgcmV0dXJuIHJldHVybmVkLmxlbmd0aCA9PT0gMCAmJiBwb3MgPj0gbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBuZXh0VG9rZW4gKG9wdHMpIHtcbiAgICBpZiAocmV0dXJuZWQubGVuZ3RoKSByZXR1cm4gcmV0dXJuZWQucG9wKClcbiAgICBpZiAocG9zID49IGxlbmd0aCkgcmV0dXJuXG5cbiAgICBsZXQgaWdub3JlVW5jbG9zZWQgPSBvcHRzID8gb3B0cy5pZ25vcmVVbmNsb3NlZCA6IGZhbHNlXG5cbiAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQocG9zKVxuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IE5FV0xJTkUgfHwgY29kZSA9PT0gRkVFRCB8fFxuICAgICAgKGNvZGUgPT09IENSICYmIGNzcy5jaGFyQ29kZUF0KHBvcyArIDEpICE9PSBORVdMSU5FKVxuICAgICkge1xuICAgICAgb2Zmc2V0ID0gcG9zXG4gICAgICBsaW5lICs9IDFcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgTkVXTElORTpcbiAgICAgIGNhc2UgU1BBQ0U6XG4gICAgICBjYXNlIFRBQjpcbiAgICAgIGNhc2UgQ1I6XG4gICAgICBjYXNlIEZFRUQ6XG4gICAgICAgIG5leHQgPSBwb3NcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5leHQgKz0gMVxuICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0KVxuICAgICAgICAgIGlmIChjb2RlID09PSBORVdMSU5FKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBuZXh0XG4gICAgICAgICAgICBsaW5lICs9IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKFxuICAgICAgICAgIGNvZGUgPT09IFNQQUNFIHx8XG4gICAgICAgICAgY29kZSA9PT0gTkVXTElORSB8fFxuICAgICAgICAgIGNvZGUgPT09IFRBQiB8fFxuICAgICAgICAgIGNvZGUgPT09IENSIHx8XG4gICAgICAgICAgY29kZSA9PT0gRkVFRFxuICAgICAgICApXG5cbiAgICAgICAgY3VycmVudFRva2VuID0gWydzcGFjZScsIGNzcy5zbGljZShwb3MsIG5leHQpXVxuICAgICAgICBwb3MgPSBuZXh0IC0gMVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIE9QRU5fU1FVQVJFOlxuICAgICAgY2FzZSBDTE9TRV9TUVVBUkU6XG4gICAgICBjYXNlIE9QRU5fQ1VSTFk6XG4gICAgICBjYXNlIENMT1NFX0NVUkxZOlxuICAgICAgY2FzZSBDT0xPTjpcbiAgICAgIGNhc2UgU0VNSUNPTE9OOlxuICAgICAgY2FzZSBDTE9TRV9QQVJFTlRIRVNFUzpcbiAgICAgICAgbGV0IGNvbnRyb2xDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbY29udHJvbENoYXIsIGNvbnRyb2xDaGFyLCBsaW5lLCBwb3MgLSBvZmZzZXRdXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgT1BFTl9QQVJFTlRIRVNFUzpcbiAgICAgICAgcHJldiA9IGJ1ZmZlci5sZW5ndGggPyBidWZmZXIucG9wKClbMV0gOiAnJ1xuICAgICAgICBuID0gY3NzLmNoYXJDb2RlQXQocG9zICsgMSlcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByZXYgPT09ICd1cmwnICYmXG4gICAgICAgICAgbiAhPT0gU0lOR0xFX1FVT1RFICYmIG4gIT09IERPVUJMRV9RVU9URSAmJlxuICAgICAgICAgIG4gIT09IFNQQUNFICYmIG4gIT09IE5FV0xJTkUgJiYgbiAhPT0gVEFCICYmXG4gICAgICAgICAgbiAhPT0gRkVFRCAmJiBuICE9PSBDUlxuICAgICAgICApIHtcbiAgICAgICAgICBuZXh0ID0gcG9zXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlXG4gICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoJyknLCBuZXh0ICsgMSlcbiAgICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHBvc1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5jbG9zZWQoJ2JyYWNrZXQnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0XG4gICAgICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMVxuICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChlc2NhcGVkKVxuXG4gICAgICAgICAgY3VycmVudFRva2VuID0gWydicmFja2V0cycsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgIGxpbmUsIHBvcyAtIG9mZnNldCxcbiAgICAgICAgICAgIGxpbmUsIG5leHQgLSBvZmZzZXRcbiAgICAgICAgICBdXG5cbiAgICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKCcpJywgcG9zICsgMSlcbiAgICAgICAgICBjb250ZW50ID0gY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpXG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gLTEgfHwgUkVfQkFEX0JSQUNLRVQudGVzdChjb250ZW50KSkge1xuICAgICAgICAgICAgY3VycmVudFRva2VuID0gWycoJywgJygnLCBsaW5lLCBwb3MgLSBvZmZzZXRdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFsnYnJhY2tldHMnLCBjb250ZW50LFxuICAgICAgICAgICAgICBsaW5lLCBwb3MgLSBvZmZzZXQsXG4gICAgICAgICAgICAgIGxpbmUsIG5leHQgLSBvZmZzZXRcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIHBvcyA9IG5leHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFNJTkdMRV9RVU9URTpcbiAgICAgIGNhc2UgRE9VQkxFX1FVT1RFOlxuICAgICAgICBxdW90ZSA9IGNvZGUgPT09IFNJTkdMRV9RVU9URSA/ICdcXCcnIDogJ1wiJ1xuICAgICAgICBuZXh0ID0gcG9zXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBlc2NhcGVkID0gZmFsc2VcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKVxuICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICBuZXh0ID0gcG9zICsgMVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5jbG9zZWQoJ3N0cmluZycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHRcbiAgICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgZXNjYXBlUG9zIC09IDFcbiAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZFxuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZXNjYXBlZClcblxuICAgICAgICBjb250ZW50ID0gY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpXG4gICAgICAgIGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJylcbiAgICAgICAgbGFzdCA9IGxpbmVzLmxlbmd0aCAtIDFcblxuICAgICAgICBpZiAobGFzdCA+IDApIHtcbiAgICAgICAgICBuZXh0TGluZSA9IGxpbmUgKyBsYXN0XG4gICAgICAgICAgbmV4dE9mZnNldCA9IG5leHQgLSBsaW5lc1tsYXN0XS5sZW5ndGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0TGluZSA9IGxpbmVcbiAgICAgICAgICBuZXh0T2Zmc2V0ID0gb2Zmc2V0XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ3N0cmluZycsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICBsaW5lLCBwb3MgLSBvZmZzZXQsXG4gICAgICAgICAgbmV4dExpbmUsIG5leHQgLSBuZXh0T2Zmc2V0XG4gICAgICAgIF1cblxuICAgICAgICBvZmZzZXQgPSBuZXh0T2Zmc2V0XG4gICAgICAgIGxpbmUgPSBuZXh0TGluZVxuICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgQVQ6XG4gICAgICAgIFJFX0FUX0VORC5sYXN0SW5kZXggPSBwb3MgKyAxXG4gICAgICAgIFJFX0FUX0VORC50ZXN0KGNzcylcbiAgICAgICAgaWYgKFJFX0FUX0VORC5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICBuZXh0ID0gY3NzLmxlbmd0aCAtIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gUkVfQVRfRU5ELmxhc3RJbmRleCAtIDJcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IFsnYXQtd29yZCcsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICBsaW5lLCBwb3MgLSBvZmZzZXQsXG4gICAgICAgICAgbGluZSwgbmV4dCAtIG9mZnNldFxuICAgICAgICBdXG5cbiAgICAgICAgcG9zID0gbmV4dFxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIEJBQ0tTTEFTSDpcbiAgICAgICAgbmV4dCA9IHBvc1xuICAgICAgICBlc2NhcGUgPSB0cnVlXG4gICAgICAgIHdoaWxlIChjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IEJBQ0tTTEFTSCkge1xuICAgICAgICAgIG5leHQgKz0gMVxuICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGVcbiAgICAgICAgfVxuICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpXG4gICAgICAgIGlmIChcbiAgICAgICAgICBlc2NhcGUgJiZcbiAgICAgICAgICBjb2RlICE9PSBTTEFTSCAmJlxuICAgICAgICAgIGNvZGUgIT09IFNQQUNFICYmXG4gICAgICAgICAgY29kZSAhPT0gTkVXTElORSAmJlxuICAgICAgICAgIGNvZGUgIT09IFRBQiAmJlxuICAgICAgICAgIGNvZGUgIT09IENSICYmXG4gICAgICAgICAgY29kZSAhPT0gRkVFRFxuICAgICAgICApIHtcbiAgICAgICAgICBuZXh0ICs9IDFcbiAgICAgICAgICBpZiAoUkVfSEVYX0VTQ0FQRS50ZXN0KGNzcy5jaGFyQXQobmV4dCkpKSB7XG4gICAgICAgICAgICB3aGlsZSAoUkVfSEVYX0VTQ0FQRS50ZXN0KGNzcy5jaGFyQXQobmV4dCArIDEpKSkge1xuICAgICAgICAgICAgICBuZXh0ICs9IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IFNQQUNFKSB7XG4gICAgICAgICAgICAgIG5leHQgKz0gMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRUb2tlbiA9IFsnd29yZCcsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICBsaW5lLCBwb3MgLSBvZmZzZXQsXG4gICAgICAgICAgbGluZSwgbmV4dCAtIG9mZnNldFxuICAgICAgICBdXG5cbiAgICAgICAgcG9zID0gbmV4dFxuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY29kZSA9PT0gU0xBU0ggJiYgY3NzLmNoYXJDb2RlQXQocG9zICsgMSkgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKCcqLycsIHBvcyArIDIpICsgMVxuICAgICAgICAgIGlmIChuZXh0ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmNsb3NlZCgnY29tbWVudCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGVudCA9IGNzcy5zbGljZShwb3MsIG5leHQgKyAxKVxuICAgICAgICAgIGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJylcbiAgICAgICAgICBsYXN0ID0gbGluZXMubGVuZ3RoIC0gMVxuXG4gICAgICAgICAgaWYgKGxhc3QgPiAwKSB7XG4gICAgICAgICAgICBuZXh0TGluZSA9IGxpbmUgKyBsYXN0XG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gbmV4dCAtIGxpbmVzW2xhc3RdLmxlbmd0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0TGluZSA9IGxpbmVcbiAgICAgICAgICAgIG5leHRPZmZzZXQgPSBvZmZzZXRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ2NvbW1lbnQnLCBjb250ZW50LFxuICAgICAgICAgICAgbGluZSwgcG9zIC0gb2Zmc2V0LFxuICAgICAgICAgICAgbmV4dExpbmUsIG5leHQgLSBuZXh0T2Zmc2V0XG4gICAgICAgICAgXVxuXG4gICAgICAgICAgb2Zmc2V0ID0gbmV4dE9mZnNldFxuICAgICAgICAgIGxpbmUgPSBuZXh0TGluZVxuICAgICAgICAgIHBvcyA9IG5leHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSRV9XT1JEX0VORC5sYXN0SW5kZXggPSBwb3MgKyAxXG4gICAgICAgICAgUkVfV09SRF9FTkQudGVzdChjc3MpXG4gICAgICAgICAgaWYgKFJFX1dPUkRfRU5ELmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQgPSBSRV9XT1JEX0VORC5sYXN0SW5kZXggLSAyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFRva2VuID0gWyd3b3JkJywgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgbGluZSwgcG9zIC0gb2Zmc2V0LFxuICAgICAgICAgICAgbGluZSwgbmV4dCAtIG9mZnNldFxuICAgICAgICAgIF1cblxuICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnJlbnRUb2tlbilcblxuICAgICAgICAgIHBvcyA9IG5leHRcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgcG9zKytcbiAgICByZXR1cm4gY3VycmVudFRva2VuXG4gIH1cblxuICBmdW5jdGlvbiBiYWNrICh0b2tlbikge1xuICAgIHJldHVybmVkLnB1c2godG9rZW4pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2ssXG4gICAgbmV4dFRva2VuLFxuICAgIGVuZE9mRmlsZSxcbiAgICBwb3NpdGlvblxuICB9XG59XG4iXSwiZmlsZSI6InRva2VuaXplLmpzIn0=


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _path = _interopRequireDefault(__webpack_require__(3));

var _cssSyntaxError = _interopRequireDefault(__webpack_require__(35));

var _previousMap = _interopRequireDefault(__webpack_require__(93));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sequence = 0;
/**
 * Represents the source CSS.
 *
 * @example
 * const root  = postcss.parse(css, { from: file })
 * const input = root.source.input
 */

var Input =
/*#__PURE__*/
function () {
  /**
   * @param {string} css    Input CSS source.
   * @param {object} [opts] {@link Processor#process} options.
   */
  function Input(css, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (css === null || typeof css === 'undefined' || typeof css === 'object' && !css.toString) {
      throw new Error("PostCSS received " + css + " instead of CSS string");
    }
    /**
     * Input CSS source
     *
     * @type {string}
     *
     * @example
     * const input = postcss.parse('a{}', { from: file }).input
     * input.css //=> "a{}"
     */


    this.css = css.toString();

    if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }

    if (opts.from) {
      if (/^\w+:\/\//.test(opts.from) || _path.default.isAbsolute(opts.from)) {
        /**
         * The absolute path to the CSS source file defined
         * with the `from` option.
         *
         * @type {string}
         *
         * @example
         * const root = postcss.parse(css, { from: 'a.css' })
         * root.source.input.file //=> '/home/ai/a.css'
         */
        this.file = opts.from;
      } else {
        this.file = _path.default.resolve(opts.from);
      }
    }

    var map = new _previousMap.default(this.css, opts);

    if (map.text) {
      /**
       * The input source map passed from a compilation step before PostCSS
       * (for example, from Sass compiler).
       *
       * @type {PreviousMap}
       *
       * @example
       * root.source.input.map.consumer().sources //=> ['a.sass']
       */
      this.map = map;
      var file = map.consumer().file;
      if (!this.file && file) this.file = this.mapResolve(file);
    }

    if (!this.file) {
      sequence += 1;
      /**
       * The unique ID of the CSS source. It will be created if `from` option
       * is not provided (because PostCSS does not know the file path).
       *
       * @type {string}
       *
       * @example
       * const root = postcss.parse(css)
       * root.source.input.file //=> undefined
       * root.source.input.id   //=> "<input css 1>"
       */

      this.id = '<input css ' + sequence + '>';
    }

    if (this.map) this.map.file = this.from;
  }

  var _proto = Input.prototype;

  _proto.error = function error(message, line, column, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var result;
    var origin = this.origin(line, column);

    if (origin) {
      result = new _cssSyntaxError.default(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);
    } else {
      result = new _cssSyntaxError.default(message, line, column, this.css, this.file, opts.plugin);
    }

    result.input = {
      line: line,
      column: column,
      source: this.css
    };
    if (this.file) result.input.file = this.file;
    return result;
  }
  /**
   * Reads the input source map and returns a symbol position
   * in the input source (e.g., in a Sass file that was compiled
   * to CSS before being passed to PostCSS).
   *
   * @param {number} line   Line in input CSS.
   * @param {number} column Column in input CSS.
   *
   * @return {filePosition} Position in input source.
   *
   * @example
   * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }
   */
  ;

  _proto.origin = function origin(line, column) {
    if (!this.map) return false;
    var consumer = this.map.consumer();
    var from = consumer.originalPositionFor({
      line: line,
      column: column
    });
    if (!from.source) return false;
    var result = {
      file: this.mapResolve(from.source),
      line: from.line,
      column: from.column
    };
    var source = consumer.sourceContentFor(from.source);
    if (source) result.source = source;
    return result;
  };

  _proto.mapResolve = function mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }

    return _path.default.resolve(this.map.consumer().sourceRoot || '.', file);
  }
  /**
   * The CSS source identifier. Contains {@link Input#file} if the user
   * set the `from` option, or {@link Input#id} if they did not.
   *
   * @type {string}
   *
   * @example
   * const root = postcss.parse(css, { from: 'a.css' })
   * root.source.input.from //=> "/home/ai/a.css"
   *
   * const root = postcss.parse(css)
   * root.source.input.from //=> "<input css 1>"
   */
  ;

  _createClass(Input, [{
    key: "from",
    get: function get() {
      return this.file || this.id;
    }
  }]);

  return Input;
}();

var _default = Input;
/**
 * @typedef  {object} filePosition
 * @property {string} file   Path to file.
 * @property {number} line   Source line in file.
 * @property {number} column Source column in file.
 */

exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlucHV0LmVzNiJdLCJuYW1lcyI6WyJzZXF1ZW5jZSIsIklucHV0IiwiY3NzIiwib3B0cyIsInRvU3RyaW5nIiwiRXJyb3IiLCJoYXNCT00iLCJzbGljZSIsImZyb20iLCJ0ZXN0IiwicGF0aCIsImlzQWJzb2x1dGUiLCJmaWxlIiwicmVzb2x2ZSIsIm1hcCIsIlByZXZpb3VzTWFwIiwidGV4dCIsImNvbnN1bWVyIiwibWFwUmVzb2x2ZSIsImlkIiwiZXJyb3IiLCJtZXNzYWdlIiwibGluZSIsImNvbHVtbiIsInJlc3VsdCIsIm9yaWdpbiIsIkNzc1N5bnRheEVycm9yIiwic291cmNlIiwicGx1Z2luIiwiaW5wdXQiLCJvcmlnaW5hbFBvc2l0aW9uRm9yIiwic291cmNlQ29udGVudEZvciIsInNvdXJjZVJvb3QiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7Ozs7Ozs7O0FBRUEsSUFBSUEsUUFBUSxHQUFHLENBQWY7QUFFQTs7Ozs7Ozs7SUFPTUMsSzs7O0FBQ0o7Ozs7QUFJQSxpQkFBYUMsR0FBYixFQUFrQkMsSUFBbEIsRUFBOEI7QUFBQSxRQUFaQSxJQUFZO0FBQVpBLE1BQUFBLElBQVksR0FBTCxFQUFLO0FBQUE7O0FBQzVCLFFBQ0VELEdBQUcsS0FBSyxJQUFSLElBQ0EsT0FBT0EsR0FBUCxLQUFlLFdBRGYsSUFFQyxPQUFPQSxHQUFQLEtBQWUsUUFBZixJQUEyQixDQUFDQSxHQUFHLENBQUNFLFFBSG5DLEVBSUU7QUFDQSxZQUFNLElBQUlDLEtBQUosdUJBQStCSCxHQUEvQiw0QkFBTjtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7O0FBU0EsU0FBS0EsR0FBTCxHQUFXQSxHQUFHLENBQUNFLFFBQUosRUFBWDs7QUFFQSxRQUFJLEtBQUtGLEdBQUwsQ0FBUyxDQUFULE1BQWdCLFFBQWhCLElBQTRCLEtBQUtBLEdBQUwsQ0FBUyxDQUFULE1BQWdCLFFBQWhELEVBQTBEO0FBQ3hELFdBQUtJLE1BQUwsR0FBYyxJQUFkO0FBQ0EsV0FBS0osR0FB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YSxtQkFBVCxDQUE2QjtBQUFFUixNQUFBQSxJQUFJLEVBQUpBLElBQUY7QUFBUUMsTUFBQUEsTUFBTSxFQUFOQTtBQUFSLEtBQTdCLENBQVg7QUFDQSxRQUFJLENBQUNmLElBQUksQ0FBQ21CLE1BQVYsRUFBa0IsT0FBTyxLQUFQO0FBRWxCLFFBQUlILE1BQU0sR0FBRztBQUNYWixNQUFBQSxJQUFJLEVBQUUsS0FBS00sVUFBTCxDQUFnQlYsSUFBSSxDQUFDbUIsTUFBckIsQ0FESztBQUVYTCxNQUFBQSxJQUFJLEVBQUVkLElBQUksQ0FBQ2MsSUFGQTtBQUdYQyxNQUFBQSxNQUFNLEVBQUVmLElBQUksQ0FBQ2U7QUFIRixLQUFiO0FBTUEsUUFBSUksTUFBTSxHQUFHVixRQUFRLENBQUNjLGdCQUFULENBQTBCdkIsSUFBSSxDQUFDbUIsTUFBL0IsQ0FBYjtBQUNBLFFBQUlBLE1BQUosRUFBWUgsTUFBTSxDQUFDRyxNQUFQLEdBQWdCQSxNQUFoQjtBQUVaLFdBQU9ILE1BQVA7QUFDRCxHOztTQUVETixVLEdBQUEsb0JBQVlOLElBQVosRUFBa0I7QUFDaEIsUUFBSSxZQUFZSCxJQUFaLENBQWlCRyxJQUFqQixDQUFKLEVBQTRCO0FBQzFCLGFBQU9BLElBQVA7QUFDRDs7QUFDRCxXQUFPRixjQUFLRyxPQUFMLENBQWEsS0FBS0MsR0FBTCxDQUFTRyxRQUFULEdBQW9CZSxVQUFwQixJQUFrQyxHQUEvQyxFQUFvRHBCLElBQXBELENBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFhWTtBQUNWLGFBQU8sS0FBS0EsSUFBTCxJQUFhLEtBQUtPLEVBQXpCO0FBQ0Q7Ozs7OztlQUdZbEIsSztBQUVmIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcblxuaW1wb3J0IENzc1N5bnRheEVycm9yIGZyb20gJy4vY3NzLXN5bnRheC1lcnJvcidcbmltcG9ydCBQcmV2aW91c01hcCBmcm9tICcuL3ByZXZpb3VzLW1hcCdcblxubGV0IHNlcXVlbmNlID0gMFxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHNvdXJjZSBDU1MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJvb3QgID0gcG9zdGNzcy5wYXJzZShjc3MsIHsgZnJvbTogZmlsZSB9KVxuICogY29uc3QgaW5wdXQgPSByb290LnNvdXJjZS5pbnB1dFxuICovXG5jbGFzcyBJbnB1dCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3NzICAgIElucHV0IENTUyBzb3VyY2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10ge0BsaW5rIFByb2Nlc3NvciNwcm9jZXNzfSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNzcywgb3B0cyA9IHsgfSkge1xuICAgIGlmIChcbiAgICAgIGNzcyA9PT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIGNzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICh0eXBlb2YgY3NzID09PSAnb2JqZWN0JyAmJiAhY3NzLnRvU3RyaW5nKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3N0Q1NTIHJlY2VpdmVkICR7IGNzcyB9IGluc3RlYWQgb2YgQ1NTIHN0cmluZ2ApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5wdXQgQ1NTIHNvdXJjZVxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgaW5wdXQgPSBwb3N0Y3NzLnBhcnNlKCdhe30nLCB7IGZyb206IGZpbGUgfSkuaW5wdXRcbiAgICAgKiBpbnB1dC5jc3MgLy89PiBcImF7fVwiXG4gICAgICovXG4gICAgdGhpcy5jc3MgPSBjc3MudG9TdHJpbmcoKVxuXG4gICAgaWYgKHRoaXMuY3NzWzBdID09PSAnXFx1RkVGRicgfHwgdGhpcy5jc3NbMF0gPT09ICdcXHVGRkZFJykge1xuICAgICAgdGhpcy5oYXNCT00gPSB0cnVlXG4gICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnNsaWNlKDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzQk9NID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAob3B0cy5mcm9tKSB7XG4gICAgICBpZiAoL15cXHcrOlxcL1xcLy8udGVzdChvcHRzLmZyb20pIHx8IHBhdGguaXNBYnNvbHV0ZShvcHRzLmZyb20pKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgQ1NTIHNvdXJjZSBmaWxlIGRlZmluZWRcbiAgICAgICAgICogd2l0aCB0aGUgYGZyb21gIG9wdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoY3NzLCB7IGZyb206ICdhLmNzcycgfSlcbiAgICAgICAgICogcm9vdC5zb3VyY2UuaW5wdXQuZmlsZSAvLz0+ICcvaG9tZS9haS9hLmNzcydcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsZSA9IG9wdHMuZnJvbVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maWxlID0gcGF0aC5yZXNvbHZlKG9wdHMuZnJvbSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbWFwID0gbmV3IFByZXZpb3VzTWFwKHRoaXMuY3NzLCBvcHRzKVxuICAgIGlmIChtYXAudGV4dCkge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaW5wdXQgc291cmNlIG1hcCBwYXNzZWQgZnJvbSBhIGNvbXBpbGF0aW9uIHN0ZXAgYmVmb3JlIFBvc3RDU1NcbiAgICAgICAqIChmb3IgZXhhbXBsZSwgZnJvbSBTYXNzIGNvbXBpbGVyKS5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7UHJldmlvdXNNYXB9XG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIHJvb3Quc291cmNlLmlucHV0Lm1hcC5jb25zdW1lcigpLnNvdXJjZXMgLy89PiBbJ2Euc2FzcyddXG4gICAgICAgKi9cbiAgICAgIHRoaXMubWFwID0gbWFwXG4gICAgICBsZXQgZmlsZSA9IG1hcC5jb25zdW1lcigpLmZpbGVcbiAgICAgIGlmICghdGhpcy5maWxlICYmIGZpbGUpIHRoaXMuZmlsZSA9IHRoaXMubWFwUmVzb2x2ZShmaWxlKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5maWxlKSB7XG4gICAgICBzZXF1ZW5jZSArPSAxXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIENTUyBzb3VyY2UuIEl0IHdpbGwgYmUgY3JlYXRlZCBpZiBgZnJvbWAgb3B0aW9uXG4gICAgICAgKiBpcyBub3QgcHJvdmlkZWQgKGJlY2F1c2UgUG9zdENTUyBkb2VzIG5vdCBrbm93IHRoZSBmaWxlIHBhdGgpLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKGNzcylcbiAgICAgICAqIHJvb3Quc291cmNlLmlucHV0LmZpbGUgLy89PiB1bmRlZmluZWRcbiAgICAgICAqIHJvb3Quc291cmNlLmlucHV0LmlkICAgLy89PiBcIjxpbnB1dCBjc3MgMT5cIlxuICAgICAgICovXG4gICAgICB0aGlzLmlkID0gJzxpbnB1dCBjc3MgJyArIHNlcXVlbmNlICsgJz4nXG4gICAgfVxuICAgIGlmICh0aGlzLm1hcCkgdGhpcy5tYXAuZmlsZSA9IHRoaXMuZnJvbVxuICB9XG5cbiAgZXJyb3IgKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgb3B0cyA9IHsgfSkge1xuICAgIGxldCByZXN1bHRcbiAgICBsZXQgb3JpZ2luID0gdGhpcy5vcmlnaW4obGluZSwgY29sdW1uKVxuICAgIGlmIChvcmlnaW4pIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDc3NTeW50YXhFcnJvcihcbiAgICAgICAgbWVzc2FnZSwgb3JpZ2luLmxpbmUsIG9yaWdpbi5jb2x1bW4sXG4gICAgICAgIG9yaWdpbi5zb3VyY2UsIG9yaWdpbi5maWxlLCBvcHRzLnBsdWdpblxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBuZXcgQ3NzU3ludGF4RXJyb3IoXG4gICAgICAgIG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgdGhpcy5jc3MsIHRoaXMuZmlsZSwgb3B0cy5wbHVnaW4pXG4gICAgfVxuXG4gICAgcmVzdWx0LmlucHV0ID0geyBsaW5lLCBjb2x1bW4sIHNvdXJjZTogdGhpcy5jc3MgfVxuICAgIGlmICh0aGlzLmZpbGUpIHJlc3VsdC5pbnB1dC5maWxlID0gdGhpcy5maWxlXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIGlucHV0IHNvdXJjZSBtYXAgYW5kIHJldHVybnMgYSBzeW1ib2wgcG9zaXRpb25cbiAgICogaW4gdGhlIGlucHV0IHNvdXJjZSAoZS5nLiwgaW4gYSBTYXNzIGZpbGUgdGhhdCB3YXMgY29tcGlsZWRcbiAgICogdG8gQ1NTIGJlZm9yZSBiZWluZyBwYXNzZWQgdG8gUG9zdENTUykuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lICAgTGluZSBpbiBpbnB1dCBDU1MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4gQ29sdW1uIGluIGlucHV0IENTUy5cbiAgICpcbiAgICogQHJldHVybiB7ZmlsZVBvc2l0aW9ufSBQb3NpdGlvbiBpbiBpbnB1dCBzb3VyY2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJvb3Quc291cmNlLmlucHV0Lm9yaWdpbigxLCAxKSAvLz0+IHsgZmlsZTogJ2EuY3NzJywgbGluZTogMywgY29sdW1uOiAxIH1cbiAgICovXG4gIG9yaWdpbiAobGluZSwgY29sdW1uKSB7XG4gICAgaWYgKCF0aGlzLm1hcCkgcmV0dXJuIGZhbHNlXG4gICAgbGV0IGNvbnN1bWVyID0gdGhpcy5tYXAuY29uc3VtZXIoKVxuXG4gICAgbGV0IGZyb20gPSBjb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHsgbGluZSwgY29sdW1uIH0pXG4gICAgaWYgKCFmcm9tLnNvdXJjZSkgcmV0dXJuIGZhbHNlXG5cbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgZmlsZTogdGhpcy5tYXBSZXNvbHZlKGZyb20uc291cmNlKSxcbiAgICAgIGxpbmU6IGZyb20ubGluZSxcbiAgICAgIGNvbHVtbjogZnJvbS5jb2x1bW5cbiAgICB9XG5cbiAgICBsZXQgc291cmNlID0gY29uc3VtZXIuc291cmNlQ29udGVudEZvcihmcm9tLnNvdXJjZSlcbiAgICBpZiAoc291cmNlKSByZXN1bHQuc291cmNlID0gc291cmNlXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBtYXBSZXNvbHZlIChmaWxlKSB7XG4gICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHtcbiAgICAgIHJldHVybiBmaWxlXG4gICAgfVxuICAgIHJldHVybiBwYXRoLnJlc29sdmUodGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8ICcuJywgZmlsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQ1NTIHNvdXJjZSBpZGVudGlmaWVyLiBDb250YWlucyB7QGxpbmsgSW5wdXQjZmlsZX0gaWYgdGhlIHVzZXJcbiAgICogc2V0IHRoZSBgZnJvbWAgb3B0aW9uLCBvciB7QGxpbmsgSW5wdXQjaWR9IGlmIHRoZXkgZGlkIG5vdC5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoY3NzLCB7IGZyb206ICdhLmNzcycgfSlcbiAgICogcm9vdC5zb3VyY2UuaW5wdXQuZnJvbSAvLz0+IFwiL2hvbWUvYWkvYS5jc3NcIlxuICAgKlxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZShjc3MpXG4gICAqIHJvb3Quc291cmNlLmlucHV0LmZyb20gLy89PiBcIjxpbnB1dCBjc3MgMT5cIlxuICAgKi9cbiAgZ2V0IGZyb20gKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGUgfHwgdGhpcy5pZFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0XG5cbi8qKlxuICogQHR5cGVkZWYgIHtvYmplY3R9IGZpbGVQb3NpdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZpbGUgICBQYXRoIHRvIGZpbGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZSAgIFNvdXJjZSBsaW5lIGluIGZpbGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29sdW1uIFNvdXJjZSBjb2x1bW4gaW4gZmlsZS5cbiAqL1xuIl0sImZpbGUiOiJpbnB1dC5qcyJ9


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;
exports.default = void 0;

var _sourceMap = _interopRequireDefault(__webpack_require__(39));

var _path = _interopRequireDefault(__webpack_require__(3));

var _fs = _interopRequireDefault(__webpack_require__(94));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, 'base64').toString();
  } else {
    return window.atob(str);
  }
}
/**
 * Source map information from input CSS.
 * For example, source map after Sass compiler.
 *
 * This class will automatically find source map in input CSS or in file system
 * near input file (according `from` option).
 *
 * @example
 * const root = postcss.parse(css, { from: 'a.sass.css' })
 * root.input.map //=> PreviousMap
 */


var PreviousMap =
/*#__PURE__*/
function () {
  /**
   * @param {string}         css    Input CSS source.
   * @param {processOptions} [opts] {@link Processor#process} options.
   */
  function PreviousMap(css, opts) {
    this.loadAnnotation(css);
    /**
     * Was source map inlined by data-uri to input CSS.
     *
     * @type {boolean}
     */

    this.inline = this.startWith(this.annotation, 'data:');
    var prev = opts.map ? opts.map.prev : undefined;
    var text = this.loadMap(opts.from, prev);
    if (text) this.text = text;
  }
  /**
   * Create a instance of `SourceMapGenerator` class
   * from the `source-map` library to work with source map information.
   *
   * It is lazy method, so it will create object only on first call
   * and then it will use cache.
   *
   * @return {SourceMapGenerator} Object with source map information.
   */


  var _proto = PreviousMap.prototype;

  _proto.consumer = function consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new _sourceMap.default.SourceMapConsumer(this.text);
    }

    return this.consumerCache;
  }
  /**
   * Does source map contains `sourcesContent` with input source text.
   *
   * @return {boolean} Is `sourcesContent` present.
   */
  ;

  _proto.withContent = function withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  };

  _proto.startWith = function startWith(string, start) {
    if (!string) return false;
    return string.substr(0, start.length) === start;
  };

  _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {
    return sourceMapString.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//)[1].trim();
  };

  _proto.loadAnnotation = function loadAnnotation(css) {
    var annotations = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//mg);

    if (annotations && annotations.length > 0) {
      // Locate the last sourceMappingURL to avoid picking up
      // sourceMappingURLs from comments, strings, etc.
      var lastAnnotation = annotations[annotations.length - 1];

      if (lastAnnotation) {
        this.annotation = this.getAnnotationURL(lastAnnotation);
      }
    }
  };

  _proto.decodeInline = function decodeInline(text) {
    var baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    var baseUri = /^data:application\/json;base64,/;
    var uri = 'data:application/json,';

    if (this.startWith(text, uri)) {
      return decodeURIComponent(text.substr(uri.length));
    }

    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64(text.substr(RegExp.lastMatch.length));
    }

    var encoding = text.match(/data:application\/json;([^,]+),/)[1];
    throw new Error('Unsupported source map encoding ' + encoding);
  };

  _proto.loadMap = function loadMap(file, prev) {
    if (prev === false) return false;

    if (prev) {
      if (typeof prev === 'string') {
        return prev;
      } else if (typeof prev === 'function') {
        var prevPath = prev(file);

        if (prevPath && _fs.default.existsSync && _fs.default.existsSync(prevPath)) {
          return _fs.default.readFileSync(prevPath, 'utf-8').toString().trim();
        } else {
          throw new Error('Unable to load previous source map: ' + prevPath.toString());
        }
      } else if (prev instanceof _sourceMap.default.SourceMapConsumer) {
        return _sourceMap.default.SourceMapGenerator.fromSourceMap(prev).toString();
      } else if (prev instanceof _sourceMap.default.SourceMapGenerator) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error('Unsupported previous source map format: ' + prev.toString());
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      var map = this.annotation;
      if (file) map = _path.default.join(_path.default.dirname(file), map);
      this.root = _path.default.dirname(map);

      if (_fs.default.existsSync && _fs.default.existsSync(map)) {
        return _fs.default.readFileSync(map, 'utf-8').toString().trim();
      } else {
        return false;
      }
    }
  };

  _proto.isMap = function isMap(map) {
    if (typeof map !== 'object') return false;
    return typeof map.mappings === 'string' || typeof map._mappings === 'string';
  };

  return PreviousMap;
}();

var _default = PreviousMap;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByZXZpb3VzLW1hcC5lczYiXSwibmFtZXMiOlsiZnJvbUJhc2U2NCIsInN0ciIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsIndpbmRvdyIsImF0b2IiLCJQcmV2aW91c01hcCIsImNzcyIsIm9wdHMiLCJsb2FkQW5ub3RhdGlvbiIsImlubGluZSIsInN0YXJ0V2l0aCIsImFubm90YXRpb24iLCJwcmV2IiwibWFwIiwidW5kZWZpbmVkIiwidGV4dCIsImxvYWRNYXAiLCJjb25zdW1lciIsImNvbnN1bWVyQ2FjaGUiLCJtb3ppbGxhIiwiU291cmNlTWFwQ29uc3VtZXIiLCJ3aXRoQ29udGVudCIsInNvdXJjZXNDb250ZW50IiwibGVuZ3RoIiwic3RyaW5nIiwic3RhcnQiLCJzdWJzdHIiLCJnZXRBbm5vdGF0aW9uVVJMIiwic291cmNlTWFwU3RyaW5nIiwibWF0Y2giLCJ0cmltIiwiYW5ub3RhdGlvbnMiLCJsYXN0QW5ub3RhdGlvbiIsImRlY29kZUlubGluZSIsImJhc2VDaGFyc2V0VXJpIiwiYmFzZVVyaSIsInVyaSIsImRlY29kZVVSSUNvbXBvbmVudCIsInRlc3QiLCJSZWdFeHAiLCJsYXN0TWF0Y2giLCJlbmNvZGluZyIsIkVycm9yIiwiZmlsZSIsInByZXZQYXRoIiwiZnMiLCJleGlzdHNTeW5jIiwicmVhZEZpbGVTeW5jIiwiU291cmNlTWFwR2VuZXJhdG9yIiwiZnJvbVNvdXJjZU1hcCIsImlzTWFwIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhdGgiLCJqb2luIiwiZGlybmFtZSIsInJvb3QiLCJtYXBwaW5ncyIsIl9tYXBwaW5ncyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7OztBQUVBLFNBQVNBLFVBQVQsQ0FBcUJDLEdBQXJCLEVBQTBCO0FBQ3hCLE1BQUlDLE1BQUosRUFBWTtBQUNWLFdBQU9BLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZRixHQUFaLEVBQWlCLFFBQWpCLEVBQTJCRyxRQUEzQixFQUFQO0FBQ0QsR0FGRCxN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QUFMLENBQWV4QyxJQUFmLENBQVA7QUFDRCxPQUZNLE1BRUE7QUFDTCxjQUFNLElBQUk4QixLQUFKLENBQ0osNkNBQTZDOUIsSUFBSSxDQUFDVixRQUFMLEVBRHpDLENBQU47QUFFRDtBQUNGLEtBckJELE1BcUJPLElBQUksS0FBS08sTUFBVCxFQUFpQjtBQUN0QixhQUFPLEtBQUt3QixZQUFMLENBQWtCLEtBQUt0QixVQUF2QixDQUFQO0FBQ0QsS0FGTSxNQUVBLElBQUksS0FBS0EsVUFBVCxFQUFxQjtBQUMxQixVQUFJRSxHQUFHLEdBQUcsS0FBS0YsVUFBZjtBQUNBLFVBQUlnQyxJQUFKLEVBQVU5QixHQUFHLEdBQUd3QyxjQUFLQyxJQUFMLENBQVVELGNBQUtFLE9BQUwsQ0FBYVosSUFBYixDQUFWLEVBQThCOUIsR0FBOUIsQ0FBTjtBQUVWLFdBQUsyQyxJQUFMLEdBQVlILGNBQUtFLE9BQUwsQ0FBYTFDLEdBQWIsQ0FBWjs7QUFDQSxVQUFJZ0MsWUFBR0MsVUFBSCxJQUFpQkQsWUFBR0MsVUFBSCxDQUFjakMsR0FBZCxDQUFyQixFQUF5QztBQUN2QyxlQUFPZ0MsWUFBR0UsWUFBSCxDQUFnQmxDLEdBQWhCLEVBQXFCLE9BQXJCLEVBQThCWCxRQUE5QixHQUF5QzRCLElBQXpDLEVBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0YsRzs7U0FFRG9CLEssR0FBQSxlQUFPckMsR0FBUCxFQUFZO0FBQ1YsUUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkIsT0FBTyxLQUFQO0FBQzdCLFdBQU8sT0FBT0EsR0FBRyxDQUFDNEMsUUFBWCxLQUF3QixRQUF4QixJQUFvQyxPQUFPNUMsR0FBRyxDQUFDNkMsU0FBWCxLQUF5QixRQUFwRTtBQUNELEc7Ozs7O2VBR1lyRCxXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vemlsbGEgZnJvbSAnc291cmNlLW1hcCdcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXG5pbXBvcnQgZnMgZnJvbSAnZnMnXG5cbmZ1bmN0aW9uIGZyb21CYXNlNjQgKHN0cikge1xuICBpZiAoQnVmZmVyKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgJ2Jhc2U2NCcpLnRvU3RyaW5nKClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd2luZG93LmF0b2Ioc3RyKVxuICB9XG59XG5cbi8qKlxuICogU291cmNlIG1hcCBpbmZvcm1hdGlvbiBmcm9tIGlucHV0IENTUy5cbiAqIEZvciBleGFtcGxlLCBzb3VyY2UgbWFwIGFmdGVyIFNhc3MgY29tcGlsZXIuXG4gKlxuICogVGhpcyBjbGFzcyB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBzb3VyY2UgbWFwIGluIGlucHV0IENTUyBvciBpbiBmaWxlIHN5c3RlbVxuICogbmVhciBpbnB1dCBmaWxlIChhY2NvcmRpbmcgYGZyb21gIG9wdGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKGNzcywgeyBmcm9tOiAnYS5zYXNzLmNzcycgfSlcbiAqIHJvb3QuaW5wdXQubWFwIC8vPT4gUHJldmlvdXNNYXBcbiAqL1xuY2xhc3MgUHJldmlvdXNNYXAge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgY3NzICAgIElucHV0IENTUyBzb3VyY2UuXG4gICAqIEBwYXJhbSB7cHJvY2Vzc09wdGlvbnN9IFtvcHRzXSB7QGxpbmsgUHJvY2Vzc29yI3Byb2Nlc3N9IG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY3NzLCBvcHRzKSB7XG4gICAgdGhpcy5sb2FkQW5ub3RhdGlvbihjc3MpXG4gICAgLyoqXG4gICAgICogV2FzIHNvdXJjZSBtYXAgaW5saW5lZCBieSBkYXRhLXVyaSB0byBpbnB1dCBDU1MuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlubGluZSA9IHRoaXMuc3RhcnRXaXRoKHRoaXMuYW5ub3RhdGlvbiwgJ2RhdGE6JylcblxuICAgIGxldCBwcmV2ID0gb3B0cy5tYXAgPyBvcHRzLm1hcC5wcmV2IDogdW5kZWZpbmVkXG4gICAgbGV0IHRleHQgPSB0aGlzLmxvYWRNYXAob3B0cy5mcm9tLCBwcmV2KVxuICAgIGlmICh0ZXh0KSB0aGlzLnRleHQgPSB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgaW5zdGFuY2Ugb2YgYFNvdXJjZU1hcEdlbmVyYXRvcmAgY2xhc3NcbiAgICogZnJvbSB0aGUgYHNvdXJjZS1tYXBgIGxpYnJhcnkgdG8gd29yayB3aXRoIHNvdXJjZSBtYXAgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEl0IGlzIGxhenkgbWV0aG9kLCBzbyBpdCB3aWxsIGNyZWF0ZSBvYmplY3Qgb25seSBvbiBmaXJzdCBjYWxsXG4gICAqIGFuZCB0aGVuIGl0IHdpbGwgdXNlIGNhY2hlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTb3VyY2VNYXBHZW5lcmF0b3J9IE9iamVjdCB3aXRoIHNvdXJjZSBtYXAgaW5mb3JtYXRpb24uXG4gICAqL1xuICBjb25zdW1lciAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgIHRoaXMuY29uc3VtZXJDYWNoZSA9IG5ldyBtb3ppbGxhLlNvdXJjZU1hcENvbnN1bWVyKHRoaXMudGV4dClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uc3VtZXJDYWNoZVxuICB9XG5cbiAgLyoqXG4gICAqIERvZXMgc291cmNlIG1hcCBjb250YWlucyBgc291cmNlc0NvbnRlbnRgIHdpdGggaW5wdXQgc291cmNlIHRleHQuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGBzb3VyY2VzQ29udGVudGAgcHJlc2VudC5cbiAgICovXG4gIHdpdGhDb250ZW50ICgpIHtcbiAgICByZXR1cm4gISEodGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50ICYmXG4gICAgICAgICAgICAgIHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudC5sZW5ndGggPiAwKVxuICB9XG5cbiAgc3RhcnRXaXRoIChzdHJpbmcsIHN0YXJ0KSB7XG4gICAgaWYgKCFzdHJpbmcpIHJldHVybiBmYWxzZVxuICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIHN0YXJ0Lmxlbmd0aCkgPT09IHN0YXJ0XG4gIH1cblxuICBnZXRBbm5vdGF0aW9uVVJMIChzb3VyY2VNYXBTdHJpbmcpIHtcbiAgICByZXR1cm4gc291cmNlTWFwU3RyaW5nXG4gICAgICAubWF0Y2goL1xcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9KC4qKVxccypcXCpcXC8vKVsxXVxuICAgICAgLnRyaW0oKVxuICB9XG5cbiAgbG9hZEFubm90YXRpb24gKGNzcykge1xuICAgIGxldCBhbm5vdGF0aW9ucyA9IGNzcy5tYXRjaCgvXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0oLiopXFxzKlxcKlxcLy9tZylcblxuICAgIGlmIChhbm5vdGF0aW9ucyAmJiBhbm5vdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBMb2NhdGUgdGhlIGxhc3Qgc291cmNlTWFwcGluZ1VSTCB0byBhdm9pZCBwaWNraW5nIHVwXG4gICAgICAvLyBzb3VyY2VNYXBwaW5nVVJMcyBmcm9tIGNvbW1lbnRzLCBzdHJpbmdzLCBldGMuXG4gICAgICBsZXQgbGFzdEFubm90YXRpb24gPSBhbm5vdGF0aW9uc1thbm5vdGF0aW9ucy5sZW5ndGggLSAxXVxuICAgICAgaWYgKGxhc3RBbm5vdGF0aW9uKSB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbiA9IHRoaXMuZ2V0QW5ub3RhdGlvblVSTChsYXN0QW5ub3RhdGlvbilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWNvZGVJbmxpbmUgKHRleHQpIHtcbiAgICBsZXQgYmFzZUNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84O2Jhc2U2NCwvXG4gICAgbGV0IGJhc2VVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2Jhc2U2NCwvXG4gICAgbGV0IHVyaSA9ICdkYXRhOmFwcGxpY2F0aW9uL2pzb24sJ1xuXG4gICAgaWYgKHRoaXMuc3RhcnRXaXRoKHRleHQsIHVyaSkpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodGV4dC5zdWJzdHIodXJpLmxlbmd0aCkpXG4gICAgfVxuXG4gICAgaWYgKGJhc2VDaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgYmFzZVVyaS50ZXN0KHRleHQpKSB7XG4gICAgICByZXR1cm4gZnJvbUJhc2U2NCh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpXG4gICAgfVxuXG4gICAgbGV0IGVuY29kaW5nID0gdGV4dC5tYXRjaCgvZGF0YTphcHBsaWNhdGlvblxcL2pzb247KFteLF0rKSwvKVsxXVxuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc291cmNlIG1hcCBlbmNvZGluZyAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBsb2FkTWFwIChmaWxlLCBwcmV2KSB7XG4gICAgaWYgKHByZXYgPT09IGZhbHNlKSByZXR1cm4gZmFsc2VcblxuICAgIGlmIChwcmV2KSB7XG4gICAgICBpZiAodHlwZW9mIHByZXYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwcmV2XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcmV2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxldCBwcmV2UGF0aCA9IHByZXYoZmlsZSlcbiAgICAgICAgaWYgKHByZXZQYXRoICYmIGZzLmV4aXN0c1N5bmMgJiYgZnMuZXhpc3RzU3luYyhwcmV2UGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKHByZXZQYXRoLCAndXRmLTgnKS50b1N0cmluZygpLnRyaW0oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdVbmFibGUgdG8gbG9hZCBwcmV2aW91cyBzb3VyY2UgbWFwOiAnICsgcHJldlBhdGgudG9TdHJpbmcoKSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcmV2IGluc3RhbmNlb2YgbW96aWxsYS5Tb3VyY2VNYXBDb25zdW1lcikge1xuICAgICAgICByZXR1cm4gbW96aWxsYS5Tb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcChwcmV2KS50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHByZXYgaW5zdGFuY2VvZiBtb3ppbGxhLlNvdXJjZU1hcEdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gcHJldi50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNNYXAocHJldikpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1Vuc3VwcG9ydGVkIHByZXZpb3VzIHNvdXJjZSBtYXAgZm9ybWF0OiAnICsgcHJldi50b1N0cmluZygpKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZUlubGluZSh0aGlzLmFubm90YXRpb24pXG4gICAgfSBlbHNlIGlmICh0aGlzLmFubm90YXRpb24pIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLmFubm90YXRpb25cbiAgICAgIGlmIChmaWxlKSBtYXAgPSBwYXRoLmpvaW4ocGF0aC5kaXJuYW1lKGZpbGUpLCBtYXApXG5cbiAgICAgIHRoaXMucm9vdCA9IHBhdGguZGlybmFtZShtYXApXG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyAmJiBmcy5leGlzdHNTeW5jKG1hcCkpIHtcbiAgICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhtYXAsICd1dGYtOCcpLnRvU3RyaW5nKCkudHJpbSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc01hcCAobWFwKSB7XG4gICAgaWYgKHR5cGVvZiBtYXAgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gdHlwZW9mIG1hcC5tYXBwaW5ncyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG1hcC5fbWFwcGluZ3MgPT09ICdzdHJpbmcnXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJldmlvdXNNYXBcbiJdLCJmaWxlIjoicHJldmlvdXMtbWFwLmpzIn0=

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18).Buffer))

/***/ }),
/* 94 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = void 0;

/**
 * Contains helpers for working with vendor prefixes.
 *
 * @example
 * const vendor = postcss.vendor
 *
 * @namespace vendor
 */
var vendor = {
  /**
   * Returns the vendor prefix extracted from an input string.
   *
   * @param {string} prop String with or without vendor prefix.
   *
   * @return {string} vendor prefix or empty string
   *
   * @example
   * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'
   * postcss.vendor.prefix('tab-size')      //=> ''
   */
  prefix: function prefix(prop) {
    var match = prop.match(/^(-\w+-)/);

    if (match) {
      return match[0];
    }

    return '';
  },

  /**
     * Returns the input string stripped of its vendor prefix.
     *
     * @param {string} prop String with or without vendor prefix.
     *
     * @return {string} String name without vendor prefixes.
     *
     * @example
     * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
     */
  unprefixed: function unprefixed(prop) {
    return prop.replace(/^-\w+-/, '');
  }
};
var _default = vendor;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZlbmRvci5lczYiXSwibmFtZXMiOlsidmVuZG9yIiwicHJlZml4IiwicHJvcCIsIm1hdGNoIiwidW5wcmVmaXhlZCIsInJlcGxhY2UiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUEsSUFBSUEsTUFBTSxHQUFHO0FBRVg7Ozs7Ozs7Ozs7O0FBV0FDLEVBQUFBLE1BYlcsa0JBYUhDLElBYkcsRUFhRztBQUNaLFFBQUlDLEtBQUssR0FBR0QsSUFBSSxDQUFDQyxLQUFMLENBQVcsVUFBWCxDQUFaOztBQUNBLFFBQUlBLEtBQUosRUFBVztBQUNULGFBQU9BLEtBQUssQ0FBQyxDQUFELENBQVo7QUFDRDs7QUFFRCxXQUFPLEVBQVA7QUFDRCxHQXBCVTs7QUFzQlg7Ozs7Ozs7Ozs7QUFVQUMsRUFBQUEsVUFoQ1csc0JBZ0NDRixJQWhDRCxFQWdDTztBQUNoQixXQUFPQSxJQUFJLENBQUNHLE9BQUwsQ0FBYSxRQUFiLEVBQXVCLEVBQXZCLENBQVA7QUFDRDtBQWxDVSxDQUFiO2VBc0NlTCxNIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyBoZWxwZXJzIGZvciB3b3JraW5nIHdpdGggdmVuZG9yIHByZWZpeGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB2ZW5kb3IgPSBwb3N0Y3NzLnZlbmRvclxuICpcbiAqIEBuYW1lc3BhY2UgdmVuZG9yXG4gKi9cbmxldCB2ZW5kb3IgPSB7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZlbmRvciBwcmVmaXggZXh0cmFjdGVkIGZyb20gYW4gaW5wdXQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBTdHJpbmcgd2l0aCBvciB3aXRob3V0IHZlbmRvciBwcmVmaXguXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gdmVuZG9yIHByZWZpeCBvciBlbXB0eSBzdHJpbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcy52ZW5kb3IucHJlZml4KCctbW96LXRhYi1zaXplJykgLy89PiAnLW1vei0nXG4gICAqIHBvc3Rjc3MudmVuZG9yLnByZWZpeCgndGFiLXNpemUnKSAgICAgIC8vPT4gJydcbiAgICovXG4gIHByZWZpeCAocHJvcCkge1xuICAgIGxldCBtYXRjaCA9IHByb3AubWF0Y2goL14oLVxcdystKS8pXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2hbMF1cbiAgICB9XG5cbiAgICByZXR1cm4gJydcbiAgfSxcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnB1dCBzdHJpbmcgc3RyaXBwZWQgb2YgaXRzIHZlbmRvciBwcmVmaXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBTdHJpbmcgd2l0aCBvciB3aXRob3V0IHZlbmRvciBwcmVmaXguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyBuYW1lIHdpdGhvdXQgdmVuZG9yIHByZWZpeGVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBwb3N0Y3NzLnZlbmRvci51bnByZWZpeGVkKCctbW96LXRhYi1zaXplJykgLy89PiAndGFiLXNpemUnXG4gICAgICovXG4gIHVucHJlZml4ZWQgKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcC5yZXBsYWNlKC9eLVxcdystLywgJycpXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCB2ZW5kb3JcbiJdLCJmaWxlIjoidmVuZG9yLmpzIn0=


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * Less - Leaner CSS v3.11.3
 * http://lesscss.org
 * 
 * Copyright (c) 2009-2020, Alexis Sellier <self@cloudhead.net>
 * Licensed under the Apache-2.0 License.
 *
 * @license Apache-2.0
 */

(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, (function () { 'use strict';

  // Export a new default each time
  var defaultOptions = (function () { return ({
      /* Inline Javascript - @plugin still allowed */
      javascriptEnabled: false,
      /* Outputs a makefile import dependency list to stdout. */
      depends: false,
      /* (DEPRECATED) Compress using less built-in compression.
    * This does an okay job but does not utilise all the tricks of
    * dedicated css compression. */
      compress: false,
      /* Runs the less parser and just reports errors without any output. */
      lint: false,
      /* Sets available include paths.
    * If the file in an @import rule does not exist at that exact location,
    * less will look for it at the location(s) passed to this option.
    * You might use this for instance to specify a path to a library which
    * you want to be referenced simply and relatively in the less files. */
      paths: [],
      /* color output in the terminal */
      color: true,
      /* The strictImports controls whether the compiler will allow an @import inside of either
    * @media blocks or (a later addition) other selector blocks.
    * See: https://github.com/less/less.js/issues/656 */
      strictImports: false,
      /* Allow Imports from Insecure HTTPS Hosts */
      insecure: false,
      /* Allows you to add a path to every generated import and url in your css.
    * This does not affect less import statements that are processed, just ones
    * that are left in the output css. */
      rootpath: '',
      /* By default URLs are kept as-is, so if you import a file in a sub-directory
    * that references an image, exactly the same URL will be output in the css.
    * This option allows you to re-write URL's in imported files so that the
    * URL is always relative to the base imported file */
      rewriteUrls: false,
      /* How to process math
    *   0 always           - eagerly try to solve all operations
    *   1 parens-division  - require parens for division "/"
    *   2 parens | strict  - require parens for all operations
    *   3 strict-legacy    - legacy strict behavior (super-strict)
    */
      math: 0,
      /* Without this option, less attempts to guess at the output unit when it does maths. */
      strictUnits: false,
      /* Effectively the declaration is put at the top of your base Less file,
    * meaning it can be used but it also can be overridden if this variable
    * is defined in the file. */
      globalVars: null,
      /* As opposed to the global variable option, this puts the declaration at the
    * end of your base file, meaning it will override anything defined in your Less file. */
      modifyVars: null,
      /* This option allows you to specify a argument to go on to every URL.  */
      urlArgs: ''
  }); });

  function extractId(href) {
      return href.replace(/^[a-z-]+:\/+?[^\/]+/, '') // Remove protocol & domain
          .replace(/[\?\&]livereload=\w+/, '') // Remove LiveReload cachebuster
          .replace(/^\//, '') // Remove root /
          .replace(/\.[a-zA-Z]+$/, '') // Remove simple extension
          .replace(/[^\.\w-]+/g, '-') // Replace illegal characters
          .replace(/\./g, ':'); // Replace dots with colons(for valid id)
  }
  function addDataAttr(options, tag) {
      for (var opt in tag.dataset) {
          if (tag.dataset.hasOwnProperty(opt)) {
              if (opt === 'env' || opt === 'dumpLineNumbers' || opt === 'rootpath' || opt === 'errorReporting') {
                  options[opt] = tag.dataset[opt];
              }
              else {
                  try {
                      options[opt] = JSON.parse(tag.dataset[opt]);
                  }
                  catch (_) { }
              }
          }
      }
  }

  var browser = {
      createCSS: function (document, styles, sheet) {
          // Strip the query-string
          var href = sheet.href || '';
          // If there is no title set, use the filename, minus the extension
          var id = "less:" + (sheet.title || extractId(href));
          // If this has already been inserted into the DOM, we may need to replace it
          var oldStyleNode = document.getElementById(id);
          var keepOldStyleNode = false;
          // Create a new stylesheet node for insertion or (if necessary) replacement
          var styleNode = document.createElement('style');
          styleNode.setAttribute('type', 'text/css');
          if (sheet.media) {
              styleNode.setAttribute('media', sheet.media);
          }
          styleNode.id = id;
          if (!styleNode.styleSheet) {
              styleNode.appendChild(document.createTextNode(styles));
              // If new contents match contents of oldStyleNode, don't replace oldStyleNode
              keepOldStyleNode = (oldStyleNode !== null && oldStyleNode.childNodes.length > 0 && styleNode.childNodes.length > 0 &&
                  oldStyleNode.firstChild.nodeValue === styleNode.firstChild.nodeValue);
          }
          var head = document.getElementsByTagName('head')[0];
          // If there is no oldStyleNode, just append; otherwise, only append if we need
          // to replace oldStyleNode with an updated stylesheet
          if (oldStyleNode === null || keepOldStyleNode === false) {
              var nextEl = sheet && sheet.nextSibling || null;
              if (nextEl) {
                  nextEl.parentNode.insertBefore(styleNode, nextEl);
              }
              else {
                  head.appendChild(styleNode);
              }
          }
          if (oldStyleNode && keepOldStyleNode === false) {
              oldStyleNode.parentNode.removeChild(oldStyleNode);
          }
          // For IE.
          // This needs to happen *after* the style element is added to the DOM, otherwise IE 7 and 8 may crash.
          // See http://social.msdn.microsoft.com/Forums/en-US/7e081b65-878a-4c22-8e68-c10d39c2ed32/internet-explorer-crashes-appending-style-element-to-head
          if (styleNode.styleSheet) {
              try {
                  styleNode.styleSheet.cssText = styles;
              }
              catch (e) {
                  throw new Error('Couldn\'t reassign styleSheet.cssText.');
              }
          }
      },
      currentScript: function (window) {
          var document = window.document;
          return document.currentScript || (function () {
              var scripts = document.getElementsByTagName('script');
              return scripts[scripts.length - 1];
          })();
      }
  };

  var addDefaultOptions = (function (window, options) {
      // use options from the current script tag data attribues
      addDataAttr(options, browser.currentScript(window));
      if (options.isFileProtocol === undefined) {
          options.isFileProtocol = /^(file|(chrome|safari)(-extension)?|resource|qrc|app):/.test(window.location.protocol);
      }
      // Load styles asynchronously (default: false)
      //
      // This is set to `false` by default, so that the body
      // doesn't start loading before the stylesheets are parsed.
      // Setting this to `true` can result in flickering.
      //
      options.async = options.async || false;
      options.fileAsync = options.fileAsync || false;
      // Interval between watch polls
      options.poll = options.poll || (options.isFileProtocol ? 1000 : 1500);
      options.env = options.env || (window.location.hostname == '127.0.0.1' ||
          window.location.hostname == '0.0.0.0' ||
          window.location.hostname == 'localhost' ||
          (window.location.port &&
              window.location.port.length > 0) ||
          options.isFileProtocol ? 'development'
          : 'production');
      var dumpLineNumbers = /!dumpLineNumbers:(comments|mediaquery|all)/.exec(window.location.hash);
      if (dumpLineNumbers) {
          options.dumpLineNumbers = dumpLineNumbers[1];
      }
      if (options.useFileCache === undefined) {
          options.useFileCache = true;
      }
      if (options.onReady === undefined) {
          options.onReady = true;
      }
      if (options.relativeUrls) {
          options.rewriteUrls = 'all';
      }
  });

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
      return r;
  }

  var colors = {
      'aliceblue': '#f0f8ff',
      'antiquewhite': '#faebd7',
      'aqua': '#00ffff',
      'aquamarine': '#7fffd4',
      'azure': '#f0ffff',
      'beige': '#f5f5dc',
      'bisque': '#ffe4c4',
      'black': '#000000',
      'blanchedalmond': '#ffebcd',
      'blue': '#0000ff',
      'blueviolet': '#8a2be2',
      'brown': '#a52a2a',
      'burlywood': '#deb887',
      'cadetblue': '#5f9ea0',
      'chartreuse': '#7fff00',
      'chocolate': '#d2691e',
      'coral': '#ff7f50',
      'cornflowerblue': '#6495ed',
      'cornsilk': '#fff8dc',
      'crimson': '#dc143c',
      'cyan': '#00ffff',
      'darkblue': '#00008b',
      'darkcyan': '#008b8b',
      'darkgoldenrod': '#b8860b',
      'darkgray': '#a9a9a9',
      'darkgrey': '#a9a9a9',
      'darkgreen': '#006400',
      'darkkhaki': '#bdb76b',
      'darkmagenta': '#8b008b',
      'darkolivegreen': '#556b2f',
      'darkorange': '#ff8c00',
      'darkorchid': '#9932cc',
      'darkred': '#8b0000',
      'darksalmon': '#e9967a',
      'darkseagreen': '#8fbc8f',
      'darkslateblue': '#483d8b',
      'darkslategray': '#2f4f4f',
      'darkslategrey': '#2f4f4f',
      'darkturquoise': '#00ced1',
      'darkviolet': '#9400d3',
      'deeppink': '#ff1493',
      'deepskyblue': '#00bfff',
      'dimgray': '#696969',
      'dimgrey': '#696969',
      'dodgerblue': '#1e90ff',
      'firebrick': '#b22222',
      'floralwhite': '#fffaf0',
      'forestgreen': '#228b22',
      'fuchsia': '#ff00ff',
      'gainsboro': '#dcdcdc',
      'ghostwhite': '#f8f8ff',
      'gold': '#ffd700',
      'goldenrod': '#daa520',
      'gray': '#808080',
      'grey': '#808080',
      'green': '#008000',
      'greenyellow': '#adff2f',
      'honeydew': '#f0fff0',
      'hotpink': '#ff69b4',
      'indianred': '#cd5c5c',
      'indigo': '#4b0082',
      'ivory': '#fffff0',
      'khaki': '#f0e68c',
      'lavender': '#e6e6fa',
      'lavenderblush': '#fff0f5',
      'lawngreen': '#7cfc00',
      'lemonchiffon': '#fffacd',
      'lightblue': '#add8e6',
      'lightcoral': '#f08080',
      'lightcyan': '#e0ffff',
      'lightgoldenrodyellow': '#fafad2',
      'lightgray': '#d3d3d3',
      'lightgrey': '#d3d3d3',
      'lightgreen': '#90ee90',
      'lightpink': '#ffb6c1',
      'lightsalmon': '#ffa07a',
      'lightseagreen': '#20b2aa',
      'lightskyblue': '#87cefa',
      'lightslategray': '#778899',
      'lightslategrey': '#778899',
      'lightsteelblue': '#b0c4de',
      'lightyellow': '#ffffe0',
      'lime': '#00ff00',
      'limegreen': '#32cd32',
      'linen': '#faf0e6',
      'magenta': '#ff00ff',
      'maroon': '#800000',
      'mediumaquamarine': '#66cdaa',
      'mediumblue': '#0000cd',
      'mediumorchid': '#ba55d3',
      'mediumpurple': '#9370d8',
      'mediumseagreen': '#3cb371',
      'mediumslateblue': '#7b68ee',
      'mediumspringgreen': '#00fa9a',
      'mediumturquoise': '#48d1cc',
      'mediumvioletred': '#c71585',
      'midnightblue': '#191970',
      'mintcream': '#f5fffa',
      'mistyrose': '#ffe4e1',
      'moccasin': '#ffe4b5',
      'navajowhite': '#ffdead',
      'navy': '#000080',
      'oldlace': '#fdf5e6',
      'olive': '#808000',
      'olivedrab': '#6b8e23',
      'orange': '#ffa500',
      'orangered': '#ff4500',
      'orchid': '#da70d6',
      'palegoldenrod': '#eee8aa',
      'palegreen': '#98fb98',
      'paleturquoise': '#afeeee',
      'palevioletred': '#d87093',
      'papayawhip': '#ffefd5',
      'peachpuff': '#ffdab9',
      'peru': '#cd853f',
      'pink': '#ffc0cb',
      'plum': '#dda0dd',
      'powderblue': '#b0e0e6',
      'purple': '#800080',
      'rebeccapurple': '#663399',
      'red': '#ff0000',
      'rosybrown': '#bc8f8f',
      'royalblue': '#4169e1',
      'saddlebrown': '#8b4513',
      'salmon': '#fa8072',
      'sandybrown': '#f4a460',
      'seagreen': '#2e8b57',
      'seashell': '#fff5ee',
      'sienna': '#a0522d',
      'silver': '#c0c0c0',
      'skyblue': '#87ceeb',
      'slateblue': '#6a5acd',
      'slategray': '#708090',
      'slategrey': '#708090',
      'snow': '#fffafa',
      'springgreen': '#00ff7f',
      'steelblue': '#4682b4',
      'tan': '#d2b48c',
      'teal': '#008080',
      'thistle': '#d8bfd8',
      'tomato': '#ff6347',
      'turquoise': '#40e0d0',
      'violet': '#ee82ee',
      'wheat': '#f5deb3',
      'white': '#ffffff',
      'whitesmoke': '#f5f5f5',
      'yellow': '#ffff00',
      'yellowgreen': '#9acd32'
  };

  var unitConversions = {
      length: {
          'm': 1,
          'cm': 0.01,
          'mm': 0.001,
          'in': 0.0254,
          'px': 0.0254 / 96,
          'pt': 0.0254 / 72,
          'pc': 0.0254 / 72 * 12
      },
      duration: {
          's': 1,
          'ms': 0.001
      },
      angle: {
          'rad': 1 / (2 * Math.PI),
          'deg': 1 / 360,
          'grad': 1 / 400,
          'turn': 1
      }
  };

  var data = { colors: colors, unitConversions: unitConversions };

  var Node = /** @class */ (function () {
      function Node() {
          this.parent = null;
          this.visibilityBlocks = undefined;
          this.nodeVisible = undefined;
          this.rootNode = null;
          this.parsed = null;
          var self = this;
          Object.defineProperty(this, 'currentFileInfo', {
              get: function () { return self.fileInfo(); }
          });
          Object.defineProperty(this, 'index', {
              get: function () { return self.getIndex(); }
          });
      }
      Node.prototype.setParent = function (nodes, parent) {
          function set(node) {
              if (node && node instanceof Node) {
                  node.parent = parent;
              }
          }
          if (Array.isArray(nodes)) {
              nodes.forEach(set);
          }
          else {
              set(nodes);
          }
      };
      Node.prototype.getIndex = function () {
          return this._index || (this.parent && this.parent.getIndex()) || 0;
      };
      Node.prototype.fileInfo = function () {
          return this._fileInfo || (this.parent && this.parent.fileInfo()) || {};
      };
      Node.prototype.isRulesetLike = function () {
          return false;
      };
      Node.prototype.toCSS = function (context) {
          var strs = [];
          this.genCSS(context, {
              add: function (chunk, fileInfo, index) {
                  strs.push(chunk);
              },
              isEmpty: function () {
                  return strs.length === 0;
              }
          });
          return strs.join('');
      };
      Node.prototype.genCSS = function (context, output) {
          output.add(this.value);
      };
      Node.prototype.accept = function (visitor) {
          this.value = visitor.visit(this.value);
      };
      Node.prototype.eval = function () { return this; };
      Node.prototype._operate = function (context, op, a, b) {
          switch (op) {
              case '+': return a + b;
              case '-': return a - b;
              case '*': return a * b;
              case '/': return a / b;
          }
      };
      Node.prototype.fround = function (context, value) {
          var precision = context && context.numPrecision;
          // add "epsilon" to ensure numbers like 1.000000005 (represented as 1.000000004999...) are properly rounded:
          return (precision) ? Number((value + 2e-16).toFixed(precision)) : value;
      };
      // Returns true if this node represents root of ast imported by reference
      Node.prototype.blocksVisibility = function () {
          if (this.visibilityBlocks == null) {
              this.visibilityBlocks = 0;
          }
          return this.visibilityBlocks !== 0;
      };
      Node.prototype.addVisibilityBlock = function () {
          if (this.visibilityBlocks == null) {
              this.visibilityBlocks = 0;
          }
          this.visibilityBlocks = this.visibilityBlocks + 1;
      };
      Node.prototype.removeVisibilityBlock = function () {
          if (this.visibilityBlocks == null) {
              this.visibilityBlocks = 0;
          }
          this.visibilityBlocks = this.visibilityBlocks - 1;
      };
      // Turns on node visibility - if called node will be shown in output regardless
      // of whether it comes from import by reference or not
      Node.prototype.ensureVisibility = function () {
          this.nodeVisible = true;
      };
      // Turns off node visibility - if called node will NOT be shown in output regardless
      // of whether it comes from import by reference or not
      Node.prototype.ensureInvisibility = function () {
          this.nodeVisible = false;
      };
      // return values:
      // false - the node must not be visible
      // true - the node must be visible
      // undefined or null - the node has the same visibility as its parent
      Node.prototype.isVisible = function () {
          return this.nodeVisible;
      };
      Node.prototype.visibilityInfo = function () {
          return {
              visibilityBlocks: this.visibilityBlocks,
              nodeVisible: this.nodeVisible
          };
      };
      Node.prototype.copyVisibilityInfo = function (info) {
          if (!info) {
              return;
          }
          this.visibilityBlocks = info.visibilityBlocks;
          this.nodeVisible = info.nodeVisible;
      };
      return Node;
  }());
  Node.compare = function (a, b) {
      /* returns:
       -1: a < b
       0: a = b
       1: a > b
       and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */
      if ((a.compare) &&
          // for "symmetric results" force toCSS-based comparison
          // of Quoted or Anonymous if either value is one of those
          !(b.type === 'Quoted' || b.type === 'Anonymous')) {
          return a.compare(b);
      }
      else if (b.compare) {
          return -b.compare(a);
      }
      else if (a.type !== b.type) {
          return undefined;
      }
      a = a.value;
      b = b.value;
      if (!Array.isArray(a)) {
          return a === b ? 0 : undefined;
      }
      if (a.length !== b.length) {
          return undefined;
      }
      for (var i_1 = 0; i_1 < a.length; i_1++) {
          if (Node.compare(a[i_1], b[i_1]) !== 0) {
              return undefined;
          }
      }
      return 0;
  };
  Node.numericCompare = function (a, b) { return a < b ? -1
      : a === b ? 0
          : a > b ? 1 : undefined; };

  //
  // RGB Colors - #ff0014, #eee
  //
  var Color = /** @class */ (function (_super) {
      __extends(Color, _super);
      function Color(rgb, a, originalForm) {
          var _this = _super.call(this) || this;
          var self = _this;
          //
          // The end goal here, is to parse the arguments
          // into an integer triplet, such as `128, 255, 0`
          //
          // This facilitates operations and conversions.
          //
          if (Array.isArray(rgb)) {
              _this.rgb = rgb;
          }
          else if (rgb.length >= 6) {
              _this.rgb = [];
              rgb.match(/.{2}/g).map(function (c, i) {
                  if (i < 3) {
                      self.rgb.push(parseInt(c, 16));
                  }
                  else {
                      self.alpha = (parseInt(c, 16)) / 255;
                  }
              });
          }
          else {
              _this.rgb = [];
              rgb.split('').map(function (c, i) {
                  if (i < 3) {
                      self.rgb.push(parseInt(c + c, 16));
                  }
                  else {
                      self.alpha = (parseInt(c + c, 16)) / 255;
                  }
              });
          }
          _this.alpha = _this.alpha || (typeof a === 'number' ? a : 1);
          if (typeof originalForm !== 'undefined') {
              _this.value = originalForm;
          }
          return _this;
      }
      Color.prototype.luma = function () {
          var r = this.rgb[0] / 255;
          var g = this.rgb[1] / 255;
          var b = this.rgb[2] / 255;
          r = (r <= 0.03928) ? r / 12.92 : Math.pow(((r + 0.055) / 1.055), 2.4);
          g = (g <= 0.03928) ? g / 12.92 : Math.pow(((g + 0.055) / 1.055), 2.4);
          b = (b <= 0.03928) ? b / 12.92 : Math.pow(((b + 0.055) / 1.055), 2.4);
          return 0.2126 * r + 0.7152 * g + 0.0722 * b;
      };
      Color.prototype.genCSS = function (context, output) {
          output.add(this.toCSS(context));
      };
      Color.prototype.toCSS = function (context, doNotCompress) {
          var compress = context && context.compress && !doNotCompress;
          var color;
          var alpha;
          var colorFunction;
          var args = [];
          // `value` is set if this color was originally
          // converted from a named color string so we need
          // to respect this and try to output named color too.
          alpha = this.fround(context, this.alpha);
          if (this.value) {
              if (this.value.indexOf('rgb') === 0) {
                  if (alpha < 1) {
                      colorFunction = 'rgba';
                  }
              }
              else if (this.value.indexOf('hsl') === 0) {
                  if (alpha < 1) {
                      colorFunction = 'hsla';
                  }
                  else {
                      colorFunction = 'hsl';
                  }
              }
              else {
                  return this.value;
              }
          }
          else {
              if (alpha < 1) {
                  colorFunction = 'rgba';
              }
          }
          switch (colorFunction) {
              case 'rgba':
                  args = this.rgb.map(function (c) { return clamp(Math.round(c), 255); }).concat(clamp(alpha, 1));
                  break;
              case 'hsla':
                  args.push(clamp(alpha, 1));
              case 'hsl':
                  color = this.toHSL();
                  args = [
                      this.fround(context, color.h),
                      this.fround(context, color.s * 100) + "%",
                      this.fround(context, color.l * 100) + "%"
                  ].concat(args);
          }
          if (colorFunction) {
              // Values are capped between `0` and `255`, rounded and zero-padded.
              return colorFunction + "(" + args.join("," + (compress ? '' : ' ')) + ")";
          }
          color = this.toRGB();
          if (compress) {
              var splitcolor = color.split('');
              // Convert color to short format
              if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {
                  color = "#" + splitcolor[1] + splitcolor[3] + splitcolor[5];
              }
          }
          return color;
      };
      //
      // Operations have to be done per-channel, if not,
      // channels will spill onto each other. Once we have
      // our result, in the form of an integer triplet,
      // we create a new Color node to hold the result.
      //
      Color.prototype.operate = function (context, op, other) {
          var rgb = new Array(3);
          var alpha = this.alpha * (1 - other.alpha) + other.alpha;
          for (var c = 0; c < 3; c++) {
              rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c]);
          }
          return new Color(rgb, alpha);
      };
      Color.prototype.toRGB = function () {
          return toHex(this.rgb);
      };
      Color.prototype.toHSL = function () {
          var r = this.rgb[0] / 255;
          var g = this.rgb[1] / 255;
          var b = this.rgb[2] / 255;
          var a = this.alpha;
          var max = Math.max(r, g, b);
          var min = Math.min(r, g, b);
          var h;
          var s;
          var l = (max + min) / 2;
          var d = max - min;
          if (max === min) {
              h = s = 0;
          }
          else {
              s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
              switch (max) {
                  case r:
                      h = (g - b) / d + (g < b ? 6 : 0);
                      break;
                  case g:
                      h = (b - r) / d + 2;
                      break;
                  case b:
                      h = (r - g) / d + 4;
                      break;
              }
              h /= 6;
          }
          return { h: h * 360, s: s, l: l, a: a };
      };
      // Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
      Color.prototype.toHSV = function () {
          var r = this.rgb[0] / 255;
          var g = this.rgb[1] / 255;
          var b = this.rgb[2] / 255;
          var a = this.alpha;
          var max = Math.max(r, g, b);
          var min = Math.min(r, g, b);
          var h;
          var s;
          var v = max;
          var d = max - min;
          if (max === 0) {
              s = 0;
          }
          else {
              s = d / max;
          }
          if (max === min) {
              h = 0;
          }
          else {
              switch (max) {
                  case r:
                      h = (g - b) / d + (g < b ? 6 : 0);
                      break;
                  case g:
                      h = (b - r) / d + 2;
                      break;
                  case b:
                      h = (r - g) / d + 4;
                      break;
              }
              h /= 6;
          }
          return { h: h * 360, s: s, v: v, a: a };
      };
      Color.prototype.toARGB = function () {
          return toHex([this.alpha * 255].concat(this.rgb));
      };
      Color.prototype.compare = function (x) {
          return (x.rgb &&
              x.rgb[0] === this.rgb[0] &&
              x.rgb[1] === this.rgb[1] &&
              x.rgb[2] === this.rgb[2] &&
              x.alpha === this.alpha) ? 0 : undefined;
      };
      return Color;
  }(Node));
  Color.prototype.type = 'Color';
  function clamp(v, max) {
      return Math.min(Math.max(v, 0), max);
  }
  function toHex(v) {
      return "#" + v.map(function (c) {
          c = clamp(Math.round(c), 255);
          return (c < 16 ? '0' : '') + c.toString(16);
      }).join('');
  }
  Color.fromKeyword = function (keyword) {
      var c;
      var key = keyword.toLowerCase();
      if (colors.hasOwnProperty(key)) {
          c = new Color(colors[key].slice(1));
      }
      else if (key === 'transparent') {
          c = new Color([0, 0, 0], 0);
      }
      if (c) {
          c.value = keyword;
          return c;
      }
  };

  var Paren = /** @class */ (function (_super) {
      __extends(Paren, _super);
      function Paren(node) {
          var _this = _super.call(this) || this;
          _this.value = node;
          return _this;
      }
      Paren.prototype.genCSS = function (context, output) {
          output.add('(');
          this.value.genCSS(context, output);
          output.add(')');
      };
      Paren.prototype.eval = function (context) {
          return new Paren(this.value.eval(context));
      };
      return Paren;
  }(Node));
  Paren.prototype.type = 'Paren';

  var _noSpaceCombinators = {
      '': true,
      ' ': true,
      '|': true
  };
  var Combinator = /** @class */ (function (_super) {
      __extends(Combinator, _super);
      function Combinator(value) {
          var _this = _super.call(this) || this;
          if (value === ' ') {
              _this.value = ' ';
              _this.emptyOrWhitespace = true;
          }
          else {
              _this.value = value ? value.trim() : '';
              _this.emptyOrWhitespace = _this.value === '';
          }
          return _this;
      }
      Combinator.prototype.genCSS = function (context, output) {
          var spaceOrEmpty = (context.compress || _noSpaceCombinators[this.value]) ? '' : ' ';
          output.add(spaceOrEmpty + this.value + spaceOrEmpty);
      };
      return Combinator;
  }(Node));
  Combinator.prototype.type = 'Combinator';

  var Element = /** @class */ (function (_super) {
      __extends(Element, _super);
      function Element(combinator, value, isVariable, index, currentFileInfo, visibilityInfo) {
          var _this = _super.call(this) || this;
          _this.combinator = combinator instanceof Combinator ?
              combinator : new Combinator(combinator);
          if (typeof value === 'string') {
              _this.value = value.trim();
          }
          else if (value) {
              _this.value = value;
          }
          else {
              _this.value = '';
          }
          _this.isVariable = isVariable;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.copyVisibilityInfo(visibilityInfo);
          _this.setParent(_this.combinator, _this);
          return _this;
      }
      Element.prototype.accept = function (visitor) {
          var value = this.value;
          this.combinator = visitor.visit(this.combinator);
          if (typeof value === 'object') {
              this.value = visitor.visit(value);
          }
      };
      Element.prototype.eval = function (context) {
          return new Element(this.combinator, this.value.eval ? this.value.eval(context) : this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());
      };
      Element.prototype.clone = function () {
          return new Element(this.combinator, this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());
      };
      Element.prototype.genCSS = function (context, output) {
          output.add(this.toCSS(context), this.fileInfo(), this.getIndex());
      };
      Element.prototype.toCSS = function (context) {
          if (context === void 0) { context = {}; }
          var value = this.value;
          var firstSelector = context.firstSelector;
          if (value instanceof Paren) {
              // selector in parens should not be affected by outer selector
              // flags (breaks only interpolated selectors - see #1973)
              context.firstSelector = true;
          }
          value = value.toCSS ? value.toCSS(context) : value;
          context.firstSelector = firstSelector;
          if (value === '' && this.combinator.value.charAt(0) === '&') {
              return '';
          }
          else {
              return this.combinator.toCSS(context) + value;
          }
      };
      return Element;
  }(Node));
  Element.prototype.type = 'Element';

  var Math$1 = {
      ALWAYS: 0,
      PARENS_DIVISION: 1,
      PARENS: 2,
      STRICT_LEGACY: 3
  };
  var RewriteUrls = {
      OFF: 0,
      LOCAL: 1,
      ALL: 2
  };

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var clone_1 = createCommonjsModule(function (module) {
      var clone = (function () {
          function _instanceof(obj, type) {
              return type != null && obj instanceof type;
          }
          var nativeMap;
          try {
              nativeMap = Map;
          }
          catch (_) {
              // maybe a reference error because no `Map`. Give it a dummy value that no
              // value will ever be an instanceof.
              nativeMap = function () { };
          }
          var nativeSet;
          try {
              nativeSet = Set;
          }
          catch (_) {
              nativeSet = function () { };
          }
          var nativePromise;
          try {
              nativePromise = Promise;
          }
          catch (_) {
              nativePromise = function () { };
          }
          /**
           * Clones (copies) an Object using deep copying.
           *
           * This function supports circular references by default, but if you are certain
           * there are no circular references in your object, you can save some CPU time
           * by calling clone(obj, false).
           *
           * Caution: if `circular` is false and `parent` contains circular references,
           * your program may enter an infinite loop and crash.
           *
           * @param `parent` - the object to be cloned
           * @param `circular` - set to true if the object to be cloned may contain
           *    circular references. (optional - true by default)
           * @param `depth` - set to a number if the object is only to be cloned to
           *    a particular depth. (optional - defaults to Infinity)
           * @param `prototype` - sets the prototype to be used when cloning an object.
           *    (optional - defaults to parent prototype).
           * @param `includeNonEnumerable` - set to true if the non-enumerable properties
           *    should be cloned as well. Non-enumerable properties on the prototype
           *    chain will be ignored. (optional - false by default)
          */
          function clone(parent, circular, depth, prototype, includeNonEnumerable) {
              if (typeof circular === 'object') {
                  depth = circular.depth;
                  prototype = circular.prototype;
                  includeNonEnumerable = circular.includeNonEnumerable;
                  circular = circular.circular;
              }
              // maintain two arrays for circular references, where corresponding parents
              // and children have the same index
              var allParents = [];
              var allChildren = [];
              var useBuffer = typeof Buffer != 'undefined';
              if (typeof circular == 'undefined')
                  circular = true;
              if (typeof depth == 'undefined')
                  depth = Infinity;
              // recurse this function so we don't reset allParents and allChildren
              function _clone(parent, depth) {
                  // cloning null always returns null
                  if (parent === null)
                      return null;
                  if (depth === 0)
                      return parent;
                  var child;
                  var proto;
                  if (typeof parent != 'object') {
                      return parent;
                  }
                  if (_instanceof(parent, nativeMap)) {
                      child = new nativeMap();
                  }
                  else if (_instanceof(parent, nativeSet)) {
                      child = new nativeSet();
                  }
                  else if (_instanceof(parent, nativePromise)) {
                      child = new nativePromise(function (resolve, reject) {
                          parent.then(function (value) {
                              resolve(_clone(value, depth - 1));
                          }, function (err) {
                              reject(_clone(err, depth - 1));
                          });
                      });
                  }
                  else if (clone.__isArray(parent)) {
                      child = [];
                  }
                  else if (clone.__isRegExp(parent)) {
                      child = new RegExp(parent.source, __getRegExpFlags(parent));
                      if (parent.lastIndex)
                          child.lastIndex = parent.lastIndex;
                  }
                  else if (clone.__isDate(parent)) {
                      child = new Date(parent.getTime());
                  }
                  else if (useBuffer && Buffer.isBuffer(parent)) {
                      if (Buffer.allocUnsafe) {
                          // Node.js >= 4.5.0
                          child = Buffer.allocUnsafe(parent.length);
                      }
                      else {
                          // Older Node.js versions
                          child = new Buffer(parent.length);
                      }
                      parent.copy(child);
                      return child;
                  }
                  else if (_instanceof(parent, Error)) {
                      child = Object.create(parent);
                  }
                  else {
                      if (typeof prototype == 'undefined') {
                          proto = Object.getPrototypeOf(parent);
                          child = Object.create(proto);
                      }
                      else {
                          child = Object.create(prototype);
                          proto = prototype;
                      }
                  }
                  if (circular) {
                      var index = allParents.indexOf(parent);
                      if (index != -1) {
                          return allChildren[index];
                      }
                      allParents.push(parent);
                      allChildren.push(child);
                  }
                  if (_instanceof(parent, nativeMap)) {
                      parent.forEach(function (value, key) {
                          var keyChild = _clone(key, depth - 1);
                          var valueChild = _clone(value, depth - 1);
                          child.set(keyChild, valueChild);
                      });
                  }
                  if (_instanceof(parent, nativeSet)) {
                      parent.forEach(function (value) {
                          var entryChild = _clone(value, depth - 1);
                          child.add(entryChild);
                      });
                  }
                  for (var i in parent) {
                      var attrs;
                      if (proto) {
                          attrs = Object.getOwnPropertyDescriptor(proto, i);
                      }
                      if (attrs && attrs.set == null) {
                          continue;
                      }
                      child[i] = _clone(parent[i], depth - 1);
                  }
                  if (Object.getOwnPropertySymbols) {
                      var symbols = Object.getOwnPropertySymbols(parent);
                      for (var i = 0; i < symbols.length; i++) {
                          // Don't need to worry about cloning a symbol because it is a primitive,
                          // like a number or string.
                          var symbol = symbols[i];
                          var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
                          if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                              continue;
                          }
                          child[symbol] = _clone(parent[symbol], depth - 1);
                          if (!descriptor.enumerable) {
                              Object.defineProperty(child, symbol, {
                                  enumerable: false
                              });
                          }
                      }
                  }
                  if (includeNonEnumerable) {
                      var allPropertyNames = Object.getOwnPropertyNames(parent);
                      for (var i = 0; i < allPropertyNames.length; i++) {
                          var propertyName = allPropertyNames[i];
                          var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
                          if (descriptor && descriptor.enumerable) {
                              continue;
                          }
                          child[propertyName] = _clone(parent[propertyName], depth - 1);
                          Object.defineProperty(child, propertyName, {
                              enumerable: false
                          });
                      }
                  }
                  return child;
              }
              return _clone(parent, depth);
          }
          /**
           * Simple flat clone using prototype, accepts only objects, usefull for property
           * override on FLAT configuration object (no nested props).
           *
           * USE WITH CAUTION! This may not behave as you wish if you do not know how this
           * works.
           */
          clone.clonePrototype = function clonePrototype(parent) {
              if (parent === null)
                  return null;
              var c = function () { };
              c.prototype = parent;
              return new c();
          };
          // private utility functions
          function __objToStr(o) {
              return Object.prototype.toString.call(o);
          }
          clone.__objToStr = __objToStr;
          function __isDate(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Date]';
          }
          clone.__isDate = __isDate;
          function __isArray(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Array]';
          }
          clone.__isArray = __isArray;
          function __isRegExp(o) {
              return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
          }
          clone.__isRegExp = __isRegExp;
          function __getRegExpFlags(re) {
              var flags = '';
              if (re.global)
                  flags += 'g';
              if (re.ignoreCase)
                  flags += 'i';
              if (re.multiline)
                  flags += 'm';
              return flags;
          }
          clone.__getRegExpFlags = __getRegExpFlags;
          return clone;
      })();
      if ( module.exports) {
          module.exports = clone;
      }
  });

  /* jshint proto: true */
  function getLocation(index, inputStream) {
      var n = index + 1;
      var line = null;
      var column = -1;
      while (--n >= 0 && inputStream.charAt(n) !== '\n') {
          column++;
      }
      if (typeof index === 'number') {
          line = (inputStream.slice(0, index).match(/\n/g) || '').length;
      }
      return {
          line: line,
          column: column
      };
  }
  function copyArray(arr) {
      var i;
      var length = arr.length;
      var copy = new Array(length);
      for (i = 0; i < length; i++) {
          copy[i] = arr[i];
      }
      return copy;
  }
  function clone(obj) {
      var cloned = {};
      for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) {
              cloned[prop] = obj[prop];
          }
      }
      return cloned;
  }
  function defaults(obj1, obj2) {
      var newObj = obj2 || {};
      if (!obj2._defaults) {
          newObj = {};
          var defaults_1 = clone_1(obj1);
          newObj._defaults = defaults_1;
          var cloned = obj2 ? clone_1(obj2) : {};
          Object.assign(newObj, defaults_1, cloned);
      }
      return newObj;
  }
  function copyOptions(obj1, obj2) {
      if (obj2 && obj2._defaults) {
          return obj2;
      }
      var opts = defaults(obj1, obj2);
      if (opts.strictMath) {
          opts.math = Math$1.STRICT_LEGACY;
      }
      // Back compat with changed relativeUrls option
      if (opts.relativeUrls) {
          opts.rewriteUrls = RewriteUrls.ALL;
      }
      if (typeof opts.math === 'string') {
          switch (opts.math.toLowerCase()) {
              case 'always':
                  opts.math = Math$1.ALWAYS;
                  break;
              case 'parens-division':
                  opts.math = Math$1.PARENS_DIVISION;
                  break;
              case 'strict':
              case 'parens':
                  opts.math = Math$1.PARENS;
                  break;
              case 'strict-legacy':
                  opts.math = Math$1.STRICT_LEGACY;
          }
      }
      if (typeof opts.rewriteUrls === 'string') {
          switch (opts.rewriteUrls.toLowerCase()) {
              case 'off':
                  opts.rewriteUrls = RewriteUrls.OFF;
                  break;
              case 'local':
                  opts.rewriteUrls = RewriteUrls.LOCAL;
                  break;
              case 'all':
                  opts.rewriteUrls = RewriteUrls.ALL;
                  break;
          }
      }
      return opts;
  }
  function merge(obj1, obj2) {
      for (var prop in obj2) {
          if (obj2.hasOwnProperty(prop)) {
              obj1[prop] = obj2[prop];
          }
      }
      return obj1;
  }
  function flattenArray(arr, result) {
      if (result === void 0) { result = []; }
      for (var i_1 = 0, length_1 = arr.length; i_1 < length_1; i_1++) {
          var value = arr[i_1];
          if (Array.isArray(value)) {
              flattenArray(value, result);
          }
          else {
              if (value !== undefined) {
                  result.push(value);
              }
          }
      }
      return result;
  }

  var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getLocation: getLocation,
    copyArray: copyArray,
    clone: clone,
    defaults: defaults,
    copyOptions: copyOptions,
    merge: merge,
    flattenArray: flattenArray
  });

  var anonymousFunc = /(<anonymous>|Function):(\d+):(\d+)/;
  /**
   * This is a centralized class of any error that could be thrown internally (mostly by the parser).
   * Besides standard .message it keeps some additional data like a path to the file where the error
   * occurred along with line and column numbers.
   *
   * @class
   * @extends Error
   * @type {module.LessError}
   *
   * @prop {string} type
   * @prop {string} filename
   * @prop {number} index
   * @prop {number} line
   * @prop {number} column
   * @prop {number} callLine
   * @prop {number} callExtract
   * @prop {string[]} extract
   *
   * @param {Object} e              - An error object to wrap around or just a descriptive object
   * @param {Object} fileContentMap - An object with file contents in 'contents' property (like importManager) @todo - move to fileManager?
   * @param {string} [currentFilename]
   */
  var LessError = function LessError(e, fileContentMap, currentFilename) {
      Error.call(this);
      var filename = e.filename || currentFilename;
      this.message = e.message;
      this.stack = e.stack;
      if (fileContentMap && filename) {
          var input = fileContentMap.contents[filename];
          var loc = getLocation(e.index, input);
          var line = loc.line;
          var col = loc.column;
          var callLine = e.call && getLocation(e.call, input).line;
          var lines = input ? input.split('\n') : '';
          this.type = e.type || 'Syntax';
          this.filename = filename;
          this.index = e.index;
          this.line = typeof line === 'number' ? line + 1 : null;
          this.column = col;
          if (!this.line && this.stack) {
              var found = this.stack.match(anonymousFunc);
              /**
               * We have to figure out how this environment stringifies anonymous functions
               * so we can correctly map plugin errors.
               *
               * Note, in Node 8, the output of anonymous funcs varied based on parameters
               * being present or not, so we inject dummy params.
               */
              var func = new Function('a', 'throw new Error()');
              var lineAdjust = 0;
              try {
                  func();
              }
              catch (e) {
                  var match = e.stack.match(anonymousFunc);
                  var line_1 = parseInt(match[2]);
                  lineAdjust = 1 - line_1;
              }
              if (found) {
                  if (found[2]) {
                      this.line = parseInt(found[2]) + lineAdjust;
                  }
                  if (found[3]) {
                      this.column = parseInt(found[3]);
                  }
              }
          }
          this.callLine = callLine + 1;
          this.callExtract = lines[callLine];
          this.extract = [
              lines[this.line - 2],
              lines[this.line - 1],
              lines[this.line]
          ];
      }
  };
  if (typeof Object.create === 'undefined') {
      var F = function () { };
      F.prototype = Error.prototype;
      LessError.prototype = new F();
  }
  else {
      LessError.prototype = Object.create(Error.prototype);
  }
  LessError.prototype.constructor = LessError;
  /**
   * An overridden version of the default Object.prototype.toString
   * which uses additional information to create a helpful message.
   *
   * @param {Object} options
   * @returns {string}
   */
  LessError.prototype.toString = function (options) {
      if (options === void 0) { options = {}; }
      var message = '';
      var extract = this.extract || [];
      var error = [];
      var stylize = function (str) { return str; };
      if (options.stylize) {
          var type = typeof options.stylize;
          if (type !== 'function') {
              throw Error("options.stylize should be a function, got a " + type + "!");
          }
          stylize = options.stylize;
      }
      if (this.line !== null) {
          if (typeof extract[0] === 'string') {
              error.push(stylize(this.line - 1 + " " + extract[0], 'grey'));
          }
          if (typeof extract[1] === 'string') {
              var errorTxt = this.line + " ";
              if (extract[1]) {
                  errorTxt += extract[1].slice(0, this.column) +
                      stylize(stylize(stylize(extract[1].substr(this.column, 1), 'bold') +
                          extract[1].slice(this.column + 1), 'red'), 'inverse');
              }
              error.push(errorTxt);
          }
          if (typeof extract[2] === 'string') {
              error.push(stylize(this.line + 1 + " " + extract[2], 'grey'));
          }
          error = error.join('\n') + stylize('', 'reset') + "\n";
      }
      message += stylize(this.type + "Error: " + this.message, 'red');
      if (this.filename) {
          message += stylize(' in ', 'red') + this.filename;
      }
      if (this.line) {
          message += stylize(" on line " + this.line + ", column " + (this.column + 1) + ":", 'grey');
      }
      message += "\n" + error;
      if (this.callLine) {
          message += stylize('from ', 'red') + (this.filename || '') + "/n";
          message += stylize(this.callLine, 'grey') + " " + this.callExtract + "/n";
      }
      return message;
  };

  var Selector = /** @class */ (function (_super) {
      __extends(Selector, _super);
      function Selector(elements, extendList, condition, index, currentFileInfo, visibilityInfo) {
          var _this = _super.call(this) || this;
          _this.extendList = extendList;
          _this.condition = condition;
          _this.evaldCondition = !condition;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.elements = _this.getElements(elements);
          _this.mixinElements_ = undefined;
          _this.copyVisibilityInfo(visibilityInfo);
          _this.setParent(_this.elements, _this);
          return _this;
      }
      Selector.prototype.accept = function (visitor) {
          if (this.elements) {
              this.elements = visitor.visitArray(this.elements);
          }
          if (this.extendList) {
              this.extendList = visitor.visitArray(this.extendList);
          }
          if (this.condition) {
              this.condition = visitor.visit(this.condition);
          }
      };
      Selector.prototype.createDerived = function (elements, extendList, evaldCondition) {
          elements = this.getElements(elements);
          var newSelector = new Selector(elements, extendList || this.extendList, null, this.getIndex(), this.fileInfo(), this.visibilityInfo());
          newSelector.evaldCondition = (evaldCondition != null) ? evaldCondition : this.evaldCondition;
          newSelector.mediaEmpty = this.mediaEmpty;
          return newSelector;
      };
      Selector.prototype.getElements = function (els) {
          if (!els) {
              return [new Element('', '&', false, this._index, this._fileInfo)];
          }
          if (typeof els === 'string') {
              this.parse.parseNode(els, ['selector'], this._index, this._fileInfo, function (err, result) {
                  if (err) {
                      throw new LessError({
                          index: err.index,
                          message: err.message
                      }, this.parse.imports, this._fileInfo.filename);
                  }
                  els = result[0].elements;
              });
          }
          return els;
      };
      Selector.prototype.createEmptySelectors = function () {
          var el = new Element('', '&', false, this._index, this._fileInfo);
          var sels = [new Selector([el], null, null, this._index, this._fileInfo)];
          sels[0].mediaEmpty = true;
          return sels;
      };
      Selector.prototype.match = function (other) {
          var elements = this.elements;
          var len = elements.length;
          var olen;
          var i;
          other = other.mixinElements();
          olen = other.length;
          if (olen === 0 || len < olen) {
              return 0;
          }
          else {
              for (i = 0; i < olen; i++) {
                  if (elements[i].value !== other[i]) {
                      return 0;
                  }
              }
          }
          return olen; // return number of matched elements
      };
      Selector.prototype.mixinElements = function () {
          if (this.mixinElements_) {
              return this.mixinElements_;
          }
          var elements = this.elements.map(function (v) { return v.combinator.value + (v.value.value || v.value); }).join('').match(/[,&#\*\.\w-]([\w-]|(\\.))*/g);
          if (elements) {
              if (elements[0] === '&') {
                  elements.shift();
              }
          }
          else {
              elements = [];
          }
          return (this.mixinElements_ = elements);
      };
      Selector.prototype.isJustParentSelector = function () {
          return !this.mediaEmpty &&
              this.elements.length === 1 &&
              this.elements[0].value === '&' &&
              (this.elements[0].combinator.value === ' ' || this.elements[0].combinator.value === '');
      };
      Selector.prototype.eval = function (context) {
          var evaldCondition = this.condition && this.condition.eval(context);
          var elements = this.elements;
          var extendList = this.extendList;
          elements = elements && elements.map(function (e) { return e.eval(context); });
          extendList = extendList && extendList.map(function (extend) { return extend.eval(context); });
          return this.createDerived(elements, extendList, evaldCondition);
      };
      Selector.prototype.genCSS = function (context, output) {
          var i;
          var element;
          if ((!context || !context.firstSelector) && this.elements[0].combinator.value === '') {
              output.add(' ', this.fileInfo(), this.getIndex());
          }
          for (i = 0; i < this.elements.length; i++) {
              element = this.elements[i];
              element.genCSS(context, output);
          }
      };
      Selector.prototype.getIsOutput = function () {
          return this.evaldCondition;
      };
      return Selector;
  }(Node));
  Selector.prototype.type = 'Selector';

  var Value = /** @class */ (function (_super) {
      __extends(Value, _super);
      function Value(value) {
          var _this = _super.call(this) || this;
          if (!value) {
              throw new Error('Value requires an array argument');
          }
          if (!Array.isArray(value)) {
              _this.value = [value];
          }
          else {
              _this.value = value;
          }
          return _this;
      }
      Value.prototype.accept = function (visitor) {
          if (this.value) {
              this.value = visitor.visitArray(this.value);
          }
      };
      Value.prototype.eval = function (context) {
          if (this.value.length === 1) {
              return this.value[0].eval(context);
          }
          else {
              return new Value(this.value.map(function (v) { return v.eval(context); }));
          }
      };
      Value.prototype.genCSS = function (context, output) {
          var i;
          for (i = 0; i < this.value.length; i++) {
              this.value[i].genCSS(context, output);
              if (i + 1 < this.value.length) {
                  output.add((context && context.compress) ? ',' : ', ');
              }
          }
      };
      return Value;
  }(Node));
  Value.prototype.type = 'Value';

  var Keyword = /** @class */ (function (_super) {
      __extends(Keyword, _super);
      function Keyword(value) {
          var _this = _super.call(this) || this;
          _this.value = value;
          return _this;
      }
      Keyword.prototype.genCSS = function (context, output) {
          if (this.value === '%') {
              throw { type: 'Syntax', message: 'Invalid % without number' };
          }
          output.add(this.value);
      };
      return Keyword;
  }(Node));
  Keyword.prototype.type = 'Keyword';
  Keyword.True = new Keyword('true');
  Keyword.False = new Keyword('false');

  var Anonymous = /** @class */ (function (_super) {
      __extends(Anonymous, _super);
      function Anonymous(value, index, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {
          var _this = _super.call(this) || this;
          _this.value = value;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.mapLines = mapLines;
          _this.rulesetLike = (typeof rulesetLike === 'undefined') ? false : rulesetLike;
          _this.allowRoot = true;
          _this.copyVisibilityInfo(visibilityInfo);
          return _this;
      }
      Anonymous.prototype.eval = function () {
          return new Anonymous(this.value, this._index, this._fileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());
      };
      Anonymous.prototype.compare = function (other) {
          return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
      };
      Anonymous.prototype.isRulesetLike = function () {
          return this.rulesetLike;
      };
      Anonymous.prototype.genCSS = function (context, output) {
          this.nodeVisible = Boolean(this.value);
          if (this.nodeVisible) {
              output.add(this.value, this._fileInfo, this._index, this.mapLines);
          }
      };
      return Anonymous;
  }(Node));
  Anonymous.prototype.type = 'Anonymous';

  var MATH = Math$1;
  var Declaration = /** @class */ (function (_super) {
      __extends(Declaration, _super);
      function Declaration(name, value, important, merge, index, currentFileInfo, inline, variable) {
          var _this = _super.call(this) || this;
          _this.name = name;
          _this.value = (value instanceof Node) ? value : new Value([value ? new Anonymous(value) : null]);
          _this.important = important ? " " + important.trim() : '';
          _this.merge = merge;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.inline = inline || false;
          _this.variable = (variable !== undefined) ? variable
              : (name.charAt && (name.charAt(0) === '@'));
          _this.allowRoot = true;
          _this.setParent(_this.value, _this);
          return _this;
      }
      Declaration.prototype.genCSS = function (context, output) {
          output.add(this.name + (context.compress ? ':' : ': '), this.fileInfo(), this.getIndex());
          try {
              this.value.genCSS(context, output);
          }
          catch (e) {
              e.index = this._index;
              e.filename = this._fileInfo.filename;
              throw e;
          }
          output.add(this.important + ((this.inline || (context.lastRule && context.compress)) ? '' : ';'), this._fileInfo, this._index);
      };
      Declaration.prototype.eval = function (context) {
          var mathBypass = false;
          var prevMath;
          var name = this.name;
          var evaldValue;
          var variable = this.variable;
          if (typeof name !== 'string') {
              // expand 'primitive' name directly to get
              // things faster (~10% for benchmark.less):
              name = (name.length === 1) && (name[0] instanceof Keyword) ?
                  name[0].value : evalName(context, name);
              variable = false; // never treat expanded interpolation as new variable name
          }
          // @todo remove when parens-division is default
          if (name === 'font' && context.math === MATH.ALWAYS) {
              mathBypass = true;
              prevMath = context.math;
              context.math = MATH.PARENS_DIVISION;
          }
          try {
              context.importantScope.push({});
              evaldValue = this.value.eval(context);
              if (!this.variable && evaldValue.type === 'DetachedRuleset') {
                  throw { message: 'Rulesets cannot be evaluated on a property.',
                      index: this.getIndex(), filename: this.fileInfo().filename };
              }
              var important = this.important;
              var importantResult = context.importantScope.pop();
              if (!important && importantResult.important) {
                  important = importantResult.important;
              }
              return new Declaration(name, evaldValue, important, this.merge, this.getIndex(), this.fileInfo(), this.inline, variable);
          }
          catch (e) {
              if (typeof e.index !== 'number') {
                  e.index = this.getIndex();
                  e.filename = this.fileInfo().filename;
              }
              throw e;
          }
          finally {
              if (mathBypass) {
                  context.math = prevMath;
              }
          }
      };
      Declaration.prototype.makeImportant = function () {
          return new Declaration(this.name, this.value, '!important', this.merge, this.getIndex(), this.fileInfo(), this.inline);
      };
      return Declaration;
  }(Node));
  function evalName(context, name) {
      var value = '';
      var i;
      var n = name.length;
      var output = { add: function (s) { value += s; } };
      for (i = 0; i < n; i++) {
          name[i].eval(context).genCSS(context, output);
      }
      return value;
  }
  Declaration.prototype.type = 'Declaration';

  var debugInfo = function (context, ctx, lineSeparator) {
      var result = '';
      if (context.dumpLineNumbers && !context.compress) {
          switch (context.dumpLineNumbers) {
              case 'comments':
                  result = debugInfo.asComment(ctx);
                  break;
              case 'mediaquery':
                  result = debugInfo.asMediaQuery(ctx);
                  break;
              case 'all':
                  result = debugInfo.asComment(ctx) + (lineSeparator || '') + debugInfo.asMediaQuery(ctx);
                  break;
          }
      }
      return result;
  };
  debugInfo.asComment = function (ctx) { return ctx.debugInfo ? "/* line " + ctx.debugInfo.lineNumber + ", " + ctx.debugInfo.fileName + " */\n" : ''; };
  debugInfo.asMediaQuery = function (ctx) {
      if (!ctx.debugInfo) {
          return '';
      }
      var filenameWithProtocol = ctx.debugInfo.fileName;
      if (!/^[a-z]+:\/\//i.test(filenameWithProtocol)) {
          filenameWithProtocol = "file://" + filenameWithProtocol;
      }
      return "@media -sass-debug-info{filename{font-family:" + filenameWithProtocol.replace(/([.:\/\\])/g, function (a) {
          if (a == '\\') {
              a = '\/';
          }
          return "\\" + a;
      }) + "}line{font-family:\\00003" + ctx.debugInfo.lineNumber + "}}\n";
  };

  var Comment = /** @class */ (function (_super) {
      __extends(Comment, _super);
      function Comment(value, isLineComment, index, currentFileInfo) {
          var _this = _super.call(this) || this;
          _this.value = value;
          _this.isLineComment = isLineComment;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.allowRoot = true;
          return _this;
      }
      Comment.prototype.genCSS = function (context, output) {
          if (this.debugInfo) {
              output.add(debugInfo(context, this), this.fileInfo(), this.getIndex());
          }
          output.add(this.value);
      };
      Comment.prototype.isSilent = function (context) {
          var isCompressed = context.compress && this.value[2] !== '!';
          return this.isLineComment || isCompressed;
      };
      return Comment;
  }(Node));
  Comment.prototype.type = 'Comment';

  var contexts = {};
  var copyFromOriginal = function copyFromOriginal(original, destination, propertiesToCopy) {
      if (!original) {
          return;
      }
      for (var i_1 = 0; i_1 < propertiesToCopy.length; i_1++) {
          if (original.hasOwnProperty(propertiesToCopy[i_1])) {
              destination[propertiesToCopy[i_1]] = original[propertiesToCopy[i_1]];
          }
      }
  };
  /*
   parse is used whilst parsing
   */
  var parseCopyProperties = [
      // options
      'paths',
      'rewriteUrls',
      'rootpath',
      'strictImports',
      'insecure',
      'dumpLineNumbers',
      'compress',
      'syncImport',
      'chunkInput',
      'mime',
      'useFileCache',
      // context
      'processImports',
      // Used by the import manager to stop multiple import visitors being created.
      'pluginManager' // Used as the plugin manager for the session
  ];
  contexts.Parse = function (options) {
      copyFromOriginal(options, this, parseCopyProperties);
      if (typeof this.paths === 'string') {
          this.paths = [this.paths];
      }
  };
  var evalCopyProperties = [
      'paths',
      'compress',
      'math',
      'strictUnits',
      'sourceMap',
      'importMultiple',
      'urlArgs',
      'javascriptEnabled',
      'pluginManager',
      'importantScope',
      'rewriteUrls' // option - whether to adjust URL's to be relative
  ];
  function isPathRelative(path) {
      return !/^(?:[a-z-]+:|\/|#)/i.test(path);
  }
  function isPathLocalRelative(path) {
      return path.charAt(0) === '.';
  }
  contexts.Eval = /** @class */ (function () {
      function Eval(options, frames) {
          copyFromOriginal(options, this, evalCopyProperties);
          if (typeof this.paths === 'string') {
              this.paths = [this.paths];
          }
          this.frames = frames || [];
          this.importantScope = this.importantScope || [];
          this.inCalc = false;
          this.mathOn = true;
      }
      Eval.prototype.enterCalc = function () {
          if (!this.calcStack) {
              this.calcStack = [];
          }
          this.calcStack.push(true);
          this.inCalc = true;
      };
      Eval.prototype.exitCalc = function () {
          this.calcStack.pop();
          if (!this.calcStack.length) {
              this.inCalc = false;
          }
      };
      Eval.prototype.inParenthesis = function () {
          if (!this.parensStack) {
              this.parensStack = [];
          }
          this.parensStack.push(true);
      };
      Eval.prototype.outOfParenthesis = function () {
          this.parensStack.pop();
      };
      Eval.prototype.isMathOn = function (op) {
          if (!this.mathOn) {
              return false;
          }
          if (op === '/' && this.math !== Math$1.ALWAYS && (!this.parensStack || !this.parensStack.length)) {
              return false;
          }
          if (this.math > Math$1.PARENS_DIVISION) {
              return this.parensStack && this.parensStack.length;
          }
          return true;
      };
      Eval.prototype.pathRequiresRewrite = function (path) {
          var isRelative = this.rewriteUrls === RewriteUrls.LOCAL ? isPathLocalRelative : isPathRelative;
          return isRelative(path);
      };
      Eval.prototype.rewritePath = function (path, rootpath) {
          var newPath;
          rootpath = rootpath || '';
          newPath = this.normalizePath(rootpath + path);
          // If a path was explicit relative and the rootpath was not an absolute path
          // we must ensure that the new path is also explicit relative.
          if (isPathLocalRelative(path) &&
              isPathRelative(rootpath) &&
              isPathLocalRelative(newPath) === false) {
              newPath = "./" + newPath;
          }
          return newPath;
      };
      Eval.prototype.normalizePath = function (path) {
          var segments = path.split('/').reverse();
          var segment;
          path = [];
          while (segments.length !== 0) {
              segment = segments.pop();
              switch (segment) {
                  case '.':
                      break;
                  case '..':
                      if ((path.length === 0) || (path[path.length - 1] === '..')) {
                          path.push(segment);
                      }
                      else {
                          path.pop();
                      }
                      break;
                  default:
                      path.push(segment);
                      break;
              }
          }
          return path.join('/');
      };
      return Eval;
  }());

  function makeRegistry(base) {
      return {
          _data: {},
          add: function (name, func) {
              // precautionary case conversion, as later querying of
              // the registry by function-caller uses lower case as well.
              name = name.toLowerCase();
              if (this._data.hasOwnProperty(name)) ;
              this._data[name] = func;
          },
          addMultiple: function (functions) {
              var _this = this;
              Object.keys(functions).forEach(function (name) {
                  _this.add(name, functions[name]);
              });
          },
          get: function (name) {
              return this._data[name] || (base && base.get(name));
          },
          getLocalFunctions: function () {
              return this._data;
          },
          inherit: function () {
              return makeRegistry(this);
          },
          create: function (base) {
              return makeRegistry(base);
          }
      };
  }
  var functionRegistry = makeRegistry(null);

  var defaultFunc = {
      eval: function () {
          var v = this.value_;
          var e = this.error_;
          if (e) {
              throw e;
          }
          if (v != null) {
              return v ? Keyword.True : Keyword.False;
          }
      },
      value: function (v) {
          this.value_ = v;
      },
      error: function (e) {
          this.error_ = e;
      },
      reset: function () {
          this.value_ = this.error_ = null;
      }
  };

  var Ruleset = /** @class */ (function (_super) {
      __extends(Ruleset, _super);
      function Ruleset(selectors, rules, strictImports, visibilityInfo) {
          var _this = _super.call(this) || this;
          _this.selectors = selectors;
          _this.rules = rules;
          _this._lookups = {};
          _this._variables = null;
          _this._properties = null;
          _this.strictImports = strictImports;
          _this.copyVisibilityInfo(visibilityInfo);
          _this.allowRoot = true;
          _this.setParent(_this.selectors, _this);
          _this.setParent(_this.rules, _this);
          return _this;
      }
      Ruleset.prototype.isRulesetLike = function () {
          return true;
      };
      Ruleset.prototype.accept = function (visitor) {
          if (this.paths) {
              this.paths = visitor.visitArray(this.paths, true);
          }
          else if (this.selectors) {
              this.selectors = visitor.visitArray(this.selectors);
          }
          if (this.rules && this.rules.length) {
              this.rules = visitor.visitArray(this.rules);
          }
      };
      Ruleset.prototype.eval = function (context) {
          var selectors;
          var selCnt;
          var selector;
          var i;
          var hasVariable;
          var hasOnePassingSelector = false;
          if (this.selectors && (selCnt = this.selectors.length)) {
              selectors = new Array(selCnt);
              defaultFunc.error({
                  type: 'Syntax',
                  message: 'it is currently only allowed in parametric mixin guards,'
              });
              for (i = 0; i < selCnt; i++) {
                  selector = this.selectors[i].eval(context);
                  for (var j = 0; j < selector.elements.length; j++) {
                      if (selector.elements[j].isVariable) {
                          hasVariable = true;
                          break;
                      }
                  }
                  selectors[i] = selector;
                  if (selector.evaldCondition) {
                      hasOnePassingSelector = true;
                  }
              }
              if (hasVariable) {
                  var toParseSelectors = new Array(selCnt);
                  for (i = 0; i < selCnt; i++) {
                      selector = selectors[i];
                      toParseSelectors[i] = selector.toCSS(context);
                  }
                  this.parse.parseNode(toParseSelectors.join(','), ["selectors"], selectors[0].getIndex(), selectors[0].fileInfo(), function (err, result) {
                      if (result) {
                          selectors = flattenArray(result);
                      }
                  });
              }
              defaultFunc.reset();
          }
          else {
              hasOnePassingSelector = true;
          }
          var rules = this.rules ? copyArray(this.rules) : null;
          var ruleset = new Ruleset(selectors, rules, this.strictImports, this.visibilityInfo());
          var rule;
          var subRule;
          ruleset.originalRuleset = this;
          ruleset.root = this.root;
          ruleset.firstRoot = this.firstRoot;
          ruleset.allowImports = this.allowImports;
          if (this.debugInfo) {
              ruleset.debugInfo = this.debugInfo;
          }
          if (!hasOnePassingSelector) {
              rules.length = 0;
          }
          // inherit a function registry from the frames stack when possible;
          // otherwise from the global registry
          ruleset.functionRegistry = (function (frames) {
              var i = 0;
              var n = frames.length;
              var found;
              for (; i !== n; ++i) {
                  found = frames[i].functionRegistry;
                  if (found) {
                      return found;
                  }
              }
              return functionRegistry;
          })(context.frames).inherit();
          // push the current ruleset to the frames stack
          var ctxFrames = context.frames;
          ctxFrames.unshift(ruleset);
          // currrent selectors
          var ctxSelectors = context.selectors;
          if (!ctxSelectors) {
              context.selectors = ctxSelectors = [];
          }
          ctxSelectors.unshift(this.selectors);
          // Evaluate imports
          if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {
              ruleset.evalImports(context);
          }
          // Store the frames around mixin definitions,
          // so they can be evaluated like closures when the time comes.
          var rsRules = ruleset.rules;
          for (i = 0; (rule = rsRules[i]); i++) {
              if (rule.evalFirst) {
                  rsRules[i] = rule.eval(context);
              }
          }
          var mediaBlockCount = (context.mediaBlocks && context.mediaBlocks.length) || 0;
          // Evaluate mixin calls.
          for (i = 0; (rule = rsRules[i]); i++) {
              if (rule.type === 'MixinCall') {
                  /* jshint loopfunc:true */
                  rules = rule.eval(context).filter(function (r) {
                      if ((r instanceof Declaration) && r.variable) {
                          // do not pollute the scope if the variable is
                          // already there. consider returning false here
                          // but we need a way to "return" variable from mixins
                          return !(ruleset.variable(r.name));
                      }
                      return true;
                  });
                  rsRules.splice.apply(rsRules, [i, 1].concat(rules));
                  i += rules.length - 1;
                  ruleset.resetCache();
              }
              else if (rule.type === 'VariableCall') {
                  /* jshint loopfunc:true */
                  rules = rule.eval(context).rules.filter(function (r) {
                      if ((r instanceof Declaration) && r.variable) {
                          // do not pollute the scope at all
                          return false;
                      }
                      return true;
                  });
                  rsRules.splice.apply(rsRules, [i, 1].concat(rules));
                  i += rules.length - 1;
                  ruleset.resetCache();
              }
          }
          // Evaluate everything else
          for (i = 0; (rule = rsRules[i]); i++) {
              if (!rule.evalFirst) {
                  rsRules[i] = rule = rule.eval ? rule.eval(context) : rule;
              }
          }
          // Evaluate everything else
          for (i = 0; (rule = rsRules[i]); i++) {
              // for rulesets, check if it is a css guard and can be removed
              if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {
                  // check if it can be folded in (e.g. & where)
                  if (rule.selectors[0] && rule.selectors[0].isJustParentSelector()) {
                      rsRules.splice(i--, 1);
                      for (var j = 0; (subRule = rule.rules[j]); j++) {
                          if (subRule instanceof Node) {
                              subRule.copyVisibilityInfo(rule.visibilityInfo());
                              if (!(subRule instanceof Declaration) || !subRule.variable) {
                                  rsRules.splice(++i, 0, subRule);
                              }
                          }
                      }
                  }
              }
          }
          // Pop the stack
          ctxFrames.shift();
          ctxSelectors.shift();
          if (context.mediaBlocks) {
              for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {
                  context.mediaBlocks[i].bubbleSelectors(selectors);
              }
          }
          return ruleset;
      };
      Ruleset.prototype.evalImports = function (context) {
          var rules = this.rules;
          var i;
          var importRules;
          if (!rules) {
              return;
          }
          for (i = 0; i < rules.length; i++) {
              if (rules[i].type === 'Import') {
                  importRules = rules[i].eval(context);
                  if (importRules && (importRules.length || importRules.length === 0)) {
                      rules.splice.apply(rules, [i, 1].concat(importRules));
                      i += importRules.length - 1;
                  }
                  else {
                      rules.splice(i, 1, importRules);
                  }
                  this.resetCache();
              }
          }
      };
      Ruleset.prototype.makeImportant = function () {
          var result = new Ruleset(this.selectors, this.rules.map(function (r) {
              if (r.makeImportant) {
                  return r.makeImportant();
              }
              else {
                  return r;
              }
          }), this.strictImports, this.visibilityInfo());
          return result;
      };
      Ruleset.prototype.matchArgs = function (args) {
          return !args || args.length === 0;
      };
      // lets you call a css selector with a guard
      Ruleset.prototype.matchCondition = function (args, context) {
          var lastSelector = this.selectors[this.selectors.length - 1];
          if (!lastSelector.evaldCondition) {
              return false;
          }
          if (lastSelector.condition &&
              !lastSelector.condition.eval(new contexts.Eval(context, context.frames))) {
              return false;
          }
          return true;
      };
      Ruleset.prototype.resetCache = function () {
          this._rulesets = null;
          this._variables = null;
          this._properties = null;
          this._lookups = {};
      };
      Ruleset.prototype.variables = function () {
          if (!this._variables) {
              this._variables = !this.rules ? {} : this.rules.reduce(function (hash, r) {
                  if (r instanceof Declaration && r.variable === true) {
                      hash[r.name] = r;
                  }
                  // when evaluating variables in an import statement, imports have not been eval'd
                  // so we need to go inside import statements.
                  // guard against root being a string (in the case of inlined less)
                  if (r.type === 'Import' && r.root && r.root.variables) {
                      var vars = r.root.variables();
                      for (var name_1 in vars) {
                          if (vars.hasOwnProperty(name_1)) {
                              hash[name_1] = r.root.variable(name_1);
                          }
                      }
                  }
                  return hash;
              }, {});
          }
          return this._variables;
      };
      Ruleset.prototype.properties = function () {
          if (!this._properties) {
              this._properties = !this.rules ? {} : this.rules.reduce(function (hash, r) {
                  if (r instanceof Declaration && r.variable !== true) {
                      var name_2 = (r.name.length === 1) && (r.name[0] instanceof Keyword) ?
                          r.name[0].value : r.name;
                      // Properties don't overwrite as they can merge
                      if (!hash["$" + name_2]) {
                          hash["$" + name_2] = [r];
                      }
                      else {
                          hash["$" + name_2].push(r);
                      }
                  }
                  return hash;
              }, {});
          }
          return this._properties;
      };
      Ruleset.prototype.variable = function (name) {
          var decl = this.variables()[name];
          if (decl) {
              return this.parseValue(decl);
          }
      };
      Ruleset.prototype.property = function (name) {
          var decl = this.properties()[name];
          if (decl) {
              return this.parseValue(decl);
          }
      };
      Ruleset.prototype.lastDeclaration = function () {
          for (var i_1 = this.rules.length; i_1 > 0; i_1--) {
              var decl = this.rules[i_1 - 1];
              if (decl instanceof Declaration) {
                  return this.parseValue(decl);
              }
          }
      };
      Ruleset.prototype.parseValue = function (toParse) {
          var self = this;
          function transformDeclaration(decl) {
              if (decl.value instanceof Anonymous && !decl.parsed) {
                  if (typeof decl.value.value === 'string') {
                      this.parse.parseNode(decl.value.value, ['value', 'important'], decl.value.getIndex(), decl.fileInfo(), function (err, result) {
                          if (err) {
                              decl.parsed = true;
                          }
                          if (result) {
                              decl.value = result[0];
                              decl.important = result[1] || '';
                              decl.parsed = true;
                          }
                      });
                  }
                  else {
                      decl.parsed = true;
                  }
                  return decl;
              }
              else {
                  return decl;
              }
          }
          if (!Array.isArray(toParse)) {
              return transformDeclaration.call(self, toParse);
          }
          else {
              var nodes_1 = [];
              toParse.forEach(function (n) {
                  nodes_1.push(transformDeclaration.call(self, n));
              });
              return nodes_1;
          }
      };
      Ruleset.prototype.rulesets = function () {
          if (!this.rules) {
              return [];
          }
          var filtRules = [];
          var rules = this.rules;
          var i;
          var rule;
          for (i = 0; (rule = rules[i]); i++) {
              if (rule.isRuleset) {
                  filtRules.push(rule);
              }
          }
          return filtRules;
      };
      Ruleset.prototype.prependRule = function (rule) {
          var rules = this.rules;
          if (rules) {
              rules.unshift(rule);
          }
          else {
              this.rules = [rule];
          }
          this.setParent(rule, this);
      };
      Ruleset.prototype.find = function (selector, self, filter) {
          if (self === void 0) { self = this; }
          var rules = [];
          var match;
          var foundMixins;
          var key = selector.toCSS();
          if (key in this._lookups) {
              return this._lookups[key];
          }
          this.rulesets().forEach(function (rule) {
              if (rule !== self) {
                  for (var j = 0; j < rule.selectors.length; j++) {
                      match = selector.match(rule.selectors[j]);
                      if (match) {
                          if (selector.elements.length > match) {
                              if (!filter || filter(rule)) {
                                  foundMixins = rule.find(new Selector(selector.elements.slice(match)), self, filter);
                                  for (var i_2 = 0; i_2 < foundMixins.length; ++i_2) {
                                      foundMixins[i_2].path.push(rule);
                                  }
                                  Array.prototype.push.apply(rules, foundMixins);
                              }
                          }
                          else {
                              rules.push({ rule: rule, path: [] });
                          }
                          break;
                      }
                  }
              }
          });
          this._lookups[key] = rules;
          return rules;
      };
      Ruleset.prototype.genCSS = function (context, output) {
          var i;
          var j;
          var charsetRuleNodes = [];
          var ruleNodes = [];
          var // Line number debugging
          debugInfo$1;
          var rule;
          var path;
          context.tabLevel = (context.tabLevel || 0);
          if (!this.root) {
              context.tabLevel++;
          }
          var tabRuleStr = context.compress ? '' : Array(context.tabLevel + 1).join('  ');
          var tabSetStr = context.compress ? '' : Array(context.tabLevel).join('  ');
          var sep;
          var charsetNodeIndex = 0;
          var importNodeIndex = 0;
          for (i = 0; (rule = this.rules[i]); i++) {
              if (rule instanceof Comment) {
                  if (importNodeIndex === i) {
                      importNodeIndex++;
                  }
                  ruleNodes.push(rule);
              }
              else if (rule.isCharset && rule.isCharset()) {
                  ruleNodes.splice(charsetNodeIndex, 0, rule);
                  charsetNodeIndex++;
                  importNodeIndex++;
              }
              else if (rule.type === 'Import') {
                  ruleNodes.splice(importNodeIndex, 0, rule);
                  importNodeIndex++;
              }
              else {
                  ruleNodes.push(rule);
              }
          }
          ruleNodes = charsetRuleNodes.concat(ruleNodes);
          // If this is the root node, we don't render
          // a selector, or {}.
          if (!this.root) {
              debugInfo$1 = debugInfo(context, this, tabSetStr);
              if (debugInfo$1) {
                  output.add(debugInfo$1);
                  output.add(tabSetStr);
              }
              var paths = this.paths;
              var pathCnt = paths.length;
              var pathSubCnt = void 0;
              sep = context.compress ? ',' : (",\n" + tabSetStr);
              for (i = 0; i < pathCnt; i++) {
                  path = paths[i];
                  if (!(pathSubCnt = path.length)) {
                      continue;
                  }
                  if (i > 0) {
                      output.add(sep);
                  }
                  context.firstSelector = true;
                  path[0].genCSS(context, output);
                  context.firstSelector = false;
                  for (j = 1; j < pathSubCnt; j++) {
                      path[j].genCSS(context, output);
                  }
              }
              output.add((context.compress ? '{' : ' {\n') + tabRuleStr);
          }
          // Compile rules and rulesets
          for (i = 0; (rule = ruleNodes[i]); i++) {
              if (i + 1 === ruleNodes.length) {
                  context.lastRule = true;
              }
              var currentLastRule = context.lastRule;
              if (rule.isRulesetLike(rule)) {
                  context.lastRule = false;
              }
              if (rule.genCSS) {
                  rule.genCSS(context, output);
              }
              else if (rule.value) {
                  output.add(rule.value.toString());
              }
              context.lastRule = currentLastRule;
              if (!context.lastRule && rule.isVisible()) {
                  output.add(context.compress ? '' : ("\n" + tabRuleStr));
              }
              else {
                  context.lastRule = false;
              }
          }
          if (!this.root) {
              output.add((context.compress ? '}' : "\n" + tabSetStr + "}"));
              context.tabLevel--;
          }
          if (!output.isEmpty() && !context.compress && this.firstRoot) {
              output.add('\n');
          }
      };
      Ruleset.prototype.joinSelectors = function (paths, context, selectors) {
          for (var s = 0; s < selectors.length; s++) {
              this.joinSelector(paths, context, selectors[s]);
          }
      };
      Ruleset.prototype.joinSelector = function (paths, context, selector) {
          function createParenthesis(elementsToPak, originalElement) {
              var replacementParen;
              var j;
              if (elementsToPak.length === 0) {
                  replacementParen = new Paren(elementsToPak[0]);
              }
              else {
                  var insideParent = new Array(elementsToPak.length);
                  for (j = 0; j < elementsToPak.length; j++) {
                      insideParent[j] = new Element(null, elementsToPak[j], originalElement.isVariable, originalElement._index, originalElement._fileInfo);
                  }
                  replacementParen = new Paren(new Selector(insideParent));
              }
              return replacementParen;
          }
          function createSelector(containedElement, originalElement) {
              var element;
              var selector;
              element = new Element(null, containedElement, originalElement.isVariable, originalElement._index, originalElement._fileInfo);
              selector = new Selector([element]);
              return selector;
          }
          // joins selector path from `beginningPath` with selector path in `addPath`
          // `replacedElement` contains element that is being replaced by `addPath`
          // returns concatenated path
          function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {
              var newSelectorPath;
              var lastSelector;
              var newJoinedSelector;
              // our new selector path
              newSelectorPath = [];
              // construct the joined selector - if & is the first thing this will be empty,
              // if not newJoinedSelector will be the last set of elements in the selector
              if (beginningPath.length > 0) {
                  newSelectorPath = copyArray(beginningPath);
                  lastSelector = newSelectorPath.pop();
                  newJoinedSelector = originalSelector.createDerived(copyArray(lastSelector.elements));
              }
              else {
                  newJoinedSelector = originalSelector.createDerived([]);
              }
              if (addPath.length > 0) {
                  // /deep/ is a CSS4 selector - (removed, so should deprecate)
                  // that is valid without anything in front of it
                  // so if the & does not have a combinator that is "" or " " then
                  // and there is a combinator on the parent, then grab that.
                  // this also allows + a { & .b { .a & { ... though not sure why you would want to do that
                  var combinator = replacedElement.combinator;
                  var parentEl = addPath[0].elements[0];
                  if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {
                      combinator = parentEl.combinator;
                  }
                  // join the elements so far with the first part of the parent
                  newJoinedSelector.elements.push(new Element(combinator, parentEl.value, replacedElement.isVariable, replacedElement._index, replacedElement._fileInfo));
                  newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));
              }
              // now add the joined selector - but only if it is not empty
              if (newJoinedSelector.elements.length !== 0) {
                  newSelectorPath.push(newJoinedSelector);
              }
              // put together the parent selectors after the join (e.g. the rest of the parent)
              if (addPath.length > 1) {
                  var restOfPath = addPath.slice(1);
                  restOfPath = restOfPath.map(function (selector) { return selector.createDerived(selector.elements, []); });
                  newSelectorPath = newSelectorPath.concat(restOfPath);
              }
              return newSelectorPath;
          }
          // joins selector path from `beginningPath` with every selector path in `addPaths` array
          // `replacedElement` contains element that is being replaced by `addPath`
          // returns array with all concatenated paths
          function addAllReplacementsIntoPath(beginningPath, addPaths, replacedElement, originalSelector, result) {
              var j;
              for (j = 0; j < beginningPath.length; j++) {
                  var newSelectorPath = addReplacementIntoPath(beginningPath[j], addPaths, replacedElement, originalSelector);
                  result.push(newSelectorPath);
              }
              return result;
          }
          function mergeElementsOnToSelectors(elements, selectors) {
              var i;
              var sel;
              if (elements.length === 0) {
                  return;
              }
              if (selectors.length === 0) {
                  selectors.push([new Selector(elements)]);
                  return;
              }
              for (i = 0; (sel = selectors[i]); i++) {
                  // if the previous thing in sel is a parent this needs to join on to it
                  if (sel.length > 0) {
                      sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));
                  }
                  else {
                      sel.push(new Selector(elements));
                  }
              }
          }
          // replace all parent selectors inside `inSelector` by content of `context` array
          // resulting selectors are returned inside `paths` array
          // returns true if `inSelector` contained at least one parent selector
          function replaceParentSelector(paths, context, inSelector) {
              // The paths are [[Selector]]
              // The first list is a list of comma separated selectors
              // The inner list is a list of inheritance separated selectors
              // e.g.
              // .a, .b {
              //   .c {
              //   }
              // }
              // == [[.a] [.c]] [[.b] [.c]]
              //
              var i;
              var j;
              var k;
              var currentElements;
              var newSelectors;
              var selectorsMultiplied;
              var sel;
              var el;
              var hadParentSelector = false;
              var length;
              var lastSelector;
              function findNestedSelector(element) {
                  var maybeSelector;
                  if (!(element.value instanceof Paren)) {
                      return null;
                  }
                  maybeSelector = element.value.value;
                  if (!(maybeSelector instanceof Selector)) {
                      return null;
                  }
                  return maybeSelector;
              }
              // the elements from the current selector so far
              currentElements = [];
              // the current list of new selectors to add to the path.
              // We will build it up. We initiate it with one empty selector as we "multiply" the new selectors
              // by the parents
              newSelectors = [
                  []
              ];
              for (i = 0; (el = inSelector.elements[i]); i++) {
                  // non parent reference elements just get added
                  if (el.value !== '&') {
                      var nestedSelector = findNestedSelector(el);
                      if (nestedSelector != null) {
                          // merge the current list of non parent selector elements
                          // on to the current list of selectors to add
                          mergeElementsOnToSelectors(currentElements, newSelectors);
                          var nestedPaths = [];
                          var replaced = void 0;
                          var replacedNewSelectors = [];
                          replaced = replaceParentSelector(nestedPaths, context, nestedSelector);
                          hadParentSelector = hadParentSelector || replaced;
                          // the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors
                          for (k = 0; k < nestedPaths.length; k++) {
                              var replacementSelector = createSelector(createParenthesis(nestedPaths[k], el), el);
                              addAllReplacementsIntoPath(newSelectors, [replacementSelector], el, inSelector, replacedNewSelectors);
                          }
                          newSelectors = replacedNewSelectors;
                          currentElements = [];
                      }
                      else {
                          currentElements.push(el);
                      }
                  }
                  else {
                      hadParentSelector = true;
                      // the new list of selectors to add
                      selectorsMultiplied = [];
                      // merge the current list of non parent selector elements
                      // on to the current list of selectors to add
                      mergeElementsOnToSelectors(currentElements, newSelectors);
                      // loop through our current selectors
                      for (j = 0; j < newSelectors.length; j++) {
                          sel = newSelectors[j];
                          // if we don't have any parent paths, the & might be in a mixin so that it can be used
                          // whether there are parents or not
                          if (context.length === 0) {
                              // the combinator used on el should now be applied to the next element instead so that
                              // it is not lost
                              if (sel.length > 0) {
                                  sel[0].elements.push(new Element(el.combinator, '', el.isVariable, el._index, el._fileInfo));
                              }
                              selectorsMultiplied.push(sel);
                          }
                          else {
                              // and the parent selectors
                              for (k = 0; k < context.length; k++) {
                                  // We need to put the current selectors
                                  // then join the last selector's elements on to the parents selectors
                                  var newSelectorPath = addReplacementIntoPath(sel, context[k], el, inSelector);
                                  // add that to our new set of selectors
                                  selectorsMultiplied.push(newSelectorPath);
                              }
                          }
                      }
                      // our new selectors has been multiplied, so reset the state
                      newSelectors = selectorsMultiplied;
                      currentElements = [];
                  }
              }
              // if we have any elements left over (e.g. .a& .b == .b)
              // add them on to all the current selectors
              mergeElementsOnToSelectors(currentElements, newSelectors);
              for (i = 0; i < newSelectors.length; i++) {
                  length = newSelectors[i].length;
                  if (length > 0) {
                      paths.push(newSelectors[i]);
                      lastSelector = newSelectors[i][length - 1];
                      newSelectors[i][length - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);
                  }
              }
              return hadParentSelector;
          }
          function deriveSelector(visibilityInfo, deriveFrom) {
              var newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);
              newSelector.copyVisibilityInfo(visibilityInfo);
              return newSelector;
          }
          // joinSelector code follows
          var i;
          var newPaths;
          var hadParentSelector;
          newPaths = [];
          hadParentSelector = replaceParentSelector(newPaths, context, selector);
          if (!hadParentSelector) {
              if (context.length > 0) {
                  newPaths = [];
                  for (i = 0; i < context.length; i++) {
                      var concatenated = context[i].map(deriveSelector.bind(this, selector.visibilityInfo()));
                      concatenated.push(selector);
                      newPaths.push(concatenated);
                  }
              }
              else {
                  newPaths = [[selector]];
              }
          }
          for (i = 0; i < newPaths.length; i++) {
              paths.push(newPaths[i]);
          }
      };
      return Ruleset;
  }(Node));
  Ruleset.prototype.type = 'Ruleset';
  Ruleset.prototype.isRuleset = true;

  var AtRule = /** @class */ (function (_super) {
      __extends(AtRule, _super);
      function AtRule(name, value, rules, index, currentFileInfo, debugInfo, isRooted, visibilityInfo) {
          var _this = _super.call(this) || this;
          var i;
          _this.name = name;
          _this.value = (value instanceof Node) ? value : (value ? new Anonymous(value) : value);
          if (rules) {
              if (Array.isArray(rules)) {
                  _this.rules = rules;
              }
              else {
                  _this.rules = [rules];
                  _this.rules[0].selectors = (new Selector([], null, null, index, currentFileInfo)).createEmptySelectors();
              }
              for (i = 0; i < _this.rules.length; i++) {
                  _this.rules[i].allowImports = true;
              }
              _this.setParent(_this.rules, _this);
          }
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.debugInfo = debugInfo;
          _this.isRooted = isRooted || false;
          _this.copyVisibilityInfo(visibilityInfo);
          _this.allowRoot = true;
          return _this;
      }
      AtRule.prototype.accept = function (visitor) {
          var value = this.value;
          var rules = this.rules;
          if (rules) {
              this.rules = visitor.visitArray(rules);
          }
          if (value) {
              this.value = visitor.visit(value);
          }
      };
      AtRule.prototype.isRulesetLike = function () {
          return this.rules || !this.isCharset();
      };
      AtRule.prototype.isCharset = function () {
          return '@charset' === this.name;
      };
      AtRule.prototype.genCSS = function (context, output) {
          var value = this.value;
          var rules = this.rules;
          output.add(this.name, this.fileInfo(), this.getIndex());
          if (value) {
              output.add(' ');
              value.genCSS(context, output);
          }
          if (rules) {
              this.outputRuleset(context, output, rules);
          }
          else {
              output.add(';');
          }
      };
      AtRule.prototype.eval = function (context) {
          var mediaPathBackup;
          var mediaBlocksBackup;
          var value = this.value;
          var rules = this.rules;
          // media stored inside other atrule should not bubble over it
          // backpup media bubbling information
          mediaPathBackup = context.mediaPath;
          mediaBlocksBackup = context.mediaBlocks;
          // deleted media bubbling information
          context.mediaPath = [];
          context.mediaBlocks = [];
          if (value) {
              value = value.eval(context);
          }
          if (rules) {
              // assuming that there is only one rule at this point - that is how parser constructs the rule
              rules = [rules[0].eval(context)];
              rules[0].root = true;
          }
          // restore media bubbling information
          context.mediaPath = mediaPathBackup;
          context.mediaBlocks = mediaBlocksBackup;
          return new AtRule(this.name, value, rules, this.getIndex(), this.fileInfo(), this.debugInfo, this.isRooted, this.visibilityInfo());
      };
      AtRule.prototype.variable = function (name) {
          if (this.rules) {
              // assuming that there is only one rule at this point - that is how parser constructs the rule
              return Ruleset.prototype.variable.call(this.rules[0], name);
          }
      };
      AtRule.prototype.find = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.rules) {
              // assuming that there is only one rule at this point - that is how parser constructs the rule
              return Ruleset.prototype.find.apply(this.rules[0], args);
          }
      };
      AtRule.prototype.rulesets = function () {
          if (this.rules) {
              // assuming that there is only one rule at this point - that is how parser constructs the rule
              return Ruleset.prototype.rulesets.apply(this.rules[0]);
          }
      };
      AtRule.prototype.outputRuleset = function (context, output, rules) {
          var ruleCnt = rules.length;
          var i;
          context.tabLevel = (context.tabLevel | 0) + 1;
          // Compressed
          if (context.compress) {
              output.add('{');
              for (i = 0; i < ruleCnt; i++) {
                  rules[i].genCSS(context, output);
              }
              output.add('}');
              context.tabLevel--;
              return;
          }
          // Non-compressed
          var tabSetStr = "\n" + Array(context.tabLevel).join('  ');
          var tabRuleStr = tabSetStr + "  ";
          if (!ruleCnt) {
              output.add(" {" + tabSetStr + "}");
          }
          else {
              output.add(" {" + tabRuleStr);
              rules[0].genCSS(context, output);
              for (i = 1; i < ruleCnt; i++) {
                  output.add(tabRuleStr);
                  rules[i].genCSS(context, output);
              }
              output.add(tabSetStr + "}");
          }
          context.tabLevel--;
      };
      return AtRule;
  }(Node));
  AtRule.prototype.type = 'AtRule';

  var DetachedRuleset = /** @class */ (function (_super) {
      __extends(DetachedRuleset, _super);
      function DetachedRuleset(ruleset, frames) {
          var _this = _super.call(this) || this;
          _this.ruleset = ruleset;
          _this.frames = frames;
          _this.setParent(_this.ruleset, _this);
          return _this;
      }
      DetachedRuleset.prototype.accept = function (visitor) {
          this.ruleset = visitor.visit(this.ruleset);
      };
      DetachedRuleset.prototype.eval = function (context) {
          var frames = this.frames || copyArray(context.frames);
          return new DetachedRuleset(this.ruleset, frames);
      };
      DetachedRuleset.prototype.callEval = function (context) {
          return this.ruleset.eval(this.frames ? new contexts.Eval(context, this.frames.concat(context.frames)) : context);
      };
      return DetachedRuleset;
  }(Node));
  DetachedRuleset.prototype.type = 'DetachedRuleset';
  DetachedRuleset.prototype.evalFirst = true;

  var Unit = /** @class */ (function (_super) {
      __extends(Unit, _super);
      function Unit(numerator, denominator, backupUnit) {
          var _this = _super.call(this) || this;
          _this.numerator = numerator ? copyArray(numerator).sort() : [];
          _this.denominator = denominator ? copyArray(denominator).sort() : [];
          if (backupUnit) {
              _this.backupUnit = backupUnit;
          }
          else if (numerator && numerator.length) {
              _this.backupUnit = numerator[0];
          }
          return _this;
      }
      Unit.prototype.clone = function () {
          return new Unit(copyArray(this.numerator), copyArray(this.denominator), this.backupUnit);
      };
      Unit.prototype.genCSS = function (context, output) {
          // Dimension checks the unit is singular and throws an error if in strict math mode.
          var strictUnits = context && context.strictUnits;
          if (this.numerator.length === 1) {
              output.add(this.numerator[0]); // the ideal situation
          }
          else if (!strictUnits && this.backupUnit) {
              output.add(this.backupUnit);
          }
          else if (!strictUnits && this.denominator.length) {
              output.add(this.denominator[0]);
          }
      };
      Unit.prototype.toString = function () {
          var i;
          var returnStr = this.numerator.join('*');
          for (i = 0; i < this.denominator.length; i++) {
              returnStr += "/" + this.denominator[i];
          }
          return returnStr;
      };
      Unit.prototype.compare = function (other) {
          return this.is(other.toString()) ? 0 : undefined;
      };
      Unit.prototype.is = function (unitString) {
          return this.toString().toUpperCase() === unitString.toUpperCase();
      };
      Unit.prototype.isLength = function () {
          return RegExp('^(px|em|ex|ch|rem|in|cm|mm|pc|pt|ex|vw|vh|vmin|vmax)$', 'gi').test(this.toCSS());
      };
      Unit.prototype.isEmpty = function () {
          return this.numerator.length === 0 && this.denominator.length === 0;
      };
      Unit.prototype.isSingular = function () {
          return this.numerator.length <= 1 && this.denominator.length === 0;
      };
      Unit.prototype.map = function (callback) {
          var i;
          for (i = 0; i < this.numerator.length; i++) {
              this.numerator[i] = callback(this.numerator[i], false);
          }
          for (i = 0; i < this.denominator.length; i++) {
              this.denominator[i] = callback(this.denominator[i], true);
          }
      };
      Unit.prototype.usedUnits = function () {
          var group;
          var result = {};
          var mapUnit;
          var groupName;
          mapUnit = function (atomicUnit) {
              /* jshint loopfunc:true */
              if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {
                  result[groupName] = atomicUnit;
              }
              return atomicUnit;
          };
          for (groupName in unitConversions) {
              if (unitConversions.hasOwnProperty(groupName)) {
                  group = unitConversions[groupName];
                  this.map(mapUnit);
              }
          }
          return result;
      };
      Unit.prototype.cancel = function () {
          var counter = {};
          var atomicUnit;
          var i;
          for (i = 0; i < this.numerator.length; i++) {
              atomicUnit = this.numerator[i];
              counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;
          }
          for (i = 0; i < this.denominator.length; i++) {
              atomicUnit = this.denominator[i];
              counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;
          }
          this.numerator = [];
          this.denominator = [];
          for (atomicUnit in counter) {
              if (counter.hasOwnProperty(atomicUnit)) {
                  var count = counter[atomicUnit];
                  if (count > 0) {
                      for (i = 0; i < count; i++) {
                          this.numerator.push(atomicUnit);
                      }
                  }
                  else if (count < 0) {
                      for (i = 0; i < -count; i++) {
                          this.denominator.push(atomicUnit);
                      }
                  }
              }
          }
          this.numerator.sort();
          this.denominator.sort();
      };
      return Unit;
  }(Node));
  Unit.prototype.type = 'Unit';

  //
  // A number with a unit
  //
  var Dimension = /** @class */ (function (_super) {
      __extends(Dimension, _super);
      function Dimension(value, unit) {
          var _this = _super.call(this) || this;
          _this.value = parseFloat(value);
          if (isNaN(_this.value)) {
              throw new Error('Dimension is not a number.');
          }
          _this.unit = (unit && unit instanceof Unit) ? unit :
              new Unit(unit ? [unit] : undefined);
          _this.setParent(_this.unit, _this);
          return _this;
      }
      Dimension.prototype.accept = function (visitor) {
          this.unit = visitor.visit(this.unit);
      };
      Dimension.prototype.eval = function (context) {
          return this;
      };
      Dimension.prototype.toColor = function () {
          return new Color([this.value, this.value, this.value]);
      };
      Dimension.prototype.genCSS = function (context, output) {
          if ((context && context.strictUnits) && !this.unit.isSingular()) {
              throw new Error("Multiple units in dimension. Correct the units or use the unit function. Bad unit: " + this.unit.toString());
          }
          var value = this.fround(context, this.value);
          var strValue = String(value);
          if (value !== 0 && value < 0.000001 && value > -0.000001) {
              // would be output 1e-6 etc.
              strValue = value.toFixed(20).replace(/0+$/, '');
          }
          if (context && context.compress) {
              // Zero values doesn't need a unit
              if (value === 0 && this.unit.isLength()) {
                  output.add(strValue);
                  return;
              }
              // Float values doesn't need a leading zero
              if (value > 0 && value < 1) {
                  strValue = (strValue).substr(1);
              }
          }
          output.add(strValue);
          this.unit.genCSS(context, output);
      };
      // In an operation between two Dimensions,
      // we default to the first Dimension's unit,
      // so `1px + 2` will yield `3px`.
      Dimension.prototype.operate = function (context, op, other) {
          /* jshint noempty:false */
          var value = this._operate(context, op, this.value, other.value);
          var unit = this.unit.clone();
          if (op === '+' || op === '-') {
              if (unit.numerator.length === 0 && unit.denominator.length === 0) {
                  unit = other.unit.clone();
                  if (this.unit.backupUnit) {
                      unit.backupUnit = this.unit.backupUnit;
                  }
              }
              else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) ;
              else {
                  other = other.convertTo(this.unit.usedUnits());
                  if (context.strictUnits && other.unit.toString() !== unit.toString()) {
                      throw new Error("Incompatible units. Change the units or use the unit function. " +
                          ("Bad units: '" + unit.toString() + "' and '" + other.unit.toString() + "'."));
                  }
                  value = this._operate(context, op, this.value, other.value);
              }
          }
          else if (op === '*') {
              unit.numerator = unit.numerator.concat(other.unit.numerator).sort();
              unit.denominator = unit.denominator.concat(other.unit.denominator).sort();
              unit.cancel();
          }
          else if (op === '/') {
              unit.numerator = unit.numerator.concat(other.unit.denominator).sort();
              unit.denominator = unit.denominator.concat(other.unit.numerator).sort();
              unit.cancel();
          }
          return new Dimension(value, unit);
      };
      Dimension.prototype.compare = function (other) {
          var a;
          var b;
          if (!(other instanceof Dimension)) {
              return undefined;
          }
          if (this.unit.isEmpty() || other.unit.isEmpty()) {
              a = this;
              b = other;
          }
          else {
              a = this.unify();
              b = other.unify();
              if (a.unit.compare(b.unit) !== 0) {
                  return undefined;
              }
          }
          return Node.numericCompare(a.value, b.value);
      };
      Dimension.prototype.unify = function () {
          return this.convertTo({ length: 'px', duration: 's', angle: 'rad' });
      };
      Dimension.prototype.convertTo = function (conversions) {
          var value = this.value;
          var unit = this.unit.clone();
          var i;
          var groupName;
          var group;
          var targetUnit;
          var derivedConversions = {};
          var applyUnit;
          if (typeof conversions === 'string') {
              for (i in unitConversions) {
                  if (unitConversions[i].hasOwnProperty(conversions)) {
                      derivedConversions = {};
                      derivedConversions[i] = conversions;
                  }
              }
              conversions = derivedConversions;
          }
          applyUnit = function (atomicUnit, denominator) {
              /* jshint loopfunc:true */
              if (group.hasOwnProperty(atomicUnit)) {
                  if (denominator) {
                      value = value / (group[atomicUnit] / group[targetUnit]);
                  }
                  else {
                      value = value * (group[atomicUnit] / group[targetUnit]);
                  }
                  return targetUnit;
              }
              return atomicUnit;
          };
          for (groupName in conversions) {
              if (conversions.hasOwnProperty(groupName)) {
                  targetUnit = conversions[groupName];
                  group = unitConversions[groupName];
                  unit.map(applyUnit);
              }
          }
          unit.cancel();
          return new Dimension(value, unit);
      };
      return Dimension;
  }(Node));
  Dimension.prototype.type = 'Dimension';

  var MATH$1 = Math$1;
  var Operation = /** @class */ (function (_super) {
      __extends(Operation, _super);
      function Operation(op, operands, isSpaced) {
          var _this = _super.call(this) || this;
          _this.op = op.trim();
          _this.operands = operands;
          _this.isSpaced = isSpaced;
          return _this;
      }
      Operation.prototype.accept = function (visitor) {
          this.operands = visitor.visitArray(this.operands);
      };
      Operation.prototype.eval = function (context) {
          var a = this.operands[0].eval(context);
          var b = this.operands[1].eval(context);
          var op;
          if (context.isMathOn(this.op)) {
              op = this.op === './' ? '/' : this.op;
              if (a instanceof Dimension && b instanceof Color) {
                  a = a.toColor();
              }
              if (b instanceof Dimension && a instanceof Color) {
                  b = b.toColor();
              }
              if (!a.operate) {
                  if (a instanceof Operation && a.op === '/' && context.math === MATH$1.PARENS_DIVISION) {
                      return new Operation(this.op, [a, b], this.isSpaced);
                  }
                  throw { type: 'Operation',
                      message: 'Operation on an invalid type' };
              }
              return a.operate(context, op, b);
          }
          else {
              return new Operation(this.op, [a, b], this.isSpaced);
          }
      };
      Operation.prototype.genCSS = function (context, output) {
          this.operands[0].genCSS(context, output);
          if (this.isSpaced) {
              output.add(' ');
          }
          output.add(this.op);
          if (this.isSpaced) {
              output.add(' ');
          }
          this.operands[1].genCSS(context, output);
      };
      return Operation;
  }(Node));
  Operation.prototype.type = 'Operation';

  var MATH$2 = Math$1;
  var Expression = /** @class */ (function (_super) {
      __extends(Expression, _super);
      function Expression(value, noSpacing) {
          var _this = _super.call(this) || this;
          _this.value = value;
          _this.noSpacing = noSpacing;
          if (!value) {
              throw new Error('Expression requires an array parameter');
          }
          return _this;
      }
      Expression.prototype.accept = function (visitor) {
          this.value = visitor.visitArray(this.value);
      };
      Expression.prototype.eval = function (context) {
          var returnValue;
          var mathOn = context.isMathOn();
          var inParenthesis = this.parens &&
              (context.math !== MATH$2.STRICT_LEGACY || !this.parensInOp);
          var doubleParen = false;
          if (inParenthesis) {
              context.inParenthesis();
          }
          if (this.value.length > 1) {
              returnValue = new Expression(this.value.map(function (e) {
                  if (!e.eval) {
                      return e;
                  }
                  return e.eval(context);
              }), this.noSpacing);
          }
          else if (this.value.length === 1) {
              if (this.value[0].parens && !this.value[0].parensInOp && !context.inCalc) {
                  doubleParen = true;
              }
              returnValue = this.value[0].eval(context);
          }
          else {
              returnValue = this;
          }
          if (inParenthesis) {
              context.outOfParenthesis();
          }
          if (this.parens && this.parensInOp && !mathOn && !doubleParen
              && (!(returnValue instanceof Dimension))) {
              returnValue = new Paren(returnValue);
          }
          return returnValue;
      };
      Expression.prototype.genCSS = function (context, output) {
          for (var i_1 = 0; i_1 < this.value.length; i_1++) {
              this.value[i_1].genCSS(context, output);
              if (!this.noSpacing && i_1 + 1 < this.value.length) {
                  output.add(' ');
              }
          }
      };
      Expression.prototype.throwAwayComments = function () {
          this.value = this.value.filter(function (v) { return !(v instanceof Comment); });
      };
      return Expression;
  }(Node));
  Expression.prototype.type = 'Expression';

  var functionCaller = /** @class */ (function () {
      function functionCaller(name, context, index, currentFileInfo) {
          this.name = name.toLowerCase();
          this.index = index;
          this.context = context;
          this.currentFileInfo = currentFileInfo;
          this.func = context.frames[0].functionRegistry.get(this.name);
      }
      functionCaller.prototype.isValid = function () {
          return Boolean(this.func);
      };
      functionCaller.prototype.call = function (args) {
          // This code is terrible and should be replaced as per this issue...
          // https://github.com/less/less.js/issues/2477
          if (Array.isArray(args)) {
              args = args.filter(function (item) {
                  if (item.type === 'Comment') {
                      return false;
                  }
                  return true;
              })
                  .map(function (item) {
                  if (item.type === 'Expression') {
                      var subNodes = item.value.filter(function (item) {
                          if (item.type === 'Comment') {
                              return false;
                          }
                          return true;
                      });
                      if (subNodes.length === 1) {
                          return subNodes[0];
                      }
                      else {
                          return new Expression(subNodes);
                      }
                  }
                  return item;
              });
          }
          return this.func.apply(this, args);
      };
      return functionCaller;
  }());

  //
  // A function call node.
  //
  var Call = /** @class */ (function (_super) {
      __extends(Call, _super);
      function Call(name, args, index, currentFileInfo) {
          var _this = _super.call(this) || this;
          _this.name = name;
          _this.args = args;
          _this.calc = name === 'calc';
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          return _this;
      }
      Call.prototype.accept = function (visitor) {
          if (this.args) {
              this.args = visitor.visitArray(this.args);
          }
      };
      //
      // When evaluating a function call,
      // we either find the function in the functionRegistry,
      // in which case we call it, passing the  evaluated arguments,
      // if this returns null or we cannot find the function, we
      // simply print it out as it appeared originally [2].
      //
      // The reason why we evaluate the arguments, is in the case where
      // we try to pass a variable to a function, like: `saturate(@color)`.
      // The function should receive the value, not the variable.
      //
      Call.prototype.eval = function (context) {
          /**
           * Turn off math for calc(), and switch back on for evaluating nested functions
           */
          var currentMathContext = context.mathOn;
          context.mathOn = !this.calc;
          if (this.calc || context.inCalc) {
              context.enterCalc();
          }
          var args = this.args.map(function (a) { return a.eval(context); });
          if (this.calc || context.inCalc) {
              context.exitCalc();
          }
          context.mathOn = currentMathContext;
          var result;
          var funcCaller = new functionCaller(this.name, context, this.getIndex(), this.fileInfo());
          if (funcCaller.isValid()) {
              try {
                  result = funcCaller.call(args);
              }
              catch (e) {
                  throw {
                      type: e.type || 'Runtime',
                      message: "error evaluating function `" + this.name + "`" + (e.message ? ": " + e.message : ''),
                      index: this.getIndex(),
                      filename: this.fileInfo().filename,
                      line: e.lineNumber,
                      column: e.columnNumber
                  };
              }
              if (result !== null && result !== undefined) {
                  // Results that that are not nodes are cast as Anonymous nodes
                  // Falsy values or booleans are returned as empty nodes
                  if (!(result instanceof Node)) {
                      if (!result || result === true) {
                          result = new Anonymous(null);
                      }
                      else {
                          result = new Anonymous(result.toString());
                      }
                  }
                  result._index = this._index;
                  result._fileInfo = this._fileInfo;
                  return result;
              }
          }
          return new Call(this.name, args, this.getIndex(), this.fileInfo());
      };
      Call.prototype.genCSS = function (context, output) {
          output.add(this.name + "(", this.fileInfo(), this.getIndex());
          for (var i_1 = 0; i_1 < this.args.length; i_1++) {
              this.args[i_1].genCSS(context, output);
              if (i_1 + 1 < this.args.length) {
                  output.add(', ');
              }
          }
          output.add(')');
      };
      return Call;
  }(Node));
  Call.prototype.type = 'Call';

  var Variable = /** @class */ (function (_super) {
      __extends(Variable, _super);
      function Variable(name, index, currentFileInfo) {
          var _this = _super.call(this) || this;
          _this.name = name;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          return _this;
      }
      Variable.prototype.eval = function (context) {
          var variable;
          var name = this.name;
          if (name.indexOf('@@') === 0) {
              name = "@" + new Variable(name.slice(1), this.getIndex(), this.fileInfo()).eval(context).value;
          }
          if (this.evaluating) {
              throw { type: 'Name',
                  message: "Recursive variable definition for " + name,
                  filename: this.fileInfo().filename,
                  index: this.getIndex() };
          }
          this.evaluating = true;
          variable = this.find(context.frames, function (frame) {
              var v = frame.variable(name);
              if (v) {
                  if (v.important) {
                      var importantScope = context.importantScope[context.importantScope.length - 1];
                      importantScope.important = v.important;
                  }
                  // If in calc, wrap vars in a function call to cascade evaluate args first
                  if (context.inCalc) {
                      return (new Call('_SELF', [v.value])).eval(context);
                  }
                  else {
                      return v.value.eval(context);
                  }
              }
          });
          if (variable) {
              this.evaluating = false;
              return variable;
          }
          else {
              throw { type: 'Name',
                  message: "variable " + name + " is undefined",
                  filename: this.fileInfo().filename,
                  index: this.getIndex() };
          }
      };
      Variable.prototype.find = function (obj, fun) {
          for (var i_1 = 0, r = void 0; i_1 < obj.length; i_1++) {
              r = fun.call(obj, obj[i_1]);
              if (r) {
                  return r;
              }
          }
          return null;
      };
      return Variable;
  }(Node));
  Variable.prototype.type = 'Variable';

  var Property = /** @class */ (function (_super) {
      __extends(Property, _super);
      function Property(name, index, currentFileInfo) {
          var _this = _super.call(this) || this;
          _this.name = name;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          return _this;
      }
      Property.prototype.eval = function (context) {
          var property;
          var name = this.name;
          // TODO: shorten this reference
          var mergeRules = context.pluginManager.less.visitors.ToCSSVisitor.prototype._mergeRules;
          if (this.evaluating) {
              throw { type: 'Name',
                  message: "Recursive property reference for " + name,
                  filename: this.fileInfo().filename,
                  index: this.getIndex() };
          }
          this.evaluating = true;
          property = this.find(context.frames, function (frame) {
              var v;
              var vArr = frame.property(name);
              if (vArr) {
                  for (var i_1 = 0; i_1 < vArr.length; i_1++) {
                      v = vArr[i_1];
                      vArr[i_1] = new Declaration(v.name, v.value, v.important, v.merge, v.index, v.currentFileInfo, v.inline, v.variable);
                  }
                  mergeRules(vArr);
                  v = vArr[vArr.length - 1];
                  if (v.important) {
                      var importantScope = context.importantScope[context.importantScope.length - 1];
                      importantScope.important = v.important;
                  }
                  v = v.value.eval(context);
                  return v;
              }
          });
          if (property) {
              this.evaluating = false;
              return property;
          }
          else {
              throw { type: 'Name',
                  message: "Property '" + name + "' is undefined",
                  filename: this.currentFileInfo.filename,
                  index: this.index };
          }
      };
      Property.prototype.find = function (obj, fun) {
          for (var i_2 = 0, r = void 0; i_2 < obj.length; i_2++) {
              r = fun.call(obj, obj[i_2]);
              if (r) {
                  return r;
              }
          }
          return null;
      };
      return Property;
  }(Node));
  Property.prototype.type = 'Property';

  var Attribute = /** @class */ (function (_super) {
      __extends(Attribute, _super);
      function Attribute(key, op, value) {
          var _this = _super.call(this) || this;
          _this.key = key;
          _this.op = op;
          _this.value = value;
          return _this;
      }
      Attribute.prototype.eval = function (context) {
          return new Attribute(this.key.eval ? this.key.eval(context) : this.key, this.op, (this.value && this.value.eval) ? this.value.eval(context) : this.value);
      };
      Attribute.prototype.genCSS = function (context, output) {
          output.add(this.toCSS(context));
      };
      Attribute.prototype.toCSS = function (context) {
          var value = this.key.toCSS ? this.key.toCSS(context) : this.key;
          if (this.op) {
              value += this.op;
              value += (this.value.toCSS ? this.value.toCSS(context) : this.value);
          }
          return "[" + value + "]";
      };
      return Attribute;
  }(Node));
  Attribute.prototype.type = 'Attribute';

  var Quoted = /** @class */ (function (_super) {
      __extends(Quoted, _super);
      function Quoted(str, content, escaped, index, currentFileInfo) {
          var _this = _super.call(this) || this;
          _this.escaped = (escaped == null) ? true : escaped;
          _this.value = content || '';
          _this.quote = str.charAt(0);
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.variableRegex = /@\{([\w-]+)\}/g;
          _this.propRegex = /\$\{([\w-]+)\}/g;
          _this.allowRoot = escaped;
          return _this;
      }
      Quoted.prototype.genCSS = function (context, output) {
          if (!this.escaped) {
              output.add(this.quote, this.fileInfo(), this.getIndex());
          }
          output.add(this.value);
          if (!this.escaped) {
              output.add(this.quote);
          }
      };
      Quoted.prototype.containsVariables = function () {
          return this.value.match(this.variableRegex);
      };
      Quoted.prototype.eval = function (context) {
          var that = this;
          var value = this.value;
          var variableReplacement = function (_, name) {
              var v = new Variable("@" + name, that.getIndex(), that.fileInfo()).eval(context, true);
              return (v instanceof Quoted) ? v.value : v.toCSS();
          };
          var propertyReplacement = function (_, name) {
              var v = new Property("$" + name, that.getIndex(), that.fileInfo()).eval(context, true);
              return (v instanceof Quoted) ? v.value : v.toCSS();
          };
          function iterativeReplace(value, regexp, replacementFnc) {
              var evaluatedValue = value;
              do {
                  value = evaluatedValue.toString();
                  evaluatedValue = value.replace(regexp, replacementFnc);
              } while (value !== evaluatedValue);
              return evaluatedValue;
          }
          value = iterativeReplace(value, this.variableRegex, variableReplacement);
          value = iterativeReplace(value, this.propRegex, propertyReplacement);
          return new Quoted(this.quote + value + this.quote, value, this.escaped, this.getIndex(), this.fileInfo());
      };
      Quoted.prototype.compare = function (other) {
          // when comparing quoted strings allow the quote to differ
          if (other.type === 'Quoted' && !this.escaped && !other.escaped) {
              return Node.numericCompare(this.value, other.value);
          }
          else {
              return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
          }
      };
      return Quoted;
  }(Node));
  Quoted.prototype.type = 'Quoted';

  var URL = /** @class */ (function (_super) {
      __extends(URL, _super);
      function URL(val, index, currentFileInfo, isEvald) {
          var _this = _super.call(this) || this;
          _this.value = val;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.isEvald = isEvald;
          return _this;
      }
      URL.prototype.accept = function (visitor) {
          this.value = visitor.visit(this.value);
      };
      URL.prototype.genCSS = function (context, output) {
          output.add('url(');
          this.value.genCSS(context, output);
          output.add(')');
      };
      URL.prototype.eval = function (context) {
          var val = this.value.eval(context);
          var rootpath;
          if (!this.isEvald) {
              // Add the rootpath if the URL requires a rewrite
              rootpath = this.fileInfo() && this.fileInfo().rootpath;
              if (typeof rootpath === 'string' &&
                  typeof val.value === 'string' &&
                  context.pathRequiresRewrite(val.value)) {
                  if (!val.quote) {
                      rootpath = escapePath(rootpath);
                  }
                  val.value = context.rewritePath(val.value, rootpath);
              }
              else {
                  val.value = context.normalizePath(val.value);
              }
              // Add url args if enabled
              if (context.urlArgs) {
                  if (!val.value.match(/^\s*data:/)) {
                      var delimiter = val.value.indexOf('?') === -1 ? '?' : '&';
                      var urlArgs = delimiter + context.urlArgs;
                      if (val.value.indexOf('#') !== -1) {
                          val.value = val.value.replace('#', urlArgs + "#");
                      }
                      else {
                          val.value += urlArgs;
                      }
                  }
              }
          }
          return new URL(val, this.getIndex(), this.fileInfo(), true);
      };
      return URL;
  }(Node));
  URL.prototype.type = 'Url';
  function escapePath(path) {
      return path.replace(/[\(\)'"\s]/g, function (match) { return "\\" + match; });
  }

  var Media = /** @class */ (function (_super) {
      __extends(Media, _super);
      function Media(value, features, index, currentFileInfo, visibilityInfo) {
          var _this = _super.call(this) || this;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          var selectors = (new Selector([], null, null, _this._index, _this._fileInfo)).createEmptySelectors();
          _this.features = new Value(features);
          _this.rules = [new Ruleset(selectors, value)];
          _this.rules[0].allowImports = true;
          _this.copyVisibilityInfo(visibilityInfo);
          _this.allowRoot = true;
          _this.setParent(selectors, _this);
          _this.setParent(_this.features, _this);
          _this.setParent(_this.rules, _this);
          return _this;
      }
      Media.prototype.isRulesetLike = function () {
          return true;
      };
      Media.prototype.accept = function (visitor) {
          if (this.features) {
              this.features = visitor.visit(this.features);
          }
          if (this.rules) {
              this.rules = visitor.visitArray(this.rules);
          }
      };
      Media.prototype.genCSS = function (context, output) {
          output.add('@media ', this._fileInfo, this._index);
          this.features.genCSS(context, output);
          this.outputRuleset(context, output, this.rules);
      };
      Media.prototype.eval = function (context) {
          if (!context.mediaBlocks) {
              context.mediaBlocks = [];
              context.mediaPath = [];
          }
          var media = new Media(null, [], this._index, this._fileInfo, this.visibilityInfo());
          if (this.debugInfo) {
              this.rules[0].debugInfo = this.debugInfo;
              media.debugInfo = this.debugInfo;
          }
          media.features = this.features.eval(context);
          context.mediaPath.push(media);
          context.mediaBlocks.push(media);
          this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();
          context.frames.unshift(this.rules[0]);
          media.rules = [this.rules[0].eval(context)];
          context.frames.shift();
          context.mediaPath.pop();
          return context.mediaPath.length === 0 ? media.evalTop(context) :
              media.evalNested(context);
      };
      Media.prototype.evalTop = function (context) {
          var result = this;
          // Render all dependent Media blocks.
          if (context.mediaBlocks.length > 1) {
              var selectors = (new Selector([], null, null, this.getIndex(), this.fileInfo())).createEmptySelectors();
              result = new Ruleset(selectors, context.mediaBlocks);
              result.multiMedia = true;
              result.copyVisibilityInfo(this.visibilityInfo());
              this.setParent(result, this);
          }
          delete context.mediaBlocks;
          delete context.mediaPath;
          return result;
      };
      Media.prototype.evalNested = function (context) {
          var i;
          var value;
          var path = context.mediaPath.concat([this]);
          // Extract the media-query conditions separated with `,` (OR).
          for (i = 0; i < path.length; i++) {
              value = path[i].features instanceof Value ?
                  path[i].features.value : path[i].features;
              path[i] = Array.isArray(value) ? value : [value];
          }
          // Trace all permutations to generate the resulting media-query.
          //
          // (a, b and c) with nested (d, e) ->
          //    a and d
          //    a and e
          //    b and c and d
          //    b and c and e
          this.features = new Value(this.permute(path).map(function (path) {
              path = path.map(function (fragment) { return fragment.toCSS ? fragment : new Anonymous(fragment); });
              for (i = path.length - 1; i > 0; i--) {
                  path.splice(i, 0, new Anonymous('and'));
              }
              return new Expression(path);
          }));
          this.setParent(this.features, this);
          // Fake a tree-node that doesn't output anything.
          return new Ruleset([], []);
      };
      Media.prototype.permute = function (arr) {
          if (arr.length === 0) {
              return [];
          }
          else if (arr.length === 1) {
              return arr[0];
          }
          else {
              var result = [];
              var rest = this.permute(arr.slice(1));
              for (var i_1 = 0; i_1 < rest.length; i_1++) {
                  for (var j = 0; j < arr[0].length; j++) {
                      result.push([arr[0][j]].concat(rest[i_1]));
                  }
              }
              return result;
          }
      };
      Media.prototype.bubbleSelectors = function (selectors) {
          if (!selectors) {
              return;
          }
          this.rules = [new Ruleset(copyArray(selectors), [this.rules[0]])];
          this.setParent(this.rules, this);
      };
      return Media;
  }(AtRule));
  Media.prototype.type = 'Media';

  //
  // CSS @import node
  //
  // The general strategy here is that we don't want to wait
  // for the parsing to be completed, before we start importing
  // the file. That's because in the context of a browser,
  // most of the time will be spent waiting for the server to respond.
  //
  // On creation, we push the import path to our import queue, though
  // `import,push`, we also pass it a callback, which it'll call once
  // the file has been fetched, and parsed.
  //
  var Import = /** @class */ (function (_super) {
      __extends(Import, _super);
      function Import(path, features, options, index, currentFileInfo, visibilityInfo) {
          var _this = _super.call(this) || this;
          _this.options = options;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.path = path;
          _this.features = features;
          _this.allowRoot = true;
          if (_this.options.less !== undefined || _this.options.inline) {
              _this.css = !_this.options.less || _this.options.inline;
          }
          else {
              var pathValue = _this.getPath();
              if (pathValue && /[#\.\&\?]css([\?;].*)?$/.test(pathValue)) {
                  _this.css = true;
              }
          }
          _this.copyVisibilityInfo(visibilityInfo);
          _this.setParent(_this.features, _this);
          _this.setParent(_this.path, _this);
          return _this;
      }
      Import.prototype.accept = function (visitor) {
          if (this.features) {
              this.features = visitor.visit(this.features);
          }
          this.path = visitor.visit(this.path);
          if (!this.options.isPlugin && !this.options.inline && this.root) {
              this.root = visitor.visit(this.root);
          }
      };
      Import.prototype.genCSS = function (context, output) {
          if (this.css && this.path._fileInfo.reference === undefined) {
              output.add('@import ', this._fileInfo, this._index);
              this.path.genCSS(context, output);
              if (this.features) {
                  output.add(' ');
                  this.features.genCSS(context, output);
              }
              output.add(';');
          }
      };
      Import.prototype.getPath = function () {
          return (this.path instanceof URL) ?
              this.path.value.value : this.path.value;
      };
      Import.prototype.isVariableImport = function () {
          var path = this.path;
          if (path instanceof URL) {
              path = path.value;
          }
          if (path instanceof Quoted) {
              return path.containsVariables();
          }
          return true;
      };
      Import.prototype.evalForImport = function (context) {
          var path = this.path;
          if (path instanceof URL) {
              path = path.value;
          }
          return new Import(path.eval(context), this.features, this.options, this._index, this._fileInfo, this.visibilityInfo());
      };
      Import.prototype.evalPath = function (context) {
          var path = this.path.eval(context);
          var fileInfo = this._fileInfo;
          if (!(path instanceof URL)) {
              // Add the rootpath if the URL requires a rewrite
              var pathValue = path.value;
              if (fileInfo &&
                  pathValue &&
                  context.pathRequiresRewrite(pathValue)) {
                  path.value = context.rewritePath(pathValue, fileInfo.rootpath);
              }
              else {
                  path.value = context.normalizePath(path.value);
              }
          }
          return path;
      };
      Import.prototype.eval = function (context) {
          var result = this.doEval(context);
          if (this.options.reference || this.blocksVisibility()) {
              if (result.length || result.length === 0) {
                  result.forEach(function (node) {
                      node.addVisibilityBlock();
                  });
              }
              else {
                  result.addVisibilityBlock();
              }
          }
          return result;
      };
      Import.prototype.doEval = function (context) {
          var ruleset;
          var registry;
          var features = this.features && this.features.eval(context);
          if (this.options.isPlugin) {
              if (this.root && this.root.eval) {
                  try {
                      this.root.eval(context);
                  }
                  catch (e) {
                      e.message = 'Plugin error during evaluation';
                      throw new LessError(e, this.root.imports, this.root.filename);
                  }
              }
              registry = context.frames[0] && context.frames[0].functionRegistry;
              if (registry && this.root && this.root.functions) {
                  registry.addMultiple(this.root.functions);
              }
              return [];
          }
          if (this.skip) {
              if (typeof this.skip === 'function') {
                  this.skip = this.skip();
              }
              if (this.skip) {
                  return [];
              }
          }
          if (this.options.inline) {
              var contents = new Anonymous(this.root, 0, {
                  filename: this.importedFilename,
                  reference: this.path._fileInfo && this.path._fileInfo.reference
              }, true, true);
              return this.features ? new Media([contents], this.features.value) : [contents];
          }
          else if (this.css) {
              var newImport = new Import(this.evalPath(context), features, this.options, this._index);
              if (!newImport.css && this.error) {
                  throw this.error;
              }
              return newImport;
          }
          else {
              ruleset = new Ruleset(null, copyArray(this.root.rules));
              ruleset.evalImports(context);
              return this.features ? new Media(ruleset.rules, this.features.value) : ruleset.rules;
          }
      };
      return Import;
  }(Node));
  Import.prototype.type = 'Import';

  var JsEvalNode = /** @class */ (function (_super) {
      __extends(JsEvalNode, _super);
      function JsEvalNode() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      JsEvalNode.prototype.evaluateJavaScript = function (expression, context) {
          var result;
          var that = this;
          var evalContext = {};
          if (!context.javascriptEnabled) {
              throw { message: 'Inline JavaScript is not enabled. Is it set in your options?',
                  filename: this.fileInfo().filename,
                  index: this.getIndex() };
          }
          expression = expression.replace(/@\{([\w-]+)\}/g, function (_, name) { return that.jsify(new Variable("@" + name, that.getIndex(), that.fileInfo()).eval(context)); });
          try {
              expression = new Function("return (" + expression + ")");
          }
          catch (e) {
              throw { message: "JavaScript evaluation error: " + e.message + " from `" + expression + "`",
                  filename: this.fileInfo().filename,
                  index: this.getIndex() };
          }
          var variables = context.frames[0].variables();
          for (var k in variables) {
              if (variables.hasOwnProperty(k)) {
                  /* jshint loopfunc:true */
                  evalContext[k.slice(1)] = {
                      value: variables[k].value,
                      toJS: function () {
                          return this.value.eval(context).toCSS();
                      }
                  };
              }
          }
          try {
              result = expression.call(evalContext);
          }
          catch (e) {
              throw { message: "JavaScript evaluation error: '" + e.name + ": " + e.message.replace(/["]/g, '\'') + "'",
                  filename: this.fileInfo().filename,
                  index: this.getIndex() };
          }
          return result;
      };
      JsEvalNode.prototype.jsify = function (obj) {
          if (Array.isArray(obj.value) && (obj.value.length > 1)) {
              return "[" + obj.value.map(function (v) { return v.toCSS(); }).join(', ') + "]";
          }
          else {
              return obj.toCSS();
          }
      };
      return JsEvalNode;
  }(Node));

  var JavaScript = /** @class */ (function (_super) {
      __extends(JavaScript, _super);
      function JavaScript(string, escaped, index, currentFileInfo) {
          var _this = _super.call(this) || this;
          _this.escaped = escaped;
          _this.expression = string;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          return _this;
      }
      JavaScript.prototype.eval = function (context) {
          var result = this.evaluateJavaScript(this.expression, context);
          var type = typeof result;
          if (type === 'number' && !isNaN(result)) {
              return new Dimension(result);
          }
          else if (type === 'string') {
              return new Quoted("\"" + result + "\"", result, this.escaped, this._index);
          }
          else if (Array.isArray(result)) {
              return new Anonymous(result.join(', '));
          }
          else {
              return new Anonymous(result);
          }
      };
      return JavaScript;
  }(JsEvalNode));
  JavaScript.prototype.type = 'JavaScript';

  var Assignment = /** @class */ (function (_super) {
      __extends(Assignment, _super);
      function Assignment(key, val) {
          var _this = _super.call(this) || this;
          _this.key = key;
          _this.value = val;
          return _this;
      }
      Assignment.prototype.accept = function (visitor) {
          this.value = visitor.visit(this.value);
      };
      Assignment.prototype.eval = function (context) {
          if (this.value.eval) {
              return new Assignment(this.key, this.value.eval(context));
          }
          return this;
      };
      Assignment.prototype.genCSS = function (context, output) {
          output.add(this.key + "=");
          if (this.value.genCSS) {
              this.value.genCSS(context, output);
          }
          else {
              output.add(this.value);
          }
      };
      return Assignment;
  }(Node));
  Assignment.prototype.type = 'Assignment';

  var Condition = /** @class */ (function (_super) {
      __extends(Condition, _super);
      function Condition(op, l, r, i, negate) {
          var _this = _super.call(this) || this;
          _this.op = op.trim();
          _this.lvalue = l;
          _this.rvalue = r;
          _this._index = i;
          _this.negate = negate;
          return _this;
      }
      Condition.prototype.accept = function (visitor) {
          this.lvalue = visitor.visit(this.lvalue);
          this.rvalue = visitor.visit(this.rvalue);
      };
      Condition.prototype.eval = function (context) {
          var result = (function (op, a, b) {
              switch (op) {
                  case 'and': return a && b;
                  case 'or': return a || b;
                  default:
                      switch (Node.compare(a, b)) {
                          case -1:
                              return op === '<' || op === '=<' || op === '<=';
                          case 0:
                              return op === '=' || op === '>=' || op === '=<' || op === '<=';
                          case 1:
                              return op === '>' || op === '>=';
                          default:
                              return false;
                      }
              }
          })(this.op, this.lvalue.eval(context), this.rvalue.eval(context));
          return this.negate ? !result : result;
      };
      return Condition;
  }(Node));
  Condition.prototype.type = 'Condition';

  var UnicodeDescriptor = /** @class */ (function (_super) {
      __extends(UnicodeDescriptor, _super);
      function UnicodeDescriptor(value) {
          var _this = _super.call(this) || this;
          _this.value = value;
          return _this;
      }
      return UnicodeDescriptor;
  }(Node));
  UnicodeDescriptor.prototype.type = 'UnicodeDescriptor';

  var Negative = /** @class */ (function (_super) {
      __extends(Negative, _super);
      function Negative(node) {
          var _this = _super.call(this) || this;
          _this.value = node;
          return _this;
      }
      Negative.prototype.genCSS = function (context, output) {
          output.add('-');
          this.value.genCSS(context, output);
      };
      Negative.prototype.eval = function (context) {
          if (context.isMathOn()) {
              return (new Operation('*', [new Dimension(-1), this.value])).eval(context);
          }
          return new Negative(this.value.eval(context));
      };
      return Negative;
  }(Node));
  Negative.prototype.type = 'Negative';

  var Extend = /** @class */ (function (_super) {
      __extends(Extend, _super);
      function Extend(selector, option, index, currentFileInfo, visibilityInfo) {
          var _this = _super.call(this) || this;
          _this.selector = selector;
          _this.option = option;
          _this.object_id = Extend.next_id++;
          _this.parent_ids = [_this.object_id];
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.copyVisibilityInfo(visibilityInfo);
          _this.allowRoot = true;
          switch (option) {
              case 'all':
                  _this.allowBefore = true;
                  _this.allowAfter = true;
                  break;
              default:
                  _this.allowBefore = false;
                  _this.allowAfter = false;
                  break;
          }
          _this.setParent(_this.selector, _this);
          return _this;
      }
      Extend.prototype.accept = function (visitor) {
          this.selector = visitor.visit(this.selector);
      };
      Extend.prototype.eval = function (context) {
          return new Extend(this.selector.eval(context), this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());
      };
      Extend.prototype.clone = function (context) {
          return new Extend(this.selector, this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());
      };
      // it concatenates (joins) all selectors in selector array
      Extend.prototype.findSelfSelectors = function (selectors) {
          var selfElements = [];
          var i;
          var selectorElements;
          for (i = 0; i < selectors.length; i++) {
              selectorElements = selectors[i].elements;
              // duplicate the logic in genCSS function inside the selector node.
              // future TODO - move both logics into the selector joiner visitor
              if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === '') {
                  selectorElements[0].combinator.value = ' ';
              }
              selfElements = selfElements.concat(selectors[i].elements);
          }
          this.selfSelectors = [new Selector(selfElements)];
          this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());
      };
      return Extend;
  }(Node));
  Extend.next_id = 0;
  Extend.prototype.type = 'Extend';

  var VariableCall = /** @class */ (function (_super) {
      __extends(VariableCall, _super);
      function VariableCall(variable, index, currentFileInfo) {
          var _this = _super.call(this) || this;
          _this.variable = variable;
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.allowRoot = true;
          return _this;
      }
      VariableCall.prototype.eval = function (context) {
          var rules;
          var detachedRuleset = new Variable(this.variable, this.getIndex(), this.fileInfo()).eval(context);
          var error = new LessError({ message: "Could not evaluate variable call " + this.variable });
          if (!detachedRuleset.ruleset) {
              if (detachedRuleset.rules) {
                  rules = detachedRuleset;
              }
              else if (Array.isArray(detachedRuleset)) {
                  rules = new Ruleset('', detachedRuleset);
              }
              else if (Array.isArray(detachedRuleset.value)) {
                  rules = new Ruleset('', detachedRuleset.value);
              }
              else {
                  throw error;
              }
              detachedRuleset = new DetachedRuleset(rules);
          }
          if (detachedRuleset.ruleset) {
              return detachedRuleset.callEval(context);
          }
          throw error;
      };
      return VariableCall;
  }(Node));
  VariableCall.prototype.type = 'VariableCall';

  var NamespaceValue = /** @class */ (function (_super) {
      __extends(NamespaceValue, _super);
      function NamespaceValue(ruleCall, lookups, index, fileInfo) {
          var _this = _super.call(this) || this;
          _this.value = ruleCall;
          _this.lookups = lookups;
          _this._index = index;
          _this._fileInfo = fileInfo;
          return _this;
      }
      NamespaceValue.prototype.eval = function (context) {
          var i;
          var name;
          var rules = this.value.eval(context);
          for (i = 0; i < this.lookups.length; i++) {
              name = this.lookups[i];
              /**
               * Eval'd DRs return rulesets.
               * Eval'd mixins return rules, so let's make a ruleset if we need it.
               * We need to do this because of late parsing of values
               */
              if (Array.isArray(rules)) {
                  rules = new Ruleset([new Selector()], rules);
              }
              if (name === '') {
                  rules = rules.lastDeclaration();
              }
              else if (name.charAt(0) === '@') {
                  if (name.charAt(1) === '@') {
                      name = "@" + new Variable(name.substr(1)).eval(context).value;
                  }
                  if (rules.variables) {
                      rules = rules.variable(name);
                  }
                  if (!rules) {
                      throw { type: 'Name',
                          message: "variable " + name + " not found",
                          filename: this.fileInfo().filename,
                          index: this.getIndex() };
                  }
              }
              else {
                  if (name.substring(0, 2) === '$@') {
                      name = "$" + new Variable(name.substr(1)).eval(context).value;
                  }
                  else {
                      name = name.charAt(0) === '$' ? name : "$" + name;
                  }
                  if (rules.properties) {
                      rules = rules.property(name);
                  }
                  if (!rules) {
                      throw { type: 'Name',
                          message: "property \"" + name.substr(1) + "\" not found",
                          filename: this.fileInfo().filename,
                          index: this.getIndex() };
                  }
                  // Properties are an array of values, since a ruleset can have multiple props.
                  // We pick the last one (the "cascaded" value)
                  rules = rules[rules.length - 1];
              }
              if (rules.value) {
                  rules = rules.eval(context).value;
              }
              if (rules.ruleset) {
                  rules = rules.ruleset.eval(context);
              }
          }
          return rules;
      };
      return NamespaceValue;
  }(Node));
  NamespaceValue.prototype.type = 'NamespaceValue';

  var Definition = /** @class */ (function (_super) {
      __extends(Definition, _super);
      function Definition(name, params, rules, condition, variadic, frames, visibilityInfo) {
          var _this = _super.call(this) || this;
          _this.name = name || 'anonymous mixin';
          _this.selectors = [new Selector([new Element(null, name, false, _this._index, _this._fileInfo)])];
          _this.params = params;
          _this.condition = condition;
          _this.variadic = variadic;
          _this.arity = params.length;
          _this.rules = rules;
          _this._lookups = {};
          var optionalParameters = [];
          _this.required = params.reduce(function (count, p) {
              if (!p.name || (p.name && !p.value)) {
                  return count + 1;
              }
              else {
                  optionalParameters.push(p.name);
                  return count;
              }
          }, 0);
          _this.optionalParameters = optionalParameters;
          _this.frames = frames;
          _this.copyVisibilityInfo(visibilityInfo);
          _this.allowRoot = true;
          return _this;
      }
      Definition.prototype.accept = function (visitor) {
          if (this.params && this.params.length) {
              this.params = visitor.visitArray(this.params);
          }
          this.rules = visitor.visitArray(this.rules);
          if (this.condition) {
              this.condition = visitor.visit(this.condition);
          }
      };
      Definition.prototype.evalParams = function (context, mixinEnv, args, evaldArguments) {
          /* jshint boss:true */
          var frame = new Ruleset(null, null);
          var varargs;
          var arg;
          var params = copyArray(this.params);
          var i;
          var j;
          var val;
          var name;
          var isNamedFound;
          var argIndex;
          var argsLength = 0;
          if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {
              frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();
          }
          mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames));
          if (args) {
              args = copyArray(args);
              argsLength = args.length;
              for (i = 0; i < argsLength; i++) {
                  arg = args[i];
                  if (name = (arg && arg.name)) {
                      isNamedFound = false;
                      for (j = 0; j < params.length; j++) {
                          if (!evaldArguments[j] && name === params[j].name) {
                              evaldArguments[j] = arg.value.eval(context);
                              frame.prependRule(new Declaration(name, arg.value.eval(context)));
                              isNamedFound = true;
                              break;
                          }
                      }
                      if (isNamedFound) {
                          args.splice(i, 1);
                          i--;
                          continue;
                      }
                      else {
                          throw { type: 'Runtime', message: "Named argument for " + this.name + " " + args[i].name + " not found" };
                      }
                  }
              }
          }
          argIndex = 0;
          for (i = 0; i < params.length; i++) {
              if (evaldArguments[i]) {
                  continue;
              }
              arg = args && args[argIndex];
              if (name = params[i].name) {
                  if (params[i].variadic) {
                      varargs = [];
                      for (j = argIndex; j < argsLength; j++) {
                          varargs.push(args[j].value.eval(context));
                      }
                      frame.prependRule(new Declaration(name, new Expression(varargs).eval(context)));
                  }
                  else {
                      val = arg && arg.value;
                      if (val) {
                          // This was a mixin call, pass in a detached ruleset of it's eval'd rules
                          if (Array.isArray(val)) {
                              val = new DetachedRuleset(new Ruleset('', val));
                          }
                          else {
                              val = val.eval(context);
                          }
                      }
                      else if (params[i].value) {
                          val = params[i].value.eval(mixinEnv);
                          frame.resetCache();
                      }
                      else {
                          throw { type: 'Runtime', message: "wrong number of arguments for " + this.name + " (" + argsLength + " for " + this.arity + ")" };
                      }
                      frame.prependRule(new Declaration(name, val));
                      evaldArguments[i] = val;
                  }
              }
              if (params[i].variadic && args) {
                  for (j = argIndex; j < argsLength; j++) {
                      evaldArguments[j] = args[j].value.eval(context);
                  }
              }
              argIndex++;
          }
          return frame;
      };
      Definition.prototype.makeImportant = function () {
          var rules = !this.rules ? this.rules : this.rules.map(function (r) {
              if (r.makeImportant) {
                  return r.makeImportant(true);
              }
              else {
                  return r;
              }
          });
          var result = new Definition(this.name, this.params, rules, this.condition, this.variadic, this.frames);
          return result;
      };
      Definition.prototype.eval = function (context) {
          return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || copyArray(context.frames));
      };
      Definition.prototype.evalCall = function (context, args, important) {
          var _arguments = [];
          var mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames;
          var frame = this.evalParams(context, new contexts.Eval(context, mixinFrames), args, _arguments);
          var rules;
          var ruleset;
          frame.prependRule(new Declaration('@arguments', new Expression(_arguments).eval(context)));
          rules = copyArray(this.rules);
          ruleset = new Ruleset(null, rules);
          ruleset.originalRuleset = this;
          ruleset = ruleset.eval(new contexts.Eval(context, [this, frame].concat(mixinFrames)));
          if (important) {
              ruleset = ruleset.makeImportant();
          }
          return ruleset;
      };
      Definition.prototype.matchCondition = function (args, context) {
          if (this.condition && !this.condition.eval(new contexts.Eval(context, [this.evalParams(context, /* the parameter variables */ new contexts.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])]
              .concat(this.frames || []) // the parent namespace/mixin frames
              .concat(context.frames)))) { // the current environment frames
              return false;
          }
          return true;
      };
      Definition.prototype.matchArgs = function (args, context) {
          var allArgsCnt = (args && args.length) || 0;
          var len;
          var optionalParameters = this.optionalParameters;
          var requiredArgsCnt = !args ? 0 : args.reduce(function (count, p) {
              if (optionalParameters.indexOf(p.name) < 0) {
                  return count + 1;
              }
              else {
                  return count;
              }
          }, 0);
          if (!this.variadic) {
              if (requiredArgsCnt < this.required) {
                  return false;
              }
              if (allArgsCnt > this.params.length) {
                  return false;
              }
          }
          else {
              if (requiredArgsCnt < (this.required - 1)) {
                  return false;
              }
          }
          // check patterns
          len = Math.min(requiredArgsCnt, this.arity);
          for (var i_1 = 0; i_1 < len; i_1++) {
              if (!this.params[i_1].name && !this.params[i_1].variadic) {
                  if (args[i_1].value.eval(context).toCSS() != this.params[i_1].value.eval(context).toCSS()) {
                      return false;
                  }
              }
          }
          return true;
      };
      return Definition;
  }(Ruleset));
  Definition.prototype.type = 'MixinDefinition';
  Definition.prototype.evalFirst = true;

  var MixinCall = /** @class */ (function (_super) {
      __extends(MixinCall, _super);
      function MixinCall(elements, args, index, currentFileInfo, important) {
          var _this = _super.call(this) || this;
          _this.selector = new Selector(elements);
          _this.arguments = args || [];
          _this._index = index;
          _this._fileInfo = currentFileInfo;
          _this.important = important;
          _this.allowRoot = true;
          _this.setParent(_this.selector, _this);
          return _this;
      }
      MixinCall.prototype.accept = function (visitor) {
          if (this.selector) {
              this.selector = visitor.visit(this.selector);
          }
          if (this.arguments.length) {
              this.arguments = visitor.visitArray(this.arguments);
          }
      };
      MixinCall.prototype.eval = function (context) {
          var mixins;
          var mixin;
          var mixinPath;
          var args = [];
          var arg;
          var argValue;
          var rules = [];
          var match = false;
          var i;
          var m;
          var f;
          var isRecursive;
          var isOneFound;
          var candidates = [];
          var candidate;
          var conditionResult = [];
          var defaultResult;
          var defFalseEitherCase = -1;
          var defNone = 0;
          var defTrue = 1;
          var defFalse = 2;
          var count;
          var originalRuleset;
          var noArgumentsFilter;
          this.selector = this.selector.eval(context);
          function calcDefGroup(mixin, mixinPath) {
              var f;
              var p;
              var namespace;
              for (f = 0; f < 2; f++) {
                  conditionResult[f] = true;
                  defaultFunc.value(f);
                  for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {
                      namespace = mixinPath[p];
                      if (namespace.matchCondition) {
                          conditionResult[f] = conditionResult[f] && namespace.matchCondition(null, context);
                      }
                  }
                  if (mixin.matchCondition) {
                      conditionResult[f] = conditionResult[f] && mixin.matchCondition(args, context);
                  }
              }
              if (conditionResult[0] || conditionResult[1]) {
                  if (conditionResult[0] != conditionResult[1]) {
                      return conditionResult[1] ?
                          defTrue : defFalse;
                  }
                  return defNone;
              }
              return defFalseEitherCase;
          }
          for (i = 0; i < this.arguments.length; i++) {
              arg = this.arguments[i];
              argValue = arg.value.eval(context);
              if (arg.expand && Array.isArray(argValue.value)) {
                  argValue = argValue.value;
                  for (m = 0; m < argValue.length; m++) {
                      args.push({ value: argValue[m] });
                  }
              }
              else {
                  args.push({ name: arg.name, value: argValue });
              }
          }
          noArgumentsFilter = function (rule) { return rule.matchArgs(null, context); };
          for (i = 0; i < context.frames.length; i++) {
              if ((mixins = context.frames[i].find(this.selector, null, noArgumentsFilter)).length > 0) {
                  isOneFound = true;
                  // To make `default()` function independent of definition order we have two "subpasses" here.
                  // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),
                  // and build candidate list with corresponding flags. Then, when we know all possible matches,
                  // we make a final decision.
                  for (m = 0; m < mixins.length; m++) {
                      mixin = mixins[m].rule;
                      mixinPath = mixins[m].path;
                      isRecursive = false;
                      for (f = 0; f < context.frames.length; f++) {
                          if ((!(mixin instanceof Definition)) && mixin === (context.frames[f].originalRuleset || context.frames[f])) {
                              isRecursive = true;
                              break;
                          }
                      }
                      if (isRecursive) {
                          continue;
                      }
                      if (mixin.matchArgs(args, context)) {
                          candidate = { mixin: mixin, group: calcDefGroup(mixin, mixinPath) };
                          if (candidate.group !== defFalseEitherCase) {
                              candidates.push(candidate);
                          }
                          match = true;
                      }
                  }
                  defaultFunc.reset();
                  count = [0, 0, 0];
                  for (m = 0; m < candidates.length; m++) {
                      count[candidates[m].group]++;
                  }
                  if (count[defNone] > 0) {
                      defaultResult = defFalse;
                  }
                  else {
                      defaultResult = defTrue;
                      if ((count[defTrue] + count[defFalse]) > 1) {
                          throw { type: 'Runtime',
                              message: "Ambiguous use of `default()` found when matching for `" + this.format(args) + "`",
                              index: this.getIndex(), filename: this.fileInfo().filename };
                      }
                  }
                  for (m = 0; m < candidates.length; m++) {
                      candidate = candidates[m].group;
                      if ((candidate === defNone) || (candidate === defaultResult)) {
                          try {
                              mixin = candidates[m].mixin;
                              if (!(mixin instanceof Definition)) {
                                  originalRuleset = mixin.originalRuleset || mixin;
                                  mixin = new Definition('', [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());
                                  mixin.originalRuleset = originalRuleset;
                              }
                              var newRules = mixin.evalCall(context, args, this.important).rules;
                              this._setVisibilityToReplacement(newRules);
                              Array.prototype.push.apply(rules, newRules);
                          }
                          catch (e) {
                              throw { message: e.message, index: this.getIndex(), filename: this.fileInfo().filename, stack: e.stack };
                          }
                      }
                  }
                  if (match) {
                      return rules;
                  }
              }
          }
          if (isOneFound) {
              throw { type: 'Runtime',
                  message: "No matching definition was found for `" + this.format(args) + "`",
                  index: this.getIndex(), filename: this.fileInfo().filename };
          }
          else {
              throw { type: 'Name',
                  message: this.selector.toCSS().trim() + " is undefined",
                  index: this.getIndex(), filename: this.fileInfo().filename };
          }
      };
      MixinCall.prototype._setVisibilityToReplacement = function (replacement) {
          var i;
          var rule;
          if (this.blocksVisibility()) {
              for (i = 0; i < replacement.length; i++) {
                  rule = replacement[i];
                  rule.addVisibilityBlock();
              }
          }
      };
      MixinCall.prototype.format = function (args) {
          return this.selector.toCSS().trim() + "(" + (args ? args.map(function (a) {
              var argValue = '';
              if (a.name) {
                  argValue += a.name + ":";
              }
              if (a.value.toCSS) {
                  argValue += a.value.toCSS();
              }
              else {
                  argValue += '???';
              }
              return argValue;
          }).join(', ') : '') + ")";
      };
      return MixinCall;
  }(Node));
  MixinCall.prototype.type = 'MixinCall';

  var tree = {
      Node: Node, Color: Color, AtRule: AtRule, DetachedRuleset: DetachedRuleset, Operation: Operation,
      Dimension: Dimension, Unit: Unit, Keyword: Keyword, Variable: Variable, Property: Property,
      Ruleset: Ruleset, Element: Element, Attribute: Attribute, Combinator: Combinator, Selector: Selector,
      Quoted: Quoted, Expression: Expression, Declaration: Declaration, Call: Call, URL: URL, Import: Import,
      Comment: Comment, Anonymous: Anonymous, Value: Value, JavaScript: JavaScript, Assignment: Assignment,
      Condition: Condition, Paren: Paren, Media: Media, UnicodeDescriptor: UnicodeDescriptor, Negative: Negative,
      Extend: Extend, VariableCall: VariableCall, NamespaceValue: NamespaceValue,
      mixin: {
          Call: MixinCall,
          Definition: Definition
      }
  };

  var logger = {
      error: function (msg) {
          this._fireEvent('error', msg);
      },
      warn: function (msg) {
          this._fireEvent('warn', msg);
      },
      info: function (msg) {
          this._fireEvent('info', msg);
      },
      debug: function (msg) {
          this._fireEvent('debug', msg);
      },
      addListener: function (listener) {
          this._listeners.push(listener);
      },
      removeListener: function (listener) {
          for (var i_1 = 0; i_1 < this._listeners.length; i_1++) {
              if (this._listeners[i_1] === listener) {
                  this._listeners.splice(i_1, 1);
                  return;
              }
          }
      },
      _fireEvent: function (type, msg) {
          for (var i_2 = 0; i_2 < this._listeners.length; i_2++) {
              var logFunction = this._listeners[i_2][type];
              if (logFunction) {
                  logFunction(msg);
              }
          }
      },
      _listeners: []
  };

  /**
   * @todo Document why this abstraction exists, and the relationship between
   *       environment, file managers, and plugin manager
   */
  var environment = /** @class */ (function () {
      function environment(externalEnvironment, fileManagers) {
          this.fileManagers = fileManagers || [];
          externalEnvironment = externalEnvironment || {};
          var optionalFunctions = ['encodeBase64', 'mimeLookup', 'charsetLookup', 'getSourceMapGenerator'];
          var requiredFunctions = [];
          var functions = requiredFunctions.concat(optionalFunctions);
          for (var i_1 = 0; i_1 < functions.length; i_1++) {
              var propName = functions[i_1];
              var environmentFunc = externalEnvironment[propName];
              if (environmentFunc) {
                  this[propName] = environmentFunc.bind(externalEnvironment);
              }
              else if (i_1 < requiredFunctions.length) {
                  this.warn("missing required function in environment - " + propName);
              }
          }
      }
      environment.prototype.getFileManager = function (filename, currentDirectory, options, environment, isSync) {
          if (!filename) {
              logger.warn('getFileManager called with no filename.. Please report this issue. continuing.');
          }
          if (currentDirectory == null) {
              logger.warn('getFileManager called with null directory.. Please report this issue. continuing.');
          }
          var fileManagers = this.fileManagers;
          if (options.pluginManager) {
              fileManagers = [].concat(fileManagers).concat(options.pluginManager.getFileManagers());
          }
          for (var i_2 = fileManagers.length - 1; i_2 >= 0; i_2--) {
              var fileManager = fileManagers[i_2];
              if (fileManager[isSync ? 'supportsSync' : 'supports'](filename, currentDirectory, options, environment)) {
                  return fileManager;
              }
          }
          return null;
      };
      environment.prototype.addFileManager = function (fileManager) {
          this.fileManagers.push(fileManager);
      };
      environment.prototype.clearFileManagers = function () {
          this.fileManagers = [];
      };
      return environment;
  }());

  var AbstractFileManager = /** @class */ (function () {
      function AbstractFileManager() {
      }
      AbstractFileManager.prototype.getPath = function (filename) {
          var j = filename.lastIndexOf('?');
          if (j > 0) {
              filename = filename.slice(0, j);
          }
          j = filename.lastIndexOf('/');
          if (j < 0) {
              j = filename.lastIndexOf('\\');
          }
          if (j < 0) {
              return '';
          }
          return filename.slice(0, j + 1);
      };
      AbstractFileManager.prototype.tryAppendExtension = function (path, ext) {
          return /(\.[a-z]*$)|([\?;].*)$/.test(path) ? path : path + ext;
      };
      AbstractFileManager.prototype.tryAppendLessExtension = function (path) {
          return this.tryAppendExtension(path, '.less');
      };
      AbstractFileManager.prototype.supportsSync = function () { return false; };
      AbstractFileManager.prototype.alwaysMakePathsAbsolute = function () { return false; };
      AbstractFileManager.prototype.isPathAbsolute = function (filename) {
          return (/^(?:[a-z-]+:|\/|\\|#)/i).test(filename);
      };
      // TODO: pull out / replace?
      AbstractFileManager.prototype.join = function (basePath, laterPath) {
          if (!basePath) {
              return laterPath;
          }
          return basePath + laterPath;
      };
      AbstractFileManager.prototype.pathDiff = function (url, baseUrl) {
          // diff between two paths to create a relative path
          var urlParts = this.extractUrlParts(url);
          var baseUrlParts = this.extractUrlParts(baseUrl);
          var i;
          var max;
          var urlDirectories;
          var baseUrlDirectories;
          var diff = '';
          if (urlParts.hostPart !== baseUrlParts.hostPart) {
              return '';
          }
          max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);
          for (i = 0; i < max; i++) {
              if (baseUrlParts.directories[i] !== urlParts.directories[i]) {
                  break;
              }
          }
          baseUrlDirectories = baseUrlParts.directories.slice(i);
          urlDirectories = urlParts.directories.slice(i);
          for (i = 0; i < baseUrlDirectories.length - 1; i++) {
              diff += '../';
          }
          for (i = 0; i < urlDirectories.length - 1; i++) {
              diff += urlDirectories[i] + "/";
          }
          return diff;
      };
      // helper function, not part of API
      AbstractFileManager.prototype.extractUrlParts = function (url, baseUrl) {
          // urlParts[1] = protocol://hostname/ OR /
          // urlParts[2] = / if path relative to host base
          // urlParts[3] = directories
          // urlParts[4] = filename
          // urlParts[5] = parameters
          var urlPartsRegex = /^((?:[a-z-]+:)?\/{2}(?:[^\/\?#]*\/)|([\/\\]))?((?:[^\/\\\?#]*[\/\\])*)([^\/\\\?#]*)([#\?].*)?$/i;
          var urlParts = url.match(urlPartsRegex);
          var returner = {};
          var rawDirectories = [];
          var directories = [];
          var i;
          var baseUrlParts;
          if (!urlParts) {
              throw new Error("Could not parse sheet href - '" + url + "'");
          }
          // Stylesheets in IE don't always return the full path
          if (baseUrl && (!urlParts[1] || urlParts[2])) {
              baseUrlParts = baseUrl.match(urlPartsRegex);
              if (!baseUrlParts) {
                  throw new Error("Could not parse page url - '" + baseUrl + "'");
              }
              urlParts[1] = urlParts[1] || baseUrlParts[1] || '';
              if (!urlParts[2]) {
                  urlParts[3] = baseUrlParts[3] + urlParts[3];
              }
          }
          if (urlParts[3]) {
              rawDirectories = urlParts[3].replace(/\\/g, '/').split('/');
              // collapse '..' and skip '.'
              for (i = 0; i < rawDirectories.length; i++) {
                  if (rawDirectories[i] === '..') {
                      directories.pop();
                  }
                  else if (rawDirectories[i] !== '.') {
                      directories.push(rawDirectories[i]);
                  }
              }
          }
          returner.hostPart = urlParts[1];
          returner.directories = directories;
          returner.rawPath = (urlParts[1] || '') + rawDirectories.join('/');
          returner.path = (urlParts[1] || '') + directories.join('/');
          returner.filename = urlParts[4];
          returner.fileUrl = returner.path + (urlParts[4] || '');
          returner.url = returner.fileUrl + (urlParts[5] || '');
          return returner;
      };
      return AbstractFileManager;
  }());

  var AbstractPluginLoader = /** @class */ (function () {
      function AbstractPluginLoader() {
          // Implemented by Node.js plugin loader
          this.require = function () { return null; };
      }
      AbstractPluginLoader.prototype.evalPlugin = function (contents, context, imports, pluginOptions, fileInfo) {
          var loader;
          var registry;
          var pluginObj;
          var localModule;
          var pluginManager;
          var filename;
          var result;
          pluginManager = context.pluginManager;
          if (fileInfo) {
              if (typeof fileInfo === 'string') {
                  filename = fileInfo;
              }
              else {
                  filename = fileInfo.filename;
              }
          }
          var shortname = (new this.less.FileManager()).extractUrlParts(filename).filename;
          if (filename) {
              pluginObj = pluginManager.get(filename);
              if (pluginObj) {
                  result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
                  if (result) {
                      return result;
                  }
                  try {
                      if (pluginObj.use) {
                          pluginObj.use.call(this.context, pluginObj);
                      }
                  }
                  catch (e) {
                      e.message = e.message || 'Error during @plugin call';
                      return new LessError(e, imports, filename);
                  }
                  return pluginObj;
              }
          }
          localModule = {
              exports: {},
              pluginManager: pluginManager,
              fileInfo: fileInfo
          };
          registry = functionRegistry.create();
          var registerPlugin = function (obj) {
              pluginObj = obj;
          };
          try {
              loader = new Function('module', 'require', 'registerPlugin', 'functions', 'tree', 'less', 'fileInfo', contents);
              loader(localModule, this.require(filename), registerPlugin, registry, this.less.tree, this.less, fileInfo);
          }
          catch (e) {
              return new LessError(e, imports, filename);
          }
          if (!pluginObj) {
              pluginObj = localModule.exports;
          }
          pluginObj = this.validatePlugin(pluginObj, filename, shortname);
          if (pluginObj instanceof LessError) {
              return pluginObj;
          }
          if (pluginObj) {
              pluginObj.imports = imports;
              pluginObj.filename = filename;
              // For < 3.x (or unspecified minVersion) - setOptions() before install()
              if (!pluginObj.minVersion || this.compareVersion('3.0.0', pluginObj.minVersion) < 0) {
                  result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
                  if (result) {
                      return result;
                  }
              }
              // Run on first load
              pluginManager.addPlugin(pluginObj, fileInfo.filename, registry);
              pluginObj.functions = registry.getLocalFunctions();
              // Need to call setOptions again because the pluginObj might have functions
              result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
              if (result) {
                  return result;
              }
              // Run every @plugin call
              try {
                  if (pluginObj.use) {
                      pluginObj.use.call(this.context, pluginObj);
                  }
              }
              catch (e) {
                  e.message = e.message || 'Error during @plugin call';
                  return new LessError(e, imports, filename);
              }
          }
          else {
              return new LessError({ message: 'Not a valid plugin' }, imports, filename);
          }
          return pluginObj;
      };
      AbstractPluginLoader.prototype.trySetOptions = function (plugin, filename, name, options) {
          if (options && !plugin.setOptions) {
              return new LessError({
                  message: "Options have been provided but the plugin " + name + " does not support any options."
              });
          }
          try {
              plugin.setOptions && plugin.setOptions(options);
          }
          catch (e) {
              return new LessError(e);
          }
      };
      AbstractPluginLoader.prototype.validatePlugin = function (plugin, filename, name) {
          if (plugin) {
              // support plugins being a function
              // so that the plugin can be more usable programmatically
              if (typeof plugin === 'function') {
                  plugin = new plugin();
              }
              if (plugin.minVersion) {
                  if (this.compareVersion(plugin.minVersion, this.less.version) < 0) {
                      return new LessError({
                          message: "Plugin " + name + " requires version " + this.versionToString(plugin.minVersion)
                      });
                  }
              }
              return plugin;
          }
          return null;
      };
      AbstractPluginLoader.prototype.compareVersion = function (aVersion, bVersion) {
          if (typeof aVersion === 'string') {
              aVersion = aVersion.match(/^(\d+)\.?(\d+)?\.?(\d+)?/);
              aVersion.shift();
          }
          for (var i_1 = 0; i_1 < aVersion.length; i_1++) {
              if (aVersion[i_1] !== bVersion[i_1]) {
                  return parseInt(aVersion[i_1]) > parseInt(bVersion[i_1]) ? -1 : 1;
              }
          }
          return 0;
      };
      AbstractPluginLoader.prototype.versionToString = function (version) {
          var versionString = '';
          for (var i_2 = 0; i_2 < version.length; i_2++) {
              versionString += (versionString ? '.' : '') + version[i_2];
          }
          return versionString;
      };
      AbstractPluginLoader.prototype.printUsage = function (plugins) {
          for (var i_3 = 0; i_3 < plugins.length; i_3++) {
              var plugin = plugins[i_3];
              if (plugin.printUsage) {
                  plugin.printUsage();
              }
          }
      };
      return AbstractPluginLoader;
  }());

  var _visitArgs = { visitDeeper: true };
  var _hasIndexed = false;
  function _noop(node) {
      return node;
  }
  function indexNodeTypes(parent, ticker) {
      // add .typeIndex to tree node types for lookup table
      var key;
      var child;
      for (key in parent) {
          /* eslint guard-for-in: 0 */
          child = parent[key];
          switch (typeof child) {
              case 'function':
                  // ignore bound functions directly on tree which do not have a prototype
                  // or aren't nodes
                  if (child.prototype && child.prototype.type) {
                      child.prototype.typeIndex = ticker++;
                  }
                  break;
              case 'object':
                  ticker = indexNodeTypes(child, ticker);
                  break;
          }
      }
      return ticker;
  }
  var Visitor = /** @class */ (function () {
      function Visitor(implementation) {
          this._implementation = implementation;
          this._visitInCache = {};
          this._visitOutCache = {};
          if (!_hasIndexed) {
              indexNodeTypes(tree, 1);
              _hasIndexed = true;
          }
      }
      Visitor.prototype.visit = function (node) {
          if (!node) {
              return node;
          }
          var nodeTypeIndex = node.typeIndex;
          if (!nodeTypeIndex) {
              // MixinCall args aren't a node type?
              if (node.value && node.value.typeIndex) {
                  this.visit(node.value);
              }
              return node;
          }
          var impl = this._implementation;
          var func = this._visitInCache[nodeTypeIndex];
          var funcOut = this._visitOutCache[nodeTypeIndex];
          var visitArgs = _visitArgs;
          var fnName;
          visitArgs.visitDeeper = true;
          if (!func) {
              fnName = "visit" + node.type;
              func = impl[fnName] || _noop;
              funcOut = impl[fnName + "Out"] || _noop;
              this._visitInCache[nodeTypeIndex] = func;
              this._visitOutCache[nodeTypeIndex] = funcOut;
          }
          if (func !== _noop) {
              var newNode = func.call(impl, node, visitArgs);
              if (node && impl.isReplacing) {
                  node = newNode;
              }
          }
          if (visitArgs.visitDeeper && node) {
              if (node.length) {
                  for (var i = 0, cnt = node.length; i < cnt; i++) {
                      if (node[i].accept) {
                          node[i].accept(this);
                      }
                  }
              }
              else if (node.accept) {
                  node.accept(this);
              }
          }
          if (funcOut != _noop) {
              funcOut.call(impl, node);
          }
          return node;
      };
      Visitor.prototype.visitArray = function (nodes, nonReplacing) {
          if (!nodes) {
              return nodes;
          }
          var cnt = nodes.length;
          var i;
          // Non-replacing
          if (nonReplacing || !this._implementation.isReplacing) {
              for (i = 0; i < cnt; i++) {
                  this.visit(nodes[i]);
              }
              return nodes;
          }
          // Replacing
          var out = [];
          for (i = 0; i < cnt; i++) {
              var evald = this.visit(nodes[i]);
              if (evald === undefined) {
                  continue;
              }
              if (!evald.splice) {
                  out.push(evald);
              }
              else if (evald.length) {
                  this.flatten(evald, out);
              }
          }
          return out;
      };
      Visitor.prototype.flatten = function (arr, out) {
          if (!out) {
              out = [];
          }
          var cnt;
          var i;
          var item;
          var nestedCnt;
          var j;
          var nestedItem;
          for (i = 0, cnt = arr.length; i < cnt; i++) {
              item = arr[i];
              if (item === undefined) {
                  continue;
              }
              if (!item.splice) {
                  out.push(item);
                  continue;
              }
              for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {
                  nestedItem = item[j];
                  if (nestedItem === undefined) {
                      continue;
                  }
                  if (!nestedItem.splice) {
                      out.push(nestedItem);
                  }
                  else if (nestedItem.length) {
                      this.flatten(nestedItem, out);
                  }
              }
          }
          return out;
      };
      return Visitor;
  }());

  var ImportSequencer = /** @class */ (function () {
      function ImportSequencer(onSequencerEmpty) {
          this.imports = [];
          this.variableImports = [];
          this._onSequencerEmpty = onSequencerEmpty;
          this._currentDepth = 0;
      }
      ImportSequencer.prototype.addImport = function (callback) {
          var importSequencer = this;
          var importItem = {
              callback: callback,
              args: null,
              isReady: false
          };
          this.imports.push(importItem);
          return function () {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              importItem.args = Array.prototype.slice.call(args, 0);
              importItem.isReady = true;
              importSequencer.tryRun();
          };
      };
      ImportSequencer.prototype.addVariableImport = function (callback) {
          this.variableImports.push(callback);
      };
      ImportSequencer.prototype.tryRun = function () {
          this._currentDepth++;
          try {
              while (true) {
                  while (this.imports.length > 0) {
                      var importItem = this.imports[0];
                      if (!importItem.isReady) {
                          return;
                      }
                      this.imports = this.imports.slice(1);
                      importItem.callback.apply(null, importItem.args);
                  }
                  if (this.variableImports.length === 0) {
                      break;
                  }
                  var variableImport = this.variableImports[0];
                  this.variableImports = this.variableImports.slice(1);
                  variableImport();
              }
          }
          finally {
              this._currentDepth--;
          }
          if (this._currentDepth === 0 && this._onSequencerEmpty) {
              this._onSequencerEmpty();
          }
      };
      return ImportSequencer;
  }());

  var ImportVisitor = function (importer, finish) {
      this._visitor = new Visitor(this);
      this._importer = importer;
      this._finish = finish;
      this.context = new contexts.Eval();
      this.importCount = 0;
      this.onceFileDetectionMap = {};
      this.recursionDetector = {};
      this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this));
  };
  ImportVisitor.prototype = {
      isReplacing: false,
      run: function (root) {
          try {
              // process the contents
              this._visitor.visit(root);
          }
          catch (e) {
              this.error = e;
          }
          this.isFinished = true;
          this._sequencer.tryRun();
      },
      _onSequencerEmpty: function () {
          if (!this.isFinished) {
              return;
          }
          this._finish(this.error);
      },
      visitImport: function (importNode, visitArgs) {
          var inlineCSS = importNode.options.inline;
          if (!importNode.css || inlineCSS) {
              var context = new contexts.Eval(this.context, copyArray(this.context.frames));
              var importParent = context.frames[0];
              this.importCount++;
              if (importNode.isVariableImport()) {
                  this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));
              }
              else {
                  this.processImportNode(importNode, context, importParent);
              }
          }
          visitArgs.visitDeeper = false;
      },
      processImportNode: function (importNode, context, importParent) {
          var evaldImportNode;
          var inlineCSS = importNode.options.inline;
          try {
              evaldImportNode = importNode.evalForImport(context);
          }
          catch (e) {
              if (!e.filename) {
                  e.index = importNode.getIndex();
                  e.filename = importNode.fileInfo().filename;
              }
              // attempt to eval properly and treat as css
              importNode.css = true;
              // if that fails, this error will be thrown
              importNode.error = e;
          }
          if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {
              if (evaldImportNode.options.multiple) {
                  context.importMultiple = true;
              }
              // try appending if we haven't determined if it is css or not
              var tryAppendLessExtension = evaldImportNode.css === undefined;
              for (var i_1 = 0; i_1 < importParent.rules.length; i_1++) {
                  if (importParent.rules[i_1] === importNode) {
                      importParent.rules[i_1] = evaldImportNode;
                      break;
                  }
              }
              var onImported = this.onImported.bind(this, evaldImportNode, context);
              var sequencedOnImported = this._sequencer.addImport(onImported);
              this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.fileInfo(), evaldImportNode.options, sequencedOnImported);
          }
          else {
              this.importCount--;
              if (this.isFinished) {
                  this._sequencer.tryRun();
              }
          }
      },
      onImported: function (importNode, context, e, root, importedAtRoot, fullPath) {
          if (e) {
              if (!e.filename) {
                  e.index = importNode.getIndex();
                  e.filename = importNode.fileInfo().filename;
              }
              this.error = e;
          }
          var importVisitor = this;
          var inlineCSS = importNode.options.inline;
          var isPlugin = importNode.options.isPlugin;
          var isOptional = importNode.options.optional;
          var duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;
          if (!context.importMultiple) {
              if (duplicateImport) {
                  importNode.skip = true;
              }
              else {
                  importNode.skip = function () {
                      if (fullPath in importVisitor.onceFileDetectionMap) {
                          return true;
                      }
                      importVisitor.onceFileDetectionMap[fullPath] = true;
                      return false;
                  };
              }
          }
          if (!fullPath && isOptional) {
              importNode.skip = true;
          }
          if (root) {
              importNode.root = root;
              importNode.importedFilename = fullPath;
              if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {
                  importVisitor.recursionDetector[fullPath] = true;
                  var oldContext = this.context;
                  this.context = context;
                  try {
                      this._visitor.visit(root);
                  }
                  catch (e) {
                      this.error = e;
                  }
                  this.context = oldContext;
              }
          }
          importVisitor.importCount--;
          if (importVisitor.isFinished) {
              importVisitor._sequencer.tryRun();
          }
      },
      visitDeclaration: function (declNode, visitArgs) {
          if (declNode.value.type === 'DetachedRuleset') {
              this.context.frames.unshift(declNode);
          }
          else {
              visitArgs.visitDeeper = false;
          }
      },
      visitDeclarationOut: function (declNode) {
          if (declNode.value.type === 'DetachedRuleset') {
              this.context.frames.shift();
          }
      },
      visitAtRule: function (atRuleNode, visitArgs) {
          this.context.frames.unshift(atRuleNode);
      },
      visitAtRuleOut: function (atRuleNode) {
          this.context.frames.shift();
      },
      visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
          this.context.frames.unshift(mixinDefinitionNode);
      },
      visitMixinDefinitionOut: function (mixinDefinitionNode) {
          this.context.frames.shift();
      },
      visitRuleset: function (rulesetNode, visitArgs) {
          this.context.frames.unshift(rulesetNode);
      },
      visitRulesetOut: function (rulesetNode) {
          this.context.frames.shift();
      },
      visitMedia: function (mediaNode, visitArgs) {
          this.context.frames.unshift(mediaNode.rules[0]);
      },
      visitMediaOut: function (mediaNode) {
          this.context.frames.shift();
      }
  };

  var SetTreeVisibilityVisitor = /** @class */ (function () {
      function SetTreeVisibilityVisitor(visible) {
          this.visible = visible;
      }
      SetTreeVisibilityVisitor.prototype.run = function (root) {
          this.visit(root);
      };
      SetTreeVisibilityVisitor.prototype.visitArray = function (nodes) {
          if (!nodes) {
              return nodes;
          }
          var cnt = nodes.length;
          var i;
          for (i = 0; i < cnt; i++) {
              this.visit(nodes[i]);
          }
          return nodes;
      };
      SetTreeVisibilityVisitor.prototype.visit = function (node) {
          if (!node) {
              return node;
          }
          if (node.constructor === Array) {
              return this.visitArray(node);
          }
          if (!node.blocksVisibility || node.blocksVisibility()) {
              return node;
          }
          if (this.visible) {
              node.ensureVisibility();
          }
          else {
              node.ensureInvisibility();
          }
          node.accept(this);
          return node;
      };
      return SetTreeVisibilityVisitor;
  }());

  /* jshint loopfunc:true */
  var ExtendFinderVisitor = /** @class */ (function () {
      function ExtendFinderVisitor() {
          this._visitor = new Visitor(this);
          this.contexts = [];
          this.allExtendsStack = [[]];
      }
      ExtendFinderVisitor.prototype.run = function (root) {
          root = this._visitor.visit(root);
          root.allExtends = this.allExtendsStack[0];
          return root;
      };
      ExtendFinderVisitor.prototype.visitDeclaration = function (declNode, visitArgs) {
          visitArgs.visitDeeper = false;
      };
      ExtendFinderVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
          visitArgs.visitDeeper = false;
      };
      ExtendFinderVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
          if (rulesetNode.root) {
              return;
          }
          var i;
          var j;
          var extend;
          var allSelectorsExtendList = [];
          var extendList;
          // get &:extend(.a); rules which apply to all selectors in this ruleset
          var rules = rulesetNode.rules;
          var ruleCnt = rules ? rules.length : 0;
          for (i = 0; i < ruleCnt; i++) {
              if (rulesetNode.rules[i] instanceof tree.Extend) {
                  allSelectorsExtendList.push(rules[i]);
                  rulesetNode.extendOnEveryPath = true;
              }
          }
          // now find every selector and apply the extends that apply to all extends
          // and the ones which apply to an individual extend
          var paths = rulesetNode.paths;
          for (i = 0; i < paths.length; i++) {
              var selectorPath = paths[i];
              var selector = selectorPath[selectorPath.length - 1];
              var selExtendList = selector.extendList;
              extendList = selExtendList ? copyArray(selExtendList).concat(allSelectorsExtendList)
                  : allSelectorsExtendList;
              if (extendList) {
                  extendList = extendList.map(function (allSelectorsExtend) { return allSelectorsExtend.clone(); });
              }
              for (j = 0; j < extendList.length; j++) {
                  this.foundExtends = true;
                  extend = extendList[j];
                  extend.findSelfSelectors(selectorPath);
                  extend.ruleset = rulesetNode;
                  if (j === 0) {
                      extend.firstExtendOnThisSelectorPath = true;
                  }
                  this.allExtendsStack[this.allExtendsStack.length - 1].push(extend);
              }
          }
          this.contexts.push(rulesetNode.selectors);
      };
      ExtendFinderVisitor.prototype.visitRulesetOut = function (rulesetNode) {
          if (!rulesetNode.root) {
              this.contexts.length = this.contexts.length - 1;
          }
      };
      ExtendFinderVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
          mediaNode.allExtends = [];
          this.allExtendsStack.push(mediaNode.allExtends);
      };
      ExtendFinderVisitor.prototype.visitMediaOut = function (mediaNode) {
          this.allExtendsStack.length = this.allExtendsStack.length - 1;
      };
      ExtendFinderVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
          atRuleNode.allExtends = [];
          this.allExtendsStack.push(atRuleNode.allExtends);
      };
      ExtendFinderVisitor.prototype.visitAtRuleOut = function (atRuleNode) {
          this.allExtendsStack.length = this.allExtendsStack.length - 1;
      };
      return ExtendFinderVisitor;
  }());
  var ProcessExtendsVisitor = /** @class */ (function () {
      function ProcessExtendsVisitor() {
          this._visitor = new Visitor(this);
      }
      ProcessExtendsVisitor.prototype.run = function (root) {
          var extendFinder = new ExtendFinderVisitor();
          this.extendIndices = {};
          extendFinder.run(root);
          if (!extendFinder.foundExtends) {
              return root;
          }
          root.allExtends = root.allExtends.concat(this.doExtendChaining(root.allExtends, root.allExtends));
          this.allExtendsStack = [root.allExtends];
          var newRoot = this._visitor.visit(root);
          this.checkExtendsForNonMatched(root.allExtends);
          return newRoot;
      };
      ProcessExtendsVisitor.prototype.checkExtendsForNonMatched = function (extendList) {
          var indices = this.extendIndices;
          extendList.filter(function (extend) { return !extend.hasFoundMatches && extend.parent_ids.length == 1; }).forEach(function (extend) {
              var selector = '_unknown_';
              try {
                  selector = extend.selector.toCSS({});
              }
              catch (_) { }
              if (!indices[extend.index + " " + selector]) {
                  indices[extend.index + " " + selector] = true;
                  logger.warn("extend '" + selector + "' has no matches");
              }
          });
      };
      ProcessExtendsVisitor.prototype.doExtendChaining = function (extendsList, extendsListTarget, iterationCount) {
          //
          // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering
          // and pasting the selector we would do normally, but we are also adding an extend with the same target selector
          // this means this new extend can then go and alter other extends
          //
          // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors
          // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already
          // processed if we look at each selector at a time, as is done in visitRuleset
          var extendIndex;
          var targetExtendIndex;
          var matches;
          var extendsToAdd = [];
          var newSelector;
          var extendVisitor = this;
          var selectorPath;
          var extend;
          var targetExtend;
          var newExtend;
          iterationCount = iterationCount || 0;
          // loop through comparing every extend with every target extend.
          // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place
          // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one
          // and the second is the target.
          // the separation into two lists allows us to process a subset of chains with a bigger set, as is the
          // case when processing media queries
          for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {
              for (targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++) {
                  extend = extendsList[extendIndex];
                  targetExtend = extendsListTarget[targetExtendIndex];
                  // look for circular references
                  if (extend.parent_ids.indexOf(targetExtend.object_id) >= 0) {
                      continue;
                  }
                  // find a match in the target extends self selector (the bit before :extend)
                  selectorPath = [targetExtend.selfSelectors[0]];
                  matches = extendVisitor.findMatch(extend, selectorPath);
                  if (matches.length) {
                      extend.hasFoundMatches = true;
                      // we found a match, so for each self selector..
                      extend.selfSelectors.forEach(function (selfSelector) {
                          var info = targetExtend.visibilityInfo();
                          // process the extend as usual
                          newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector, extend.isVisible());
                          // but now we create a new extend from it
                          newExtend = new (tree.Extend)(targetExtend.selector, targetExtend.option, 0, targetExtend.fileInfo(), info);
                          newExtend.selfSelectors = newSelector;
                          // add the extend onto the list of extends for that selector
                          newSelector[newSelector.length - 1].extendList = [newExtend];
                          // record that we need to add it.
                          extendsToAdd.push(newExtend);
                          newExtend.ruleset = targetExtend.ruleset;
                          // remember its parents for circular references
                          newExtend.parent_ids = newExtend.parent_ids.concat(targetExtend.parent_ids, extend.parent_ids);
                          // only process the selector once.. if we have :extend(.a,.b) then multiple
                          // extends will look at the same selector path, so when extending
                          // we know that any others will be duplicates in terms of what is added to the css
                          if (targetExtend.firstExtendOnThisSelectorPath) {
                              newExtend.firstExtendOnThisSelectorPath = true;
                              targetExtend.ruleset.paths.push(newSelector);
                          }
                      });
                  }
              }
          }
          if (extendsToAdd.length) {
              // try to detect circular references to stop a stack overflow.
              // may no longer be needed.
              this.extendChainCount++;
              if (iterationCount > 100) {
                  var selectorOne = '{unable to calculate}';
                  var selectorTwo = '{unable to calculate}';
                  try {
                      selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();
                      selectorTwo = extendsToAdd[0].selector.toCSS();
                  }
                  catch (e) { }
                  throw { message: "extend circular reference detected. One of the circular extends is currently:" + selectorOne + ":extend(" + selectorTwo + ")" };
              }
              // now process the new extends on the existing rules so that we can handle a extending b extending c extending
              // d extending e...
              return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount + 1));
          }
          else {
              return extendsToAdd;
          }
      };
      ProcessExtendsVisitor.prototype.visitDeclaration = function (ruleNode, visitArgs) {
          visitArgs.visitDeeper = false;
      };
      ProcessExtendsVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
          visitArgs.visitDeeper = false;
      };
      ProcessExtendsVisitor.prototype.visitSelector = function (selectorNode, visitArgs) {
          visitArgs.visitDeeper = false;
      };
      ProcessExtendsVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
          if (rulesetNode.root) {
              return;
          }
          var matches;
          var pathIndex;
          var extendIndex;
          var allExtends = this.allExtendsStack[this.allExtendsStack.length - 1];
          var selectorsToAdd = [];
          var extendVisitor = this;
          var selectorPath;
          // look at each selector path in the ruleset, find any extend matches and then copy, find and replace
          for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {
              for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {
                  selectorPath = rulesetNode.paths[pathIndex];
                  // extending extends happens initially, before the main pass
                  if (rulesetNode.extendOnEveryPath) {
                      continue;
                  }
                  var extendList = selectorPath[selectorPath.length - 1].extendList;
                  if (extendList && extendList.length) {
                      continue;
                  }
                  matches = this.findMatch(allExtends[extendIndex], selectorPath);
                  if (matches.length) {
                      allExtends[extendIndex].hasFoundMatches = true;
                      allExtends[extendIndex].selfSelectors.forEach(function (selfSelector) {
                          var extendedSelectors;
                          extendedSelectors = extendVisitor.extendSelector(matches, selectorPath, selfSelector, allExtends[extendIndex].isVisible());
                          selectorsToAdd.push(extendedSelectors);
                      });
                  }
              }
          }
          rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);
      };
      ProcessExtendsVisitor.prototype.findMatch = function (extend, haystackSelectorPath) {
          //
          // look through the haystack selector path to try and find the needle - extend.selector
          // returns an array of selector matches that can then be replaced
          //
          var haystackSelectorIndex;
          var hackstackSelector;
          var hackstackElementIndex;
          var haystackElement;
          var targetCombinator;
          var i;
          var extendVisitor = this;
          var needleElements = extend.selector.elements;
          var potentialMatches = [];
          var potentialMatch;
          var matches = [];
          // loop through the haystack elements
          for (haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {
              hackstackSelector = haystackSelectorPath[haystackSelectorIndex];
              for (hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {
                  haystackElement = hackstackSelector.elements[hackstackElementIndex];
                  // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.
                  if (extend.allowBefore || (haystackSelectorIndex === 0 && hackstackElementIndex === 0)) {
                      potentialMatches.push({ pathIndex: haystackSelectorIndex, index: hackstackElementIndex, matched: 0,
                          initialCombinator: haystackElement.combinator });
                  }
                  for (i = 0; i < potentialMatches.length; i++) {
                      potentialMatch = potentialMatches[i];
                      // selectors add " " onto the first element. When we use & it joins the selectors together, but if we don't
                      // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to
                      // work out what the resulting combinator will be
                      targetCombinator = haystackElement.combinator.value;
                      if (targetCombinator === '' && hackstackElementIndex === 0) {
                          targetCombinator = ' ';
                      }
                      // if we don't match, null our match to indicate failure
                      if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) ||
                          (potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator)) {
                          potentialMatch = null;
                      }
                      else {
                          potentialMatch.matched++;
                      }
                      // if we are still valid and have finished, test whether we have elements after and whether these are allowed
                      if (potentialMatch) {
                          potentialMatch.finished = potentialMatch.matched === needleElements.length;
                          if (potentialMatch.finished &&
                              (!extend.allowAfter &&
                                  (hackstackElementIndex + 1 < hackstackSelector.elements.length || haystackSelectorIndex + 1 < haystackSelectorPath.length))) {
                              potentialMatch = null;
                          }
                      }
                      // if null we remove, if not, we are still valid, so either push as a valid match or continue
                      if (potentialMatch) {
                          if (potentialMatch.finished) {
                              potentialMatch.length = needleElements.length;
                              potentialMatch.endPathIndex = haystackSelectorIndex;
                              potentialMatch.endPathElementIndex = hackstackElementIndex + 1; // index after end of match
                              potentialMatches.length = 0; // we don't allow matches to overlap, so start matching again
                              matches.push(potentialMatch);
                          }
                      }
                      else {
                          potentialMatches.splice(i, 1);
                          i--;
                      }
                  }
              }
          }
          return matches;
      };
      ProcessExtendsVisitor.prototype.isElementValuesEqual = function (elementValue1, elementValue2) {
          if (typeof elementValue1 === 'string' || typeof elementValue2 === 'string') {
              return elementValue1 === elementValue2;
          }
          if (elementValue1 instanceof tree.Attribute) {
              if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {
                  return false;
              }
              if (!elementValue1.value || !elementValue2.value) {
                  if (elementValue1.value || elementValue2.value) {
                      return false;
                  }
                  return true;
              }
              elementValue1 = elementValue1.value.value || elementValue1.value;
              elementValue2 = elementValue2.value.value || elementValue2.value;
              return elementValue1 === elementValue2;
          }
          elementValue1 = elementValue1.value;
          elementValue2 = elementValue2.value;
          if (elementValue1 instanceof tree.Selector) {
              if (!(elementValue2 instanceof tree.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {
                  return false;
              }
              for (var i_1 = 0; i_1 < elementValue1.elements.length; i_1++) {
                  if (elementValue1.elements[i_1].combinator.value !== elementValue2.elements[i_1].combinator.value) {
                      if (i_1 !== 0 || (elementValue1.elements[i_1].combinator.value || ' ') !== (elementValue2.elements[i_1].combinator.value || ' ')) {
                          return false;
                      }
                  }
                  if (!this.isElementValuesEqual(elementValue1.elements[i_1].value, elementValue2.elements[i_1].value)) {
                      return false;
                  }
              }
              return true;
          }
          return false;
      };
      ProcessExtendsVisitor.prototype.extendSelector = function (matches, selectorPath, replacementSelector, isVisible) {
          // for a set of matches, replace each match with the replacement selector
          var currentSelectorPathIndex = 0;
          var currentSelectorPathElementIndex = 0;
          var path = [];
          var matchIndex;
          var selector;
          var firstElement;
          var match;
          var newElements;
          for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {
              match = matches[matchIndex];
              selector = selectorPath[match.pathIndex];
              firstElement = new tree.Element(match.initialCombinator, replacementSelector.elements[0].value, replacementSelector.elements[0].isVariable, replacementSelector.elements[0].getIndex(), replacementSelector.elements[0].fileInfo());
              if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {
                  path[path.length - 1].elements = path[path.length - 1]
                      .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
                  currentSelectorPathElementIndex = 0;
                  currentSelectorPathIndex++;
              }
              newElements = selector.elements
                  .slice(currentSelectorPathElementIndex, match.index)
                  .concat([firstElement])
                  .concat(replacementSelector.elements.slice(1));
              if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {
                  path[path.length - 1].elements =
                      path[path.length - 1].elements.concat(newElements);
              }
              else {
                  path = path.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));
                  path.push(new tree.Selector(newElements));
              }
              currentSelectorPathIndex = match.endPathIndex;
              currentSelectorPathElementIndex = match.endPathElementIndex;
              if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {
                  currentSelectorPathElementIndex = 0;
                  currentSelectorPathIndex++;
              }
          }
          if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {
              path[path.length - 1].elements = path[path.length - 1]
                  .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
              currentSelectorPathIndex++;
          }
          path = path.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));
          path = path.map(function (currentValue) {
              // we can re-use elements here, because the visibility property matters only for selectors
              var derived = currentValue.createDerived(currentValue.elements);
              if (isVisible) {
                  derived.ensureVisibility();
              }
              else {
                  derived.ensureInvisibility();
              }
              return derived;
          });
          return path;
      };
      ProcessExtendsVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
          var newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
          newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));
          this.allExtendsStack.push(newAllExtends);
      };
      ProcessExtendsVisitor.prototype.visitMediaOut = function (mediaNode) {
          var lastIndex = this.allExtendsStack.length - 1;
          this.allExtendsStack.length = lastIndex;
      };
      ProcessExtendsVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
          var newAllExtends = atRuleNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
          newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, atRuleNode.allExtends));
          this.allExtendsStack.push(newAllExtends);
      };
      ProcessExtendsVisitor.prototype.visitAtRuleOut = function (atRuleNode) {
          var lastIndex = this.allExtendsStack.length - 1;
          this.allExtendsStack.length = lastIndex;
      };
      return ProcessExtendsVisitor;
  }());

  var JoinSelectorVisitor = /** @class */ (function () {
      function JoinSelectorVisitor() {
          this.contexts = [[]];
          this._visitor = new Visitor(this);
      }
      JoinSelectorVisitor.prototype.run = function (root) {
          return this._visitor.visit(root);
      };
      JoinSelectorVisitor.prototype.visitDeclaration = function (declNode, visitArgs) {
          visitArgs.visitDeeper = false;
      };
      JoinSelectorVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
          visitArgs.visitDeeper = false;
      };
      JoinSelectorVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
          var context = this.contexts[this.contexts.length - 1];
          var paths = [];
          var selectors;
          this.contexts.push(paths);
          if (!rulesetNode.root) {
              selectors = rulesetNode.selectors;
              if (selectors) {
                  selectors = selectors.filter(function (selector) { return selector.getIsOutput(); });
                  rulesetNode.selectors = selectors.length ? selectors : (selectors = null);
                  if (selectors) {
                      rulesetNode.joinSelectors(paths, context, selectors);
                  }
              }
              if (!selectors) {
                  rulesetNode.rules = null;
              }
              rulesetNode.paths = paths;
          }
      };
      JoinSelectorVisitor.prototype.visitRulesetOut = function (rulesetNode) {
          this.contexts.length = this.contexts.length - 1;
      };
      JoinSelectorVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
          var context = this.contexts[this.contexts.length - 1];
          mediaNode.rules[0].root = (context.length === 0 || context[0].multiMedia);
      };
      JoinSelectorVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
          var context = this.contexts[this.contexts.length - 1];
          if (atRuleNode.rules && atRuleNode.rules.length) {
              atRuleNode.rules[0].root = (atRuleNode.isRooted || context.length === 0 || null);
          }
      };
      return JoinSelectorVisitor;
  }());

  var CSSVisitorUtils = /** @class */ (function () {
      function CSSVisitorUtils(context) {
          this._visitor = new Visitor(this);
          this._context = context;
      }
      CSSVisitorUtils.prototype.containsSilentNonBlockedChild = function (bodyRules) {
          var rule;
          if (!bodyRules) {
              return false;
          }
          for (var r = 0; r < bodyRules.length; r++) {
              rule = bodyRules[r];
              if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {
                  // the atrule contains something that was referenced (likely by extend)
                  // therefore it needs to be shown in output too
                  return true;
              }
          }
          return false;
      };
      CSSVisitorUtils.prototype.keepOnlyVisibleChilds = function (owner) {
          if (owner && owner.rules) {
              owner.rules = owner.rules.filter(function (thing) { return thing.isVisible(); });
          }
      };
      CSSVisitorUtils.prototype.isEmpty = function (owner) {
          return (owner && owner.rules)
              ? (owner.rules.length === 0) : true;
      };
      CSSVisitorUtils.prototype.hasVisibleSelector = function (rulesetNode) {
          return (rulesetNode && rulesetNode.paths)
              ? (rulesetNode.paths.length > 0) : false;
      };
      CSSVisitorUtils.prototype.resolveVisibility = function (node, originalRules) {
          if (!node.blocksVisibility()) {
              if (this.isEmpty(node) && !this.containsSilentNonBlockedChild(originalRules)) {
                  return;
              }
              return node;
          }
          var compiledRulesBody = node.rules[0];
          this.keepOnlyVisibleChilds(compiledRulesBody);
          if (this.isEmpty(compiledRulesBody)) {
              return;
          }
          node.ensureVisibility();
          node.removeVisibilityBlock();
          return node;
      };
      CSSVisitorUtils.prototype.isVisibleRuleset = function (rulesetNode) {
          if (rulesetNode.firstRoot) {
              return true;
          }
          if (this.isEmpty(rulesetNode)) {
              return false;
          }
          if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {
              return false;
          }
          return true;
      };
      return CSSVisitorUtils;
  }());
  var ToCSSVisitor = function (context) {
      this._visitor = new Visitor(this);
      this._context = context;
      this.utils = new CSSVisitorUtils(context);
  };
  ToCSSVisitor.prototype = {
      isReplacing: true,
      run: function (root) {
          return this._visitor.visit(root);
      },
      visitDeclaration: function (declNode, visitArgs) {
          if (declNode.blocksVisibility() || declNode.variable) {
              return;
          }
          return declNode;
      },
      visitMixinDefinition: function (mixinNode, visitArgs) {
          // mixin definitions do not get eval'd - this means they keep state
          // so we have to clear that state here so it isn't used if toCSS is called twice
          mixinNode.frames = [];
      },
      visitExtend: function (extendNode, visitArgs) {
      },
      visitComment: function (commentNode, visitArgs) {
          if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {
              return;
          }
          return commentNode;
      },
      visitMedia: function (mediaNode, visitArgs) {
          var originalRules = mediaNode.rules[0].rules;
          mediaNode.accept(this._visitor);
          visitArgs.visitDeeper = false;
          return this.utils.resolveVisibility(mediaNode, originalRules);
      },
      visitImport: function (importNode, visitArgs) {
          if (importNode.blocksVisibility()) {
              return;
          }
          return importNode;
      },
      visitAtRule: function (atRuleNode, visitArgs) {
          if (atRuleNode.rules && atRuleNode.rules.length) {
              return this.visitAtRuleWithBody(atRuleNode, visitArgs);
          }
          else {
              return this.visitAtRuleWithoutBody(atRuleNode, visitArgs);
          }
      },
      visitAnonymous: function (anonymousNode, visitArgs) {
          if (!anonymousNode.blocksVisibility()) {
              anonymousNode.accept(this._visitor);
              return anonymousNode;
          }
      },
      visitAtRuleWithBody: function (atRuleNode, visitArgs) {
          // if there is only one nested ruleset and that one has no path, then it is
          // just fake ruleset
          function hasFakeRuleset(atRuleNode) {
              var bodyRules = atRuleNode.rules;
              return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);
          }
          function getBodyRules(atRuleNode) {
              var nodeRules = atRuleNode.rules;
              if (hasFakeRuleset(atRuleNode)) {
                  return nodeRules[0].rules;
              }
              return nodeRules;
          }
          // it is still true that it is only one ruleset in array
          // this is last such moment
          // process childs
          var originalRules = getBodyRules(atRuleNode);
          atRuleNode.accept(this._visitor);
          visitArgs.visitDeeper = false;
          if (!this.utils.isEmpty(atRuleNode)) {
              this._mergeRules(atRuleNode.rules[0].rules);
          }
          return this.utils.resolveVisibility(atRuleNode, originalRules);
      },
      visitAtRuleWithoutBody: function (atRuleNode, visitArgs) {
          if (atRuleNode.blocksVisibility()) {
              return;
          }
          if (atRuleNode.name === '@charset') {
              // Only output the debug info together with subsequent @charset definitions
              // a comment (or @media statement) before the actual @charset atrule would
              // be considered illegal css as it has to be on the first line
              if (this.charset) {
                  if (atRuleNode.debugInfo) {
                      var comment = new tree.Comment("/* " + atRuleNode.toCSS(this._context).replace(/\n/g, '') + " */\n");
                      comment.debugInfo = atRuleNode.debugInfo;
                      return this._visitor.visit(comment);
                  }
                  return;
              }
              this.charset = true;
          }
          return atRuleNode;
      },
      checkValidNodes: function (rules, isRoot) {
          if (!rules) {
              return;
          }
          for (var i_1 = 0; i_1 < rules.length; i_1++) {
              var ruleNode = rules[i_1];
              if (isRoot && ruleNode instanceof tree.Declaration && !ruleNode.variable) {
                  throw { message: 'Properties must be inside selector blocks. They cannot be in the root',
                      index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };
              }
              if (ruleNode instanceof tree.Call) {
                  throw { message: "Function '" + ruleNode.name + "' is undefined",
                      index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };
              }
              if (ruleNode.type && !ruleNode.allowRoot) {
                  throw { message: ruleNode.type + " node returned by a function is not valid here",
                      index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };
              }
          }
      },
      visitRuleset: function (rulesetNode, visitArgs) {
          // at this point rulesets are nested into each other
          var rule;
          var rulesets = [];
          this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot);
          if (!rulesetNode.root) {
              // remove invisible paths
              this._compileRulesetPaths(rulesetNode);
              // remove rulesets from this ruleset body and compile them separately
              var nodeRules = rulesetNode.rules;
              var nodeRuleCnt = nodeRules ? nodeRules.length : 0;
              for (var i_2 = 0; i_2 < nodeRuleCnt;) {
                  rule = nodeRules[i_2];
                  if (rule && rule.rules) {
                      // visit because we are moving them out from being a child
                      rulesets.push(this._visitor.visit(rule));
                      nodeRules.splice(i_2, 1);
                      nodeRuleCnt--;
                      continue;
                  }
                  i_2++;
              }
              // accept the visitor to remove rules and refactor itself
              // then we can decide nogw whether we want it or not
              // compile body
              if (nodeRuleCnt > 0) {
                  rulesetNode.accept(this._visitor);
              }
              else {
                  rulesetNode.rules = null;
              }
              visitArgs.visitDeeper = false;
          }
          else { // if (! rulesetNode.root) {
              rulesetNode.accept(this._visitor);
              visitArgs.visitDeeper = false;
          }
          if (rulesetNode.rules) {
              this._mergeRules(rulesetNode.rules);
              this._removeDuplicateRules(rulesetNode.rules);
          }
          // now decide whether we keep the ruleset
          if (this.utils.isVisibleRuleset(rulesetNode)) {
              rulesetNode.ensureVisibility();
              rulesets.splice(0, 0, rulesetNode);
          }
          if (rulesets.length === 1) {
              return rulesets[0];
          }
          return rulesets;
      },
      _compileRulesetPaths: function (rulesetNode) {
          if (rulesetNode.paths) {
              rulesetNode.paths = rulesetNode.paths
                  .filter(function (p) {
                  var i;
                  if (p[0].elements[0].combinator.value === ' ') {
                      p[0].elements[0].combinator = new (tree.Combinator)('');
                  }
                  for (i = 0; i < p.length; i++) {
                      if (p[i].isVisible() && p[i].getIsOutput()) {
                          return true;
                      }
                  }
                  return false;
              });
          }
      },
      _removeDuplicateRules: function (rules) {
          if (!rules) {
              return;
          }
          // remove duplicates
          var ruleCache = {};
          var ruleList;
          var rule;
          var i;
          for (i = rules.length - 1; i >= 0; i--) {
              rule = rules[i];
              if (rule instanceof tree.Declaration) {
                  if (!ruleCache[rule.name]) {
                      ruleCache[rule.name] = rule;
                  }
                  else {
                      ruleList = ruleCache[rule.name];
                      if (ruleList instanceof tree.Declaration) {
                          ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];
                      }
                      var ruleCSS = rule.toCSS(this._context);
                      if (ruleList.indexOf(ruleCSS) !== -1) {
                          rules.splice(i, 1);
                      }
                      else {
                          ruleList.push(ruleCSS);
                      }
                  }
              }
          }
      },
      _mergeRules: function (rules) {
          if (!rules) {
              return;
          }
          var groups = {};
          var groupsArr = [];
          for (var i_3 = 0; i_3 < rules.length; i_3++) {
              var rule = rules[i_3];
              if (rule.merge) {
                  var key = rule.name;
                  groups[key] ? rules.splice(i_3--, 1) :
                      groupsArr.push(groups[key] = []);
                  groups[key].push(rule);
              }
          }
          groupsArr.forEach(function (group) {
              if (group.length > 0) {
                  var result_1 = group[0];
                  var space_1 = [];
                  var comma_1 = [new tree.Expression(space_1)];
                  group.forEach(function (rule) {
                      if ((rule.merge === '+') && (space_1.length > 0)) {
                          comma_1.push(new tree.Expression(space_1 = []));
                      }
                      space_1.push(rule.value);
                      result_1.important = result_1.important || rule.important;
                  });
                  result_1.value = new tree.Value(comma_1);
              }
          });
      }
  };

  var visitors = {
      Visitor: Visitor,
      ImportVisitor: ImportVisitor,
      MarkVisibleSelectorsVisitor: SetTreeVisibilityVisitor,
      ExtendVisitor: ProcessExtendsVisitor,
      JoinSelectorVisitor: JoinSelectorVisitor,
      ToCSSVisitor: ToCSSVisitor
  };

  // Split the input into chunks.
  var chunker = (function (input, fail) {
      var len = input.length;
      var level = 0;
      var parenLevel = 0;
      var lastOpening;
      var lastOpeningParen;
      var lastMultiComment;
      var lastMultiCommentEndBrace;
      var chunks = [];
      var emitFrom = 0;
      var chunkerCurrentIndex;
      var currentChunkStartIndex;
      var cc;
      var cc2;
      var matched;
      function emitChunk(force) {
          var len = chunkerCurrentIndex - emitFrom;
          if (((len < 512) && !force) || !len) {
              return;
          }
          chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));
          emitFrom = chunkerCurrentIndex + 1;
      }
      for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
          cc = input.charCodeAt(chunkerCurrentIndex);
          if (((cc >= 97) && (cc <= 122)) || (cc < 34)) {
              // a-z or whitespace
              continue;
          }
          switch (cc) {
              case 40: // (
                  parenLevel++;
                  lastOpeningParen = chunkerCurrentIndex;
                  continue;
              case 41: // )
                  if (--parenLevel < 0) {
                      return fail('missing opening `(`', chunkerCurrentIndex);
                  }
                  continue;
              case 59: // ;
                  if (!parenLevel) {
                      emitChunk();
                  }
                  continue;
              case 123: // {
                  level++;
                  lastOpening = chunkerCurrentIndex;
                  continue;
              case 125: // }
                  if (--level < 0) {
                      return fail('missing opening `{`', chunkerCurrentIndex);
                  }
                  if (!level && !parenLevel) {
                      emitChunk();
                  }
                  continue;
              case 92: // \
                  if (chunkerCurrentIndex < len - 1) {
                      chunkerCurrentIndex++;
                      continue;
                  }
                  return fail('unescaped `\\`', chunkerCurrentIndex);
              case 34:
              case 39:
              case 96: // ", ' and `
                  matched = 0;
                  currentChunkStartIndex = chunkerCurrentIndex;
                  for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
                      cc2 = input.charCodeAt(chunkerCurrentIndex);
                      if (cc2 > 96) {
                          continue;
                      }
                      if (cc2 == cc) {
                          matched = 1;
                          break;
                      }
                      if (cc2 == 92) { // \
                          if (chunkerCurrentIndex == len - 1) {
                              return fail('unescaped `\\`', chunkerCurrentIndex);
                          }
                          chunkerCurrentIndex++;
                      }
                  }
                  if (matched) {
                      continue;
                  }
                  return fail("unmatched `" + String.fromCharCode(cc) + "`", currentChunkStartIndex);
              case 47: // /, check for comment
                  if (parenLevel || (chunkerCurrentIndex == len - 1)) {
                      continue;
                  }
                  cc2 = input.charCodeAt(chunkerCurrentIndex + 1);
                  if (cc2 == 47) {
                      // //, find lnfeed
                      for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
                          cc2 = input.charCodeAt(chunkerCurrentIndex);
                          if ((cc2 <= 13) && ((cc2 == 10) || (cc2 == 13))) {
                              break;
                          }
                      }
                  }
                  else if (cc2 == 42) {
                      // /*, find */
                      lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;
                      for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {
                          cc2 = input.charCodeAt(chunkerCurrentIndex);
                          if (cc2 == 125) {
                              lastMultiCommentEndBrace = chunkerCurrentIndex;
                          }
                          if (cc2 != 42) {
                              continue;
                          }
                          if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) {
                              break;
                          }
                      }
                      if (chunkerCurrentIndex == len - 1) {
                          return fail('missing closing `*/`', currentChunkStartIndex);
                      }
                      chunkerCurrentIndex++;
                  }
                  continue;
              case 42: // *, check for unmatched */
                  if ((chunkerCurrentIndex < len - 1) && (input.charCodeAt(chunkerCurrentIndex + 1) == 47)) {
                      return fail('unmatched `/*`', chunkerCurrentIndex);
                  }
                  continue;
          }
      }
      if (level !== 0) {
          if ((lastMultiComment > lastOpening) && (lastMultiCommentEndBrace > lastMultiComment)) {
              return fail('missing closing `}` or `*/`', lastOpening);
          }
          else {
              return fail('missing closing `}`', lastOpening);
          }
      }
      else if (parenLevel !== 0) {
          return fail('missing closing `)`', lastOpeningParen);
      }
      emitChunk(true);
      return chunks;
  });

  var getParserInput = (function () {
      var // Less input string
      input;
      var // current chunk
      j;
      var // holds state for backtracking
      saveStack = [];
      var // furthest index the parser has gone to
      furthest;
      var // if this is furthest we got to, this is the probably cause
      furthestPossibleErrorMessage;
      var // chunkified input
      chunks;
      var // current chunk
      current;
      var // index of current chunk, in `input`
      currentPos;
      var parserInput = {};
      var CHARCODE_SPACE = 32;
      var CHARCODE_TAB = 9;
      var CHARCODE_LF = 10;
      var CHARCODE_CR = 13;
      var CHARCODE_PLUS = 43;
      var CHARCODE_COMMA = 44;
      var CHARCODE_FORWARD_SLASH = 47;
      var CHARCODE_9 = 57;
      function skipWhitespace(length) {
          var oldi = parserInput.i;
          var oldj = j;
          var curr = parserInput.i - currentPos;
          var endIndex = parserInput.i + current.length - curr;
          var mem = (parserInput.i += length);
          var inp = input;
          var c;
          var nextChar;
          var comment;
          for (; parserInput.i < endIndex; parserInput.i++) {
              c = inp.charCodeAt(parserInput.i);
              if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {
                  nextChar = inp.charAt(parserInput.i + 1);
                  if (nextChar === '/') {
                      comment = { index: parserInput.i, isLineComment: true };
                      var nextNewLine = inp.indexOf('\n', parserInput.i + 2);
                      if (nextNewLine < 0) {
                          nextNewLine = endIndex;
                      }
                      parserInput.i = nextNewLine;
                      comment.text = inp.substr(comment.index, parserInput.i - comment.index);
                      parserInput.commentStore.push(comment);
                      continue;
                  }
                  else if (nextChar === '*') {
                      var nextStarSlash = inp.indexOf('*/', parserInput.i + 2);
                      if (nextStarSlash >= 0) {
                          comment = {
                              index: parserInput.i,
                              text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),
                              isLineComment: false
                          };
                          parserInput.i += comment.text.length - 1;
                          parserInput.commentStore.push(comment);
                          continue;
                      }
                  }
                  break;
              }
              if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {
                  break;
              }
          }
          current = current.slice(length + parserInput.i - mem + curr);
          currentPos = parserInput.i;
          if (!current.length) {
              if (j < chunks.length - 1) {
                  current = chunks[++j];
                  skipWhitespace(0); // skip space at the beginning of a chunk
                  return true; // things changed
              }
              parserInput.finished = true;
          }
          return oldi !== parserInput.i || oldj !== j;
      }
      parserInput.save = function () {
          currentPos = parserInput.i;
          saveStack.push({ current: current, i: parserInput.i, j: j });
      };
      parserInput.restore = function (possibleErrorMessage) {
          if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {
              furthest = parserInput.i;
              furthestPossibleErrorMessage = possibleErrorMessage;
          }
          var state = saveStack.pop();
          current = state.current;
          currentPos = parserInput.i = state.i;
          j = state.j;
      };
      parserInput.forget = function () {
          saveStack.pop();
      };
      parserInput.isWhitespace = function (offset) {
          var pos = parserInput.i + (offset || 0);
          var code = input.charCodeAt(pos);
          return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);
      };
      // Specialization of $(tok)
      parserInput.$re = function (tok) {
          if (parserInput.i > currentPos) {
              current = current.slice(parserInput.i - currentPos);
              currentPos = parserInput.i;
          }
          var m = tok.exec(current);
          if (!m) {
              return null;
          }
          skipWhitespace(m[0].length);
          if (typeof m === 'string') {
              return m;
          }
          return m.length === 1 ? m[0] : m;
      };
      parserInput.$char = function (tok) {
          if (input.charAt(parserInput.i) !== tok) {
              return null;
          }
          skipWhitespace(1);
          return tok;
      };
      parserInput.$str = function (tok) {
          var tokLength = tok.length;
          // https://jsperf.com/string-startswith/21
          for (var i_1 = 0; i_1 < tokLength; i_1++) {
              if (input.charAt(parserInput.i + i_1) !== tok.charAt(i_1)) {
                  return null;
              }
          }
          skipWhitespace(tokLength);
          return tok;
      };
      parserInput.$quoted = function (loc) {
          var pos = loc || parserInput.i;
          var startChar = input.charAt(pos);
          if (startChar !== '\'' && startChar !== '"') {
              return;
          }
          var length = input.length;
          var currentPosition = pos;
          for (var i_2 = 1; i_2 + currentPosition < length; i_2++) {
              var nextChar = input.charAt(i_2 + currentPosition);
              switch (nextChar) {
                  case '\\':
                      i_2++;
                      continue;
                  case '\r':
                  case '\n':
                      break;
                  case startChar:
                      var str = input.substr(currentPosition, i_2 + 1);
                      if (!loc && loc !== 0) {
                          skipWhitespace(i_2 + 1);
                          return str;
                      }
                      return [startChar, str];
              }
          }
          return null;
      };
      /**
       * Permissive parsing. Ignores everything except matching {} [] () and quotes
       * until matching token (outside of blocks)
       */
      parserInput.$parseUntil = function (tok) {
          var quote = '';
          var returnVal = null;
          var inComment = false;
          var blockDepth = 0;
          var blockStack = [];
          var parseGroups = [];
          var length = input.length;
          var startPos = parserInput.i;
          var lastPos = parserInput.i;
          var i = parserInput.i;
          var loop = true;
          var testChar;
          if (typeof tok === 'string') {
              testChar = function (char) { return char === tok; };
          }
          else {
              testChar = function (char) { return tok.test(char); };
          }
          do {
              var nextChar = input.charAt(i);
              if (blockDepth === 0 && testChar(nextChar)) {
                  returnVal = input.substr(lastPos, i - lastPos);
                  if (returnVal) {
                      parseGroups.push(returnVal);
                  }
                  else {
                      parseGroups.push(' ');
                  }
                  returnVal = parseGroups;
                  skipWhitespace(i - startPos);
                  loop = false;
              }
              else {
                  if (inComment) {
                      if (nextChar === '*' &&
                          input.charAt(i + 1) === '/') {
                          i++;
                          blockDepth--;
                          inComment = false;
                      }
                      i++;
                      continue;
                  }
                  switch (nextChar) {
                      case '\\':
                          i++;
                          nextChar = input.charAt(i);
                          parseGroups.push(input.substr(lastPos, i - lastPos + 1));
                          lastPos = i + 1;
                          break;
                      case '/':
                          if (input.charAt(i + 1) === '*') {
                              i++;
                              inComment = true;
                              blockDepth++;
                          }
                          break;
                      case '\'':
                      case '"':
                          quote = parserInput.$quoted(i);
                          if (quote) {
                              parseGroups.push(input.substr(lastPos, i - lastPos), quote);
                              i += quote[1].length - 1;
                              lastPos = i + 1;
                          }
                          else {
                              skipWhitespace(i - startPos);
                              returnVal = nextChar;
                              loop = false;
                          }
                          break;
                      case '{':
                          blockStack.push('}');
                          blockDepth++;
                          break;
                      case '(':
                          blockStack.push(')');
                          blockDepth++;
                          break;
                      case '[':
                          blockStack.push(']');
                          blockDepth++;
                          break;
                      case '}':
                      case ')':
                      case ']':
                          var expected = blockStack.pop();
                          if (nextChar === expected) {
                              blockDepth--;
                          }
                          else {
                              // move the parser to the error and return expected
                              skipWhitespace(i - startPos);
                              returnVal = expected;
                              loop = false;
                          }
                  }
                  i++;
                  if (i > length) {
                      loop = false;
                  }
              }
          } while (loop);
          return returnVal ? returnVal : null;
      };
      parserInput.autoCommentAbsorb = true;
      parserInput.commentStore = [];
      parserInput.finished = false;
      // Same as $(), but don't change the state of the parser,
      // just return the match.
      parserInput.peek = function (tok) {
          if (typeof tok === 'string') {
              // https://jsperf.com/string-startswith/21
              for (var i_3 = 0; i_3 < tok.length; i_3++) {
                  if (input.charAt(parserInput.i + i_3) !== tok.charAt(i_3)) {
                      return false;
                  }
              }
              return true;
          }
          else {
              return tok.test(current);
          }
      };
      // Specialization of peek()
      // TODO remove or change some currentChar calls to peekChar
      parserInput.peekChar = function (tok) { return input.charAt(parserInput.i) === tok; };
      parserInput.currentChar = function () { return input.charAt(parserInput.i); };
      parserInput.prevChar = function () { return input.charAt(parserInput.i - 1); };
      parserInput.getInput = function () { return input; };
      parserInput.peekNotNumeric = function () {
          var c = input.charCodeAt(parserInput.i);
          // Is the first char of the dimension 0-9, '.', '+' or '-'
          return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;
      };
      parserInput.start = function (str, chunkInput, failFunction) {
          input = str;
          parserInput.i = j = currentPos = furthest = 0;
          // chunking apparently makes things quicker (but my tests indicate
          // it might actually make things slower in node at least)
          // and it is a non-perfect parse - it can't recognise
          // unquoted urls, meaning it can't distinguish comments
          // meaning comments with quotes or {}() in them get 'counted'
          // and then lead to parse errors.
          // In addition if the chunking chunks in the wrong place we might
          // not be able to parse a parser statement in one go
          // this is officially deprecated but can be switched on via an option
          // in the case it causes too much performance issues.
          if (chunkInput) {
              chunks = chunker(str, failFunction);
          }
          else {
              chunks = [str];
          }
          current = chunks[0];
          skipWhitespace(0);
      };
      parserInput.end = function () {
          var message;
          var isFinished = parserInput.i >= input.length;
          if (parserInput.i < furthest) {
              message = furthestPossibleErrorMessage;
              parserInput.i = furthest;
          }
          return {
              isFinished: isFinished,
              furthest: parserInput.i,
              furthestPossibleErrorMessage: message,
              furthestReachedEnd: parserInput.i >= input.length - 1,
              furthestChar: input[parserInput.i]
          };
      };
      return parserInput;
  });

  //
  // less.js - parser
  //
  //    A relatively straight-forward predictive parser.
  //    There is no tokenization/lexing stage, the input is parsed
  //    in one sweep.
  //
  //    To make the parser fast enough to run in the browser, several
  //    optimization had to be made:
  //
  //    - Matching and slicing on a huge input is often cause of slowdowns.
  //      The solution is to chunkify the input into smaller strings.
  //      The chunks are stored in the `chunks` var,
  //      `j` holds the current chunk index, and `currentPos` holds
  //      the index of the current chunk in relation to `input`.
  //      This gives us an almost 4x speed-up.
  //
  //    - In many cases, we don't need to match individual tokens;
  //      for example, if a value doesn't hold any variables, operations
  //      or dynamic references, the parser can effectively 'skip' it,
  //      treating it as a literal.
  //      An example would be '1px solid #000' - which evaluates to itself,
  //      we don't need to know what the individual components are.
  //      The drawback, of course is that you don't get the benefits of
  //      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,
  //      and a smaller speed-up in the code-gen.
  //
  //
  //    Token matching is done with the `$` function, which either takes
  //    a terminal string or regexp, or a non-terminal function to call.
  //    It also takes care of moving all the indices forwards.
  //
  var Parser = function Parser(context, imports, fileInfo) {
      var parsers;
      var parserInput = getParserInput();
      function error(msg, type) {
          throw new LessError({
              index: parserInput.i,
              filename: fileInfo.filename,
              type: type || 'Syntax',
              message: msg
          }, imports);
      }
      function expect(arg, msg) {
          // some older browsers return typeof 'function' for RegExp
          var result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);
          if (result) {
              return result;
          }
          error(msg || (typeof arg === 'string'
              ? "expected '" + arg + "' got '" + parserInput.currentChar() + "'"
              : 'unexpected token'));
      }
      // Specialization of expect()
      function expectChar(arg, msg) {
          if (parserInput.$char(arg)) {
              return arg;
          }
          error(msg || "expected '" + arg + "' got '" + parserInput.currentChar() + "'");
      }
      function getDebugInfo(index) {
          var filename = fileInfo.filename;
          return {
              lineNumber: getLocation(index, parserInput.getInput()).line + 1,
              fileName: filename
          };
      }
      /**
       *  Used after initial parsing to create nodes on the fly
       *
       *  @param {String} str          - string to parse
       *  @param {Array}  parseList    - array of parsers to run input through e.g. ["value", "important"]
       *  @param {Number} currentIndex - start number to begin indexing
       *  @param {Object} fileInfo     - fileInfo to attach to created nodes
       */
      function parseNode(str, parseList, currentIndex, fileInfo, callback) {
          var result;
          var returnNodes = [];
          var parser = parserInput;
          try {
              parser.start(str, false, function fail(msg, index) {
                  callback({
                      message: msg,
                      index: index + currentIndex
                  });
              });
              for (var x = 0, p = void 0, i_1; (p = parseList[x]); x++) {
                  i_1 = parser.i;
                  result = parsers[p]();
                  if (result) {
                      try {
                          result._index = i_1 + currentIndex;
                          result._fileInfo = fileInfo;
                      }
                      catch (e) { }
                      returnNodes.push(result);
                  }
                  else {
                      returnNodes.push(null);
                  }
              }
              var endInfo = parser.end();
              if (endInfo.isFinished) {
                  callback(null, returnNodes);
              }
              else {
                  callback(true, null);
              }
          }
          catch (e) {
              throw new LessError({
                  index: e.index + currentIndex,
                  message: e.message
              }, imports, fileInfo.filename);
          }
      }
      //
      // The Parser
      //
      return {
          parserInput: parserInput,
          imports: imports,
          fileInfo: fileInfo,
          parseNode: parseNode,
          //
          // Parse an input string into an abstract syntax tree,
          // @param str A string containing 'less' markup
          // @param callback call `callback` when done.
          // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply
          //
          parse: function (str, callback, additionalData) {
              var root;
              var error = null;
              var globalVars;
              var modifyVars;
              var ignored;
              var preText = '';
              globalVars = (additionalData && additionalData.globalVars) ? Parser.serializeVars(additionalData.globalVars) + "\n" : '';
              modifyVars = (additionalData && additionalData.modifyVars) ? "\n" + Parser.serializeVars(additionalData.modifyVars) : '';
              if (context.pluginManager) {
                  var preProcessors = context.pluginManager.getPreProcessors();
                  for (var i_2 = 0; i_2 < preProcessors.length; i_2++) {
                      str = preProcessors[i_2].process(str, { context: context, imports: imports, fileInfo: fileInfo });
                  }
              }
              if (globalVars || (additionalData && additionalData.banner)) {
                  preText = ((additionalData && additionalData.banner) ? additionalData.banner : '') + globalVars;
                  ignored = imports.contentsIgnoredChars;
                  ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;
                  ignored[fileInfo.filename] += preText.length;
              }
              str = str.replace(/\r\n?/g, '\n');
              // Remove potential UTF Byte Order Mark
              str = preText + str.replace(/^\uFEFF/, '') + modifyVars;
              imports.contents[fileInfo.filename] = str;
              // Start with the primary rule.
              // The whole syntax tree is held under a Ruleset node,
              // with the `root` property set to true, so no `{}` are
              // output. The callback is called when the input is parsed.
              try {
                  parserInput.start(str, context.chunkInput, function fail(msg, index) {
                      throw new LessError({
                          index: index,
                          type: 'Parse',
                          message: msg,
                          filename: fileInfo.filename
                      }, imports);
                  });
                  tree.Node.prototype.parse = this;
                  root = new tree.Ruleset(null, this.parsers.primary());
                  tree.Node.prototype.rootNode = root;
                  root.root = true;
                  root.firstRoot = true;
                  root.functionRegistry = functionRegistry.inherit();
              }
              catch (e) {
                  return callback(new LessError(e, imports, fileInfo.filename));
              }
              // If `i` is smaller than the `input.length - 1`,
              // it means the parser wasn't able to parse the whole
              // string, so we've got a parsing error.
              //
              // We try to extract a \n delimited string,
              // showing the line where the parse error occurred.
              // We split it up into two parts (the part which parsed,
              // and the part which didn't), so we can color them differently.
              var endInfo = parserInput.end();
              if (!endInfo.isFinished) {
                  var message = endInfo.furthestPossibleErrorMessage;
                  if (!message) {
                      message = 'Unrecognised input';
                      if (endInfo.furthestChar === '}') {
                          message += '. Possibly missing opening \'{\'';
                      }
                      else if (endInfo.furthestChar === ')') {
                          message += '. Possibly missing opening \'(\'';
                      }
                      else if (endInfo.furthestReachedEnd) {
                          message += '. Possibly missing something';
                      }
                  }
                  error = new LessError({
                      type: 'Parse',
                      message: message,
                      index: endInfo.furthest,
                      filename: fileInfo.filename
                  }, imports);
              }
              var finish = function (e) {
                  e = error || e || imports.error;
                  if (e) {
                      if (!(e instanceof LessError)) {
                          e = new LessError(e, imports, fileInfo.filename);
                      }
                      return callback(e);
                  }
                  else {
                      return callback(null, root);
                  }
              };
              if (context.processImports !== false) {
                  new visitors.ImportVisitor(imports, finish)
                      .run(root);
              }
              else {
                  return finish();
              }
          },
          //
          // Here in, the parsing rules/functions
          //
          // The basic structure of the syntax tree generated is as follows:
          //
          //   Ruleset ->  Declaration -> Value -> Expression -> Entity
          //
          // Here's some Less code:
          //
          //    .class {
          //      color: #fff;
          //      border: 1px solid #000;
          //      width: @w + 4px;
          //      > .child {...}
          //    }
          //
          // And here's what the parse tree might look like:
          //
          //     Ruleset (Selector '.class', [
          //         Declaration ("color",  Value ([Expression [Color #fff]]))
          //         Declaration ("border", Value ([Expression [Dimension 1px][Keyword "solid"][Color #000]]))
          //         Declaration ("width",  Value ([Expression [Operation " + " [Variable "@w"][Dimension 4px]]]))
          //         Ruleset (Selector [Element '>', '.child'], [...])
          //     ])
          //
          //  In general, most rules will try to parse a token with the `$re()` function, and if the return
          //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
          //  first, before parsing, that's when we use `peek()`.
          //
          parsers: parsers = {
              //
              // The `primary` rule is the *entry* and *exit* point of the parser.
              // The rules here can appear at any level of the parse tree.
              //
              // The recursive nature of the grammar is an interplay between the `block`
              // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
              // as represented by this simplified grammar:
              //
              //     primary  →  (ruleset | declaration)+
              //     ruleset  →  selector+ block
              //     block    →  '{' primary '}'
              //
              // Only at one point is the primary rule not called from the
              // block rule: at the root level.
              //
              primary: function () {
                  var mixin = this.mixin;
                  var root = [];
                  var node;
                  while (true) {
                      while (true) {
                          node = this.comment();
                          if (!node) {
                              break;
                          }
                          root.push(node);
                      }
                      // always process comments before deciding if finished
                      if (parserInput.finished) {
                          break;
                      }
                      if (parserInput.peek('}')) {
                          break;
                      }
                      node = this.extendRule();
                      if (node) {
                          root = root.concat(node);
                          continue;
                      }
                      node = mixin.definition() || this.declaration() || mixin.call(false, false) ||
                          this.ruleset() || this.variableCall() || this.entities.call() || this.atrule();
                      if (node) {
                          root.push(node);
                      }
                      else {
                          var foundSemiColon = false;
                          while (parserInput.$char(';')) {
                              foundSemiColon = true;
                          }
                          if (!foundSemiColon) {
                              break;
                          }
                      }
                  }
                  return root;
              },
              // comments are collected by the main parsing mechanism and then assigned to nodes
              // where the current structure allows it
              comment: function () {
                  if (parserInput.commentStore.length) {
                      var comment = parserInput.commentStore.shift();
                      return new (tree.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);
                  }
              },
              //
              // Entities are tokens which can be found inside an Expression
              //
              entities: {
                  mixinLookup: function () {
                      return parsers.mixin.call(true, true);
                  },
                  //
                  // A string, which supports escaping " and '
                  //
                  //     "milky way" 'he\'s the one!'
                  //
                  quoted: function (forceEscaped) {
                      var str;
                      var index = parserInput.i;
                      var isEscaped = false;
                      parserInput.save();
                      if (parserInput.$char('~')) {
                          isEscaped = true;
                      }
                      else if (forceEscaped) {
                          parserInput.restore();
                          return;
                      }
                      str = parserInput.$quoted();
                      if (!str) {
                          parserInput.restore();
                          return;
                      }
                      parserInput.forget();
                      return new (tree.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);
                  },
                  //
                  // A catch-all word, such as:
                  //
                  //     black border-collapse
                  //
                  keyword: function () {
                      var k = parserInput.$char('%') || parserInput.$re(/^\[?(?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\]?/);
                      if (k) {
                          return tree.Color.fromKeyword(k) || new (tree.Keyword)(k);
                      }
                  },
                  //
                  // A function call
                  //
                  //     rgb(255, 0, 255)
                  //
                  // The arguments are parsed with the `entities.arguments` parser.
                  //
                  call: function () {
                      var name;
                      var args;
                      var func;
                      var index = parserInput.i;
                      // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
                      if (parserInput.peek(/^url\(/i)) {
                          return;
                      }
                      parserInput.save();
                      name = parserInput.$re(/^([\w-]+|%|progid:[\w\.]+)\(/);
                      if (!name) {
                          parserInput.forget();
                          return;
                      }
                      name = name[1];
                      func = this.customFuncCall(name);
                      if (func) {
                          args = func.parse();
                          if (args && func.stop) {
                              parserInput.forget();
                              return args;
                          }
                      }
                      args = this.arguments(args);
                      if (!parserInput.$char(')')) {
                          parserInput.restore('Could not parse call arguments or missing \')\'');
                          return;
                      }
                      parserInput.forget();
                      return new (tree.Call)(name, args, index, fileInfo);
                  },
                  //
                  // Parsing rules for functions with non-standard args, e.g.:
                  //
                  //     boolean(not(2 > 1))
                  //
                  //     This is a quick prototype, to be modified/improved when
                  //     more custom-parsed funcs come (e.g. `selector(...)`)
                  //
                  customFuncCall: function (name) {
                      /* Ideally the table is to be moved out of here for faster perf.,
                         but it's quite tricky since it relies on all these `parsers`
                         and `expect` available only here */
                      return {
                          alpha: f(parsers.ieAlpha, true),
                          boolean: f(condition),
                          'if': f(condition)
                      }[name.toLowerCase()];
                      function f(parse, stop) {
                          return {
                              parse: parse,
                              stop: stop // when true - stop after parse() and return its result, 
                              // otherwise continue for plain args
                          };
                      }
                      function condition() {
                          return [expect(parsers.condition, 'expected condition')];
                      }
                  },
                  arguments: function (prevArgs) {
                      var argsComma = prevArgs || [];
                      var argsSemiColon = [];
                      var isSemiColonSeparated;
                      var value;
                      parserInput.save();
                      while (true) {
                          if (prevArgs) {
                              prevArgs = false;
                          }
                          else {
                              value = parsers.detachedRuleset() || this.assignment() || parsers.expression();
                              if (!value) {
                                  break;
                              }
                              if (value.value && value.value.length == 1) {
                                  value = value.value[0];
                              }
                              argsComma.push(value);
                          }
                          if (parserInput.$char(',')) {
                              continue;
                          }
                          if (parserInput.$char(';') || isSemiColonSeparated) {
                              isSemiColonSeparated = true;
                              value = (argsComma.length < 1) ? argsComma[0]
                                  : new tree.Value(argsComma);
                              argsSemiColon.push(value);
                              argsComma = [];
                          }
                      }
                      parserInput.forget();
                      return isSemiColonSeparated ? argsSemiColon : argsComma;
                  },
                  literal: function () {
                      return this.dimension() ||
                          this.color() ||
                          this.quoted() ||
                          this.unicodeDescriptor();
                  },
                  // Assignments are argument entities for calls.
                  // They are present in ie filter properties as shown below.
                  //
                  //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )
                  //
                  assignment: function () {
                      var key;
                      var value;
                      parserInput.save();
                      key = parserInput.$re(/^\w+(?=\s?=)/i);
                      if (!key) {
                          parserInput.restore();
                          return;
                      }
                      if (!parserInput.$char('=')) {
                          parserInput.restore();
                          return;
                      }
                      value = parsers.entity();
                      if (value) {
                          parserInput.forget();
                          return new (tree.Assignment)(key, value);
                      }
                      else {
                          parserInput.restore();
                      }
                  },
                  //
                  // Parse url() tokens
                  //
                  // We use a specific rule for urls, because they don't really behave like
                  // standard function calls. The difference is that the argument doesn't have
                  // to be enclosed within a string, so it can't be parsed as an Expression.
                  //
                  url: function () {
                      var value;
                      var index = parserInput.i;
                      parserInput.autoCommentAbsorb = false;
                      if (!parserInput.$str('url(')) {
                          parserInput.autoCommentAbsorb = true;
                          return;
                      }
                      value = this.quoted() || this.variable() || this.property() ||
                          parserInput.$re(/^(?:(?:\\[\(\)'"])|[^\(\)'"])+/) || '';
                      parserInput.autoCommentAbsorb = true;
                      expectChar(')');
                      return new (tree.URL)((value.value != null ||
                          value instanceof tree.Variable ||
                          value instanceof tree.Property) ?
                          value : new (tree.Anonymous)(value, index), index, fileInfo);
                  },
                  //
                  // A Variable entity, such as `@fink`, in
                  //
                  //     width: @fink + 2px
                  //
                  // We use a different parser for variable definitions,
                  // see `parsers.variable`.
                  //
                  variable: function () {
                      var ch;
                      var name;
                      var index = parserInput.i;
                      parserInput.save();
                      if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\w-]+/))) {
                          ch = parserInput.currentChar();
                          if (ch === '(' || ch === '[' && !parserInput.prevChar().match(/^\s/)) {
                              // this may be a VariableCall lookup
                              var result = parsers.variableCall(name);
                              if (result) {
                                  parserInput.forget();
                                  return result;
                              }
                          }
                          parserInput.forget();
                          return new (tree.Variable)(name, index, fileInfo);
                      }
                      parserInput.restore();
                  },
                  // A variable entity using the protective {} e.g. @{var}
                  variableCurly: function () {
                      var curly;
                      var index = parserInput.i;
                      if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\{([\w-]+)\}/))) {
                          return new (tree.Variable)("@" + curly[1], index, fileInfo);
                      }
                  },
                  //
                  // A Property accessor, such as `$color`, in
                  //
                  //     background-color: $color
                  //
                  property: function () {
                      var name;
                      var index = parserInput.i;
                      if (parserInput.currentChar() === '$' && (name = parserInput.$re(/^\$[\w-]+/))) {
                          return new (tree.Property)(name, index, fileInfo);
                      }
                  },
                  // A property entity useing the protective {} e.g. ${prop}
                  propertyCurly: function () {
                      var curly;
                      var index = parserInput.i;
                      if (parserInput.currentChar() === '$' && (curly = parserInput.$re(/^\$\{([\w-]+)\}/))) {
                          return new (tree.Property)("$" + curly[1], index, fileInfo);
                      }
                  },
                  //
                  // A Hexadecimal color
                  //
                  //     #4F3C2F
                  //
                  // `rgb` and `hsl` colors are parsed through the `entities.call` parser.
                  //
                  color: function () {
                      var rgb;
                      parserInput.save();
                      if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})([\w.#\[])?/))) {
                          if (!rgb[2]) {
                              parserInput.forget();
                              return new (tree.Color)(rgb[1], undefined, rgb[0]);
                          }
                      }
                      parserInput.restore();
                  },
                  colorKeyword: function () {
                      parserInput.save();
                      var autoCommentAbsorb = parserInput.autoCommentAbsorb;
                      parserInput.autoCommentAbsorb = false;
                      var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);
                      parserInput.autoCommentAbsorb = autoCommentAbsorb;
                      if (!k) {
                          parserInput.forget();
                          return;
                      }
                      parserInput.restore();
                      var color = tree.Color.fromKeyword(k);
                      if (color) {
                          parserInput.$str(k);
                          return color;
                      }
                  },
                  //
                  // A Dimension, that is, a number and a unit
                  //
                  //     0.5em 95%
                  //
                  dimension: function () {
                      if (parserInput.peekNotNumeric()) {
                          return;
                      }
                      var value = parserInput.$re(/^([+-]?\d*\.?\d+)(%|[a-z_]+)?/i);
                      if (value) {
                          return new (tree.Dimension)(value[1], value[2]);
                      }
                  },
                  //
                  // A unicode descriptor, as is used in unicode-range
                  //
                  // U+0??  or U+00A1-00A9
                  //
                  unicodeDescriptor: function () {
                      var ud;
                      ud = parserInput.$re(/^U\+[0-9a-fA-F?]+(\-[0-9a-fA-F?]+)?/);
                      if (ud) {
                          return new (tree.UnicodeDescriptor)(ud[0]);
                      }
                  },
                  //
                  // JavaScript code to be evaluated
                  //
                  //     `window.location.href`
                  //
                  javascript: function () {
                      var js;
                      var index = parserInput.i;
                      parserInput.save();
                      var escape = parserInput.$char('~');
                      var jsQuote = parserInput.$char('`');
                      if (!jsQuote) {
                          parserInput.restore();
                          return;
                      }
                      js = parserInput.$re(/^[^`]*`/);
                      if (js) {
                          parserInput.forget();
                          return new (tree.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);
                      }
                      parserInput.restore('invalid javascript definition');
                  }
              },
              //
              // The variable part of a variable definition. Used in the `rule` parser
              //
              //     @fink:
              //
              variable: function () {
                  var name;
                  if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\w-]+)\s*:/))) {
                      return name[1];
                  }
              },
              //
              // Call a variable value to retrieve a detached ruleset
              // or a value from a detached ruleset's rules.
              //
              //     @fink();
              //     @fink;
              //     color: @fink[@color];
              //
              variableCall: function (parsedName) {
                  var lookups;
                  var i = parserInput.i;
                  var inValue = !!parsedName;
                  var name = parsedName;
                  parserInput.save();
                  if (name || (parserInput.currentChar() === '@'
                      && (name = parserInput.$re(/^(@[\w-]+)(\(\s*\))?/)))) {
                      lookups = this.mixin.ruleLookups();
                      if (!lookups && ((inValue && parserInput.$str('()') !== '()') || (name[2] !== '()'))) {
                          parserInput.restore('Missing \'[...]\' lookup in variable call');
                          return;
                      }
                      if (!inValue) {
                          name = name[1];
                      }
                      var call = new tree.VariableCall(name, i, fileInfo);
                      if (!inValue && parsers.end()) {
                          parserInput.forget();
                          return call;
                      }
                      else {
                          parserInput.forget();
                          return new tree.NamespaceValue(call, lookups, i, fileInfo);
                      }
                  }
                  parserInput.restore();
              },
              //
              // extend syntax - used to extend selectors
              //
              extend: function (isRule) {
                  var elements;
                  var e;
                  var index = parserInput.i;
                  var option;
                  var extendList;
                  var extend;
                  if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {
                      return;
                  }
                  do {
                      option = null;
                      elements = null;
                      while (!(option = parserInput.$re(/^(all)(?=\s*(\)|,))/))) {
                          e = this.element();
                          if (!e) {
                              break;
                          }
                          if (elements) {
                              elements.push(e);
                          }
                          else {
                              elements = [e];
                          }
                      }
                      option = option && option[1];
                      if (!elements) {
                          error('Missing target selector for :extend().');
                      }
                      extend = new (tree.Extend)(new (tree.Selector)(elements), option, index, fileInfo);
                      if (extendList) {
                          extendList.push(extend);
                      }
                      else {
                          extendList = [extend];
                      }
                  } while (parserInput.$char(','));
                  expect(/^\)/);
                  if (isRule) {
                      expect(/^;/);
                  }
                  return extendList;
              },
              //
              // extendRule - used in a rule to extend all the parent selectors
              //
              extendRule: function () {
                  return this.extend(true);
              },
              //
              // Mixins
              //
              mixin: {
                  //
                  // A Mixin call, with an optional argument list
                  //
                  //     #mixins > .square(#fff);
                  //     #mixins.square(#fff);
                  //     .rounded(4px, black);
                  //     .button;
                  //
                  // We can lookup / return a value using the lookup syntax:
                  //
                  //     color: #mixin.square(#fff)[@color];
                  //
                  // The `while` loop is there because mixins can be
                  // namespaced, but we only support the child and descendant
                  // selector for now.
                  //
                  call: function (inValue, getLookup) {
                      var s = parserInput.currentChar();
                      var important = false;
                      var lookups;
                      var index = parserInput.i;
                      var elements;
                      var args;
                      var hasParens;
                      if (s !== '.' && s !== '#') {
                          return;
                      }
                      parserInput.save(); // stop us absorbing part of an invalid selector
                      elements = this.elements();
                      if (elements) {
                          if (parserInput.$char('(')) {
                              args = this.args(true).args;
                              expectChar(')');
                              hasParens = true;
                          }
                          if (getLookup !== false) {
                              lookups = this.ruleLookups();
                          }
                          if (getLookup === true && !lookups) {
                              parserInput.restore();
                              return;
                          }
                          if (inValue && !lookups && !hasParens) {
                              // This isn't a valid in-value mixin call
                              parserInput.restore();
                              return;
                          }
                          if (!inValue && parsers.important()) {
                              important = true;
                          }
                          if (inValue || parsers.end()) {
                              parserInput.forget();
                              var mixin = new (tree.mixin.Call)(elements, args, index, fileInfo, !lookups && important);
                              if (lookups) {
                                  return new tree.NamespaceValue(mixin, lookups);
                              }
                              else {
                                  return mixin;
                              }
                          }
                      }
                      parserInput.restore();
                  },
                  /**
                   * Matching elements for mixins
                   * (Start with . or # and can have > )
                   */
                  elements: function () {
                      var elements;
                      var e;
                      var c;
                      var elem;
                      var elemIndex;
                      var re = /^[#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;
                      while (true) {
                          elemIndex = parserInput.i;
                          e = parserInput.$re(re);
                          if (!e) {
                              break;
                          }
                          elem = new (tree.Element)(c, e, false, elemIndex, fileInfo);
                          if (elements) {
                              elements.push(elem);
                          }
                          else {
                              elements = [elem];
                          }
                          c = parserInput.$char('>');
                      }
                      return elements;
                  },
                  args: function (isCall) {
                      var entities = parsers.entities;
                      var returner = { args: null, variadic: false };
                      var expressions = [];
                      var argsSemiColon = [];
                      var argsComma = [];
                      var isSemiColonSeparated;
                      var expressionContainsNamed;
                      var name;
                      var nameLoop;
                      var value;
                      var arg;
                      var expand;
                      var hasSep = true;
                      parserInput.save();
                      while (true) {
                          if (isCall) {
                              arg = parsers.detachedRuleset() || parsers.expression();
                          }
                          else {
                              parserInput.commentStore.length = 0;
                              if (parserInput.$str('...')) {
                                  returner.variadic = true;
                                  if (parserInput.$char(';') && !isSemiColonSeparated) {
                                      isSemiColonSeparated = true;
                                  }
                                  (isSemiColonSeparated ? argsSemiColon : argsComma)
                                      .push({ variadic: true });
                                  break;
                              }
                              arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);
                          }
                          if (!arg || !hasSep) {
                              break;
                          }
                          nameLoop = null;
                          if (arg.throwAwayComments) {
                              arg.throwAwayComments();
                          }
                          value = arg;
                          var val = null;
                          if (isCall) {
                              // Variable
                              if (arg.value && arg.value.length == 1) {
                                  val = arg.value[0];
                              }
                          }
                          else {
                              val = arg;
                          }
                          if (val && (val instanceof tree.Variable || val instanceof tree.Property)) {
                              if (parserInput.$char(':')) {
                                  if (expressions.length > 0) {
                                      if (isSemiColonSeparated) {
                                          error('Cannot mix ; and , as delimiter types');
                                      }
                                      expressionContainsNamed = true;
                                  }
                                  value = parsers.detachedRuleset() || parsers.expression();
                                  if (!value) {
                                      if (isCall) {
                                          error('could not understand value for named argument');
                                      }
                                      else {
                                          parserInput.restore();
                                          returner.args = [];
                                          return returner;
                                      }
                                  }
                                  nameLoop = (name = val.name);
                              }
                              else if (parserInput.$str('...')) {
                                  if (!isCall) {
                                      returner.variadic = true;
                                      if (parserInput.$char(';') && !isSemiColonSeparated) {
                                          isSemiColonSeparated = true;
                                      }
                                      (isSemiColonSeparated ? argsSemiColon : argsComma)
                                          .push({ name: arg.name, variadic: true });
                                      break;
                                  }
                                  else {
                                      expand = true;
                                  }
                              }
                              else if (!isCall) {
                                  name = nameLoop = val.name;
                                  value = null;
                              }
                          }
                          if (value) {
                              expressions.push(value);
                          }
                          argsComma.push({ name: nameLoop, value: value, expand: expand });
                          if (parserInput.$char(',')) {
                              hasSep = true;
                              continue;
                          }
                          hasSep = parserInput.$char(';') === ';';
                          if (hasSep || isSemiColonSeparated) {
                              if (expressionContainsNamed) {
                                  error('Cannot mix ; and , as delimiter types');
                              }
                              isSemiColonSeparated = true;
                              if (expressions.length > 1) {
                                  value = new (tree.Value)(expressions);
                              }
                              argsSemiColon.push({ name: name, value: value, expand: expand });
                              name = null;
                              expressions = [];
                              expressionContainsNamed = false;
                          }
                      }
                      parserInput.forget();
                      returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;
                      return returner;
                  },
                  //
                  // A Mixin definition, with a list of parameters
                  //
                  //     .rounded (@radius: 2px, @color) {
                  //        ...
                  //     }
                  //
                  // Until we have a finer grained state-machine, we have to
                  // do a look-ahead, to make sure we don't have a mixin call.
                  // See the `rule` function for more information.
                  //
                  // We start by matching `.rounded (`, and then proceed on to
                  // the argument list, which has optional default values.
                  // We store the parameters in `params`, with a `value` key,
                  // if there is a value, such as in the case of `@radius`.
                  //
                  // Once we've got our params list, and a closing `)`, we parse
                  // the `{...}` block.
                  //
                  definition: function () {
                      var name;
                      var params = [];
                      var match;
                      var ruleset;
                      var cond;
                      var variadic = false;
                      if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||
                          parserInput.peek(/^[^{]*\}/)) {
                          return;
                      }
                      parserInput.save();
                      match = parserInput.$re(/^([#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\s*\(/);
                      if (match) {
                          name = match[1];
                          var argInfo = this.args(false);
                          params = argInfo.args;
                          variadic = argInfo.variadic;
                          // .mixincall("@{a}");
                          // looks a bit like a mixin definition..
                          // also
                          // .mixincall(@a: {rule: set;});
                          // so we have to be nice and restore
                          if (!parserInput.$char(')')) {
                              parserInput.restore('Missing closing \')\'');
                              return;
                          }
                          parserInput.commentStore.length = 0;
                          if (parserInput.$str('when')) { // Guard
                              cond = expect(parsers.conditions, 'expected condition');
                          }
                          ruleset = parsers.block();
                          if (ruleset) {
                              parserInput.forget();
                              return new (tree.mixin.Definition)(name, params, ruleset, cond, variadic);
                          }
                          else {
                              parserInput.restore();
                          }
                      }
                      else {
                          parserInput.restore();
                      }
                  },
                  ruleLookups: function () {
                      var rule;
                      var lookups = [];
                      if (parserInput.currentChar() !== '[') {
                          return;
                      }
                      while (true) {
                          parserInput.save();
                          rule = this.lookupValue();
                          if (!rule && rule !== '') {
                              parserInput.restore();
                              break;
                          }
                          lookups.push(rule);
                          parserInput.forget();
                      }
                      if (lookups.length > 0) {
                          return lookups;
                      }
                  },
                  lookupValue: function () {
                      parserInput.save();
                      if (!parserInput.$char('[')) {
                          parserInput.restore();
                          return;
                      }
                      var name = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);
                      if (!parserInput.$char(']')) {
                          parserInput.restore();
                          return;
                      }
                      if (name || name === '') {
                          parserInput.forget();
                          return name;
                      }
                      parserInput.restore();
                  }
              },
              //
              // Entities are the smallest recognized token,
              // and can be found inside a rule's value.
              //
              entity: function () {
                  var entities = this.entities;
                  return this.comment() || entities.literal() || entities.variable() || entities.url() ||
                      entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) ||
                      entities.javascript();
              },
              //
              // A Declaration terminator. Note that we use `peek()` to check for '}',
              // because the `block` rule will be expecting it, but we still need to make sure
              // it's there, if ';' was omitted.
              //
              end: function () {
                  return parserInput.$char(';') || parserInput.peek('}');
              },
              //
              // IE's alpha function
              //
              //     alpha(opacity=88)
              //
              ieAlpha: function () {
                  var value;
                  // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
                  if (!parserInput.$re(/^opacity=/i)) {
                      return;
                  }
                  value = parserInput.$re(/^\d+/);
                  if (!value) {
                      value = expect(parsers.entities.variable, 'Could not parse alpha');
                      value = "@{" + value.name.slice(1) + "}";
                  }
                  expectChar(')');
                  return new tree.Quoted('', "alpha(opacity=" + value + ")");
              },
              //
              // A Selector Element
              //
              //     div
              //     + h1
              //     #socks
              //     input[type="text"]
              //
              // Elements are the building blocks for Selectors,
              // they are made out of a `Combinator` (see combinator rule),
              // and an element name, such as a tag a class, or `*`.
              //
              element: function () {
                  var e;
                  var c;
                  var v;
                  var index = parserInput.i;
                  c = this.combinator();
                  e = parserInput.$re(/^(?:\d+\.\d+|\d+)%/) ||
                      parserInput.$re(/^(?:[.#]?|:*)(?:[\w-]|[^\x00-\x9f]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||
                      parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||
                      parserInput.$re(/^\([^&()@]+\)/) || parserInput.$re(/^[\.#:](?=@)/) ||
                      this.entities.variableCurly();
                  if (!e) {
                      parserInput.save();
                      if (parserInput.$char('(')) {
                          if ((v = this.selector(false)) && parserInput.$char(')')) {
                              e = new (tree.Paren)(v);
                              parserInput.forget();
                          }
                          else {
                              parserInput.restore('Missing closing \')\'');
                          }
                      }
                      else {
                          parserInput.forget();
                      }
                  }
                  if (e) {
                      return new (tree.Element)(c, e, e instanceof tree.Variable, index, fileInfo);
                  }
              },
              //
              // Combinators combine elements together, in a Selector.
              //
              // Because our parser isn't white-space sensitive, special care
              // has to be taken, when parsing the descendant combinator, ` `,
              // as it's an empty space. We have to check the previous character
              // in the input, to see if it's a ` ` character. More info on how
              // we deal with this in *combinator.js*.
              //
              combinator: function () {
                  var c = parserInput.currentChar();
                  if (c === '/') {
                      parserInput.save();
                      var slashedCombinator = parserInput.$re(/^\/[a-z]+\//i);
                      if (slashedCombinator) {
                          parserInput.forget();
                          return new (tree.Combinator)(slashedCombinator);
                      }
                      parserInput.restore();
                  }
                  if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {
                      parserInput.i++;
                      if (c === '^' && parserInput.currentChar() === '^') {
                          c = '^^';
                          parserInput.i++;
                      }
                      while (parserInput.isWhitespace()) {
                          parserInput.i++;
                      }
                      return new (tree.Combinator)(c);
                  }
                  else if (parserInput.isWhitespace(-1)) {
                      return new (tree.Combinator)(' ');
                  }
                  else {
                      return new (tree.Combinator)(null);
                  }
              },
              //
              // A CSS Selector
              // with less extensions e.g. the ability to extend and guard
              //
              //     .class > div + h1
              //     li a:hover
              //
              // Selectors are made out of one or more Elements, see above.
              //
              selector: function (isLess) {
                  var index = parserInput.i;
                  var elements;
                  var extendList;
                  var c;
                  var e;
                  var allExtends;
                  var when;
                  var condition;
                  isLess = isLess !== false;
                  while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str('when'))) || (e = this.element())) {
                      if (when) {
                          condition = expect(this.conditions, 'expected condition');
                      }
                      else if (condition) {
                          error('CSS guard can only be used at the end of selector');
                      }
                      else if (extendList) {
                          if (allExtends) {
                              allExtends = allExtends.concat(extendList);
                          }
                          else {
                              allExtends = extendList;
                          }
                      }
                      else {
                          if (allExtends) {
                              error('Extend can only be used at the end of selector');
                          }
                          c = parserInput.currentChar();
                          if (elements) {
                              elements.push(e);
                          }
                          else {
                              elements = [e];
                          }
                          e = null;
                      }
                      if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {
                          break;
                      }
                  }
                  if (elements) {
                      return new (tree.Selector)(elements, allExtends, condition, index, fileInfo);
                  }
                  if (allExtends) {
                      error('Extend must be used to extend a selector, it cannot be used on its own');
                  }
              },
              selectors: function () {
                  var s;
                  var selectors;
                  while (true) {
                      s = this.selector();
                      if (!s) {
                          break;
                      }
                      if (selectors) {
                          selectors.push(s);
                      }
                      else {
                          selectors = [s];
                      }
                      parserInput.commentStore.length = 0;
                      if (s.condition && selectors.length > 1) {
                          error("Guards are only currently allowed on a single selector.");
                      }
                      if (!parserInput.$char(',')) {
                          break;
                      }
                      if (s.condition) {
                          error("Guards are only currently allowed on a single selector.");
                      }
                      parserInput.commentStore.length = 0;
                  }
                  return selectors;
              },
              attribute: function () {
                  if (!parserInput.$char('[')) {
                      return;
                  }
                  var entities = this.entities;
                  var key;
                  var val;
                  var op;
                  if (!(key = entities.variableCurly())) {
                      key = expect(/^(?:[_A-Za-z0-9-\*]*\|)?(?:[_A-Za-z0-9-]|\\.)+/);
                  }
                  op = parserInput.$re(/^[|~*$^]?=/);
                  if (op) {
                      val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\w-]+/) || entities.variableCurly();
                  }
                  expectChar(']');
                  return new (tree.Attribute)(key, op, val);
              },
              //
              // The `block` rule is used by `ruleset` and `mixin.definition`.
              // It's a wrapper around the `primary` rule, with added `{}`.
              //
              block: function () {
                  var content;
                  if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {
                      return content;
                  }
              },
              blockRuleset: function () {
                  var block = this.block();
                  if (block) {
                      block = new tree.Ruleset(null, block);
                  }
                  return block;
              },
              detachedRuleset: function () {
                  var argInfo;
                  var params;
                  var variadic;
                  parserInput.save();
                  if (parserInput.$re(/^[.#]\(/)) {
                      /**
                       * DR args currently only implemented for each() function, and not
                       * yet settable as `@dr: #(@arg) {}`
                       * This should be done when DRs are merged with mixins.
                       * See: https://github.com/less/less-meta/issues/16
                       */
                      argInfo = this.mixin.args(false);
                      params = argInfo.args;
                      variadic = argInfo.variadic;
                      if (!parserInput.$char(')')) {
                          parserInput.restore();
                          return;
                      }
                  }
                  var blockRuleset = this.blockRuleset();
                  if (blockRuleset) {
                      parserInput.forget();
                      if (params) {
                          return new tree.mixin.Definition(null, params, blockRuleset, null, variadic);
                      }
                      return new tree.DetachedRuleset(blockRuleset);
                  }
                  parserInput.restore();
              },
              //
              // div, .class, body > p {...}
              //
              ruleset: function () {
                  var selectors;
                  var rules;
                  var debugInfo;
                  parserInput.save();
                  if (context.dumpLineNumbers) {
                      debugInfo = getDebugInfo(parserInput.i);
                  }
                  selectors = this.selectors();
                  if (selectors && (rules = this.block())) {
                      parserInput.forget();
                      var ruleset = new (tree.Ruleset)(selectors, rules, context.strictImports);
                      if (context.dumpLineNumbers) {
                          ruleset.debugInfo = debugInfo;
                      }
                      return ruleset;
                  }
                  else {
                      parserInput.restore();
                  }
              },
              declaration: function () {
                  var name;
                  var value;
                  var index = parserInput.i;
                  var hasDR;
                  var c = parserInput.currentChar();
                  var important;
                  var merge;
                  var isVariable;
                  if (c === '.' || c === '#' || c === '&' || c === ':') {
                      return;
                  }
                  parserInput.save();
                  name = this.variable() || this.ruleProperty();
                  if (name) {
                      isVariable = typeof name === 'string';
                      if (isVariable) {
                          value = this.detachedRuleset();
                          if (value) {
                              hasDR = true;
                          }
                      }
                      parserInput.commentStore.length = 0;
                      if (!value) {
                          // a name returned by this.ruleProperty() is always an array of the form:
                          // [string-1, ..., string-n, ""] or [string-1, ..., string-n, "+"]
                          // where each item is a tree.Keyword or tree.Variable
                          merge = !isVariable && name.length > 1 && name.pop().value;
                          // Custom property values get permissive parsing
                          if (name[0].value && name[0].value.slice(0, 2) === '--') {
                              value = this.permissiveValue();
                          }
                          // Try to store values as anonymous
                          // If we need the value later we'll re-parse it in ruleset.parseValue
                          else {
                              value = this.anonymousValue();
                          }
                          if (value) {
                              parserInput.forget();
                              // anonymous values absorb the end ';' which is required for them to work
                              return new (tree.Declaration)(name, value, false, merge, index, fileInfo);
                          }
                          if (!value) {
                              value = this.value();
                          }
                          if (value) {
                              important = this.important();
                          }
                          else if (isVariable) {
                              // As a last resort, try permissiveValue
                              value = this.permissiveValue();
                          }
                      }
                      if (value && (this.end() || hasDR)) {
                          parserInput.forget();
                          return new (tree.Declaration)(name, value, important, merge, index, fileInfo);
                      }
                      else {
                          parserInput.restore();
                      }
                  }
                  else {
                      parserInput.restore();
                  }
              },
              anonymousValue: function () {
                  var index = parserInput.i;
                  var match = parserInput.$re(/^([^.#@\$+\/'"*`(;{}-]*);/);
                  if (match) {
                      return new (tree.Anonymous)(match[1], index);
                  }
              },
              /**
               * Used for custom properties, at-rules, and variables (as fallback)
               * Parses almost anything inside of {} [] () "" blocks
               * until it reaches outer-most tokens.
               *
               * First, it will try to parse comments and entities to reach
               * the end. This is mostly like the Expression parser except no
               * math is allowed.
               */
              permissiveValue: function (untilTokens) {
                  var i;
                  var e;
                  var done;
                  var value;
                  var tok = untilTokens || ';';
                  var index = parserInput.i;
                  var result = [];
                  function testCurrentChar() {
                      var char = parserInput.currentChar();
                      if (typeof tok === 'string') {
                          return char === tok;
                      }
                      else {
                          return tok.test(char);
                      }
                  }
                  if (testCurrentChar()) {
                      return;
                  }
                  value = [];
                  do {
                      e = this.comment();
                      if (e) {
                          value.push(e);
                          continue;
                      }
                      e = this.entity();
                      if (e) {
                          value.push(e);
                      }
                  } while (e);
                  done = testCurrentChar();
                  if (value.length > 0) {
                      value = new (tree.Expression)(value);
                      if (done) {
                          return value;
                      }
                      else {
                          result.push(value);
                      }
                      // Preserve space before $parseUntil as it will not
                      if (parserInput.prevChar() === ' ') {
                          result.push(new tree.Anonymous(' ', index));
                      }
                  }
                  parserInput.save();
                  value = parserInput.$parseUntil(tok);
                  if (value) {
                      if (typeof value === 'string') {
                          error("Expected '" + value + "'", 'Parse');
                      }
                      if (value.length === 1 && value[0] === ' ') {
                          parserInput.forget();
                          return new tree.Anonymous('', index);
                      }
                      var item = void 0;
                      for (i = 0; i < value.length; i++) {
                          item = value[i];
                          if (Array.isArray(item)) {
                              // Treat actual quotes as normal quoted values
                              result.push(new tree.Quoted(item[0], item[1], true, index, fileInfo));
                          }
                          else {
                              if (i === value.length - 1) {
                                  item = item.trim();
                              }
                              // Treat like quoted values, but replace vars like unquoted expressions
                              var quote = new tree.Quoted('\'', item, true, index, fileInfo);
                              quote.variableRegex = /@([\w-]+)/g;
                              quote.propRegex = /\$([\w-]+)/g;
                              result.push(quote);
                          }
                      }
                      parserInput.forget();
                      return new tree.Expression(result, true);
                  }
                  parserInput.restore();
              },
              //
              // An @import atrule
              //
              //     @import "lib";
              //
              // Depending on our environment, importing is done differently:
              // In the browser, it's an XHR request, in Node, it would be a
              // file-system operation. The function used for importing is
              // stored in `import`, which we pass to the Import constructor.
              //
              'import': function () {
                  var path;
                  var features;
                  var index = parserInput.i;
                  var dir = parserInput.$re(/^@import?\s+/);
                  if (dir) {
                      var options_1 = (dir ? this.importOptions() : null) || {};
                      if ((path = this.entities.quoted() || this.entities.url())) {
                          features = this.mediaFeatures();
                          if (!parserInput.$char(';')) {
                              parserInput.i = index;
                              error('missing semi-colon or unrecognised media features on import');
                          }
                          features = features && new (tree.Value)(features);
                          return new (tree.Import)(path, features, options_1, index, fileInfo);
                      }
                      else {
                          parserInput.i = index;
                          error('malformed import statement');
                      }
                  }
              },
              importOptions: function () {
                  var o;
                  var options = {};
                  var optionName;
                  var value;
                  // list of options, surrounded by parens
                  if (!parserInput.$char('(')) {
                      return null;
                  }
                  do {
                      o = this.importOption();
                      if (o) {
                          optionName = o;
                          value = true;
                          switch (optionName) {
                              case 'css':
                                  optionName = 'less';
                                  value = false;
                                  break;
                              case 'once':
                                  optionName = 'multiple';
                                  value = false;
                                  break;
                          }
                          options[optionName] = value;
                          if (!parserInput.$char(',')) {
                              break;
                          }
                      }
                  } while (o);
                  expectChar(')');
                  return options;
              },
              importOption: function () {
                  var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);
                  if (opt) {
                      return opt[1];
                  }
              },
              mediaFeature: function () {
                  var entities = this.entities;
                  var nodes = [];
                  var e;
                  var p;
                  parserInput.save();
                  do {
                      e = entities.keyword() || entities.variable() || entities.mixinLookup();
                      if (e) {
                          nodes.push(e);
                      }
                      else if (parserInput.$char('(')) {
                          p = this.property();
                          e = this.value();
                          if (parserInput.$char(')')) {
                              if (p && e) {
                                  nodes.push(new (tree.Paren)(new (tree.Declaration)(p, e, null, null, parserInput.i, fileInfo, true)));
                              }
                              else if (e) {
                                  nodes.push(new (tree.Paren)(e));
                              }
                              else {
                                  error('badly formed media feature definition');
                              }
                          }
                          else {
                              error('Missing closing \')\'', 'Parse');
                          }
                      }
                  } while (e);
                  parserInput.forget();
                  if (nodes.length > 0) {
                      return new (tree.Expression)(nodes);
                  }
              },
              mediaFeatures: function () {
                  var entities = this.entities;
                  var features = [];
                  var e;
                  do {
                      e = this.mediaFeature();
                      if (e) {
                          features.push(e);
                          if (!parserInput.$char(',')) {
                              break;
                          }
                      }
                      else {
                          e = entities.variable() || entities.mixinLookup();
                          if (e) {
                              features.push(e);
                              if (!parserInput.$char(',')) {
                                  break;
                              }
                          }
                      }
                  } while (e);
                  return features.length > 0 ? features : null;
              },
              media: function () {
                  var features;
                  var rules;
                  var media;
                  var debugInfo;
                  var index = parserInput.i;
                  if (context.dumpLineNumbers) {
                      debugInfo = getDebugInfo(index);
                  }
                  parserInput.save();
                  if (parserInput.$str('@media')) {
                      features = this.mediaFeatures();
                      rules = this.block();
                      if (!rules) {
                          error('media definitions require block statements after any features');
                      }
                      parserInput.forget();
                      media = new (tree.Media)(rules, features, index, fileInfo);
                      if (context.dumpLineNumbers) {
                          media.debugInfo = debugInfo;
                      }
                      return media;
                  }
                  parserInput.restore();
              },
              //
              // A @plugin directive, used to import plugins dynamically.
              //
              //     @plugin (args) "lib";
              //
              plugin: function () {
                  var path;
                  var args;
                  var options;
                  var index = parserInput.i;
                  var dir = parserInput.$re(/^@plugin?\s+/);
                  if (dir) {
                      args = this.pluginArgs();
                      if (args) {
                          options = {
                              pluginArgs: args,
                              isPlugin: true
                          };
                      }
                      else {
                          options = { isPlugin: true };
                      }
                      if ((path = this.entities.quoted() || this.entities.url())) {
                          if (!parserInput.$char(';')) {
                              parserInput.i = index;
                              error('missing semi-colon on @plugin');
                          }
                          return new (tree.Import)(path, null, options, index, fileInfo);
                      }
                      else {
                          parserInput.i = index;
                          error('malformed @plugin statement');
                      }
                  }
              },
              pluginArgs: function () {
                  // list of options, surrounded by parens
                  parserInput.save();
                  if (!parserInput.$char('(')) {
                      parserInput.restore();
                      return null;
                  }
                  var args = parserInput.$re(/^\s*([^\);]+)\)\s*/);
                  if (args[1]) {
                      parserInput.forget();
                      return args[1].trim();
                  }
                  else {
                      parserInput.restore();
                      return null;
                  }
              },
              //
              // A CSS AtRule
              //
              //     @charset "utf-8";
              //
              atrule: function () {
                  var index = parserInput.i;
                  var name;
                  var value;
                  var rules;
                  var nonVendorSpecificName;
                  var hasIdentifier;
                  var hasExpression;
                  var hasUnknown;
                  var hasBlock = true;
                  var isRooted = true;
                  if (parserInput.currentChar() !== '@') {
                      return;
                  }
                  value = this['import']() || this.plugin() || this.media();
                  if (value) {
                      return value;
                  }
                  parserInput.save();
                  name = parserInput.$re(/^@[a-z-]+/);
                  if (!name) {
                      return;
                  }
                  nonVendorSpecificName = name;
                  if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {
                      nonVendorSpecificName = "@" + name.slice(name.indexOf('-', 2) + 1);
                  }
                  switch (nonVendorSpecificName) {
                      case '@charset':
                          hasIdentifier = true;
                          hasBlock = false;
                          break;
                      case '@namespace':
                          hasExpression = true;
                          hasBlock = false;
                          break;
                      case '@keyframes':
                      case '@counter-style':
                          hasIdentifier = true;
                          break;
                      case '@document':
                      case '@supports':
                          hasUnknown = true;
                          isRooted = false;
                          break;
                      default:
                          hasUnknown = true;
                          break;
                  }
                  parserInput.commentStore.length = 0;
                  if (hasIdentifier) {
                      value = this.entity();
                      if (!value) {
                          error("expected " + name + " identifier");
                      }
                  }
                  else if (hasExpression) {
                      value = this.expression();
                      if (!value) {
                          error("expected " + name + " expression");
                      }
                  }
                  else if (hasUnknown) {
                      value = this.permissiveValue(/^[{;]/);
                      hasBlock = (parserInput.currentChar() === '{');
                      if (!value) {
                          if (!hasBlock && parserInput.currentChar() !== ';') {
                              error(name + " rule is missing block or ending semi-colon");
                          }
                      }
                      else if (!value.value) {
                          value = null;
                      }
                  }
                  if (hasBlock) {
                      rules = this.blockRuleset();
                  }
                  if (rules || (!hasBlock && value && parserInput.$char(';'))) {
                      parserInput.forget();
                      return new (tree.AtRule)(name, value, rules, index, fileInfo, context.dumpLineNumbers ? getDebugInfo(index) : null, isRooted);
                  }
                  parserInput.restore('at-rule options not recognised');
              },
              //
              // A Value is a comma-delimited list of Expressions
              //
              //     font-family: Baskerville, Georgia, serif;
              //
              // In a Rule, a Value represents everything after the `:`,
              // and before the `;`.
              //
              value: function () {
                  var e;
                  var expressions = [];
                  var index = parserInput.i;
                  do {
                      e = this.expression();
                      if (e) {
                          expressions.push(e);
                          if (!parserInput.$char(',')) {
                              break;
                          }
                      }
                  } while (e);
                  if (expressions.length > 0) {
                      return new (tree.Value)(expressions, index);
                  }
              },
              important: function () {
                  if (parserInput.currentChar() === '!') {
                      return parserInput.$re(/^! *important/);
                  }
              },
              sub: function () {
                  var a;
                  var e;
                  parserInput.save();
                  if (parserInput.$char('(')) {
                      a = this.addition();
                      if (a && parserInput.$char(')')) {
                          parserInput.forget();
                          e = new (tree.Expression)([a]);
                          e.parens = true;
                          return e;
                      }
                      parserInput.restore('Expected \')\'');
                      return;
                  }
                  parserInput.restore();
              },
              multiplication: function () {
                  var m;
                  var a;
                  var op;
                  var operation;
                  var isSpaced;
                  m = this.operand();
                  if (m) {
                      isSpaced = parserInput.isWhitespace(-1);
                      while (true) {
                          if (parserInput.peek(/^\/[*\/]/)) {
                              break;
                          }
                          parserInput.save();
                          op = parserInput.$char('/') || parserInput.$char('*') || parserInput.$str('./');
                          if (!op) {
                              parserInput.forget();
                              break;
                          }
                          a = this.operand();
                          if (!a) {
                              parserInput.restore();
                              break;
                          }
                          parserInput.forget();
                          m.parensInOp = true;
                          a.parensInOp = true;
                          operation = new (tree.Operation)(op, [operation || m, a], isSpaced);
                          isSpaced = parserInput.isWhitespace(-1);
                      }
                      return operation || m;
                  }
              },
              addition: function () {
                  var m;
                  var a;
                  var op;
                  var operation;
                  var isSpaced;
                  m = this.multiplication();
                  if (m) {
                      isSpaced = parserInput.isWhitespace(-1);
                      while (true) {
                          op = parserInput.$re(/^[-+]\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));
                          if (!op) {
                              break;
                          }
                          a = this.multiplication();
                          if (!a) {
                              break;
                          }
                          m.parensInOp = true;
                          a.parensInOp = true;
                          operation = new (tree.Operation)(op, [operation || m, a], isSpaced);
                          isSpaced = parserInput.isWhitespace(-1);
                      }
                      return operation || m;
                  }
              },
              conditions: function () {
                  var a;
                  var b;
                  var index = parserInput.i;
                  var condition;
                  a = this.condition(true);
                  if (a) {
                      while (true) {
                          if (!parserInput.peek(/^,\s*(not\s*)?\(/) || !parserInput.$char(',')) {
                              break;
                          }
                          b = this.condition(true);
                          if (!b) {
                              break;
                          }
                          condition = new (tree.Condition)('or', condition || a, b, index);
                      }
                      return condition || a;
                  }
              },
              condition: function (needsParens) {
                  var result;
                  var logical;
                  var next;
                  function or() {
                      return parserInput.$str('or');
                  }
                  result = this.conditionAnd(needsParens);
                  if (!result) {
                      return;
                  }
                  logical = or();
                  if (logical) {
                      next = this.condition(needsParens);
                      if (next) {
                          result = new (tree.Condition)(logical, result, next);
                      }
                      else {
                          return;
                      }
                  }
                  return result;
              },
              conditionAnd: function (needsParens) {
                  var result;
                  var logical;
                  var next;
                  var self = this;
                  function insideCondition() {
                      var cond = self.negatedCondition(needsParens) || self.parenthesisCondition(needsParens);
                      if (!cond && !needsParens) {
                          return self.atomicCondition(needsParens);
                      }
                      return cond;
                  }
                  function and() {
                      return parserInput.$str('and');
                  }
                  result = insideCondition();
                  if (!result) {
                      return;
                  }
                  logical = and();
                  if (logical) {
                      next = this.conditionAnd(needsParens);
                      if (next) {
                          result = new (tree.Condition)(logical, result, next);
                      }
                      else {
                          return;
                      }
                  }
                  return result;
              },
              negatedCondition: function (needsParens) {
                  if (parserInput.$str('not')) {
                      var result = this.parenthesisCondition(needsParens);
                      if (result) {
                          result.negate = !result.negate;
                      }
                      return result;
                  }
              },
              parenthesisCondition: function (needsParens) {
                  function tryConditionFollowedByParenthesis(me) {
                      var body;
                      parserInput.save();
                      body = me.condition(needsParens);
                      if (!body) {
                          parserInput.restore();
                          return;
                      }
                      if (!parserInput.$char(')')) {
                          parserInput.restore();
                          return;
                      }
                      parserInput.forget();
                      return body;
                  }
                  var body;
                  parserInput.save();
                  if (!parserInput.$str('(')) {
                      parserInput.restore();
                      return;
                  }
                  body = tryConditionFollowedByParenthesis(this);
                  if (body) {
                      parserInput.forget();
                      return body;
                  }
                  body = this.atomicCondition(needsParens);
                  if (!body) {
                      parserInput.restore();
                      return;
                  }
                  if (!parserInput.$char(')')) {
                      parserInput.restore("expected ')' got '" + parserInput.currentChar() + "'");
                      return;
                  }
                  parserInput.forget();
                  return body;
              },
              atomicCondition: function (needsParens) {
                  var entities = this.entities;
                  var index = parserInput.i;
                  var a;
                  var b;
                  var c;
                  var op;
                  function cond() {
                      return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();
                  }
                  cond = cond.bind(this);
                  a = cond();
                  if (a) {
                      if (parserInput.$char('>')) {
                          if (parserInput.$char('=')) {
                              op = '>=';
                          }
                          else {
                              op = '>';
                          }
                      }
                      else if (parserInput.$char('<')) {
                          if (parserInput.$char('=')) {
                              op = '<=';
                          }
                          else {
                              op = '<';
                          }
                      }
                      else if (parserInput.$char('=')) {
                          if (parserInput.$char('>')) {
                              op = '=>';
                          }
                          else if (parserInput.$char('<')) {
                              op = '=<';
                          }
                          else {
                              op = '=';
                          }
                      }
                      if (op) {
                          b = cond();
                          if (b) {
                              c = new (tree.Condition)(op, a, b, index, false);
                          }
                          else {
                              error('expected expression');
                          }
                      }
                      else {
                          c = new (tree.Condition)('=', a, new (tree.Keyword)('true'), index, false);
                      }
                      return c;
                  }
              },
              //
              // An operand is anything that can be part of an operation,
              // such as a Color, or a Variable
              //
              operand: function () {
                  var entities = this.entities;
                  var negate;
                  if (parserInput.peek(/^-[@\$\(]/)) {
                      negate = parserInput.$char('-');
                  }
                  var o = this.sub() || entities.dimension() ||
                      entities.color() || entities.variable() ||
                      entities.property() || entities.call() ||
                      entities.quoted(true) || entities.colorKeyword() ||
                      entities.mixinLookup();
                  if (negate) {
                      o.parensInOp = true;
                      o = new (tree.Negative)(o);
                  }
                  return o;
              },
              //
              // Expressions either represent mathematical operations,
              // or white-space delimited Entities.
              //
              //     1px solid black
              //     @var * 2
              //
              expression: function () {
                  var entities = [];
                  var e;
                  var delim;
                  var index = parserInput.i;
                  do {
                      e = this.comment();
                      if (e) {
                          entities.push(e);
                          continue;
                      }
                      e = this.addition() || this.entity();
                      if (e instanceof tree.Comment) {
                          e = null;
                      }
                      if (e) {
                          entities.push(e);
                          // operations do not allow keyword "/" dimension (e.g. small/20px) so we support that here
                          if (!parserInput.peek(/^\/[\/*]/)) {
                              delim = parserInput.$char('/');
                              if (delim) {
                                  entities.push(new (tree.Anonymous)(delim, index));
                              }
                          }
                      }
                  } while (e);
                  if (entities.length > 0) {
                      return new (tree.Expression)(entities);
                  }
              },
              property: function () {
                  var name = parserInput.$re(/^(\*?-?[_a-zA-Z0-9-]+)\s*:/);
                  if (name) {
                      return name[1];
                  }
              },
              ruleProperty: function () {
                  var name = [];
                  var index = [];
                  var s;
                  var k;
                  parserInput.save();
                  var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\s*:/);
                  if (simpleProperty) {
                      name = [new (tree.Keyword)(simpleProperty[1])];
                      parserInput.forget();
                      return name;
                  }
                  function match(re) {
                      var i = parserInput.i;
                      var chunk = parserInput.$re(re);
                      if (chunk) {
                          index.push(i);
                          return name.push(chunk[1]);
                      }
                  }
                  match(/^(\*?)/);
                  while (true) {
                      if (!match(/^((?:[\w-]+)|(?:[@\$]\{[\w-]+\}))/)) {
                          break;
                      }
                  }
                  if ((name.length > 1) && match(/^((?:\+_|\+)?)\s*:/)) {
                      parserInput.forget();
                      // at last, we have the complete match now. move forward,
                      // convert name particles to tree objects and return:
                      if (name[0] === '') {
                          name.shift();
                          index.shift();
                      }
                      for (k = 0; k < name.length; k++) {
                          s = name[k];
                          name[k] = (s.charAt(0) !== '@' && s.charAt(0) !== '$') ?
                              new (tree.Keyword)(s) :
                              (s.charAt(0) === '@' ?
                                  new (tree.Variable)("@" + s.slice(2, -1), index[k], fileInfo) :
                                  new (tree.Property)("$" + s.slice(2, -1), index[k], fileInfo));
                      }
                      return name;
                  }
                  parserInput.restore();
              }
          }
      };
  };
  Parser.serializeVars = function (vars) {
      var s = '';
      for (var name_1 in vars) {
          if (Object.hasOwnProperty.call(vars, name_1)) {
              var value = vars[name_1];
              s += ((name_1[0] === '@') ? '' : '@') + name_1 + ": " + value + ((String(value).slice(-1) === ';') ? '' : ';');
          }
      }
      return s;
  };

  function boolean(condition) {
      return condition ? Keyword.True : Keyword.False;
  }
  function If(condition, trueValue, falseValue) {
      return condition ? trueValue
          : (falseValue || new Anonymous);
  }
  var boolean$1 = { boolean: boolean, 'if': If };

  var colorFunctions;
  function clamp$1(val) {
      return Math.min(1, Math.max(0, val));
  }
  function hsla(origColor, hsl) {
      var color = colorFunctions.hsla(hsl.h, hsl.s, hsl.l, hsl.a);
      if (color) {
          if (origColor.value &&
              /^(rgb|hsl)/.test(origColor.value)) {
              color.value = origColor.value;
          }
          else {
              color.value = 'rgb';
          }
          return color;
      }
  }
  function toHSL(color) {
      if (color.toHSL) {
          return color.toHSL();
      }
      else {
          throw new Error('Argument cannot be evaluated to a color');
      }
  }
  function toHSV(color) {
      if (color.toHSV) {
          return color.toHSV();
      }
      else {
          throw new Error('Argument cannot be evaluated to a color');
      }
  }
  function number(n) {
      if (n instanceof Dimension) {
          return parseFloat(n.unit.is('%') ? n.value / 100 : n.value);
      }
      else if (typeof n === 'number') {
          return n;
      }
      else {
          throw {
              type: 'Argument',
              message: 'color functions take numbers as parameters'
          };
      }
  }
  function scaled(n, size) {
      if (n instanceof Dimension && n.unit.is('%')) {
          return parseFloat(n.value * size / 100);
      }
      else {
          return number(n);
      }
  }
  colorFunctions = {
      rgb: function (r, g, b) {
          var color = colorFunctions.rgba(r, g, b, 1.0);
          if (color) {
              color.value = 'rgb';
              return color;
          }
      },
      rgba: function (r, g, b, a) {
          try {
              if (r instanceof Color) {
                  if (g) {
                      a = number(g);
                  }
                  else {
                      a = r.alpha;
                  }
                  return new Color(r.rgb, a, 'rgba');
              }
              var rgb = [r, g, b].map(function (c) { return scaled(c, 255); });
              a = number(a);
              return new Color(rgb, a, 'rgba');
          }
          catch (e) { }
      },
      hsl: function (h, s, l) {
          var color = colorFunctions.hsla(h, s, l, 1.0);
          if (color) {
              color.value = 'hsl';
              return color;
          }
      },
      hsla: function (h, s, l, a) {
          try {
              if (h instanceof Color) {
                  if (s) {
                      a = number(s);
                  }
                  else {
                      a = h.alpha;
                  }
                  return new Color(h.rgb, a, 'hsla');
              }
              var m1_1;
              var m2_1;
              function hue(h) {
                  h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);
                  if (h * 6 < 1) {
                      return m1_1 + (m2_1 - m1_1) * h * 6;
                  }
                  else if (h * 2 < 1) {
                      return m2_1;
                  }
                  else if (h * 3 < 2) {
                      return m1_1 + (m2_1 - m1_1) * (2 / 3 - h) * 6;
                  }
                  else {
                      return m1_1;
                  }
              }
              h = (number(h) % 360) / 360;
              s = clamp$1(number(s));
              l = clamp$1(number(l));
              a = clamp$1(number(a));
              m2_1 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
              m1_1 = l * 2 - m2_1;
              var rgb = [
                  hue(h + 1 / 3) * 255,
                  hue(h) * 255,
                  hue(h - 1 / 3) * 255
              ];
              a = number(a);
              return new Color(rgb, a, 'hsla');
          }
          catch (e) { }
      },
      hsv: function (h, s, v) {
          return colorFunctions.hsva(h, s, v, 1.0);
      },
      hsva: function (h, s, v, a) {
          h = ((number(h) % 360) / 360) * 360;
          s = number(s);
          v = number(v);
          a = number(a);
          var i;
          var f;
          i = Math.floor((h / 60) % 6);
          f = (h / 60) - i;
          var vs = [v,
              v * (1 - s),
              v * (1 - f * s),
              v * (1 - (1 - f) * s)];
          var perm = [[0, 3, 1],
              [2, 0, 1],
              [1, 0, 3],
              [1, 2, 0],
              [3, 1, 0],
              [0, 1, 2]];
          return colorFunctions.rgba(vs[perm[i][0]] * 255, vs[perm[i][1]] * 255, vs[perm[i][2]] * 255, a);
      },
      hue: function (color) {
          return new Dimension(toHSL(color).h);
      },
      saturation: function (color) {
          return new Dimension(toHSL(color).s * 100, '%');
      },
      lightness: function (color) {
          return new Dimension(toHSL(color).l * 100, '%');
      },
      hsvhue: function (color) {
          return new Dimension(toHSV(color).h);
      },
      hsvsaturation: function (color) {
          return new Dimension(toHSV(color).s * 100, '%');
      },
      hsvvalue: function (color) {
          return new Dimension(toHSV(color).v * 100, '%');
      },
      red: function (color) {
          return new Dimension(color.rgb[0]);
      },
      green: function (color) {
          return new Dimension(color.rgb[1]);
      },
      blue: function (color) {
          return new Dimension(color.rgb[2]);
      },
      alpha: function (color) {
          return new Dimension(toHSL(color).a);
      },
      luma: function (color) {
          return new Dimension(color.luma() * color.alpha * 100, '%');
      },
      luminance: function (color) {
          var luminance = (0.2126 * color.rgb[0] / 255) +
              (0.7152 * color.rgb[1] / 255) +
              (0.0722 * color.rgb[2] / 255);
          return new Dimension(luminance * color.alpha * 100, '%');
      },
      saturate: function (color, amount, method) {
          // filter: saturate(3.2);
          // should be kept as is, so check for color
          if (!color.rgb) {
              return null;
          }
          var hsl = toHSL(color);
          if (typeof method !== 'undefined' && method.value === 'relative') {
              hsl.s += hsl.s * amount.value / 100;
          }
          else {
              hsl.s += amount.value / 100;
          }
          hsl.s = clamp$1(hsl.s);
          return hsla(color, hsl);
      },
      desaturate: function (color, amount, method) {
          var hsl = toHSL(color);
          if (typeof method !== 'undefined' && method.value === 'relative') {
              hsl.s -= hsl.s * amount.value / 100;
          }
          else {
              hsl.s -= amount.value / 100;
          }
          hsl.s = clamp$1(hsl.s);
          return hsla(color, hsl);
      },
      lighten: function (color, amount, method) {
          var hsl = toHSL(color);
          if (typeof method !== 'undefined' && method.value === 'relative') {
              hsl.l += hsl.l * amount.value / 100;
          }
          else {
              hsl.l += amount.value / 100;
          }
          hsl.l = clamp$1(hsl.l);
          return hsla(color, hsl);
      },
      darken: function (color, amount, method) {
          var hsl = toHSL(color);
          if (typeof method !== 'undefined' && method.value === 'relative') {
              hsl.l -= hsl.l * amount.value / 100;
          }
          else {
              hsl.l -= amount.value / 100;
          }
          hsl.l = clamp$1(hsl.l);
          return hsla(color, hsl);
      },
      fadein: function (color, amount, method) {
          var hsl = toHSL(color);
          if (typeof method !== 'undefined' && method.value === 'relative') {
              hsl.a += hsl.a * amount.value / 100;
          }
          else {
              hsl.a += amount.value / 100;
          }
          hsl.a = clamp$1(hsl.a);
          return hsla(color, hsl);
      },
      fadeout: function (color, amount, method) {
          var hsl = toHSL(color);
          if (typeof method !== 'undefined' && method.value === 'relative') {
              hsl.a -= hsl.a * amount.value / 100;
          }
          else {
              hsl.a -= amount.value / 100;
          }
          hsl.a = clamp$1(hsl.a);
          return hsla(color, hsl);
      },
      fade: function (color, amount) {
          var hsl = toHSL(color);
          hsl.a = amount.value / 100;
          hsl.a = clamp$1(hsl.a);
          return hsla(color, hsl);
      },
      spin: function (color, amount) {
          var hsl = toHSL(color);
          var hue = (hsl.h + amount.value) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return hsla(color, hsl);
      },
      //
      // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein
      // http://sass-lang.com
      //
      mix: function (color1, color2, weight) {
          if (!weight) {
              weight = new Dimension(50);
          }
          var p = weight.value / 100.0;
          var w = p * 2 - 1;
          var a = toHSL(color1).a - toHSL(color2).a;
          var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
          var w2 = 1 - w1;
          var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,
              color1.rgb[1] * w1 + color2.rgb[1] * w2,
              color1.rgb[2] * w1 + color2.rgb[2] * w2];
          var alpha = color1.alpha * p + color2.alpha * (1 - p);
          return new Color(rgb, alpha);
      },
      greyscale: function (color) {
          return colorFunctions.desaturate(color, new Dimension(100));
      },
      contrast: function (color, dark, light, threshold) {
          // filter: contrast(3.2);
          // should be kept as is, so check for color
          if (!color.rgb) {
              return null;
          }
          if (typeof light === 'undefined') {
              light = colorFunctions.rgba(255, 255, 255, 1.0);
          }
          if (typeof dark === 'undefined') {
              dark = colorFunctions.rgba(0, 0, 0, 1.0);
          }
          // Figure out which is actually light and dark:
          if (dark.luma() > light.luma()) {
              var t = light;
              light = dark;
              dark = t;
          }
          if (typeof threshold === 'undefined') {
              threshold = 0.43;
          }
          else {
              threshold = number(threshold);
          }
          if (color.luma() < threshold) {
              return light;
          }
          else {
              return dark;
          }
      },
      // Changes made in 2.7.0 - Reverted in 3.0.0
      // contrast: function (color, color1, color2, threshold) {
      //     // Return which of `color1` and `color2` has the greatest contrast with `color`
      //     // according to the standard WCAG contrast ratio calculation.
      //     // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
      //     // The threshold param is no longer used, in line with SASS.
      //     // filter: contrast(3.2);
      //     // should be kept as is, so check for color
      //     if (!color.rgb) {
      //         return null;
      //     }
      //     if (typeof color1 === 'undefined') {
      //         color1 = colorFunctions.rgba(0, 0, 0, 1.0);
      //     }
      //     if (typeof color2 === 'undefined') {
      //         color2 = colorFunctions.rgba(255, 255, 255, 1.0);
      //     }
      //     var contrast1, contrast2;
      //     var luma = color.luma();
      //     var luma1 = color1.luma();
      //     var luma2 = color2.luma();
      //     // Calculate contrast ratios for each color
      //     if (luma > luma1) {
      //         contrast1 = (luma + 0.05) / (luma1 + 0.05);
      //     } else {
      //         contrast1 = (luma1 + 0.05) / (luma + 0.05);
      //     }
      //     if (luma > luma2) {
      //         contrast2 = (luma + 0.05) / (luma2 + 0.05);
      //     } else {
      //         contrast2 = (luma2 + 0.05) / (luma + 0.05);
      //     }
      //     if (contrast1 > contrast2) {
      //         return color1;
      //     } else {
      //         return color2;
      //     }
      // },
      argb: function (color) {
          return new Anonymous(color.toARGB());
      },
      color: function (c) {
          if ((c instanceof Quoted) &&
              (/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})$/i.test(c.value))) {
              var val = c.value.slice(1);
              return new Color(val, undefined, "#" + val);
          }
          if ((c instanceof Color) || (c = Color.fromKeyword(c.value))) {
              c.value = undefined;
              return c;
          }
          throw {
              type: 'Argument',
              message: 'argument must be a color keyword or 3|4|6|8 digit hex e.g. #FFF'
          };
      },
      tint: function (color, amount) {
          return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount);
      },
      shade: function (color, amount) {
          return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount);
      }
  };
  var color = colorFunctions;

  // Color Blending
  // ref: http://www.w3.org/TR/compositing-1
  function colorBlend(mode, color1, color2) {
      var ab = color1.alpha; // result
      var // backdrop
      cb;
      var as = color2.alpha;
      var // source
      cs;
      var ar;
      var cr;
      var r = [];
      ar = as + ab * (1 - as);
      for (var i_1 = 0; i_1 < 3; i_1++) {
          cb = color1.rgb[i_1] / 255;
          cs = color2.rgb[i_1] / 255;
          cr = mode(cb, cs);
          if (ar) {
              cr = (as * cs + ab * (cb -
                  as * (cb + cs - cr))) / ar;
          }
          r[i_1] = cr * 255;
      }
      return new Color(r, ar);
  }
  var colorBlendModeFunctions = {
      multiply: function (cb, cs) {
          return cb * cs;
      },
      screen: function (cb, cs) {
          return cb + cs - cb * cs;
      },
      overlay: function (cb, cs) {
          cb *= 2;
          return (cb <= 1) ?
              colorBlendModeFunctions.multiply(cb, cs) :
              colorBlendModeFunctions.screen(cb - 1, cs);
      },
      softlight: function (cb, cs) {
          var d = 1;
          var e = cb;
          if (cs > 0.5) {
              e = 1;
              d = (cb > 0.25) ? Math.sqrt(cb)
                  : ((16 * cb - 12) * cb + 4) * cb;
          }
          return cb - (1 - 2 * cs) * e * (d - cb);
      },
      hardlight: function (cb, cs) {
          return colorBlendModeFunctions.overlay(cs, cb);
      },
      difference: function (cb, cs) {
          return Math.abs(cb - cs);
      },
      exclusion: function (cb, cs) {
          return cb + cs - 2 * cb * cs;
      },
      // non-w3c functions:
      average: function (cb, cs) {
          return (cb + cs) / 2;
      },
      negation: function (cb, cs) {
          return 1 - Math.abs(cb + cs - 1);
      }
  };
  for (var f in colorBlendModeFunctions) {
      if (colorBlendModeFunctions.hasOwnProperty(f)) {
          colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f]);
      }
  }

  var dataUri = (function (environment) {
      var fallback = function (functionThis, node) { return new URL(node, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context); };
      return { 'data-uri': function (mimetypeNode, filePathNode) {
              if (!filePathNode) {
                  filePathNode = mimetypeNode;
                  mimetypeNode = null;
              }
              var mimetype = mimetypeNode && mimetypeNode.value;
              var filePath = filePathNode.value;
              var currentFileInfo = this.currentFileInfo;
              var currentDirectory = currentFileInfo.rewriteUrls ?
                  currentFileInfo.currentDirectory : currentFileInfo.entryPath;
              var fragmentStart = filePath.indexOf('#');
              var fragment = '';
              if (fragmentStart !== -1) {
                  fragment = filePath.slice(fragmentStart);
                  filePath = filePath.slice(0, fragmentStart);
              }
              var context = clone(this.context);
              context.rawBuffer = true;
              var fileManager = environment.getFileManager(filePath, currentDirectory, context, environment, true);
              if (!fileManager) {
                  return fallback(this, filePathNode);
              }
              var useBase64 = false;
              // detect the mimetype if not given
              if (!mimetypeNode) {
                  mimetype = environment.mimeLookup(filePath);
                  if (mimetype === 'image/svg+xml') {
                      useBase64 = false;
                  }
                  else {
                      // use base 64 unless it's an ASCII or UTF-8 format
                      var charset = environment.charsetLookup(mimetype);
                      useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0;
                  }
                  if (useBase64) {
                      mimetype += ';base64';
                  }
              }
              else {
                  useBase64 = /;base64$/.test(mimetype);
              }
              var fileSync = fileManager.loadFileSync(filePath, currentDirectory, context, environment);
              if (!fileSync.contents) {
                  logger.warn("Skipped data-uri embedding of " + filePath + " because file not found");
                  return fallback(this, filePathNode || mimetypeNode);
              }
              var buf = fileSync.contents;
              if (useBase64 && !environment.encodeBase64) {
                  return fallback(this, filePathNode);
              }
              buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);
              var uri = "data:" + mimetype + "," + buf + fragment;
              return new URL(new Quoted("\"" + uri + "\"", uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
          } };
  });

  var getItemsFromNode = function (node) {
      // handle non-array values as an array of length 1
      // return 'undefined' if index is invalid
      var items = Array.isArray(node.value) ?
          node.value : Array(node);
      return items;
  };
  var list = {
      _SELF: function (n) {
          return n;
      },
      extract: function (values, index) {
          // (1-based index)
          index = index.value - 1;
          return getItemsFromNode(values)[index];
      },
      length: function (values) {
          return new Dimension(getItemsFromNode(values).length);
      },
      /**
       * Creates a Less list of incremental values.
       * Modeled after Lodash's range function, also exists natively in PHP
       *
       * @param {Dimension} [start=1]
       * @param {Dimension} end  - e.g. 10 or 10px - unit is added to output
       * @param {Dimension} [step=1]
       */
      range: function (start, end, step) {
          var from;
          var to;
          var stepValue = 1;
          var list = [];
          if (end) {
              to = end;
              from = start.value;
              if (step) {
                  stepValue = step.value;
              }
          }
          else {
              from = 1;
              to = start;
          }
          for (var i_1 = from; i_1 <= to.value; i_1 += stepValue) {
              list.push(new Dimension(i_1, to.unit));
          }
          return new Expression(list);
      },
      each: function (list, rs) {
          var rules = [];
          var newRules;
          var iterator;
          if (list.value && !(list instanceof Quoted)) {
              if (Array.isArray(list.value)) {
                  iterator = list.value;
              }
              else {
                  iterator = [list.value];
              }
          }
          else if (list.ruleset) {
              iterator = list.ruleset.rules;
          }
          else if (list.rules) {
              iterator = list.rules;
          }
          else if (Array.isArray(list)) {
              iterator = list;
          }
          else {
              iterator = [list];
          }
          var valueName = '@value';
          var keyName = '@key';
          var indexName = '@index';
          if (rs.params) {
              valueName = rs.params[0] && rs.params[0].name;
              keyName = rs.params[1] && rs.params[1].name;
              indexName = rs.params[2] && rs.params[2].name;
              rs = rs.rules;
          }
          else {
              rs = rs.ruleset;
          }
          for (var i_2 = 0; i_2 < iterator.length; i_2++) {
              var key = void 0;
              var value = void 0;
              var item = iterator[i_2];
              if (item instanceof Declaration) {
                  key = typeof item.name === 'string' ? item.name : item.name[0].value;
                  value = item.value;
              }
              else {
                  key = new Dimension(i_2 + 1);
                  value = item;
              }
              if (item instanceof Comment) {
                  continue;
              }
              newRules = rs.rules.slice(0);
              if (valueName) {
                  newRules.push(new Declaration(valueName, value, false, false, this.index, this.currentFileInfo));
              }
              if (indexName) {
                  newRules.push(new Declaration(indexName, new Dimension(i_2 + 1), false, false, this.index, this.currentFileInfo));
              }
              if (keyName) {
                  newRules.push(new Declaration(keyName, key, false, false, this.index, this.currentFileInfo));
              }
              rules.push(new Ruleset([new (Selector)([new Element("", '&')])], newRules, rs.strictImports, rs.visibilityInfo()));
          }
          return new Ruleset([new (Selector)([new Element("", '&')])], rules, rs.strictImports, rs.visibilityInfo()).eval(this.context);
      }
  };

  var MathHelper = function (fn, unit, n) {
      if (!(n instanceof Dimension)) {
          throw { type: 'Argument', message: 'argument must be a number' };
      }
      if (unit == null) {
          unit = n.unit;
      }
      else {
          n = n.unify();
      }
      return new Dimension(fn(parseFloat(n.value)), unit);
  };

  var mathFunctions = {
      // name,  unit
      ceil: null,
      floor: null,
      sqrt: null,
      abs: null,
      tan: '',
      sin: '',
      cos: '',
      atan: 'rad',
      asin: 'rad',
      acos: 'rad'
  };
  for (var f$1 in mathFunctions) {
      if (mathFunctions.hasOwnProperty(f$1)) {
          mathFunctions[f$1] = MathHelper.bind(null, Math[f$1], mathFunctions[f$1]);
      }
  }
  mathFunctions.round = function (n, f) {
      var fraction = typeof f === 'undefined' ? 0 : f.value;
      return MathHelper(function (num) { return num.toFixed(fraction); }, null, n);
  };

  var minMax = function (isMin, args) {
      args = Array.prototype.slice.call(args);
      switch (args.length) {
          case 0: throw { type: 'Argument', message: 'one or more arguments required' };
      }
      var i; // key is the unit.toString() for unified Dimension values,
      var j;
      var current;
      var currentUnified;
      var referenceUnified;
      var unit;
      var unitStatic;
      var unitClone;
      var // elems only contains original argument values.
      order = [];
      var values = {};
      // value is the index into the order array.
      for (i = 0; i < args.length; i++) {
          current = args[i];
          if (!(current instanceof Dimension)) {
              if (Array.isArray(args[i].value)) {
                  Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));
              }
              continue;
          }
          currentUnified = current.unit.toString() === '' && unitClone !== undefined ? new Dimension(current.value, unitClone).unify() : current.unify();
          unit = currentUnified.unit.toString() === '' && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();
          unitStatic = unit !== '' && unitStatic === undefined || unit !== '' && order[0].unify().unit.toString() === '' ? unit : unitStatic;
          unitClone = unit !== '' && unitClone === undefined ? current.unit.toString() : unitClone;
          j = values[''] !== undefined && unit !== '' && unit === unitStatic ? values[''] : values[unit];
          if (j === undefined) {
              if (unitStatic !== undefined && unit !== unitStatic) {
                  throw { type: 'Argument', message: 'incompatible types' };
              }
              values[unit] = order.length;
              order.push(current);
              continue;
          }
          referenceUnified = order[j].unit.toString() === '' && unitClone !== undefined ? new Dimension(order[j].value, unitClone).unify() : order[j].unify();
          if (isMin && currentUnified.value < referenceUnified.value ||
              !isMin && currentUnified.value > referenceUnified.value) {
              order[j] = current;
          }
      }
      if (order.length == 1) {
          return order[0];
      }
      args = order.map(function (a) { return a.toCSS(this.context); }).join(this.context.compress ? ',' : ', ');
      return new Anonymous((isMin ? 'min' : 'max') + "(" + args + ")");
  };
  var number$1 = {
      min: function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return minMax(true, args);
      },
      max: function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return minMax(false, args);
      },
      convert: function (val, unit) {
          return val.convertTo(unit.value);
      },
      pi: function () {
          return new Dimension(Math.PI);
      },
      mod: function (a, b) {
          return new Dimension(a.value % b.value, a.unit);
      },
      pow: function (x, y) {
          if (typeof x === 'number' && typeof y === 'number') {
              x = new Dimension(x);
              y = new Dimension(y);
          }
          else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {
              throw { type: 'Argument', message: 'arguments must be numbers' };
          }
          return new Dimension(Math.pow(x.value, y.value), x.unit);
      },
      percentage: function (n) {
          var result = MathHelper(function (num) { return num * 100; }, '%', n);
          return result;
      }
  };

  var string = {
      e: function (str) {
          return new Quoted('"', str instanceof JavaScript ? str.evaluated : str.value, true);
      },
      escape: function (str) {
          return new Anonymous(encodeURI(str.value).replace(/=/g, '%3D').replace(/:/g, '%3A').replace(/#/g, '%23').replace(/;/g, '%3B')
              .replace(/\(/g, '%28').replace(/\)/g, '%29'));
      },
      replace: function (string, pattern, replacement, flags) {
          var result = string.value;
          replacement = (replacement.type === 'Quoted') ?
              replacement.value : replacement.toCSS();
          result = result.replace(new RegExp(pattern.value, flags ? flags.value : ''), replacement);
          return new Quoted(string.quote || '', result, string.escaped);
      },
      '%': function (string /* arg, arg, ... */) {
          var args = Array.prototype.slice.call(arguments, 1);
          var result = string.value;
          var _loop_1 = function (i_1) {
              /* jshint loopfunc:true */
              result = result.replace(/%[sda]/i, function (token) {
                  var value = ((args[i_1].type === 'Quoted') &&
                      token.match(/s/i)) ? args[i_1].value : args[i_1].toCSS();
                  return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;
              });
          };
          for (var i_1 = 0; i_1 < args.length; i_1++) {
              _loop_1(i_1);
          }
          result = result.replace(/%%/g, '%');
          return new Quoted(string.quote || '', result, string.escaped);
      }
  };

  var svg = (function (environment) {
      return { 'svg-gradient': function (direction) {
              var stops;
              var gradientDirectionSvg;
              var gradientType = 'linear';
              var rectangleDimension = 'x="0" y="0" width="1" height="1"';
              var renderEnv = { compress: false };
              var returner;
              var directionValue = direction.toCSS(renderEnv);
              var i;
              var color;
              var position;
              var positionValue;
              var alpha;
              function throwArgumentDescriptor() {
                  throw { type: 'Argument',
                      message: 'svg-gradient expects direction, start_color [start_position], [color position,]...,' +
                          ' end_color [end_position] or direction, color list' };
              }
              if (arguments.length == 2) {
                  if (arguments[1].value.length < 2) {
                      throwArgumentDescriptor();
                  }
                  stops = arguments[1].value;
              }
              else if (arguments.length < 3) {
                  throwArgumentDescriptor();
              }
              else {
                  stops = Array.prototype.slice.call(arguments, 1);
              }
              switch (directionValue) {
                  case 'to bottom':
                      gradientDirectionSvg = 'x1="0%" y1="0%" x2="0%" y2="100%"';
                      break;
                  case 'to right':
                      gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="0%"';
                      break;
                  case 'to bottom right':
                      gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="100%"';
                      break;
                  case 'to top right':
                      gradientDirectionSvg = 'x1="0%" y1="100%" x2="100%" y2="0%"';
                      break;
                  case 'ellipse':
                  case 'ellipse at center':
                      gradientType = 'radial';
                      gradientDirectionSvg = 'cx="50%" cy="50%" r="75%"';
                      rectangleDimension = 'x="-50" y="-50" width="101" height="101"';
                      break;
                  default:
                      throw { type: 'Argument', message: 'svg-gradient direction must be \'to bottom\', \'to right\',' +
                              ' \'to bottom right\', \'to top right\' or \'ellipse at center\'' };
              }
              returner = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"><" + gradientType + "Gradient id=\"g\" " + gradientDirectionSvg + ">";
              for (i = 0; i < stops.length; i += 1) {
                  if (stops[i] instanceof Expression) {
                      color = stops[i].value[0];
                      position = stops[i].value[1];
                  }
                  else {
                      color = stops[i];
                      position = undefined;
                  }
                  if (!(color instanceof Color) || (!((i === 0 || i + 1 === stops.length) && position === undefined) && !(position instanceof Dimension))) {
                      throwArgumentDescriptor();
                  }
                  positionValue = position ? position.toCSS(renderEnv) : i === 0 ? '0%' : '100%';
                  alpha = color.alpha;
                  returner += "<stop offset=\"" + positionValue + "\" stop-color=\"" + color.toRGB() + "\"" + (alpha < 1 ? " stop-opacity=\"" + alpha + "\"" : '') + "/>";
              }
              returner += "</" + gradientType + "Gradient><rect " + rectangleDimension + " fill=\"url(#g)\" /></svg>";
              returner = encodeURIComponent(returner);
              returner = "data:image/svg+xml," + returner;
              return new URL(new Quoted("'" + returner + "'", returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
          } };
  });

  var isa = function (n, Type) { return (n instanceof Type) ? Keyword.True : Keyword.False; };
  var isunit = function (n, unit) {
      if (unit === undefined) {
          throw { type: 'Argument', message: 'missing the required second argument to isunit.' };
      }
      unit = typeof unit.value === 'string' ? unit.value : unit;
      if (typeof unit !== 'string') {
          throw { type: 'Argument', message: 'Second argument to isunit should be a unit or a string.' };
      }
      return (n instanceof Dimension) && n.unit.is(unit) ? Keyword.True : Keyword.False;
  };
  var types = {
      isruleset: function (n) {
          return isa(n, DetachedRuleset);
      },
      iscolor: function (n) {
          return isa(n, Color);
      },
      isnumber: function (n) {
          return isa(n, Dimension);
      },
      isstring: function (n) {
          return isa(n, Quoted);
      },
      iskeyword: function (n) {
          return isa(n, Keyword);
      },
      isurl: function (n) {
          return isa(n, URL);
      },
      ispixel: function (n) {
          return isunit(n, 'px');
      },
      ispercentage: function (n) {
          return isunit(n, '%');
      },
      isem: function (n) {
          return isunit(n, 'em');
      },
      isunit: isunit,
      unit: function (val, unit) {
          if (!(val instanceof Dimension)) {
              throw { type: 'Argument',
                  message: "the first argument to unit must be a number" + (val instanceof Operation ? '. Have you forgotten parenthesis?' : '') };
          }
          if (unit) {
              if (unit instanceof Keyword) {
                  unit = unit.value;
              }
              else {
                  unit = unit.toCSS();
              }
          }
          else {
              unit = '';
          }
          return new Dimension(val.value, unit);
      },
      'get-unit': function (n) {
          return new Anonymous(n.unit);
      }
  };

  var Functions = (function (environment) {
      var functions = { functionRegistry: functionRegistry, functionCaller: functionCaller };
      // register functions
      functionRegistry.addMultiple(boolean$1);
      functionRegistry.add('default', defaultFunc.eval.bind(defaultFunc));
      functionRegistry.addMultiple(color);
      functionRegistry.addMultiple(colorBlend);
      functionRegistry.addMultiple(dataUri(environment));
      functionRegistry.addMultiple(list);
      functionRegistry.addMultiple(mathFunctions);
      functionRegistry.addMultiple(number$1);
      functionRegistry.addMultiple(string);
      functionRegistry.addMultiple(svg());
      functionRegistry.addMultiple(types);
      return functions;
  });

  var sourceMapOutput = (function (environment) {
      var SourceMapOutput = /** @class */ (function () {
          function SourceMapOutput(options) {
              this._css = [];
              this._rootNode = options.rootNode;
              this._contentsMap = options.contentsMap;
              this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap;
              if (options.sourceMapFilename) {
                  this._sourceMapFilename = options.sourceMapFilename.replace(/\\/g, '/');
              }
              this._outputFilename = options.outputFilename;
              this.sourceMapURL = options.sourceMapURL;
              if (options.sourceMapBasepath) {
                  this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\/g, '/');
              }
              if (options.sourceMapRootpath) {
                  this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\/g, '/');
                  if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== '/') {
                      this._sourceMapRootpath += '/';
                  }
              }
              else {
                  this._sourceMapRootpath = '';
              }
              this._outputSourceFiles = options.outputSourceFiles;
              this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();
              this._lineNumber = 0;
              this._column = 0;
          }
          SourceMapOutput.prototype.removeBasepath = function (path) {
              if (this._sourceMapBasepath && path.indexOf(this._sourceMapBasepath) === 0) {
                  path = path.substring(this._sourceMapBasepath.length);
                  if (path.charAt(0) === '\\' || path.charAt(0) === '/') {
                      path = path.substring(1);
                  }
              }
              return path;
          };
          SourceMapOutput.prototype.normalizeFilename = function (filename) {
              filename = filename.replace(/\\/g, '/');
              filename = this.removeBasepath(filename);
              return (this._sourceMapRootpath || '') + filename;
          };
          SourceMapOutput.prototype.add = function (chunk, fileInfo, index, mapLines) {
              // ignore adding empty strings
              if (!chunk) {
                  return;
              }
              var lines;
              var sourceLines;
              var columns;
              var sourceColumns;
              var i;
              if (fileInfo && fileInfo.filename) {
                  var inputSource = this._contentsMap[fileInfo.filename];
                  // remove vars/banner added to the top of the file
                  if (this._contentsIgnoredCharsMap[fileInfo.filename]) {
                      // adjust the index
                      index -= this._contentsIgnoredCharsMap[fileInfo.filename];
                      if (index < 0) {
                          index = 0;
                      }
                      // adjust the source
                      inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);
                  }
                  // ignore empty content
                  if (inputSource === undefined) {
                      return;
                  }
                  inputSource = inputSource.substring(0, index);
                  sourceLines = inputSource.split('\n');
                  sourceColumns = sourceLines[sourceLines.length - 1];
              }
              lines = chunk.split('\n');
              columns = lines[lines.length - 1];
              if (fileInfo && fileInfo.filename) {
                  if (!mapLines) {
                      this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + 1, column: this._column },
                          original: { line: sourceLines.length, column: sourceColumns.length },
                          source: this.normalizeFilename(fileInfo.filename) });
                  }
                  else {
                      for (i = 0; i < lines.length; i++) {
                          this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + i + 1, column: i === 0 ? this._column : 0 },
                              original: { line: sourceLines.length + i, column: i === 0 ? sourceColumns.length : 0 },
                              source: this.normalizeFilename(fileInfo.filename) });
                      }
                  }
              }
              if (lines.length === 1) {
                  this._column += columns.length;
              }
              else {
                  this._lineNumber += lines.length - 1;
                  this._column = columns.length;
              }
              this._css.push(chunk);
          };
          SourceMapOutput.prototype.isEmpty = function () {
              return this._css.length === 0;
          };
          SourceMapOutput.prototype.toCSS = function (context) {
              this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });
              if (this._outputSourceFiles) {
                  for (var filename in this._contentsMap) {
                      if (this._contentsMap.hasOwnProperty(filename)) {
                          var source = this._contentsMap[filename];
                          if (this._contentsIgnoredCharsMap[filename]) {
                              source = source.slice(this._contentsIgnoredCharsMap[filename]);
                          }
                          this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);
                      }
                  }
              }
              this._rootNode.genCSS(context, this);
              if (this._css.length > 0) {
                  var sourceMapURL = void 0;
                  var sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());
                  if (this.sourceMapURL) {
                      sourceMapURL = this.sourceMapURL;
                  }
                  else if (this._sourceMapFilename) {
                      sourceMapURL = this._sourceMapFilename;
                  }
                  this.sourceMapURL = sourceMapURL;
                  this.sourceMap = sourceMapContent;
              }
              return this._css.join('');
          };
          return SourceMapOutput;
      }());
      return SourceMapOutput;
  });

  var sourceMapBuilder = (function (SourceMapOutput, environment) {
      var SourceMapBuilder = /** @class */ (function () {
          function SourceMapBuilder(options) {
              this.options = options;
          }
          SourceMapBuilder.prototype.toCSS = function (rootNode, options, imports) {
              var sourceMapOutput = new SourceMapOutput({
                  contentsIgnoredCharsMap: imports.contentsIgnoredChars,
                  rootNode: rootNode,
                  contentsMap: imports.contents,
                  sourceMapFilename: this.options.sourceMapFilename,
                  sourceMapURL: this.options.sourceMapURL,
                  outputFilename: this.options.sourceMapOutputFilename,
                  sourceMapBasepath: this.options.sourceMapBasepath,
                  sourceMapRootpath: this.options.sourceMapRootpath,
                  outputSourceFiles: this.options.outputSourceFiles,
                  sourceMapGenerator: this.options.sourceMapGenerator,
                  sourceMapFileInline: this.options.sourceMapFileInline
              });
              var css = sourceMapOutput.toCSS(options);
              this.sourceMap = sourceMapOutput.sourceMap;
              this.sourceMapURL = sourceMapOutput.sourceMapURL;
              if (this.options.sourceMapInputFilename) {
                  this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);
              }
              if (this.options.sourceMapBasepath !== undefined && this.sourceMapURL !== undefined) {
                  this.sourceMapURL = sourceMapOutput.removeBasepath(this.sourceMapURL);
              }
              return css + this.getCSSAppendage();
          };
          SourceMapBuilder.prototype.getCSSAppendage = function () {
              var sourceMapURL = this.sourceMapURL;
              if (this.options.sourceMapFileInline) {
                  if (this.sourceMap === undefined) {
                      return '';
                  }
                  sourceMapURL = "data:application/json;base64," + environment.encodeBase64(this.sourceMap);
              }
              if (sourceMapURL) {
                  return "/*# sourceMappingURL=" + sourceMapURL + " */";
              }
              return '';
          };
          SourceMapBuilder.prototype.getExternalSourceMap = function () {
              return this.sourceMap;
          };
          SourceMapBuilder.prototype.setExternalSourceMap = function (sourceMap) {
              this.sourceMap = sourceMap;
          };
          SourceMapBuilder.prototype.isInline = function () {
              return this.options.sourceMapFileInline;
          };
          SourceMapBuilder.prototype.getSourceMapURL = function () {
              return this.sourceMapURL;
          };
          SourceMapBuilder.prototype.getOutputFilename = function () {
              return this.options.sourceMapOutputFilename;
          };
          SourceMapBuilder.prototype.getInputFilename = function () {
              return this.sourceMapInputFilename;
          };
          return SourceMapBuilder;
      }());
      return SourceMapBuilder;
  });

  var transformTree = (function (root, options) {
      if (options === void 0) { options = {}; }
      var evaldRoot;
      var variables = options.variables;
      var evalEnv = new contexts.Eval(options);
      //
      // Allows setting variables with a hash, so:
      //
      //   `{ color: new tree.Color('#f01') }` will become:
      //
      //   new tree.Declaration('@color',
      //     new tree.Value([
      //       new tree.Expression([
      //         new tree.Color('#f01')
      //       ])
      //     ])
      //   )
      //
      if (typeof variables === 'object' && !Array.isArray(variables)) {
          variables = Object.keys(variables).map(function (k) {
              var value = variables[k];
              if (!(value instanceof tree.Value)) {
                  if (!(value instanceof tree.Expression)) {
                      value = new tree.Expression([value]);
                  }
                  value = new tree.Value([value]);
              }
              return new tree.Declaration("@" + k, value, false, null, 0);
          });
          evalEnv.frames = [new tree.Ruleset(null, variables)];
      }
      var visitors$1 = [
          new visitors.JoinSelectorVisitor(),
          new visitors.MarkVisibleSelectorsVisitor(true),
          new visitors.ExtendVisitor(),
          new visitors.ToCSSVisitor({ compress: Boolean(options.compress) })
      ];
      var preEvalVisitors = [];
      var v;
      var visitorIterator;
      /**
       * first() / get() allows visitors to be added while visiting
       *
       * @todo Add scoping for visitors just like functions for @plugin; right now they're global
       */
      if (options.pluginManager) {
          visitorIterator = options.pluginManager.visitor();
          for (var i = 0; i < 2; i++) {
              visitorIterator.first();
              while ((v = visitorIterator.get())) {
                  if (v.isPreEvalVisitor) {
                      if (i === 0 || preEvalVisitors.indexOf(v) === -1) {
                          preEvalVisitors.push(v);
                          v.run(root);
                      }
                  }
                  else {
                      if (i === 0 || visitors$1.indexOf(v) === -1) {
                          if (v.isPreVisitor) {
                              visitors$1.unshift(v);
                          }
                          else {
                              visitors$1.push(v);
                          }
                      }
                  }
              }
          }
      }
      evaldRoot = root.eval(evalEnv);
      for (var i = 0; i < visitors$1.length; i++) {
          visitors$1[i].run(evaldRoot);
      }
      // Run any remaining visitors added after eval pass
      if (options.pluginManager) {
          visitorIterator.first();
          while ((v = visitorIterator.get())) {
              if (visitors$1.indexOf(v) === -1 && preEvalVisitors.indexOf(v) === -1) {
                  v.run(evaldRoot);
              }
          }
      }
      return evaldRoot;
  });

  var parseTree = (function (SourceMapBuilder) {
      var ParseTree = /** @class */ (function () {
          function ParseTree(root, imports) {
              this.root = root;
              this.imports = imports;
          }
          ParseTree.prototype.toCSS = function (options) {
              var evaldRoot;
              var result = {};
              var sourceMapBuilder;
              try {
                  evaldRoot = transformTree(this.root, options);
              }
              catch (e) {
                  throw new LessError(e, this.imports);
              }
              try {
                  var compress = Boolean(options.compress);
                  if (compress) {
                      logger.warn('The compress option has been deprecated. ' +
                          'We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.');
                  }
                  var toCSSOptions = {
                      compress: compress,
                      dumpLineNumbers: options.dumpLineNumbers,
                      strictUnits: Boolean(options.strictUnits),
                      numPrecision: 8
                  };
                  if (options.sourceMap) {
                      sourceMapBuilder = new SourceMapBuilder(options.sourceMap);
                      result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);
                  }
                  else {
                      result.css = evaldRoot.toCSS(toCSSOptions);
                  }
              }
              catch (e) {
                  throw new LessError(e, this.imports);
              }
              if (options.pluginManager) {
                  var postProcessors = options.pluginManager.getPostProcessors();
                  for (var i_1 = 0; i_1 < postProcessors.length; i_1++) {
                      result.css = postProcessors[i_1].process(result.css, { sourceMap: sourceMapBuilder, options: options, imports: this.imports });
                  }
              }
              if (options.sourceMap) {
                  result.map = sourceMapBuilder.getExternalSourceMap();
              }
              var rootFilename = this.imports.rootFilename;
              result.imports = this.imports.files.filter(function (file) { return file !== rootFilename; });
              return result;
          };
          return ParseTree;
      }());
      return ParseTree;
  });

  var importManager = (function (environment) {
      // FileInfo = {
      //  'rewriteUrls' - option - whether to adjust URL's to be relative
      //  'filename' - full resolved filename of current file
      //  'rootpath' - path to append to normal URLs for this node
      //  'currentDirectory' - path to the current file, absolute
      //  'rootFilename' - filename of the base file
      //  'entryPath' - absolute path to the entry file
      //  'reference' - whether the file should not be output and only output parts that are referenced
      var ImportManager = /** @class */ (function () {
          function ImportManager(less, context, rootFileInfo) {
              this.less = less;
              this.rootFilename = rootFileInfo.filename;
              this.paths = context.paths || []; // Search paths, when importing
              this.contents = {}; // map - filename to contents of all the files
              this.contentsIgnoredChars = {}; // map - filename to lines at the beginning of each file to ignore
              this.mime = context.mime;
              this.error = null;
              this.context = context;
              // Deprecated? Unused outside of here, could be useful.
              this.queue = []; // Files which haven't been imported yet
              this.files = []; // List of files imported
          }
          /**
           * Add an import to be imported
           * @param path - the raw path
           * @param tryAppendExtension - whether to try appending a file extension (.less or .js if the path has no extension)
           * @param currentFileInfo - the current file info (used for instance to work out relative paths)
           * @param importOptions - import options
           * @param callback - callback for when it is imported
           */
          ImportManager.prototype.push = function (path, tryAppendExtension, currentFileInfo, importOptions, callback) {
              var importManager = this;
              var pluginLoader = this.context.pluginManager.Loader;
              this.queue.push(path);
              var fileParsedFunc = function (e, root, fullPath) {
                  importManager.queue.splice(importManager.queue.indexOf(path), 1); // Remove the path from the queue
                  var importedEqualsRoot = fullPath === importManager.rootFilename;
                  if (importOptions.optional && e) {
                      callback(null, { rules: [] }, false, null);
                      logger.info("The file " + fullPath + " was skipped because it was not found and the import was marked optional.");
                  }
                  else {
                      var files = importManager.files;
                      if (files.indexOf(fullPath) === -1) {
                          files.push(fullPath);
                      }
                      if (e && !importManager.error) {
                          importManager.error = e;
                      }
                      callback(e, root, importedEqualsRoot, fullPath);
                  }
              };
              var newFileInfo = {
                  rewriteUrls: this.context.rewriteUrls,
                  entryPath: currentFileInfo.entryPath,
                  rootpath: currentFileInfo.rootpath,
                  rootFilename: currentFileInfo.rootFilename
              };
              var fileManager = environment.getFileManager(path, currentFileInfo.currentDirectory, this.context, environment);
              if (!fileManager) {
                  fileParsedFunc({ message: "Could not find a file-manager for " + path });
                  return;
              }
              var loadFileCallback = function (loadedFile) {
                  var plugin;
                  var resolvedFilename = loadedFile.filename;
                  var contents = loadedFile.contents.replace(/^\uFEFF/, '');
                  // Pass on an updated rootpath if path of imported file is relative and file
                  // is in a (sub|sup) directory
                  //
                  // Examples:
                  // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',
                  //   then rootpath should become 'less/module/nav/'
                  // - If path of imported file is '../mixins.less' and rootpath is 'less/',
                  //   then rootpath should become 'less/../'
                  newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);
                  if (newFileInfo.rewriteUrls) {
                      newFileInfo.rootpath = fileManager.join((importManager.context.rootpath || ''), fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));
                      if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {
                          newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);
                      }
                  }
                  newFileInfo.filename = resolvedFilename;
                  var newEnv = new contexts.Parse(importManager.context);
                  newEnv.processImports = false;
                  importManager.contents[resolvedFilename] = contents;
                  if (currentFileInfo.reference || importOptions.reference) {
                      newFileInfo.reference = true;
                  }
                  if (importOptions.isPlugin) {
                      plugin = pluginLoader.evalPlugin(contents, newEnv, importManager, importOptions.pluginArgs, newFileInfo);
                      if (plugin instanceof LessError) {
                          fileParsedFunc(plugin, null, resolvedFilename);
                      }
                      else {
                          fileParsedFunc(null, plugin, resolvedFilename);
                      }
                  }
                  else if (importOptions.inline) {
                      fileParsedFunc(null, contents, resolvedFilename);
                  }
                  else {
                      new Parser(newEnv, importManager, newFileInfo).parse(contents, function (e, root) {
                          fileParsedFunc(e, root, resolvedFilename);
                      });
                  }
              };
              var promise;
              var context = clone(this.context);
              if (tryAppendExtension) {
                  context.ext = importOptions.isPlugin ? '.js' : '.less';
              }
              if (importOptions.isPlugin) {
                  context.mime = 'application/javascript';
                  promise = pluginLoader.loadPlugin(path, currentFileInfo.currentDirectory, context, environment, fileManager);
              }
              else {
                  promise = fileManager.loadFile(path, currentFileInfo.currentDirectory, context, environment, function (err, loadedFile) {
                      if (err) {
                          fileParsedFunc(err);
                      }
                      else {
                          loadFileCallback(loadedFile);
                      }
                  });
              }
              if (promise) {
                  promise.then(loadFileCallback, fileParsedFunc);
              }
          };
          return ImportManager;
      }());
      return ImportManager;
  });

  var Render = (function (environment, ParseTree, ImportManager) {
      var render = function (input, options, callback) {
          if (typeof options === 'function') {
              callback = options;
              options = copyOptions(this.options, {});
          }
          else {
              options = copyOptions(this.options, options || {});
          }
          if (!callback) {
              var self_1 = this;
              return new Promise(function (resolve, reject) {
                  render.call(self_1, input, options, function (err, output) {
                      if (err) {
                          reject(err);
                      }
                      else {
                          resolve(output);
                      }
                  });
              });
          }
          else {
              this.parse(input, options, function (err, root, imports, options) {
                  if (err) {
                      return callback(err);
                  }
                  var result;
                  try {
                      var parseTree = new ParseTree(root, imports);
                      result = parseTree.toCSS(options);
                  }
                  catch (err) {
                      return callback(err);
                  }
                  callback(null, result);
              });
          }
      };
      return render;
  });

  /**
   * Plugin Manager
   */
  var PluginManager = /** @class */ (function () {
      function PluginManager(less) {
          this.less = less;
          this.visitors = [];
          this.preProcessors = [];
          this.postProcessors = [];
          this.installedPlugins = [];
          this.fileManagers = [];
          this.iterator = -1;
          this.pluginCache = {};
          this.Loader = new less.PluginLoader(less);
      }
      /**
       * Adds all the plugins in the array
       * @param {Array} plugins
       */
      PluginManager.prototype.addPlugins = function (plugins) {
          if (plugins) {
              for (var i_1 = 0; i_1 < plugins.length; i_1++) {
                  this.addPlugin(plugins[i_1]);
              }
          }
      };
      /**
       *
       * @param plugin
       * @param {String} filename
       */
      PluginManager.prototype.addPlugin = function (plugin, filename, functionRegistry) {
          this.installedPlugins.push(plugin);
          if (filename) {
              this.pluginCache[filename] = plugin;
          }
          if (plugin.install) {
              plugin.install(this.less, this, functionRegistry || this.less.functions.functionRegistry);
          }
      };
      /**
       *
       * @param filename
       */
      PluginManager.prototype.get = function (filename) {
          return this.pluginCache[filename];
      };
      /**
       * Adds a visitor. The visitor object has options on itself to determine
       * when it should run.
       * @param visitor
       */
      PluginManager.prototype.addVisitor = function (visitor) {
          this.visitors.push(visitor);
      };
      /**
       * Adds a pre processor object
       * @param {object} preProcessor
       * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import
       */
      PluginManager.prototype.addPreProcessor = function (preProcessor, priority) {
          var indexToInsertAt;
          for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {
              if (this.preProcessors[indexToInsertAt].priority >= priority) {
                  break;
              }
          }
          this.preProcessors.splice(indexToInsertAt, 0, { preProcessor: preProcessor, priority: priority });
      };
      /**
       * Adds a post processor object
       * @param {object} postProcessor
       * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression
       */
      PluginManager.prototype.addPostProcessor = function (postProcessor, priority) {
          var indexToInsertAt;
          for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {
              if (this.postProcessors[indexToInsertAt].priority >= priority) {
                  break;
              }
          }
          this.postProcessors.splice(indexToInsertAt, 0, { postProcessor: postProcessor, priority: priority });
      };
      /**
       *
       * @param manager
       */
      PluginManager.prototype.addFileManager = function (manager) {
          this.fileManagers.push(manager);
      };
      /**
       *
       * @returns {Array}
       * @private
       */
      PluginManager.prototype.getPreProcessors = function () {
          var preProcessors = [];
          for (var i_2 = 0; i_2 < this.preProcessors.length; i_2++) {
              preProcessors.push(this.preProcessors[i_2].preProcessor);
          }
          return preProcessors;
      };
      /**
       *
       * @returns {Array}
       * @private
       */
      PluginManager.prototype.getPostProcessors = function () {
          var postProcessors = [];
          for (var i_3 = 0; i_3 < this.postProcessors.length; i_3++) {
              postProcessors.push(this.postProcessors[i_3].postProcessor);
          }
          return postProcessors;
      };
      /**
       *
       * @returns {Array}
       * @private
       */
      PluginManager.prototype.getVisitors = function () {
          return this.visitors;
      };
      PluginManager.prototype.visitor = function () {
          var self = this;
          return {
              first: function () {
                  self.iterator = -1;
                  return self.visitors[self.iterator];
              },
              get: function () {
                  self.iterator += 1;
                  return self.visitors[self.iterator];
              }
          };
      };
      /**
       *
       * @returns {Array}
       * @private
       */
      PluginManager.prototype.getFileManagers = function () {
          return this.fileManagers;
      };
      return PluginManager;
  }());
  var pm;
  function PluginManagerFactory(less, newFactory) {
      if (newFactory || !pm) {
          pm = new PluginManager(less);
      }
      return pm;
  }

  var Parse = (function (environment, ParseTree, ImportManager) {
      var parse = function (input, options, callback) {
          if (typeof options === 'function') {
              callback = options;
              options = copyOptions(this.options, {});
          }
          else {
              options = copyOptions(this.options, options || {});
          }
          if (!callback) {
              var self_1 = this;
              return new Promise(function (resolve, reject) {
                  parse.call(self_1, input, options, function (err, output) {
                      if (err) {
                          reject(err);
                      }
                      else {
                          resolve(output);
                      }
                  });
              });
          }
          else {
              var context_1;
              var rootFileInfo = void 0;
              var pluginManager_1 = new PluginManagerFactory(this, !options.reUsePluginManager);
              options.pluginManager = pluginManager_1;
              context_1 = new contexts.Parse(options);
              if (options.rootFileInfo) {
                  rootFileInfo = options.rootFileInfo;
              }
              else {
                  var filename = options.filename || 'input';
                  var entryPath = filename.replace(/[^\/\\]*$/, '');
                  rootFileInfo = {
                      filename: filename,
                      rewriteUrls: context_1.rewriteUrls,
                      rootpath: context_1.rootpath || '',
                      currentDirectory: entryPath,
                      entryPath: entryPath,
                      rootFilename: filename
                  };
                  // add in a missing trailing slash
                  if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== '/') {
                      rootFileInfo.rootpath += '/';
                  }
              }
              var imports_1 = new ImportManager(this, context_1, rootFileInfo);
              this.importManager = imports_1;
              // TODO: allow the plugins to be just a list of paths or names
              // Do an async plugin queue like lessc
              if (options.plugins) {
                  options.plugins.forEach(function (plugin) {
                      var evalResult;
                      var contents;
                      if (plugin.fileContent) {
                          contents = plugin.fileContent.replace(/^\uFEFF/, '');
                          evalResult = pluginManager_1.Loader.evalPlugin(contents, context_1, imports_1, plugin.options, plugin.filename);
                          if (evalResult instanceof LessError) {
                              return callback(evalResult);
                          }
                      }
                      else {
                          pluginManager_1.addPlugin(plugin);
                      }
                  });
              }
              new Parser(context_1, imports_1, rootFileInfo)
                  .parse(input, function (e, root) {
                  if (e) {
                      return callback(e);
                  }
                  callback(null, root, imports_1, options);
              }, options);
          }
      };
      return parse;
  });

  var lessRoot = (function (environment$1, fileManagers) {
      /**
       * @todo
       * This original code could be improved quite a bit.
       * Many classes / modules currently add side-effects / mutations to passed in objects,
       * which makes it hard to refactor and reason about.
       */
      environment$1 = new environment(environment$1, fileManagers);
      var SourceMapOutput = sourceMapOutput(environment$1);
      var SourceMapBuilder = sourceMapBuilder(SourceMapOutput, environment$1);
      var ParseTree = parseTree(SourceMapBuilder);
      var ImportManager = importManager(environment$1);
      var render = Render(environment$1, ParseTree);
      var parse = Parse(environment$1, ParseTree, ImportManager);
      var functions = Functions(environment$1);
      /**
       * @todo
       * This root properties / methods need to be organized.
       * It's not clear what should / must be public and why.
       */
      var initial = {
          version: [3, 11, 3],
          data: data,
          tree: tree,
          Environment: environment,
          AbstractFileManager: AbstractFileManager,
          AbstractPluginLoader: AbstractPluginLoader,
          environment: environment$1,
          visitors: visitors,
          Parser: Parser,
          functions: functions,
          contexts: contexts,
          SourceMapOutput: SourceMapOutput,
          SourceMapBuilder: SourceMapBuilder,
          ParseTree: ParseTree,
          ImportManager: ImportManager,
          render: render,
          parse: parse,
          LessError: LessError,
          transformTree: transformTree,
          utils: utils,
          PluginManager: PluginManagerFactory,
          logger: logger
      };
      // Create a public API
      var ctor = function (t) { return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return new (t.bind.apply(t, __spreadArrays([void 0], args)))();
      }; };
      var t;
      var api = Object.create(initial);
      for (var n in initial.tree) {
          /* eslint guard-for-in: 0 */
          t = initial.tree[n];
          if (typeof t === 'function') {
              api[n.toLowerCase()] = ctor(t);
          }
          else {
              api[n] = Object.create(null);
              for (var o in t) {
                  /* eslint guard-for-in: 0 */
                  api[n][o.toLowerCase()] = ctor(t[o]);
              }
          }
      }
      return api;
  });

  /* global window, XMLHttpRequest */
  var options;
  var logger$1;
  var fileCache = {};
  // TODOS - move log somewhere. pathDiff and doing something similar in node. use pathDiff in the other browser file for the initial load
  var FileManager = /** @class */ (function (_super) {
      __extends(FileManager, _super);
      function FileManager() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      FileManager.prototype.alwaysMakePathsAbsolute = function () {
          return true;
      };
      FileManager.prototype.join = function (basePath, laterPath) {
          if (!basePath) {
              return laterPath;
          }
          return this.extractUrlParts(laterPath, basePath).path;
      };
      FileManager.prototype.doXHR = function (url, type, callback, errback) {
          var xhr = new XMLHttpRequest();
          var async = options.isFileProtocol ? options.fileAsync : true;
          if (typeof xhr.overrideMimeType === 'function') {
              xhr.overrideMimeType('text/css');
          }
          logger$1.debug("XHR: Getting '" + url + "'");
          xhr.open('GET', url, async);
          xhr.setRequestHeader('Accept', type || 'text/x-less, text/css; q=0.9, */*; q=0.5');
          xhr.send(null);
          function handleResponse(xhr, callback, errback) {
              if (xhr.status >= 200 && xhr.status < 300) {
                  callback(xhr.responseText, xhr.getResponseHeader('Last-Modified'));
              }
              else if (typeof errback === 'function') {
                  errback(xhr.status, url);
              }
          }
          if (options.isFileProtocol && !options.fileAsync) {
              if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {
                  callback(xhr.responseText);
              }
              else {
                  errback(xhr.status, url);
              }
          }
          else if (async) {
              xhr.onreadystatechange = function () {
                  if (xhr.readyState == 4) {
                      handleResponse(xhr, callback, errback);
                  }
              };
          }
          else {
              handleResponse(xhr, callback, errback);
          }
      };
      FileManager.prototype.supports = function () {
          return true;
      };
      FileManager.prototype.clearFileCache = function () {
          fileCache = {};
      };
      FileManager.prototype.loadFile = function (filename, currentDirectory, options, environment) {
          // TODO: Add prefix support like less-node?
          // What about multiple paths?
          if (currentDirectory && !this.isPathAbsolute(filename)) {
              filename = currentDirectory + filename;
          }
          filename = options.ext ? this.tryAppendExtension(filename, options.ext) : filename;
          options = options || {};
          // sheet may be set to the stylesheet for the initial load or a collection of properties including
          // some context variables for imports
          var hrefParts = this.extractUrlParts(filename, window.location.href);
          var href = hrefParts.url;
          var self = this;
          return new Promise(function (resolve, reject) {
              if (options.useFileCache && fileCache[href]) {
                  try {
                      var lessText_1 = fileCache[href];
                      return resolve({ contents: lessText_1, filename: href, webInfo: { lastModified: new Date() } });
                  }
                  catch (e) {
                      return reject({ filename: href, message: "Error loading file " + href + " error was " + e.message });
                  }
              }
              self.doXHR(href, options.mime, function doXHRCallback(data, lastModified) {
                  // per file cache
                  fileCache[href] = data;
                  // Use remote copy (re-parse)
                  resolve({ contents: data, filename: href, webInfo: { lastModified: lastModified } });
              }, function doXHRError(status, url) {
                  reject({ type: 'File', message: "'" + url + "' wasn't found (" + status + ")", href: href });
              });
          });
      };
      return FileManager;
  }(AbstractFileManager));
  var FM = (function (opts, log) {
      options = opts;
      logger$1 = log;
      return FileManager;
  });

  // TODO: Add tests for browser @plugin
  /**
   * Browser Plugin Loader
   */
  var PluginLoader = /** @class */ (function (_super) {
      __extends(PluginLoader, _super);
      function PluginLoader(less) {
          var _this = _super.call(this) || this;
          _this.less = less;
          return _this;
          // Should we shim this.require for browser? Probably not?
      }
      PluginLoader.prototype.loadPlugin = function (filename, basePath, context, environment, fileManager) {
          return new Promise(function (fulfill, reject) {
              fileManager.loadFile(filename, basePath, context, environment)
                  .then(fulfill).catch(reject);
          });
      };
      return PluginLoader;
  }(AbstractPluginLoader));

  var LogListener = (function (less, options) {
      var logLevel_debug = 4;
      var logLevel_info = 3;
      var logLevel_warn = 2;
      var logLevel_error = 1;
      // The amount of logging in the javascript console.
      // 3 - Debug, information and errors
      // 2 - Information and errors
      // 1 - Errors
      // 0 - None
      // Defaults to 2
      options.logLevel = typeof options.logLevel !== 'undefined' ? options.logLevel : (options.env === 'development' ? logLevel_info : logLevel_error);
      if (!options.loggers) {
          options.loggers = [{
                  debug: function (msg) {
                      if (options.logLevel >= logLevel_debug) {
                          console.log(msg);
                      }
                  },
                  info: function (msg) {
                      if (options.logLevel >= logLevel_info) {
                          console.log(msg);
                      }
                  },
                  warn: function (msg) {
                      if (options.logLevel >= logLevel_warn) {
                          console.warn(msg);
                      }
                  },
                  error: function (msg) {
                      if (options.logLevel >= logLevel_error) {
                          console.error(msg);
                      }
                  }
              }];
      }
      for (var i_1 = 0; i_1 < options.loggers.length; i_1++) {
          less.logger.addListener(options.loggers[i_1]);
      }
  });

  var ErrorReporting = (function (window, less, options) {
      function errorHTML(e, rootHref) {
          var id = "less-error-message:" + extractId(rootHref || '');
          var template = '<li><label>{line}</label><pre class="{class}">{content}</pre></li>';
          var elem = window.document.createElement('div');
          var timer;
          var content;
          var errors = [];
          var filename = e.filename || rootHref;
          var filenameNoPath = filename.match(/([^\/]+(\?.*)?)$/)[1];
          elem.id = id;
          elem.className = 'less-error-message';
          content = "<h3>" + (e.type || 'Syntax') + "Error: " + (e.message || 'There is an error in your .less file') +
              ("</h3><p>in <a href=\"" + filename + "\">" + filenameNoPath + "</a> ");
          var errorline = function (e, i, classname) {
              if (e.extract[i] !== undefined) {
                  errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
                      .replace(/\{class\}/, classname)
                      .replace(/\{content\}/, e.extract[i]));
              }
          };
          if (e.line) {
              errorline(e, 0, '');
              errorline(e, 1, 'line');
              errorline(e, 2, '');
              content += "on line " + e.line + ", column " + (e.column + 1) + ":</p><ul>" + errors.join('') + "</ul>";
          }
          if (e.stack && (e.extract || options.logLevel >= 4)) {
              content += "<br/>Stack Trace</br />" + e.stack.split('\n').slice(1).join('<br/>');
          }
          elem.innerHTML = content;
          // CSS for error messages
          browser.createCSS(window.document, [
              '.less-error-message ul, .less-error-message li {',
              'list-style-type: none;',
              'margin-right: 15px;',
              'padding: 4px 0;',
              'margin: 0;',
              '}',
              '.less-error-message label {',
              'font-size: 12px;',
              'margin-right: 15px;',
              'padding: 4px 0;',
              'color: #cc7777;',
              '}',
              '.less-error-message pre {',
              'color: #dd6666;',
              'padding: 4px 0;',
              'margin: 0;',
              'display: inline-block;',
              '}',
              '.less-error-message pre.line {',
              'color: #ff0000;',
              '}',
              '.less-error-message h3 {',
              'font-size: 20px;',
              'font-weight: bold;',
              'padding: 15px 0 5px 0;',
              'margin: 0;',
              '}',
              '.less-error-message a {',
              'color: #10a',
              '}',
              '.less-error-message .error {',
              'color: red;',
              'font-weight: bold;',
              'padding-bottom: 2px;',
              'border-bottom: 1px dashed red;',
              '}'
          ].join('\n'), { title: 'error-message' });
          elem.style.cssText = [
              'font-family: Arial, sans-serif',
              'border: 1px solid #e00',
              'background-color: #eee',
              'border-radius: 5px',
              '-webkit-border-radius: 5px',
              '-moz-border-radius: 5px',
              'color: #e00',
              'padding: 15px',
              'margin-bottom: 15px'
          ].join(';');
          if (options.env === 'development') {
              timer = setInterval(function () {
                  var document = window.document;
                  var body = document.body;
                  if (body) {
                      if (document.getElementById(id)) {
                          body.replaceChild(elem, document.getElementById(id));
                      }
                      else {
                          body.insertBefore(elem, body.firstChild);
                      }
                      clearInterval(timer);
                  }
              }, 10);
          }
      }
      function removeErrorHTML(path) {
          var node = window.document.getElementById("less-error-message:" + extractId(path));
          if (node) {
              node.parentNode.removeChild(node);
          }
      }
      function removeError(path) {
          if (!options.errorReporting || options.errorReporting === 'html') {
              removeErrorHTML(path);
          }
          else if (options.errorReporting === 'console') ;
          else if (typeof options.errorReporting === 'function') {
              options.errorReporting('remove', path);
          }
      }
      function errorConsole(e, rootHref) {
          var template = '{line} {content}';
          var filename = e.filename || rootHref;
          var errors = [];
          var content = (e.type || 'Syntax') + "Error: " + (e.message || 'There is an error in your .less file') + " in " + filename;
          var errorline = function (e, i, classname) {
              if (e.extract[i] !== undefined) {
                  errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
                      .replace(/\{class\}/, classname)
                      .replace(/\{content\}/, e.extract[i]));
              }
          };
          if (e.line) {
              errorline(e, 0, '');
              errorline(e, 1, 'line');
              errorline(e, 2, '');
              content += " on line " + e.line + ", column " + (e.column + 1) + ":\n" + errors.join('\n');
          }
          if (e.stack && (e.extract || options.logLevel >= 4)) {
              content += "\nStack Trace\n" + e.stack;
          }
          less.logger.error(content);
      }
      function error(e, rootHref) {
          if (!options.errorReporting || options.errorReporting === 'html') {
              errorHTML(e, rootHref);
          }
          else if (options.errorReporting === 'console') {
              errorConsole(e, rootHref);
          }
          else if (typeof options.errorReporting === 'function') {
              options.errorReporting('add', e, rootHref);
          }
      }
      return {
          add: error,
          remove: removeError
      };
  });

  // Cache system is a bit outdated and could do with work
  var Cache = (function (window, options, logger) {
      var cache = null;
      if (options.env !== 'development') {
          try {
              cache = (typeof window.localStorage === 'undefined') ? null : window.localStorage;
          }
          catch (_) { }
      }
      return {
          setCSS: function (path, lastModified, modifyVars, styles) {
              if (cache) {
                  logger.info("saving " + path + " to cache.");
                  try {
                      cache.setItem(path, styles);
                      cache.setItem(path + ":timestamp", lastModified);
                      if (modifyVars) {
                          cache.setItem(path + ":vars", JSON.stringify(modifyVars));
                      }
                  }
                  catch (e) {
                      // TODO - could do with adding more robust error handling
                      logger.error("failed to save \"" + path + "\" to local storage for caching.");
                  }
              }
          },
          getCSS: function (path, webInfo, modifyVars) {
              var css = cache && cache.getItem(path);
              var timestamp = cache && cache.getItem(path + ":timestamp");
              var vars = cache && cache.getItem(path + ":vars");
              modifyVars = modifyVars || {};
              vars = vars || "{}"; // if not set, treat as the JSON representation of an empty object
              if (timestamp && webInfo.lastModified &&
                  (new Date(webInfo.lastModified).valueOf() ===
                      new Date(timestamp).valueOf()) &&
                  JSON.stringify(modifyVars) === vars) {
                  // Use local copy
                  return css;
              }
          }
      };
  });

  var ImageSize = (function () {
      function imageSize() {
          throw {
              type: 'Runtime',
              message: 'Image size functions are not supported in browser version of less'
          };
      }
      var imageFunctions = {
          'image-size': function (filePathNode) {
              imageSize();
              return -1;
          },
          'image-width': function (filePathNode) {
              imageSize();
              return -1;
          },
          'image-height': function (filePathNode) {
              imageSize();
              return -1;
          }
      };
      functionRegistry.addMultiple(imageFunctions);
  });

  //
  var root = (function (window, options) {
      var document = window.document;
      var less = lessRoot();
      less.options = options;
      var environment = less.environment;
      var FileManager = FM(options, less.logger);
      var fileManager = new FileManager();
      environment.addFileManager(fileManager);
      less.FileManager = FileManager;
      less.PluginLoader = PluginLoader;
      LogListener(less, options);
      var errors = ErrorReporting(window, less, options);
      var cache = less.cache = options.cache || Cache(window, options, less.logger);
      ImageSize(less.environment);
      // Setup user functions - Deprecate?
      if (options.functions) {
          less.functions.functionRegistry.addMultiple(options.functions);
      }
      var typePattern = /^text\/(x-)?less$/;
      function clone(obj) {
          var cloned = {};
          for (var prop in obj) {
              if (obj.hasOwnProperty(prop)) {
                  cloned[prop] = obj[prop];
              }
          }
          return cloned;
      }
      // only really needed for phantom
      function bind(func, thisArg) {
          var curryArgs = Array.prototype.slice.call(arguments, 2);
          return function () {
              var args = curryArgs.concat(Array.prototype.slice.call(arguments, 0));
              return func.apply(thisArg, args);
          };
      }
      function loadStyles(modifyVars) {
          var styles = document.getElementsByTagName('style');
          var style;
          for (var i_1 = 0; i_1 < styles.length; i_1++) {
              style = styles[i_1];
              if (style.type.match(typePattern)) {
                  var instanceOptions = clone(options);
                  instanceOptions.modifyVars = modifyVars;
                  var lessText_1 = style.innerHTML || '';
                  instanceOptions.filename = document.location.href.replace(/#.*$/, '');
                  /* jshint loopfunc:true */
                  // use closure to store current style
                  less.render(lessText_1, instanceOptions, bind(function (style, e, result) {
                      if (e) {
                          errors.add(e, 'inline');
                      }
                      else {
                          style.type = 'text/css';
                          if (style.styleSheet) {
                              style.styleSheet.cssText = result.css;
                          }
                          else {
                              style.innerHTML = result.css;
                          }
                      }
                  }, null, style));
              }
          }
      }
      function loadStyleSheet(sheet, callback, reload, remaining, modifyVars) {
          var instanceOptions = clone(options);
          addDataAttr(instanceOptions, sheet);
          instanceOptions.mime = sheet.type;
          if (modifyVars) {
              instanceOptions.modifyVars = modifyVars;
          }
          function loadInitialFileCallback(loadedFile) {
              var data = loadedFile.contents;
              var path = loadedFile.filename;
              var webInfo = loadedFile.webInfo;
              var newFileInfo = {
                  currentDirectory: fileManager.getPath(path),
                  filename: path,
                  rootFilename: path,
                  rewriteUrls: instanceOptions.rewriteUrls
              };
              newFileInfo.entryPath = newFileInfo.currentDirectory;
              newFileInfo.rootpath = instanceOptions.rootpath || newFileInfo.currentDirectory;
              if (webInfo) {
                  webInfo.remaining = remaining;
                  var css = cache.getCSS(path, webInfo, instanceOptions.modifyVars);
                  if (!reload && css) {
                      webInfo.local = true;
                      callback(null, css, data, sheet, webInfo, path);
                      return;
                  }
              }
              // TODO add tests around how this behaves when reloading
              errors.remove(path);
              instanceOptions.rootFileInfo = newFileInfo;
              less.render(data, instanceOptions, function (e, result) {
                  if (e) {
                      e.href = path;
                      callback(e);
                  }
                  else {
                      cache.setCSS(sheet.href, webInfo.lastModified, instanceOptions.modifyVars, result.css);
                      callback(null, result.css, data, sheet, webInfo, path);
                  }
              });
          }
          fileManager.loadFile(sheet.href, null, instanceOptions, environment)
              .then(function (loadedFile) {
              loadInitialFileCallback(loadedFile);
          }).catch(function (err) {
              console.log(err);
              callback(err);
          });
      }
      function loadStyleSheets(callback, reload, modifyVars) {
          for (var i_2 = 0; i_2 < less.sheets.length; i_2++) {
              loadStyleSheet(less.sheets[i_2], callback, reload, less.sheets.length - (i_2 + 1), modifyVars);
          }
      }
      function initRunningMode() {
          if (less.env === 'development') {
              less.watchTimer = setInterval(function () {
                  if (less.watchMode) {
                      fileManager.clearFileCache();
                      loadStyleSheets(function (e, css, _, sheet, webInfo) {
                          if (e) {
                              errors.add(e, e.href || sheet.href);
                          }
                          else if (css) {
                              browser.createCSS(window.document, css, sheet);
                          }
                      });
                  }
              }, options.poll);
          }
      }
      //
      // Watch mode
      //
      less.watch = function () {
          if (!less.watchMode) {
              less.env = 'development';
              initRunningMode();
          }
          this.watchMode = true;
          return true;
      };
      less.unwatch = function () { clearInterval(less.watchTimer); this.watchMode = false; return false; };
      //
      // Synchronously get all <link> tags with the 'rel' attribute set to
      // "stylesheet/less".
      //
      less.registerStylesheetsImmediately = function () {
          var links = document.getElementsByTagName('link');
          less.sheets = [];
          for (var i_3 = 0; i_3 < links.length; i_3++) {
              if (links[i_3].rel === 'stylesheet/less' || (links[i_3].rel.match(/stylesheet/) &&
                  (links[i_3].type.match(typePattern)))) {
                  less.sheets.push(links[i_3]);
              }
          }
      };
      //
      // Asynchronously get all <link> tags with the 'rel' attribute set to
      // "stylesheet/less", returning a Promise.
      //
      less.registerStylesheets = function () { return new Promise(function (resolve, reject) {
          less.registerStylesheetsImmediately();
          resolve();
      }); };
      //
      // With this function, it's possible to alter variables and re-render
      // CSS without reloading less-files
      //
      less.modifyVars = function (record) { return less.refresh(true, record, false); };
      less.refresh = function (reload, modifyVars, clearFileCache) {
          if ((reload || clearFileCache) && clearFileCache !== false) {
              fileManager.clearFileCache();
          }
          return new Promise(function (resolve, reject) {
              var startTime;
              var endTime;
              var totalMilliseconds;
              var remainingSheets;
              startTime = endTime = new Date();
              // Set counter for remaining unprocessed sheets
              remainingSheets = less.sheets.length;
              if (remainingSheets === 0) {
                  endTime = new Date();
                  totalMilliseconds = endTime - startTime;
                  less.logger.info('Less has finished and no sheets were loaded.');
                  resolve({
                      startTime: startTime,
                      endTime: endTime,
                      totalMilliseconds: totalMilliseconds,
                      sheets: less.sheets.length
                  });
              }
              else {
                  // Relies on less.sheets array, callback seems to be guaranteed to be called for every element of the array
                  loadStyleSheets(function (e, css, _, sheet, webInfo) {
                      if (e) {
                          errors.add(e, e.href || sheet.href);
                          reject(e);
                          return;
                      }
                      if (webInfo.local) {
                          less.logger.info("Loading " + sheet.href + " from cache.");
                      }
                      else {
                          less.logger.info("Rendered " + sheet.href + " successfully.");
                      }
                      browser.createCSS(window.document, css, sheet);
                      less.logger.info("CSS for " + sheet.href + " generated in " + (new Date() - endTime) + "ms");
                      // Count completed sheet
                      remainingSheets--;
                      // Check if the last remaining sheet was processed and then call the promise
                      if (remainingSheets === 0) {
                          totalMilliseconds = new Date() - startTime;
                          less.logger.info("Less has finished. CSS generated in " + totalMilliseconds + "ms");
                          resolve({
                              startTime: startTime,
                              endTime: endTime,
                              totalMilliseconds: totalMilliseconds,
                              sheets: less.sheets.length
                          });
                      }
                      endTime = new Date();
                  }, reload, modifyVars);
              }
              loadStyles(modifyVars);
          });
      };
      less.refreshStyles = loadStyles;
      return less;
  });

  /**
   * Kicks off less and compiles any stylesheets
   * used in the browser distributed version of less
   * to kick-start less using the browser api
   */
  var options$1 = defaultOptions();
  if (window.less) {
      for (var key in window.less) {
          if (window.less.hasOwnProperty(key)) {
              options$1[key] = window.less[key];
          }
      }
  }
  addDefaultOptions(window, options$1);
  options$1.plugins = options$1.plugins || [];
  if (window.LESS_PLUGINS) {
      options$1.plugins = options$1.plugins.concat(window.LESS_PLUGINS);
  }
  var less = root(window, options$1);
  window.less = less;
  var css;
  var head;
  var style;
  // Always restore page visibility
  function resolveOrReject(data) {
      if (data.filename) {
          console.warn(data);
      }
      if (!options$1.async) {
          head.removeChild(style);
      }
  }
  if (options$1.onReady) {
      if (/!watch/.test(window.location.hash)) {
          less.watch();
      }
      // Simulate synchronous stylesheet loading by hiding page rendering
      if (!options$1.async) {
          css = 'body { display: none !important }';
          head = document.head || document.getElementsByTagName('head')[0];
          style = document.createElement('style');
          style.type = 'text/css';
          if (style.styleSheet) {
              style.styleSheet.cssText = css;
          }
          else {
              style.appendChild(document.createTextNode(css));
          }
          head.appendChild(style);
      }
      less.registerStylesheetsImmediately();
      less.pageLoadFinished = less.refresh(less.env === 'development').then(resolveOrReject, resolveOrReject);
  }

  return less;

})));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18).Buffer))

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var csstree = __webpack_require__(1);
var parse = csstree.parse;
var compress = __webpack_require__(193);
var generate = csstree.generate;

function debugOutput(name, options, startTime, data) {
    if (options.debug) {
        console.error('## ' + name + ' done in %d ms\n', Date.now() - startTime);
    }

    return data;
}

function createDefaultLogger(level) {
    var lastDebug;

    return function logger(title, ast) {
        var line = title;

        if (ast) {
            line = '[' + ((Date.now() - lastDebug) / 1000).toFixed(3) + 's] ' + line;
        }

        if (level > 1 && ast) {
            var css = generate(ast);

            // when level 2, limit css to 256 symbols
            if (level === 2 && css.length > 256) {
                css = css.substr(0, 256) + '...';
            }

            line += '\n  ' + css + '\n';
        }

        console.error(line);
        lastDebug = Date.now();
    };
}

function copy(obj) {
    var result = {};

    for (var key in obj) {
        result[key] = obj[key];
    }

    return result;
}

function buildCompressOptions(options) {
    options = copy(options);

    if (typeof options.logger !== 'function' && options.debug) {
        options.logger = createDefaultLogger(options.debug);
    }

    return options;
}

function runHandler(ast, options, handlers) {
    if (!Array.isArray(handlers)) {
        handlers = [handlers];
    }

    handlers.forEach(function(fn) {
        fn(ast, options);
    });
}

function minify(context, source, options) {
    options = options || {};

    var filename = options.filename || '<unknown>';
    var result;

    // parse
    var ast = debugOutput('parsing', options, Date.now(),
        parse(source, {
            context: context,
            filename: filename,
            positions: Boolean(options.sourceMap)
        })
    );

    // before compress handlers
    if (options.beforeCompress) {
        debugOutput('beforeCompress', options, Date.now(),
            runHandler(ast, options, options.beforeCompress)
        );
    }

    // compress
    var compressResult = debugOutput('compress', options, Date.now(),
        compress(ast, buildCompressOptions(options))
    );

    // after compress handlers
    if (options.afterCompress) {
        debugOutput('afterCompress', options, Date.now(),
            runHandler(compressResult, options, options.afterCompress)
        );
    }

    // generate
    if (options.sourceMap) {
        result = debugOutput('generate(sourceMap: true)', options, Date.now(), (function() {
            var tmp = generate(compressResult.ast, { sourceMap: true });
            tmp.map._file = filename; // since other tools can relay on file in source map transform chain
            tmp.map.setSourceContent(filename, source);
            return tmp;
        })());
    } else {
        result = debugOutput('generate', options, Date.now(), {
            css: generate(compressResult.ast),
            map: null
        });
    }

    return result;
}

function minifyStylesheet(source, options) {
    return minify('stylesheet', source, options);
}

function minifyBlock(source, options) {
    return minify('declarationList', source, options);
}

module.exports = {
    version: __webpack_require__(227).version,

    // main methods
    minify: minifyStylesheet,
    minifyBlock: minifyBlock,

    // compress an AST
    compress: compress,

    // css syntax parser/walkers/generator/etc
    syntax: csstree
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

function merge() {
    var dest = {};

    for (var i = 0; i < arguments.length; i++) {
        var src = arguments[i];
        for (var key in src) {
            dest[key] = src[key];
        }
    }

    return dest;
}

module.exports = __webpack_require__(99).create(
    merge(
        __webpack_require__(126),
        __webpack_require__(168),
        __webpack_require__(192)
    )
);


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(7);
var Tokenizer = __webpack_require__(0);
var Lexer = __webpack_require__(102);
var grammar = __webpack_require__(110);
var createParser = __webpack_require__(111);
var createGenerator = __webpack_require__(113);
var createConvertor = __webpack_require__(122);
var createWalker = __webpack_require__(123);
var clone = __webpack_require__(124);
var names = __webpack_require__(27);
var mix = __webpack_require__(125);

function assign(dest, src) {
    for (var key in src) {
        dest[key] = src[key];
    }

    return dest;
}

function createSyntax(config) {
    var parse = createParser(config);
    var walk = createWalker(config);
    var generate = createGenerator(config);
    var convert = createConvertor(walk);

    var syntax = {
        List: List,
        Tokenizer: Tokenizer,
        Lexer: Lexer,

        vendorPrefix: names.vendorPrefix,
        keyword: names.keyword,
        property: names.property,
        isCustomProperty: names.isCustomProperty,

        grammar: grammar,
        lexer: null,
        createLexer: function(config) {
            return new Lexer(config, syntax, syntax.lexer.structure);
        },

        parse: parse,
        walk: walk,
        generate: generate,

        clone: clone,
        fromPlainObject: convert.fromPlainObject,
        toPlainObject: convert.toPlainObject,

        createSyntax: function(config) {
            return createSyntax(mix({}, config));
        },
        fork: function(extension) {
            var base = mix({}, config); // copy of config
            return createSyntax(
                typeof extension === 'function'
                    ? extension(base, assign)
                    : mix(base, extension)
            );
        }
    };

    syntax.lexer = new Lexer({
        generic: true,
        types: config.types,
        properties: config.properties,
        node: config.node
    }, syntax);

    return syntax;
};

exports.create = function(config) {
    return createSyntax(mix({}, config));
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CssSyntaxError = __webpack_require__(101);

var constants = __webpack_require__(25);
var TYPE = constants.TYPE;
var NAME = constants.NAME;
var SYMBOL_TYPE = constants.SYMBOL_TYPE;

var utils = __webpack_require__(45);
var firstCharOffset = utils.firstCharOffset;
var cmpStr = utils.cmpStr;
var isNumber = utils.isNumber;
var findWhiteSpaceStart = utils.findWhiteSpaceStart;
var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
var findCommentEnd = utils.findCommentEnd;
var findStringEnd = utils.findStringEnd;
var findNumberEnd = utils.findNumberEnd;
var findIdentifierEnd = utils.findIdentifierEnd;
var findUrlRawEnd = utils.findUrlRawEnd;

var NULL = 0;
var WHITESPACE = TYPE.WhiteSpace;
var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var STRING = TYPE.String;
var COMMENT = TYPE.Comment;
var PUNCTUATOR = TYPE.Punctuator;
var CDO = TYPE.CDO;
var CDC = TYPE.CDC;
var ATKEYWORD = TYPE.AtKeyword;
var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var RAW = TYPE.Raw;

var N = 10;
var F = 12;
var R = 13;
var STAR = TYPE.Asterisk;
var SLASH = TYPE.Solidus;
var FULLSTOP = TYPE.FullStop;
var PLUSSIGN = TYPE.PlusSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var GREATERTHANSIGN = TYPE.GreaterThanSign;
var LESSTHANSIGN = TYPE.LessThanSign;
var EXCLAMATIONMARK = TYPE.ExclamationMark;
var COMMERCIALAT = TYPE.CommercialAt;
var QUOTATIONMARK = TYPE.QuotationMark;
var APOSTROPHE = TYPE.Apostrophe;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;

var MIN_BUFFER_SIZE = 16 * 1024;
var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;
var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

function computeLinesAndColumns(tokenizer, source) {
    var sourceLength = source.length;
    var start = firstCharOffset(source);
    var lines = tokenizer.lines;
    var line = tokenizer.startLine;
    var columns = tokenizer.columns;
    var column = tokenizer.startColumn;

    if (lines === null || lines.length < sourceLength + 1) {
        lines = new SafeUint32Array(Math.max(sourceLength + 1024, MIN_BUFFER_SIZE));
        columns = new SafeUint32Array(lines.length);
    }

    for (var i = start; i < sourceLength; i++) {
        var code = source.charCodeAt(i);

        lines[i] = line;
        columns[i] = column++;

        if (code === N || code === R || code === F) {
            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
                i++;
                lines[i] = line;
                columns[i] = column;
            }

            line++;
            column = 1;
        }
    }

    lines[i] = line;
    columns[i] = column;

    tokenizer.linesAnsColumnsComputed = true;
    tokenizer.lines = lines;
    tokenizer.columns = columns;
}

function tokenLayout(tokenizer, source, startPos) {
    var sourceLength = source.length;
    var offsetAndType = tokenizer.offsetAndType;
    var balance = tokenizer.balance;
    var tokenCount = 0;
    var prevType = 0;
    var offset = startPos;
    var anchor = 0;
    var balanceCloseCode = 0;
    var balanceStart = 0;
    var balancePrev = 0;

    if (offsetAndType === null || offsetAndType.length < sourceLength + 1) {
        offsetAndType = new SafeUint32Array(sourceLength + 1024);
        balance = new SafeUint32Array(sourceLength + 1024);
    }

    while (offset < sourceLength) {
        var code = source.charCodeAt(offset);
        var type = code < 0x80 ? SYMBOL_TYPE[code] : IDENTIFIER;

        balance[tokenCount] = sourceLength;

        switch (type) {
            case WHITESPACE:
                offset = findWhiteSpaceEnd(source, offset + 1);
                break;

            case PUNCTUATOR:
                switch (code) {
                    case balanceCloseCode:
                        balancePrev = balanceStart & OFFSET_MASK;
                        balanceStart = balance[balancePrev];
                        balanceCloseCode = balanceStart >> TYPE_SHIFT;
                        balance[tokenCount] = balancePrev;
                        balance[balancePrev++] = tokenCount;
                        for (; balancePrev < tokenCount; balancePrev++) {
                            if (balance[balancePrev] === sourceLength) {
                                balance[balancePrev] = tokenCount;
                            }
                        }
                        break;

                    case LEFTSQUAREBRACKET:
                        balance[tokenCount] = balanceStart;
                        balanceCloseCode = RIGHTSQUAREBRACKET;
                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
                        break;

                    case LEFTCURLYBRACKET:
                        balance[tokenCount] = balanceStart;
                        balanceCloseCode = RIGHTCURLYBRACKET;
                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
                        break;

                    case LEFTPARENTHESIS:
                        balance[tokenCount] = balanceStart;
                        balanceCloseCode = RIGHTPARENTHESIS;
                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
                        break;
                }

                // /*
                if (code === STAR && prevType === SLASH) {
                    type = COMMENT;
                    offset = findCommentEnd(source, offset + 1);
                    tokenCount--; // rewrite prev token
                    break;
                }

                // edge case for -.123 and +.123
                if (code === FULLSTOP && (prevType === PLUSSIGN || prevType === HYPHENMINUS)) {
                    if (offset + 1 < sourceLength && isNumber(source.charCodeAt(offset + 1))) {
                        type = NUMBER;
                        offset = findNumberEnd(source, offset + 2, false);
                        tokenCount--; // rewrite prev token
                        break;
                    }
                }

                // <!--
                if (code === EXCLAMATIONMARK && prevType === LESSTHANSIGN) {
                    if (offset + 2 < sourceLength &&
                        source.charCodeAt(offset + 1) === HYPHENMINUS &&
                        source.charCodeAt(offset + 2) === HYPHENMINUS) {
                        type = CDO;
                        offset = offset + 3;
                        tokenCount--; // rewrite prev token
                        break;
                    }
                }

                // -->
                if (code === HYPHENMINUS && prevType === HYPHENMINUS) {
                    if (offset + 1 < sourceLength && source.charCodeAt(offset + 1) === GREATERTHANSIGN) {
                        type = CDC;
                        offset = offset + 2;
                        tokenCount--; // rewrite prev token
                        break;
                    }
                }

                // ident(
                if (code === LEFTPARENTHESIS && prevType === IDENTIFIER) {
                    offset = offset + 1;
                    tokenCount--; // rewrite prev token
                    balance[tokenCount] = balance[tokenCount + 1];
                    balanceStart--;

                    // 4 char length identifier and equal to `url(` (case insensitive)
                    if (offset - anchor === 4 && cmpStr(source, anchor, offset, 'url(')) {
                        // special case for url() because it can contain any symbols sequence with few exceptions
                        anchor = findWhiteSpaceEnd(source, offset);
                        code = source.charCodeAt(anchor);
                        if (code !== LEFTPARENTHESIS &&
                            code !== RIGHTPARENTHESIS &&
                            code !== QUOTATIONMARK &&
                            code !== APOSTROPHE) {
                            // url(
                            offsetAndType[tokenCount++] = (URL << TYPE_SHIFT) | offset;
                            balance[tokenCount] = sourceLength;

                            // ws*
                            if (anchor !== offset) {
                                offsetAndType[tokenCount++] = (WHITESPACE << TYPE_SHIFT) | anchor;
                                balance[tokenCount] = sourceLength;
                            }

                            // raw
                            type = RAW;
                            offset = findUrlRawEnd(source, anchor);
                        } else {
                            type = URL;
                        }
                    } else {
                        type = FUNCTION;
                    }
                    break;
                }

                type = code;
                offset = offset + 1;
                break;

            case NUMBER:
                offset = findNumberEnd(source, offset + 1, prevType !== FULLSTOP);

                // merge number with a preceding dot, dash or plus
                if (prevType === FULLSTOP ||
                    prevType === HYPHENMINUS ||
                    prevType === PLUSSIGN) {
                    tokenCount--; // rewrite prev token
                }

                break;

            case STRING:
                offset = findStringEnd(source, offset + 1, code);
                break;

            default:
                anchor = offset;
                offset = findIdentifierEnd(source, offset);

                // merge identifier with a preceding dash
                if (prevType === HYPHENMINUS) {
                    // rewrite prev token
                    tokenCount--;
                    // restore prev prev token type
                    // for case @-prefix-ident
                    prevType = tokenCount === 0 ? 0 : offsetAndType[tokenCount - 1] >> TYPE_SHIFT;
                }

                if (prevType === COMMERCIALAT) {
                    // rewrite prev token and change type to <at-keyword-token>
                    tokenCount--;
                    type = ATKEYWORD;
                }
        }

        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
        prevType = type;
    }

    // finalize arrays
    offsetAndType[tokenCount] = offset;
    balance[tokenCount] = sourceLength;
    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
    while (balanceStart !== 0) {
        balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
    }

    tokenizer.offsetAndType = offsetAndType;
    tokenizer.tokenCount = tokenCount;
    tokenizer.balance = balance;
}

//
// tokenizer
//

var Tokenizer = function(source, startOffset, startLine, startColumn) {
    this.offsetAndType = null;
    this.balance = null;
    this.lines = null;
    this.columns = null;

    this.setSource(source, startOffset, startLine, startColumn);
};

Tokenizer.prototype = {
    setSource: function(source, startOffset, startLine, startColumn) {
        var safeSource = String(source || '');
        var start = firstCharOffset(safeSource);

        this.source = safeSource;
        this.firstCharOffset = start;
        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
        this.linesAnsColumnsComputed = false;

        this.eof = false;
        this.currentToken = -1;
        this.tokenType = 0;
        this.tokenStart = start;
        this.tokenEnd = start;

        tokenLayout(this, safeSource, start);
        this.next();
    },

    lookupType: function(offset) {
        offset += this.currentToken;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
        }

        return NULL;
    },
    lookupNonWSType: function(offset) {
        offset += this.currentToken;

        for (var type; offset < this.tokenCount; offset++) {
            type = this.offsetAndType[offset] >> TYPE_SHIFT;

            if (type !== WHITESPACE) {
                return type;
            }
        }

        return NULL;
    },
    lookupValue: function(offset, referenceStr) {
        offset += this.currentToken;

        if (offset < this.tokenCount) {
            return cmpStr(
                this.source,
                this.offsetAndType[offset - 1] & OFFSET_MASK,
                this.offsetAndType[offset] & OFFSET_MASK,
                referenceStr
            );
        }

        return false;
    },
    getTokenStart: function(tokenNum) {
        if (tokenNum === this.currentToken) {
            return this.tokenStart;
        }

        if (tokenNum > 0) {
            return tokenNum < this.tokenCount
                ? this.offsetAndType[tokenNum - 1] & OFFSET_MASK
                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }

        return this.firstCharOffset;
    },
    getOffsetExcludeWS: function() {
        if (this.currentToken > 0) {
            if ((this.offsetAndType[this.currentToken - 1] >> TYPE_SHIFT) === WHITESPACE) {
                return this.currentToken > 1
                    ? this.offsetAndType[this.currentToken - 2] & OFFSET_MASK
                    : this.firstCharOffset;
            }
        }
        return this.tokenStart;
    },
    getRawLength: function(startToken, endTokenType1, endTokenType2, includeTokenType2) {
        var cursor = startToken;
        var balanceEnd;

        loop:
        for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];

            // belance end points to offset before start
            if (balanceEnd < startToken) {
                break loop;
            }

            // check token is stop type
            switch (this.offsetAndType[cursor] >> TYPE_SHIFT) {
                case endTokenType1:
                    break loop;

                case endTokenType2:
                    if (includeTokenType2) {
                        cursor++;
                    }
                    break loop;

                default:
                    // fast forward to the end of balanced block
                    if (this.balance[balanceEnd] === cursor) {
                        cursor = balanceEnd;
                    }
            }

        }

        return cursor - this.currentToken;
    },
    isBalanceEdge: function(pos) {
        var balanceStart = this.balance[this.currentToken];
        return balanceStart < pos;
    },

    getTokenValue: function() {
        return this.source.substring(this.tokenStart, this.tokenEnd);
    },
    substrToCursor: function(start) {
        return this.source.substring(start, this.tokenStart);
    },

    skipWS: function() {
        for (var i = this.currentToken, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
                break;
            }
        }

        if (skipTokenCount > 0) {
            this.skip(skipTokenCount);
        }
    },
    skipSC: function() {
        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
            this.next();
        }
    },
    skip: function(tokenCount) {
        var next = this.currentToken + tokenCount;

        if (next < this.tokenCount) {
            this.currentToken = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.currentToken = this.tokenCount;
            this.next();
        }
    },
    next: function() {
        var next = this.currentToken + 1;

        if (next < this.tokenCount) {
            this.currentToken = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.currentToken = this.tokenCount;
            this.eof = true;
            this.tokenType = NULL;
            this.tokenStart = this.tokenEnd = this.source.length;
        }
    },

    eat: function(tokenType) {
        if (this.tokenType !== tokenType) {
            var offset = this.tokenStart;
            var message = NAME[tokenType] + ' is expected';

            // tweak message and offset
            if (tokenType === IDENTIFIER) {
                // when identifier is expected but there is a function or url
                if (this.tokenType === FUNCTION || this.tokenType === URL) {
                    offset = this.tokenEnd - 1;
                    message += ' but function found';
                }
            } else {
                // when test type is part of another token show error for current position + 1
                // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
                if (this.source.charCodeAt(this.tokenStart) === tokenType) {
                    offset = offset + 1;
                }
            }

            this.error(message, offset);
        }

        this.next();
    },
    eatNonWS: function(tokenType) {
        this.skipWS();
        this.eat(tokenType);
    },

    consume: function(tokenType) {
        var value = this.getTokenValue();

        this.eat(tokenType);

        return value;
    },
    consumeFunctionName: function() {
        var name = this.source.substring(this.tokenStart, this.tokenEnd - 1);

        this.eat(FUNCTION);

        return name;
    },
    consumeNonWS: function(tokenType) {
        this.skipWS();

        return this.consume(tokenType);
    },

    expectIdentifier: function(name) {
        if (this.tokenType !== IDENTIFIER || cmpStr(this.source, this.tokenStart, this.tokenEnd, name) === false) {
            this.error('Identifier `' + name + '` is expected');
        }

        this.next();
    },

    getLocation: function(offset, filename) {
        if (!this.linesAnsColumnsComputed) {
            computeLinesAndColumns(this, this.source);
        }

        return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
        };
    },

    getLocationRange: function(start, end, filename) {
        if (!this.linesAnsColumnsComputed) {
            computeLinesAndColumns(this, this.source);
        }

        return {
            source: filename,
            start: {
                offset: this.startOffset + start,
                line: this.lines[start],
                column: this.columns[start]
            },
            end: {
                offset: this.startOffset + end,
                line: this.lines[end],
                column: this.columns[end]
            }
        };
    },

    error: function(message, offset) {
        var location = typeof offset !== 'undefined' && offset < this.source.length
            ? this.getLocation(offset)
            : this.eof
                ? this.getLocation(findWhiteSpaceStart(this.source, this.source.length - 1))
                : this.getLocation(this.tokenStart);

        throw new CssSyntaxError(
            message || 'Unexpected input',
            this.source,
            location.offset,
            location.line,
            location.column
        );
    },

    dump: function() {
        var offset = 0;

        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
            var start = offset;
            var end = item & OFFSET_MASK;

            offset = end;

            return {
                idx: idx,
                type: NAME[item >> TYPE_SHIFT],
                chunk: this.source.substring(start, end),
                balance: this.balance[idx]
            };
        }, this);
    }
};

// extend with error class
Tokenizer.CssSyntaxError = CssSyntaxError;

// extend tokenizer with constants
Object.keys(constants).forEach(function(key) {
    Tokenizer[key] = constants[key];
});

// extend tokenizer with static methods from utils
Object.keys(utils).forEach(function(key) {
    Tokenizer[key] = utils[key];
});

// warm up tokenizer to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
new Tokenizer('\n\r\r\n\f<!---->//""\'\'/*\r\n\f*/1a;.\\31\t\+2{url(a);func();+1.2e3 -.4e-5 .6e+7}').getLocation();

module.exports = Tokenizer;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createCustomError = __webpack_require__(24);
var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = '    ';

function sourceFragment(error, extraLines) {
    function processLines(start, end) {
        return lines.slice(start, end).map(function(line, idx) {
            var num = String(start + idx + 1);

            while (num.length < maxNumLength) {
                num = ' ' + num;
            }

            return num + ' |' + line;
        }).join('\n');
    }

    var lines = error.source.split(/\r\n?|\n|\f/);
    var line = error.line;
    var column = error.column;
    var startLine = Math.max(1, line - extraLines) - 1;
    var endLine = Math.min(line + extraLines, lines.length + 1);
    var maxNumLength = Math.max(4, String(endLine).length) + 1;
    var cutLeft = 0;

    // column correction according to replaced tab before column
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
    }

    for (var i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
        }
    }

    return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join('-') + '^',
        processLines(line, endLine)
    ].filter(Boolean).join('\n');
}

var CssSyntaxError = function(message, source, offset, line, column) {
    var error = createCustomError('CssSyntaxError', message);

    error.source = source;
    error.offset = offset;
    error.line = line;
    error.column = column;

    error.sourceFragment = function(extraLines) {
        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
    };
    Object.defineProperty(error, 'formattedMessage', {
        get: function() {
            return (
                'Parse error: ' + error.message + '\n' +
                sourceFragment(error, 2)
            );
        }
    });

    // for backward capability
    error.parseError = {
        offset: offset,
        line: line,
        column: column
    };

    return error;
};

module.exports = CssSyntaxError;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SyntaxReferenceError = __webpack_require__(46).SyntaxReferenceError;
var MatchError = __webpack_require__(46).MatchError;
var names = __webpack_require__(27);
var generic = __webpack_require__(103);
var parse = __webpack_require__(28);
var generate = __webpack_require__(26);
var walk = __webpack_require__(48);
var astToTokens = __webpack_require__(105);
var buildMatchGraph = __webpack_require__(49).buildMatchGraph;
var matchAsTree = __webpack_require__(106).matchAsTree;
var trace = __webpack_require__(107);
var search = __webpack_require__(108);
var getStructureFromConfig = __webpack_require__(109).getStructureFromConfig;
var cssWideKeywords = buildMatchGraph(parse('inherit | initial | unset'));
var cssWideKeywordsWithExpression = buildMatchGraph(parse('inherit | initial | unset | <expression>'));

function dumpMapSyntax(map, syntaxAsAst) {
    var result = {};

    for (var name in map) {
        if (map[name].syntax) {
            result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax);
        }
    }

    return result;
}

function valueHasVar(value) {
    var hasVar = false;

    this.syntax.walk(value, function(node) {
        if (node.type === 'Function' && node.name.toLowerCase() === 'var') {
            hasVar = true;
        }
    });

    return hasVar;
}

function buildMatchResult(match, error, iterations) {
    return {
        matched: match,
        iterations: iterations,
        error: error,
        getTrace: trace.getTrace,
        isType: trace.isType,
        isProperty: trace.isProperty,
        isKeyword: trace.isKeyword
    };
}

function matchSyntax(lexer, syntax, node, useCommon) {
    if (!node) {
        return buildMatchResult(null, new Error('Node is undefined'));
    }

    if (valueHasVar.call(lexer, node)) {
        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    }

    var tokens = lexer.syntax.generate(node, astToTokens);
    var result;

    if (useCommon) {
        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
    }

    if (!useCommon || !result.match) {
        result = matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
            return buildMatchResult(
                null,
                new MatchError(result.reason, lexer, syntax.syntax, node, result),
                result.iterations
            );
        }
    }

    return buildMatchResult(result.match, null, result.iterations);
}

var Lexer = function(config, syntax, structure) {
    this.valueCommonSyntax = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.properties = {};
    this.types = {};
    this.structure = structure || getStructureFromConfig(config);

    if (config) {
        if (config.generic) {
            this.generic = true;
            for (var name in generic) {
                this.addType_(name, generic[name]);
            }
        }

        if (config.types) {
            for (var name in config.types) {
                this.addType_(name, config.types[name]);
            }
        }

        if (config.properties) {
            for (var name in config.properties) {
                this.addProperty_(name, config.properties[name]);
            }
        }
    }
};

Lexer.prototype = {
    structure: {},
    checkStructure: function(ast) {
        function collectWarning(node, message) {
            warns.push({
                node: node,
                message: message
            });
        }

        var structure = this.structure;
        var warns = [];

        this.syntax.walk(ast, function(node) {
            if (structure.hasOwnProperty(node.type)) {
                structure[node.type].check(node, collectWarning);
            } else {
                collectWarning(node, 'Unknown node type `' + node.type + '`');
            }
        });

        return warns.length ? warns : false;
    },

    createDescriptor: function(syntax, type, name) {
        var ref = {
            type: type,
            name: name
        };
        var descriptor = {
            type: type,
            name: name,
            syntax: null,
            match: null
        };

        if (typeof syntax === 'function') {
            descriptor.match = buildMatchGraph(syntax, ref);
        } else {
            if (typeof syntax === 'string') {
                // lazy parsing on first access
                Object.defineProperty(descriptor, 'syntax', {
                    get: function() {
                        Object.defineProperty(descriptor, 'syntax', {
                            value: parse(syntax)
                        });

                        return descriptor.syntax;
                    }
                });
            } else {
                descriptor.syntax = syntax;
            }

            Object.defineProperty(descriptor, 'match', {
                get: function() {
                    Object.defineProperty(descriptor, 'match', {
                        value: buildMatchGraph(descriptor.syntax, ref)
                    });

                    return descriptor.match;
                }
            });
        }

        return descriptor;
    },
    addProperty_: function(name, syntax) {
        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    },
    addType_: function(name, syntax) {
        this.types[name] = this.createDescriptor(syntax, 'Type', name);

        if (syntax === generic.expression) {
            this.valueCommonSyntax = cssWideKeywordsWithExpression;
        }
    },

    matchDeclaration: function(node) {
        if (node.type !== 'Declaration') {
            return buildMatchResult(null, new Error('Not a Declaration node'));
        }

        return this.matchProperty(node.property, node.value);
    },
    matchProperty: function(propertyName, value) {
        var property = names.property(propertyName);

        // don't match syntax for a custom property
        if (property.custom) {
            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
        }

        var propertySyntax = property.vendor
            ? this.getProperty(property.name) || this.getProperty(property.basename)
            : this.getProperty(property.name);

        if (!propertySyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown property', propertyName));
        }

        return matchSyntax(this, propertySyntax, value, true);
    },
    matchType: function(typeName, value) {
        var typeSyntax = this.getType(typeName);

        if (!typeSyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
        }

        return matchSyntax(this, typeSyntax, value, false);
    },
    match: function(syntax, value) {
        if (!syntax || !syntax.type) {
            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
        }

        if (!syntax.match) {
            syntax = this.createDescriptor(syntax);
        }

        return matchSyntax(this, syntax, value, false);
    },

    findValueFragments: function(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    },
    findDeclarationValueFragments: function(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    },
    findAllFragments: function(ast, type, name) {
        var result = [];

        this.syntax.walk(ast, {
            visit: 'Declaration',
            enter: function(declaration) {
                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
            }.bind(this)
        });

        return result;
    },

    getProperty: function(name) {
        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
    },
    getType: function(name) {
        return this.types.hasOwnProperty(name) ? this.types[name] : null;
    },

    validate: function() {
        function validate(syntax, name, broken, descriptor) {
            if (broken.hasOwnProperty(name)) {
                return broken[name];
            }

            broken[name] = false;
            if (descriptor.syntax !== null) {
                walk(descriptor.syntax, function(node) {
                    if (node.type !== 'Type' && node.type !== 'Property') {
                        return;
                    }

                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                        broken[name] = true;
                    }
                }, this);
            }
        }

        var brokenTypes = {};
        var brokenProperties = {};

        for (var key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
        }

        for (var key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
        }

        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
            return brokenTypes[name];
        });
        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
            return brokenProperties[name];
        });

        if (brokenTypes.length || brokenProperties.length) {
            return {
                types: brokenTypes,
                properties: brokenProperties
            };
        }

        return null;
    },
    dump: function(syntaxAsAst) {
        return {
            generic: this.generic,
            types: dumpMapSyntax(this.types, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, syntaxAsAst)
        };
    },
    toString: function() {
        return JSON.stringify(this.dump());
    }
};

module.exports = Lexer;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var tokenizerUtils = __webpack_require__(45);
var findIdentifierEnd = tokenizerUtils.findIdentifierEnd;
var findNumberEnd = tokenizerUtils.findNumberEnd;
var findDecimalNumberEnd = tokenizerUtils.findDecimalNumberEnd;
var isHex = tokenizerUtils.isHex;
var tokenizerConst = __webpack_require__(25);
var SYMBOL_TYPE = tokenizerConst.SYMBOL_TYPE;
var IDENTIFIER = tokenizerConst.TYPE.Identifier;
var PLUSSIGN = tokenizerConst.TYPE.PlusSign;
var HYPHENMINUS = tokenizerConst.TYPE.HyphenMinus;
var NUMBERSIGN = tokenizerConst.TYPE.NumberSign;

var PERCENTAGE = {
    '%': true
};

// https://www.w3.org/TR/css-values-3/#lengths
var LENGTH = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,
    'q': true,

    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,

    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
};

var ANGLE = {
    'deg': true,
    'grad': true,
    'rad': true,
    'turn': true
};

var TIME = {
    's': true,
    'ms': true
};

var FREQUENCY = {
    'hz': true,
    'khz': true
};

// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
var RESOLUTION = {
    'dpi': true,
    'dpcm': true,
    'dppx': true,
    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
};

// https://drafts.csswg.org/css-grid/#fr-unit
var FLEX = {
    'fr': true
};

// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
var DECIBEL = {
    'db': true
};

// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
var SEMITONES = {
    'st': true
};

function consumeFunction(token, addTokenToMatch, getNextToken) {
    var length = 1;
    var cursor;

    do {
        cursor = getNextToken(length++);
    } while (cursor !== null && cursor.node !== token.node);

    if (cursor === null) {
        return false;
    }

    while (true) {
        // consume tokens until cursor
        if (addTokenToMatch() === cursor) {
            break;
        }
    }

    return true;
}

// TODO: implement
// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation
function calc(token, addTokenToMatch, getNextToken) {
    if (token === null) {
        return false;
    }

    var name = token.value.toLowerCase();
    if (name !== 'calc(' &&
        name !== '-moz-calc(' &&
        name !== '-webkit-calc(') {
        return false;
    }

    return consumeFunction(token, addTokenToMatch, getNextToken);
}

function attr(token, addTokenToMatch, getNextToken) {
    if (token === null || token.value.toLowerCase() !== 'attr(') {
        return false;
    }

    return consumeFunction(token, addTokenToMatch, getNextToken);
}

function expression(token, addTokenToMatch, getNextToken) {
    if (token === null || token.value.toLowerCase() !== 'expression(') {
        return false;
    }

    return consumeFunction(token, addTokenToMatch, getNextToken);
}

function url(token, addTokenToMatch, getNextToken) {
    if (token === null || token.value.toLowerCase() !== 'url(') {
        return false;
    }

    return consumeFunction(token, addTokenToMatch, getNextToken);
}

function idSelector(token, addTokenToMatch) {
    if (token === null) {
        return false;
    }

    if (token.value.charCodeAt(0) !== NUMBERSIGN) {
        return false;
    }

    if (consumeIdentifier(token.value, 1) !== token.value.length) {
        return false;
    }

    addTokenToMatch();
    return true;
}

function isNumber(str) {
    return /^[-+]?(\d+|\d*\.\d+)([eE][-+]?\d+)?$/.test(str);
}

function consumeNumber(str, allowFraction) {
    var code = str.charCodeAt(0);

    return findNumberEnd(str, code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0, allowFraction);
}

function consumeIdentifier(str, offset) {
    var code = str.charCodeAt(offset);

    if (code < 0x80 && SYMBOL_TYPE[code] !== IDENTIFIER && code !== HYPHENMINUS) {
        return offset;
    }

    return findIdentifierEnd(str, offset + 1);
}

function astNode(type) {
    return function(token, addTokenToMatch) {
        if (token === null || token.node.type !== type) {
            return false;
        }

        addTokenToMatch();
        return true;
    };
}

function dimension(type) {
    return function(token, addTokenToMatch, getNextToken) {
        if (calc(token, addTokenToMatch, getNextToken)) {
            return true;
        }

        if (token === null) {
            return false;
        }

        var numberEnd = consumeNumber(token.value, true);
        if (numberEnd === 0) {
            return false;
        }

        if (type) {
            if (!type.hasOwnProperty(token.value.substr(numberEnd).toLowerCase())) {
                return false;
            }
        } else {
            var unitEnd = consumeIdentifier(token.value, numberEnd);
            if (unitEnd === numberEnd || unitEnd !== token.value.length) {
                return false;
            }
        }

        addTokenToMatch();
        return true;
    };
}

function zeroUnitlessDimension(type) {
    var isDimension = dimension(type);

    return function(token, addTokenToMatch, getNextToken) {
        if (isDimension(token, addTokenToMatch, getNextToken)) {
            return true;
        }

        if (token === null || Number(token.value) !== 0) {
            return false;
        }

        addTokenToMatch();
        return true;
    };
}

function number(token, addTokenToMatch, getNextToken) {
    if (calc(token, addTokenToMatch, getNextToken)) {
        return true;
    }

    if (token === null) {
        return false;
    }

    var numberEnd = consumeNumber(token.value, true);
    if (numberEnd !== token.value.length) {
        return false;
    }

    addTokenToMatch();
    return true;
}

function numberZeroOne(token, addTokenToMatch, getNextToken) {
    if (calc(token, addTokenToMatch, getNextToken)) {
        return true;
    }

    if (token === null || !isNumber(token.value)) {
        return false;
    }

    var value = Number(token.value);
    if (value < 0 || value > 1) {
        return false;
    }

    addTokenToMatch();
    return true;
}

function numberOneOrGreater(token, addTokenToMatch, getNextToken) {
    if (calc(token, addTokenToMatch, getNextToken)) {
        return true;
    }

    if (token === null || !isNumber(token.value)) {
        return false;
    }

    var value = Number(token.value);
    if (value < 1) {
        return false;
    }

    addTokenToMatch();
    return true;
}

// TODO: fail on 10e-2
function integer(token, addTokenToMatch, getNextToken) {
    if (calc(token, addTokenToMatch, getNextToken)) {
        return true;
    }

    if (token === null) {
        return false;
    }

    var numberEnd = consumeNumber(token.value, false);
    if (numberEnd !== token.value.length) {
        return false;
    }

    addTokenToMatch();
    return true;
}

// TODO: fail on 10e-2
function positiveInteger(token, addTokenToMatch, getNextToken) {
    if (calc(token, addTokenToMatch, getNextToken)) {
        return true;
    }

    if (token === null) {
        return false;
    }

    var numberEnd = findDecimalNumberEnd(token.value, 0);
    if (numberEnd !== token.value.length || token.value.charCodeAt(0) === HYPHENMINUS) {
        return false;
    }

    addTokenToMatch();
    return true;
}

function hexColor(token, addTokenToMatch) {
    if (token === null || token.value.charCodeAt(0) !== NUMBERSIGN) {
        return false;
    }

    var length = token.value.length - 1;

    // valid length is 3, 4, 6 and 8 (+1 for #)
    if (length !== 3 && length !== 4 && length !== 6 && length !== 8) {
        return false;
    }

    for (var i = 1; i < length; i++) {
        if (!isHex(token.value.charCodeAt(i))) {
            return false;
        }
    }

    addTokenToMatch();
    return true;
}

// https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
// https://drafts.csswg.org/css-values-4/#identifier-value
function customIdent(token, addTokenToMatch) {
    if (token === null) {
        return false;
    }

    var identEnd = consumeIdentifier(token.value, 0);
    if (identEnd !== token.value.length) {
        return false;
    }

    var name = token.value.toLowerCase();

    // § 3.2. Author-defined Identifiers: the <custom-ident> type
    // The CSS-wide keywords are not valid <custom-ident>s
    if (name === 'unset' || name === 'initial' || name === 'inherit') {
        return false;
    }

    // The default keyword is reserved and is also not a valid <custom-ident>
    if (name === 'default') {
        return false;
    }

    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)

    addTokenToMatch();
    return true;
}

module.exports = {
    'angle': zeroUnitlessDimension(ANGLE),
    'attr()': attr,
    'custom-ident': customIdent,
    'decibel': dimension(DECIBEL),
    'dimension': dimension(),
    'frequency': dimension(FREQUENCY),
    'flex': dimension(FLEX),
    'hex-color': hexColor,
    'id-selector': idSelector, // element( <id-selector> )
    'ident': astNode('Identifier'),
    'integer': integer,
    'length': zeroUnitlessDimension(LENGTH),
    'number': number,
    'number-zero-one': numberZeroOne,
    'number-one-or-greater': numberOneOrGreater,
    'percentage': dimension(PERCENTAGE),
    'positive-integer': positiveInteger,
    'resolution': dimension(RESOLUTION),
    'semitones': dimension(SEMITONES),
    'string': astNode('String'),
    'time': dimension(TIME),
    'unicode-range': astNode('UnicodeRange'),
    'url': url,

    // old IE stuff
    'progid': astNode('Raw'),
    'expression': expression
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var SyntaxParseError = __webpack_require__(47).SyntaxParseError;

var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;

var Tokenizer = function(str) {
    this.str = str;
    this.pos = 0;
};

Tokenizer.prototype = {
    charCodeAt: function(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    },
    charCode: function() {
        return this.charCodeAt(this.pos);
    },
    nextCharCode: function() {
        return this.charCodeAt(this.pos + 1);
    },
    nextNonWsCode: function(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
    },
    findWsEnd: function(pos) {
        for (; pos < this.str.length; pos++) {
            var code = this.str.charCodeAt(pos);
            if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
                break;
            }
        }

        return pos;
    },
    substringToPos: function(end) {
        return this.str.substring(this.pos, this.pos = end);
    },
    eat: function(code) {
        if (this.charCode() !== code) {
            this.error('Expect `' + String.fromCharCode(code) + '`');
        }

        this.pos++;
    },
    peek: function() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
    },
    error: function(message) {
        throw new SyntaxParseError(message, this.str, this.pos);
    }
};

module.exports = Tokenizer;


/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = {
    decorator: function(handlers) {
        var curNode = null;
        var prev = null;
        var tokens = [];

        return {
            children: handlers.children,
            node: function(node) {
                var tmp = curNode;
                curNode = node;
                handlers.node.call(this, node);
                curNode = tmp;
            },
            chunk: function(chunk) {
                if (tokens.length > 0) {
                    switch (curNode.type) {
                        case 'Dimension':
                        case 'HexColor':
                        case 'IdSelector':
                        case 'Percentage':
                            if (prev.node === curNode) {
                                prev.value += chunk;
                                return;
                            }
                            break;

                        case 'Function':
                        case 'PseudoClassSelector':
                        case 'PseudoElementSelector':
                        case 'Url':
                            if (chunk === '(') {
                                prev.value += chunk;
                                return;
                            }
                            break;

                        case 'Atrule':
                            if (prev.node === curNode && prev.value === '@') {
                                prev.value += chunk;
                                return;
                            }
                            break;
                    }
                }

                tokens.push(prev = {
                    value: chunk,
                    node: curNode
                });
            },
            result: function() {
                return tokens;
            }
        };
    }
};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasOwnProperty = Object.prototype.hasOwnProperty;
var matchGraph = __webpack_require__(49);
var MATCH = matchGraph.MATCH;
var MISMATCH = matchGraph.MISMATCH;
var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;

var TOKEN = 1;
var OPEN_SYNTAX = 2;
var CLOSE_SYNTAX = 3;

var EXIT_REASON_MATCH = 'Match';
var EXIT_REASON_MISMATCH = 'Mismatch';
var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

var ITERATION_LIMIT = 10000;
var totalIterationCount = 0;

function mapList(list, fn) {
    var result = [];

    while (list) {
        result.unshift(fn(list));
        list = list.prev;
    }

    return result;
}

function isCommaContextStart(token) {
    if (token === null) {
        return true;
    }

    token = token.value.charAt(token.value.length - 1);

    return (
        token === ',' ||
        token === '(' ||
        token === '[' ||
        token === '/'
    );
}

function isCommaContextEnd(token) {
    if (token === null) {
        return true;
    }

    token = token.value.charAt(0);

    return (
        token === ')' ||
        token === ']' ||
        token === '/'
    );
}

function internalMatch(tokens, syntax, syntaxes) {
    function moveToNextToken() {
        do {
            tokenCursor++;
            token = tokenCursor < tokens.length ? tokens[tokenCursor] : null;
        } while (token !== null && !/\S/.test(token.value));
    }

    function getNextToken(offset) {
        var nextIndex = tokenCursor + offset;

        return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }

    function pushThenStack(nextSyntax) {
        thenStack = {
            nextSyntax: nextSyntax,
            matchStack: matchStack,
            syntaxStack: syntaxStack,
            prev: thenStack
        };
    }

    function pushElseStack(nextSyntax) {
        elseStack = {
            nextSyntax: nextSyntax,
            matchStack: matchStack,
            syntaxStack: syntaxStack,
            thenStack: thenStack,
            tokenCursor: tokenCursor,
            token: token,
            prev: elseStack
        };
    }

    function addTokenToMatch() {
        matchStack = {
            type: TOKEN,
            syntax: syntax.syntax,
            token: token,
            prev: matchStack
        };

        moveToNextToken();

        if (tokenCursor > longestMatch) {
            longestMatch = tokenCursor;
        }

        return matchStack.token;
    }

    function openSyntax() {
        syntaxStack = {
            syntax: syntax,
            prev: syntaxStack
        };

        matchStack = {
            type: OPEN_SYNTAX,
            syntax: syntax.syntax,
            token: matchStack.token,
            prev: matchStack
        };
    }

    function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
        } else {
            matchStack = {
                type: CLOSE_SYNTAX,
                syntax: syntaxStack.syntax,
                token: matchStack.token,
                prev: matchStack
            };
        }

        syntaxStack = syntaxStack.prev;
    }

    var syntaxStack = null;
    var thenStack = null;
    var elseStack = null;

    var iterationCount = 0;
    var exitReason = EXIT_REASON_MATCH;

    var matchStack = { type: 'Stub', syntax: null, token: null, tokenCursor: -1, prev: null };
    var longestMatch = 0;
    var tokenCursor = -1;
    var token = null;

    moveToNextToken();

    while (true) {
        // console.log('--\n',
        //     '#' + iterationCount,
        //     require('util').inspect({
        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? x.type + '!' + x.syntax.name : null),
        //         elseStack: mapList(elseStack, x => x.id),
        //         thenStack: mapList(thenStack, x => x.id),
        //         token: token && token.value,
        //         tokenCursor,
        //         syntax
        //     }, { depth: null })
        // );

        // prevent infinite loop
        if (++iterationCount === ITERATION_LIMIT) {
            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            break;
        }

        if (syntax === MATCH) {
            if (thenStack === null) {
                // turn to MISMATCH when some tokens left unmatched
                if (token !== null) {
                    // doesn't mismatch if just one token left and it's an IE hack
                    if (tokenCursor !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
                        syntax = MISMATCH;
                        continue;
                    }
                }

                // break the main loop, return a result - MATCH
                exitReason = EXIT_REASON_MATCH;
                break;
            }

            // go to next syntax (`then` branch)
            syntax = thenStack.nextSyntax;

            // check match is not empty
            if (syntax === DISALLOW_EMPTY) {
                if (thenStack.matchStack.token === matchStack.token) {
                    syntax = MISMATCH;
                    continue;
                } else {
                    syntax = MATCH;
                }
            }

            // close syntax if needed
            while (syntaxStack !== null && thenStack.syntaxStack !== syntaxStack) {
                closeSyntax();
            }

            // pop stack
            thenStack = thenStack.prev;
            continue;
        }

        if (syntax === MISMATCH) {
            if (elseStack === null) {
                // break the main loop, return a result - MISMATCH
                exitReason = EXIT_REASON_MISMATCH;
                break;
            }

            // go to next syntax (`else` branch)
            syntax = elseStack.nextSyntax;

            // restore all the rest stack states
            thenStack = elseStack.thenStack;
            syntaxStack = elseStack.syntaxStack;
            matchStack = elseStack.matchStack;
            tokenCursor = elseStack.tokenCursor;
            token = elseStack.token;

            // pop stack
            elseStack = elseStack.prev;
            continue;
        }

        switch (syntax.type) {
            case 'MatchGraph':
                syntax = syntax.match;
                break;

            case 'If':
                // IMPORTANT: else stack push must go first,
                // since it stores the state of thenStack before changes
                if (syntax.else !== MISMATCH) {
                    pushElseStack(syntax.else);
                }

                if (syntax.then !== MATCH) {
                    pushThenStack(syntax.then);
                }

                syntax = syntax.match;
                break;

            case 'MatchOnce':
                syntax = {
                    type: 'MatchOnceBuffer',
                    terms: syntax.terms,
                    all: syntax.all,
                    matchStack: matchStack,
                    index: 0,
                    mask: 0
                };
                break;

            case 'MatchOnceBuffer':
                if (syntax.index === syntax.terms.length) {
                    // if no matches during a cycle
                    if (syntax.matchStack === matchStack) {
                        // no matches at all or it's required all terms to be matched
                        if (syntax.mask === 0 || syntax.all) {
                            syntax = MISMATCH;
                            break;
                        }

                        // a partial match is ok
                        syntax = MATCH;
                        break;
                    } else {
                        // start trying to match from the start
                        syntax.index = 0;
                        syntax.matchStack = matchStack;
                    }
                }

                for (; syntax.index < syntax.terms.length; syntax.index++) {
                    if ((syntax.mask & (1 << syntax.index)) === 0) {
                        // IMPORTANT: else stack push must go first,
                        // since it stores the state of thenStack before changes
                        pushElseStack(syntax);
                        pushThenStack({
                            type: 'AddMatchOnce',
                            buffer: syntax
                        });

                        // match
                        syntax = syntax.terms[syntax.index++];
                        break;
                    }
                }
                break;

            case 'AddMatchOnce':
                syntax = syntax.buffer;

                var newMask = syntax.mask | (1 << (syntax.index - 1));

                // all terms are matched
                if (newMask === (1 << syntax.terms.length) - 1) {
                    syntax = MATCH;
                    continue;
                }

                syntax = {
                    type: 'MatchOnceBuffer',
                    terms: syntax.terms,
                    all: syntax.all,
                    matchStack: syntax.matchStack,
                    index: syntax.index,
                    mask: newMask
                };

                break;

            case 'Enum':
                var name = token !== null ? token.value.toLowerCase() : '';

                // drop \0 and \9 hack from keyword name
                if (name.indexOf('\\') !== -1) {
                    name = name.replace(/\\[09].*$/, '');
                }

                if (hasOwnProperty.call(syntax.map, name)) {
                    syntax = syntax.map[name];
                } else {
                    syntax = MISMATCH;
                }

                break;

            case 'Generic':
                syntax = syntax.fn(token, addTokenToMatch, getNextToken) ? MATCH : MISMATCH;
                break;

            case 'Type':
            case 'Property':
                openSyntax();

                var syntaxDict = syntax.type === 'Type' ? 'types' : 'properties';

                if (hasOwnProperty.call(syntaxes, syntaxDict) && syntaxes[syntaxDict][syntax.name]) {
                    syntax = syntaxes[syntaxDict][syntax.name].match;
                } else {
                    syntax = undefined;
                }

                if (!syntax) {
                    throw new Error(
                        'Bad syntax reference: ' +
                        (syntaxStack.syntax.type === 'Type'
                            ? '<' + syntaxStack.syntax.name + '>'
                            : '<\'' + syntaxStack.syntax.name + '\'>')
                    );
                }

                break;

            case 'Keyword':
                var name = syntax.name;

                if (token !== null) {
                    var keywordName = token.value;

                    // drop \0 and \9 hack from keyword name
                    if (keywordName.indexOf('\\') !== -1) {
                        keywordName = keywordName.replace(/\\[09].*$/, '');
                    }

                    if (keywordName.toLowerCase() === name) {
                        addTokenToMatch();

                        syntax = MATCH;
                        break;
                    }
                }

                syntax = MISMATCH;
                break;

            case 'AtKeyword':
            case 'Function':
                if (token !== null && token.value.toLowerCase() === syntax.name) {
                    addTokenToMatch();

                    syntax = MATCH;
                    break;
                }

                syntax = MISMATCH;
                break;

            case 'Token':
                if (token !== null && token.value === syntax.value) {
                    addTokenToMatch();

                    syntax = MATCH;
                    break;
                }

                syntax = MISMATCH;
                break;

            case 'Comma':
                if (token !== null && token.value === ',') {
                    if (isCommaContextStart(matchStack.token)) {
                        syntax = MISMATCH;
                    } else {
                        addTokenToMatch();
                        syntax = isCommaContextEnd(token) ? MISMATCH : MATCH;
                    }
                } else {
                    syntax = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
                }

                break;

            // case 'String':
            // TODO: strings with length other than 1 char

            default:
                throw new Error('Unknown node type: ' + syntax.type);
        }
    }

    totalIterationCount += iterationCount;

    if (exitReason === EXIT_REASON_MATCH) {
        while (syntaxStack !== null) {
            closeSyntax();
        }
    } else {
        matchStack = null;
    }

    return {
        tokens: tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch: longestMatch
    };
}

function matchAsList(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match !== null) {
        matchResult.match = mapList(matchResult.match, function(item) {
            if (item.type === OPEN_SYNTAX || item.type === CLOSE_SYNTAX) {
                return { type: item.type, syntax: item.syntax };
            }

            return {
                syntax: item.syntax,
                token: item.token && item.token.value,
                node: item.token && item.token.node
            };
        }).slice(1);
    }

    return matchResult;
}

function matchAsTree(tokens, matchGraph, syntaxes) {
    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match === null) {
        return matchResult;
    }

    var cursor = matchResult.match;
    var host = matchResult.match = {
        syntax: matchGraph.syntax || null,
        match: []
    };
    var stack = [host];

    // revert a list
    var prev = null;
    var next = null;
    while (cursor !== null) {
        next = cursor.prev;
        cursor.prev = prev;
        prev = cursor;
        cursor = next;
    }

    // init the cursor to start with 2nd item since 1st is a stub item
    cursor = prev.prev;

    // build a tree
    while (cursor !== null && cursor.syntax !== null) {
        var entry = cursor;

        switch (entry.type) {
            case OPEN_SYNTAX:
                host.match.push(host = {
                    syntax: entry.syntax,
                    match: []
                });
                stack.push(host);
                break;

            case CLOSE_SYNTAX:
                stack.pop();
                host = stack[stack.length - 1];
                break;

            default:
                host.match.push({
                    syntax: entry.syntax || null,
                    token: entry.token.value,
                    node: entry.token.node
                });
        }

        cursor = cursor.prev;
    }

    return matchResult;
}

module.exports = {
    matchAsList: matchAsList,
    matchAsTree: matchAsTree,
    getTotalIterationCount: function() {
        return totalIterationCount;
    }
};


/***/ }),
/* 107 */
/***/ (function(module, exports) {

function getTrace(node) {
    function shouldPutToTrace(syntax) {
        if (syntax === null) {
            return false;
        }

        return (
            syntax.type === 'Type' ||
            syntax.type === 'Property' ||
            syntax.type === 'Keyword'
        );
    }

    function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
            // use for-loop for better perfomance
            for (var i = 0; i < matchNode.match.length; i++) {
                if (hasMatch(matchNode.match[i])) {
                    if (shouldPutToTrace(matchNode.syntax)) {
                        result.unshift(matchNode.syntax);
                    }

                    return true;
                }
            }
        } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax)
                ? [matchNode.syntax]
                : [];

            return true;
        }

        return false;
    }

    var result = null;

    if (this.matched !== null) {
        hasMatch(this.matched);
    }

    return result;
}

function testNode(match, node, fn) {
    var trace = getTrace.call(match, node);

    if (trace === null) {
        return false;
    }

    return trace.some(fn);
}

function isType(node, type) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Type' && matchNode.name === type;
    });
}

function isProperty(node, property) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Property' && matchNode.name === property;
    });
}

function isKeyword(node) {
    return testNode(this, node, function(matchNode) {
        return matchNode.type === 'Keyword';
    });
}

module.exports = {
    getTrace: getTrace,
    isType: isType,
    isProperty: isProperty,
    isKeyword: isKeyword
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(7);

function getFirstMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getFirstMatchNode(matchNode.match[0]);
}

function getLastMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
        if (matchNode.syntax !== null &&
            matchNode.syntax.type === type &&
            matchNode.syntax.name === name) {
            var start = getFirstMatchNode(matchNode);
            var end = getLastMatchNode(matchNode);

            lexer.syntax.walk(ast, function(node, item, list) {
                if (node === start) {
                    var nodes = new List();

                    do {
                        nodes.appendData(item.data);

                        if (item.data === end) {
                            break;
                        }

                        item = item.next;
                    } while (item !== null);

                    fragments.push({
                        parent: list,
                        nodes: nodes
                    });
                }
            });
        }

        if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
        }
    }

    var fragments = [];

    if (match.matched !== null) {
        findFragments(match.matched);
    }

    return fragments;
}

module.exports = {
    matchFragments: matchFragments
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(7);
var hasOwnProperty = Object.prototype.hasOwnProperty;

function isValidNumber(value) {
    // Number.isInteger(value) && value >= 0
    return (
        typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value &&
        value >= 0
    );
}

function isValidLocation(loc) {
    return (
        Boolean(loc) &&
        isValidNumber(loc.offset) &&
        isValidNumber(loc.line) &&
        isValidNumber(loc.column)
    );
}

function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
            return warn(node, 'Type of node should be an Object');
        }

        for (var key in node) {
            var valid = true;

            if (hasOwnProperty.call(node, key) === false) {
                continue;
            }

            if (key === 'type') {
                if (node.type !== type) {
                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
                }
            } else if (key === 'loc') {
                if (node.loc === null) {
                    continue;
                } else if (node.loc && node.loc.constructor === Object) {
                    if (typeof node.loc.source !== 'string') {
                        key += '.source';
                    } else if (!isValidLocation(node.loc.start)) {
                        key += '.start';
                    } else if (!isValidLocation(node.loc.end)) {
                        key += '.end';
                    } else {
                        continue;
                    }
                }

                valid = false;
            } else if (fields.hasOwnProperty(key)) {
                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
                    var fieldType = fields[key][i];

                    switch (fieldType) {
                        case String:
                            valid = typeof node[key] === 'string';
                            break;

                        case Boolean:
                            valid = typeof node[key] === 'boolean';
                            break;

                        case null:
                            valid = node[key] === null;
                            break;

                        default:
                            if (typeof fieldType === 'string') {
                                valid = node[key] && node[key].type === fieldType;
                            } else if (Array.isArray(fieldType)) {
                                valid = node[key] instanceof List;
                            }
                    }
                }
            } else {
                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
            }

            if (!valid) {
                warn(node, 'Bad value for `' + type + '.' + key + '`');
            }
        }

        for (var key in fields) {
            if (hasOwnProperty.call(fields, key) &&
                hasOwnProperty.call(node, key) === false) {
                warn(node, 'Field `' + type + '.' + key + '` is missed');
            }
        }
    };
}

function processStructure(name, nodeType) {
    var structure = nodeType.structure;
    var fields = {
        type: String,
        loc: true
    };
    var docs = {
        type: '"' + name + '"'
    };

    for (var key in structure) {
        if (hasOwnProperty.call(structure, key) === false) {
            continue;
        }

        var docsTypes = [];
        var fieldTypes = fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]];

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
                docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
                docsTypes.push('null');
            } else if (typeof fieldType === 'string') {
                docsTypes.push('<' + fieldType + '>');
            } else if (Array.isArray(fieldType)) {
                docsTypes.push('List'); // TODO: use type enum
            } else {
                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
            }
        }

        docs[key] = docsTypes.join(' | ');
    }

    return {
        docs: docs,
        check: createNodeStructureChecker(name, fields)
    };
}

module.exports = {
    getStructureFromConfig: function(config) {
        var structure = {};

        if (config.node) {
            for (var name in config.node) {
                if (hasOwnProperty.call(config.node, name)) {
                    var nodeType = config.node[name];

                    if (nodeType.structure) {
                        structure[name] = processStructure(name, nodeType);
                    } else {
                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
                    }
                }
            }
        }

        return structure;
    }
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    SyntaxParseError: __webpack_require__(47).SyntaxParseError,
    parse: __webpack_require__(28),
    generate: __webpack_require__(26),
    walk: __webpack_require__(48)
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Tokenizer = __webpack_require__(0);
var List = __webpack_require__(7);
var sequence = __webpack_require__(112);
var noop = function() {};

function createParseContext(name) {
    return function() {
        return this[name]();
    };
}

function processConfig(config) {
    var parserConfig = {
        context: {},
        scope: {},
        atrule: {},
        pseudo: {}
    };

    if (config.parseContext) {
        for (var name in config.parseContext) {
            switch (typeof config.parseContext[name]) {
                case 'function':
                    parserConfig.context[name] = config.parseContext[name];
                    break;

                case 'string':
                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
                    break;
            }
        }
    }

    if (config.scope) {
        for (var name in config.scope) {
            parserConfig.scope[name] = config.scope[name];
        }
    }

    if (config.atrule) {
        for (var name in config.atrule) {
            var atrule = config.atrule[name];

            if (atrule.parse) {
                parserConfig.atrule[name] = atrule.parse;
            }
        }
    }

    if (config.pseudo) {
        for (var name in config.pseudo) {
            var pseudo = config.pseudo[name];

            if (pseudo.parse) {
                parserConfig.pseudo[name] = pseudo.parse;
            }
        }
    }

    if (config.node) {
        for (var name in config.node) {
            parserConfig[name] = config.node[name].parse;
        }
    }

    return parserConfig;
}

module.exports = function createParser(config) {
    var parser = {
        scanner: new Tokenizer(),
        filename: '<unknown>',
        needPositions: false,
        onParseError: noop,
        onParseErrorThrow: false,
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,

        readSequence: sequence,

        createList: function() {
            return new List();
        },
        createSingleNodeList: function(node) {
            return new List().appendData(node);
        },
        getFirstListNode: function(list) {
            return list && list.first();
        },
        getLastListNode: function(list) {
            return list.last();
        },

        parseWithFallback: function(consumer, fallback) {
            var startToken = this.scanner.currentToken;

            try {
                return consumer.call(this);
            } catch (e) {
                if (this.onParseErrorThrow) {
                    throw e;
                }

                var fallbackNode = fallback.call(this, startToken);

                this.onParseErrorThrow = true;
                this.onParseError(e, fallbackNode);
                this.onParseErrorThrow = false;

                return fallbackNode;
            }
        },

        getLocation: function(start, end) {
            if (this.needPositions) {
                return this.scanner.getLocationRange(
                    start,
                    end,
                    this.filename
                );
            }

            return null;
        },
        getLocationFromList: function(list) {
            if (this.needPositions) {
                var head = this.getFirstListNode(list);
                var tail = this.getLastListNode(list);
                return this.scanner.getLocationRange(
                    head !== null ? head.loc.start.offset - this.scanner.startOffset : this.scanner.tokenStart,
                    tail !== null ? tail.loc.end.offset - this.scanner.startOffset : this.scanner.tokenStart,
                    this.filename
                );
            }

            return null;
        }
    };

    config = processConfig(config || {});
    for (var key in config) {
        parser[key] = config[key];
    }

    return function(source, options) {
        options = options || {};

        var context = options.context || 'default';
        var ast;

        parser.scanner.setSource(source, options.offset, options.line, options.column);
        parser.filename = options.filename || '<unknown>';
        parser.needPositions = Boolean(options.positions);
        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;
        parser.onParseErrorThrow = false;
        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

        if (!parser.context.hasOwnProperty(context)) {
            throw new Error('Unknown context `' + context + '`');
        }

        ast = parser.context[context].call(parser, options);

        if (!parser.scanner.eof) {
            parser.scanner.error();
        }

        return ast;
    };
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;
var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;

module.exports = function readSequence(recognizer) {
    var children = this.createList();
    var child = null;
    var context = {
        recognizer: recognizer,
        space: null,
        ignoreWS: false,
        ignoreWSAfter: false
    };

    this.scanner.skipSC();

    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case COMMENT:
                this.scanner.next();
                continue;

            case WHITESPACE:
                if (context.ignoreWS) {
                    this.scanner.next();
                } else {
                    context.space = this.WhiteSpace();
                }
                continue;
        }

        child = recognizer.getNode.call(this, context);

        if (child === undefined) {
            break;
        }

        if (context.space !== null) {
            children.push(context.space);
            context.space = null;
        }

        children.push(child);

        if (context.ignoreWSAfter) {
            context.ignoreWSAfter = false;
            context.ignoreWS = true;
        } else {
            context.ignoreWS = false;
        }
    }

    return children;
};


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var sourceMap = __webpack_require__(114);
var hasOwnProperty = Object.prototype.hasOwnProperty;

function processChildren(node, delimeter) {
    var list = node.children;
    var prev = null;

    if (typeof delimeter !== 'function') {
        list.forEach(this.node, this);
    } else {
        list.forEach(function(node) {
            if (prev !== null) {
                delimeter.call(this, prev);
            }

            this.node(node);
            prev = node;
        }, this);
    }
}

module.exports = function createGenerator(config) {
    function processNode(node) {
        if (hasOwnProperty.call(types, node.type)) {
            types[node.type].call(this, node);
        } else {
            throw new Error('Unknown node type: ' + node.type);
        }
    }

    var types = {};

    if (config.node) {
        for (var name in config.node) {
            types[name] = config.node[name].generate;
        }
    }

    return function(node, options) {
        var buffer = '';
        var handlers = {
            children: processChildren,
            node: processNode,
            chunk: function(chunk) {
                buffer += chunk;
            },
            result: function() {
                return buffer;
            }
        };

        if (options) {
            if (typeof options.decorator === 'function') {
                handlers = options.decorator(handlers);
            }

            if (options.sourceMap) {
                handlers = sourceMap(handlers);
            }
        }

        handlers.node(node);

        return handlers.result();
    };
};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SourceMapGenerator = __webpack_require__(115).SourceMapGenerator;
var trackNodes = {
    Atrule: true,
    Selector: true,
    Declaration: true
};

module.exports = function generateSourceMap(handlers) {
    var map = new SourceMapGenerator();
    var line = 1;
    var column = 0;
    var generated = {
        line: 1,
        column: 0
    };
    var original = {
        line: 0, // should be zero to add first mapping
        column: 0
    };
    var sourceMappingActive = false;
    var activatedGenerated = {
        line: 1,
        column: 0
    };
    var activatedMapping = {
        generated: activatedGenerated
    };

    var handlersNode = handlers.node;
    handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
            var nodeLine = node.loc.start.line;
            var nodeColumn = node.loc.start.column - 1;

            if (original.line !== nodeLine ||
                original.column !== nodeColumn) {
                original.line = nodeLine;
                original.column = nodeColumn;

                generated.line = line;
                generated.column = column;

                if (sourceMappingActive) {
                    sourceMappingActive = false;
                    if (generated.line !== activatedGenerated.line ||
                        generated.column !== activatedGenerated.column) {
                        map.addMapping(activatedMapping);
                    }
                }

                sourceMappingActive = true;
                map.addMapping({
                    source: node.loc.source,
                    original: original,
                    generated: generated
                });
            }
        }

        handlersNode.call(this, node);

        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
        }
    };

    var handlersChunk = handlers.chunk;
    handlers.chunk = function(chunk) {
        for (var i = 0; i < chunk.length; i++) {
            if (chunk.charCodeAt(i) === 10) { // \n
                line++;
                column = 0;
            } else {
                column++;
            }
        }

        handlersChunk(chunk);
    };

    var handlersResult = handlers.result;
    handlers.result = function() {
        if (sourceMappingActive) {
            map.addMapping(activatedMapping);
        }

        return {
            css: handlersResult(),
            map: map
        };
    };

    return handlers;
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(50).SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(118).SourceMapConsumer;
exports.SourceNode = __webpack_require__(121).SourceNode;


/***/ }),
/* 116 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(9);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(9);
var binarySearch = __webpack_require__(119);
var ArraySet = __webpack_require__(52).ArraySet;
var base64VLQ = __webpack_require__(51);
var quickSort = __webpack_require__(120).quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),
/* 119 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),
/* 120 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __webpack_require__(50).SourceMapGenerator;
var util = __webpack_require__(9);

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(7);

module.exports = function createConvertors(walk) {
    return {
        fromPlainObject: function(ast) {
            walk(ast, {
                enter: function(node) {
                    if (node.children && node.children instanceof List === false) {
                        node.children = new List().fromArray(node.children);
                    }
                }
            });

            return ast;
        },
        toPlainObject: function(ast) {
            walk(ast, {
                leave: function(node) {
                    if (node.children && node.children instanceof List) {
                        node.children = node.children.toArray();
                    }
                }
            });

            return ast;
        }
    };
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasOwnProperty = Object.prototype.hasOwnProperty;
var noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

function invokeForType(fn, type) {
    return function(node, item, list) {
        if (node.type === type) {
            fn.call(this, node, item, list);
        }
    };
}

function getWalkersFromStructure(name, nodeType) {
    var structure = nodeType.structure;
    var walkers = [];

    for (var key in structure) {
        if (hasOwnProperty.call(structure, key) === false) {
            continue;
        }

        var fieldTypes = structure[key];
        var walker = {
            name: key,
            type: false,
            nullable: false
        };

        if (!Array.isArray(structure[key])) {
            fieldTypes = [structure[key]];
        }

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === null) {
                walker.nullable = true;
            } else if (typeof fieldType === 'string') {
                walker.type = 'node';
            } else if (Array.isArray(fieldType)) {
                walker.type = 'list';
            }
        }

        if (walker.type) {
            walkers.push(walker);
        }
    }

    if (walkers.length) {
        return {
            context: nodeType.walkContext,
            fields: walkers
        };
    }

    return null;
}

function getTypesFromConfig(config) {
    var types = {};

    for (var name in config.node) {
        if (hasOwnProperty.call(config.node, name)) {
            var nodeType = config.node[name];

            if (!nodeType.structure) {
                throw new Error('Missed `structure` field in `' + name + '` node type definition');
            }

            types[name] = getWalkersFromStructure(name, nodeType);
        }
    }

    return types;
}

function createTypeIterator(config, reverse) {
    var fields = reverse ? config.fields.slice().reverse() : config.fields;
    var body = fields.map(function(field) {
        var ref = 'node.' + field.name;
        var line;

        if (field.type === 'list') {
            line = reverse
                ? ref + '.forEachRight(walk);'
                : ref + '.forEach(walk);';
        } else {
            line = 'walk(' + ref + ');';
        }

        if (field.nullable) {
            line = 'if (' + ref + ') {\n    ' + line + '}';
        }

        return line;
    });

    if (config.context) {
        body = [].concat(
            'var old = context.' + config.context + ';',
            'context.' + config.context + ' = node;',
            body,
            'context.' + config.context + ' = old;'
        );
    }

    return new Function('node', 'context', 'walk', body.join('\n'));
}

function createFastTraveralMap(iterators) {
    return {
        Atrule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Rule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        },
        Declaration: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        }
    };
}

module.exports = function createWalker(config) {
    var types = getTypesFromConfig(config);
    var iteratorsNatural = {};
    var iteratorsReverse = {};

    for (var name in types) {
        if (hasOwnProperty.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
    }

    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    return function walk(root, options) {
        function walkNode(node, item, list) {
            enter.call(context, node, item, list);

            if (iterators.hasOwnProperty(node.type)) {
                iterators[node.type](node, context, walkNode);
            }

            leave.call(context, node, item, list);
        }

        var enter = noop;
        var leave = noop;
        var iterators = iteratorsNatural;
        var context = {
            root: root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null
        };

        if (typeof options === 'function') {
            enter = options;
        } else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);

            if (options.reverse) {
                iterators = iteratorsReverse;
            }

            if (options.visit) {
                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                    iterators = options.reverse
                        ? fastTraversalIteratorsReverse[options.visit]
                        : fastTraversalIteratorsNatural[options.visit];
                } else if (!types.hasOwnProperty(options.visit)) {
                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
                }

                enter = invokeForType(enter, options.visit);
                leave = invokeForType(leave, options.visit);
            }
        }

        if (enter === noop && leave === noop) {
            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
        }

        // swap handlers in reverse mode to invert visit order
        if (options.reverse) {
            var tmp = enter;
            enter = leave;
            leave = tmp;
        }

        walkNode(root);
    };
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var List = __webpack_require__(7);

module.exports = function clone(node) {
    var result = {};

    for (var key in node) {
        var value = node[key];

        if (value) {
            if (Array.isArray(value) || value instanceof List) {
                value = value.map(clone);
            } else if (value.constructor === Object) {
                value = clone(value);
            }
        }

        result[key] = value;
    }

    return result;
};


/***/ }),
/* 125 */
/***/ (function(module, exports) {

var hasOwnProperty = Object.prototype.hasOwnProperty;
var shape = {
    generic: true,
    types: {},
    properties: {},
    parseContext: {},
    scope: {},
    atrule: ['parse'],
    pseudo: ['parse'],
    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
};

function isObject(value) {
    return value && value.constructor === Object;
}

function copy(value) {
    if (isObject(value)) {
        var res = {};
        for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
                res[key] = value[key];
            }
        }
        return res;
    } else {
        return value;
    }
}

function extend(dest, src) {
    for (var key in src) {
        if (hasOwnProperty.call(src, key)) {
            if (isObject(dest[key])) {
                extend(dest[key], copy(src[key]));
            } else {
                dest[key] = copy(src[key]);
            }
        }
    }
}

function mix(dest, src, shape) {
    for (var key in shape) {
        if (hasOwnProperty.call(shape, key) === false) {
            continue;
        }

        if (shape[key] === true) {
            if (key in src) {
                if (hasOwnProperty.call(src, key)) {
                    dest[key] = copy(src[key]);
                }
            }
        } else if (shape[key]) {
            if (isObject(shape[key])) {
                var res = {};
                extend(res, dest[key]);
                extend(res, src[key]);
                dest[key] = res;
            } else if (Array.isArray(shape[key])) {
                var res = {};
                var innerShape = shape[key].reduce(function(s, k) {
                    s[k] = true;
                    return s;
                }, {});
                for (var name in dest[key]) {
                    if (hasOwnProperty.call(dest[key], name)) {
                        res[name] = {};
                        if (dest[key] && dest[key][name]) {
                            mix(res[name], dest[key][name], innerShape);
                        }
                    }
                }
                for (var name in src[key]) {
                    if (hasOwnProperty.call(src[key], name)) {
                        if (!res[name]) {
                            res[name] = {};
                        }
                        if (src[key] && src[key][name]) {
                            mix(res[name], src[key][name], innerShape);
                        }
                    }
                }
                dest[key] = res;
            }
        }
    }
    return dest;
}

module.exports = function(dest, src) {
    return mix(dest, src, shape);
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var data = __webpack_require__(127);

module.exports = {
    generic: true,
    types: data.types,
    properties: data.properties,
    node: __webpack_require__(29)
};


/***/ }),
/* 127 */
/***/ (function(module) {

module.exports = JSON.parse("{\"generic\":true,\"types\":{\"absolute-size\":\"xx-small | x-small | small | medium | large | x-large | xx-large\",\"alpha-value\":\"<number> | <percentage>\",\"angle-percentage\":\"<angle> | <percentage>\",\"animateable-feature\":\"scroll-position | contents | <custom-ident>\",\"attachment\":\"scroll | fixed | local\",\"auto-repeat\":\"repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )\",\"auto-track-list\":\"[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat> [ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?\",\"baseline-position\":\"[ first | last ]? baseline\",\"basic-shape\":\"<inset()> | <circle()> | <ellipse()> | <polygon()>\",\"bg-image\":\"none | <image>\",\"bg-layer\":\"<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>\",\"bg-position\":\"[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]\",\"bg-size\":\"[ <length-percentage> | auto ]{1,2} | cover | contain\",\"blur()\":\"blur( <length> )\",\"blend-mode\":\"normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity\",\"box\":\"border-box | padding-box | content-box\",\"br-style\":\"none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset\",\"br-width\":\"<length> | thin | medium | thick\",\"brightness()\":\"brightness( <number-percentage> )\",\"calc()\":\"calc( <calc-sum> )\",\"calc-sum\":\"<calc-product> [ [ '+' | '-' ] <calc-product> ]*\",\"calc-product\":\"<calc-value> [ '*' <calc-value> | '/' <number> ]*\",\"calc-value\":\"<number> | <dimension> | <percentage> | ( <calc-sum> )\",\"cf-final-image\":\"<image> | <color>\",\"cf-mixing-image\":\"<percentage>? && <image>\",\"circle()\":\"circle( [ <shape-radius> ]? [ at <position> ]? )\",\"clip-source\":\"<url>\",\"color\":\"<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>\",\"color-stop\":\"<color> <length-percentage>?\",\"color-stop-list\":\"<color-stop>#{2,}\",\"common-lig-values\":\"[ common-ligatures | no-common-ligatures ]\",\"composite-style\":\"clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor\",\"compositing-operator\":\"add | subtract | intersect | exclude\",\"contextual-alt-values\":\"[ contextual | no-contextual ]\",\"content-distribution\":\"space-between | space-around | space-evenly | stretch\",\"content-list\":\"[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident> , <'list-style-type'>? ) ]+\",\"content-position\":\"center | start | end | flex-start | flex-end\",\"content-replacement\":\"<image>\",\"contrast()\":\"contrast( [ <number-percentage> ] )\",\"counter-style\":\"<counter-style-name> | symbols( )\",\"counter-style-name\":\"<custom-ident>\",\"cross-fade()\":\"cross-fade( <cf-mixing-image> , <cf-final-image>? )\",\"cubic-bezier-timing-function\":\"ease | ease-in | ease-out | ease-in-out | cubic-bezier( <number> , <number> , <number> , <number> )\",\"deprecated-system-color\":\"ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText\",\"discretionary-lig-values\":\"[ discretionary-ligatures | no-discretionary-ligatures ]\",\"display-box\":\"contents | none\",\"display-inside\":\"flow | flow-root | table | flex | grid | subgrid | ruby\",\"display-internal\":\"table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container\",\"display-legacy\":\"inline-block | inline-list-item | inline-table | inline-flex | inline-grid\",\"display-listitem\":\"<display-outside>? && [ flow | flow-root ]? && list-item\",\"display-outside\":\"block | inline | run-in\",\"drop-shadow()\":\"drop-shadow( <length>{2,3} <color>? )\",\"east-asian-variant-values\":\"[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]\",\"east-asian-width-values\":\"[ full-width | proportional-width ]\",\"element()\":\"element( <id-selector> )\",\"ellipse()\":\"ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )\",\"ending-shape\":\"circle | ellipse\",\"explicit-track-list\":\"[ <line-names>? <track-size> ]+ <line-names>?\",\"family-name\":\"<string> | <custom-ident>+\",\"feature-tag-value\":\"<string> [ <integer> | on | off ]?\",\"feature-value-name\":\"<custom-ident>\",\"fill-rule\":\"nonzero | evenodd\",\"filter-function\":\"<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>\",\"filter-function-list\":\"[ <filter-function> | <url> ]+\",\"final-bg-layer\":\"<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>\",\"fit-content()\":\"fit-content( [ <length> | <percentage> ] )\",\"fixed-breadth\":\"<length-percentage>\",\"fixed-repeat\":\"repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )\",\"fixed-size\":\"<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )\",\"font-variant-css21\":\"[ normal | small-caps ]\",\"frames-timing-function\":\"frames( <integer> )\",\"frequency-percentage\":\"<frequency> | <percentage>\",\"generic-family\":\"serif | sans-serif | cursive | fantasy | monospace | -apple-system\",\"generic-name\":\"serif | sans-serif | cursive | fantasy | monospace\",\"geometry-box\":\"<shape-box> | fill-box | stroke-box | view-box\",\"gradient\":\"<-legacy-gradient> | <linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>\",\"grayscale()\":\"grayscale( <number-percentage> )\",\"grid-line\":\"auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]\",\"historical-lig-values\":\"[ historical-ligatures | no-historical-ligatures ]\",\"hsl()\":\"hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )\",\"hsla()\":\"hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )\",\"hue\":\"<number> | <angle>\",\"hue-rotate()\":\"hue-rotate( <angle> )\",\"image\":\"<url> | <image()> | <image-set()> | <element()> | <cross-fade()> | <gradient>\",\"image()\":\"image( [ [ <image> | <string> ]? , <color>? ]! )\",\"image-set()\":\"image-set( <image-set-option># )\",\"image-set-option\":\"[ <image> | <string> ] <resolution>\",\"inflexible-breadth\":\"<length> | <percentage> | min-content | max-content | auto\",\"inset()\":\"inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )\",\"invert()\":\"invert( <number-percentage> )\",\"keyframes-name\":\"<custom-ident> | <string>\",\"keyframe-selector\":\"from | to | <percentage>\",\"leader()\":\"leader( <leader-type> )\",\"leader-type\":\"dotted | solid | space | <string>\",\"length-percentage\":\"<length> | <percentage>\",\"line-names\":\"'[' <custom-ident>* ']'\",\"line-name-list\":\"[ <line-names> | <name-repeat> ]+\",\"linear-gradient()\":\"linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )\",\"mask-layer\":\"<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>\",\"mask-position\":\"[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?\",\"mask-reference\":\"none | <image> | <mask-source>\",\"mask-source\":\"<url>\",\"masking-mode\":\"alpha | luminance | match-source\",\"matrix()\":\"matrix( <number> [, <number> ]{5} )\",\"matrix3d()\":\"matrix3d( <number> [, <number> ]{15} )\",\"media-type\":\"<ident>\",\"mf-boolean\":\"<mf-name>\",\"mf-name\":\"<ident>\",\"minmax()\":\"minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )\",\"named-color\":\"transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>\",\"namespace-prefix\":\"<ident>\",\"number-percentage\":\"<number> | <percentage>\",\"numeric-figure-values\":\"[ lining-nums | oldstyle-nums ]\",\"numeric-fraction-values\":\"[ diagonal-fractions | stacked-fractions ]\",\"numeric-spacing-values\":\"[ proportional-nums | tabular-nums ]\",\"opacity()\":\"opacity( [ <number-percentage> ] )\",\"overflow-position\":\"unsafe | safe\",\"outline-radius\":\"<border-radius>\",\"perspective()\":\"perspective( <length> )\",\"polygon()\":\"polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )\",\"position\":\"[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]\",\"quote\":\"open-quote | close-quote | no-open-quote | no-close-quote\",\"radial-gradient()\":\"radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )\",\"relative-size\":\"larger | smaller\",\"repeat-style\":\"repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}\",\"repeating-linear-gradient()\":\"repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )\",\"repeating-radial-gradient()\":\"repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )\",\"rgb()\":\"rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )\",\"rgba()\":\"rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )\",\"rotate()\":\"rotate( <angle> )\",\"rotate3d()\":\"rotate3d( <number> , <number> , <number> , <angle> )\",\"rotateX()\":\"rotateX( <angle> )\",\"rotateY()\":\"rotateY( <angle> )\",\"rotateZ()\":\"rotateZ( <angle> )\",\"saturate()\":\"saturate( <number-percentage> )\",\"scale()\":\"scale( <number> [, <number> ]? )\",\"scale3d()\":\"scale3d( <number> , <number> , <number> )\",\"scaleX()\":\"scaleX( <number> )\",\"scaleY()\":\"scaleY( <number> )\",\"scaleZ()\":\"scaleZ( <number> )\",\"self-position\":\"center | start | end | self-start | self-end | flex-start | flex-end\",\"shape-radius\":\"<length-percentage> | closest-side | farthest-side\",\"skew()\":\"skew( <angle> [, <angle> ]? )\",\"skewX()\":\"skewX( <angle> )\",\"skewY()\":\"skewY( <angle> )\",\"sepia()\":\"sepia( <number-percentage> )\",\"shadow\":\"inset? && <length>{2,4} && <color>?\",\"shadow-t\":\"[ <length>{2,3} && <color>? ]\",\"shape\":\"rect( [ [ <top> , <right> , <bottom> , <left> ] | [ <top> <right> <bottom> <left> ] ] )\",\"shape-box\":\"<box> | margin-box\",\"side-or-corner\":\"[ left | right ] || [ top | bottom ]\",\"single-animation\":\"<time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]\",\"single-animation-direction\":\"normal | reverse | alternate | alternate-reverse\",\"single-animation-fill-mode\":\"none | forwards | backwards | both\",\"single-animation-iteration-count\":\"infinite | <number>\",\"single-animation-play-state\":\"running | paused\",\"single-timing-function\":\"linear | <cubic-bezier-timing-function> | <step-timing-function> | <frames-timing-function>\",\"single-transition\":\"<single-transition-timing-function> || [ none | <single-transition-property> ] || <time> || <time>\",\"single-transition-timing-function\":\"<single-timing-function>\",\"single-transition-property\":\"all | <custom-ident>\",\"size\":\"closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}\",\"step-timing-function\":\"step-start | step-end | steps( <integer> [, [ start | end ] ]? )\",\"symbol\":\"<string> | <image> | <custom-ident>\",\"target\":\"<target-counter()> | <target-counters()> | <target-text()>\",\"target-counter()\":\"target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )\",\"target-counters()\":\"target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )\",\"target-text()\":\"target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )\",\"time-percentage\":\"<time> | <percentage>\",\"track-breadth\":\"<length-percentage> | <flex> | min-content | max-content | auto\",\"track-list\":\"[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?\",\"track-repeat\":\"repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )\",\"track-size\":\"<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )\",\"transform-function\":\"<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>\",\"transform-list\":\"<transform-function>+\",\"translate()\":\"translate( <length-percentage> [, <length-percentage> ]? )\",\"translate3d()\":\"translate3d( <length-percentage> , <length-percentage> , <length> )\",\"translateX()\":\"translateX( <length-percentage> )\",\"translateY()\":\"translateY( <length-percentage> )\",\"translateZ()\":\"translateZ( <length> )\",\"type-or-unit\":\"string | integer | color | url | integer | number | length | angle | time | frequency | em | ex | px | rem | vw | vh | vmin | vmax | mm | q | cm | in | pt | pc | deg | grad | rad | ms | s | Hz | kHz | %\",\"viewport-length\":\"auto | <length-percentage>\",\"-legacy-gradient\":\"<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>\",\"-legacy-linear-gradient\":\"-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )\",\"-legacy-repeating-linear-gradient\":\"-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )\",\"-legacy-linear-gradient-arguments\":\"[ <angle> | <side-or-corner> ]? , <color-stop-list>\",\"-legacy-radial-gradient\":\"-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )\",\"-legacy-repeating-radial-gradient\":\"-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )\",\"-legacy-radial-gradient-arguments\":\"[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>\",\"-legacy-radial-gradient-size\":\"closest-side | closest-corner | farthest-side | farthest-corner | contain | cover\",\"-legacy-radial-gradient-shape\":\"circle | ellipse\",\"-non-standard-font\":\"-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body\",\"-non-standard-color\":\"-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text\",\"-non-standard-image-rendering\":\"optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast\",\"-non-standard-overflow\":\"-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable\",\"-non-standard-width\":\"min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content\",\"-non-standard-word-break\":\"break-word\",\"-webkit-gradient()\":\"-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius> , <-webkit-gradient-point> ] [, <-webkit-gradient-radius> ]? [, <-webkit-gradient-color-stop> ]* )\",\"-webkit-gradient-color-stop\":\"from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )\",\"-webkit-gradient-point\":\"[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]\",\"-webkit-gradient-radius\":\"<length> | <percentage>\",\"-webkit-gradient-type\":\"linear | radial\",\"-webkit-mask-box-repeat\":\"repeat | stretch | round\",\"-webkit-mask-clip-style\":\"border | border-box | padding | padding-box | content | content-box | text\",\"-ms-filter\":\"[ <progid> | FlipH | FlipV ]+\",\"age\":\"child | young | old\",\"border-radius\":\"<length-percentage>{1,2}\",\"bottom\":\"<length> | auto\",\"generic-voice\":\"[ <age>? <gender> <integer>? ]\",\"gender\":\"male | female | neutral\",\"left\":\"<length> | auto\",\"mask-image\":\"<mask-reference>#\",\"name-repeat\":\"repeat( [ <positive-integer> | auto-fill ] , <line-names>+ )\",\"paint\":\"none | currentColor | <color> | <url> [ none | currentColor | <color> ]?\",\"path()\":\"path( <string> )\",\"right\":\"<length> | auto\",\"svg-length\":\"<percentage> | <length> | <number>\",\"svg-writing-mode\":\"lr-tb | rl-tb | tb-rl | lr | rl | tb\",\"top\":\"<length> | auto\",\"x\":\"<number>\",\"y\":\"<number>\"},\"properties\":{\"-ms-accelerator\":\"false | true\",\"-ms-block-progression\":\"tb | rl | bt | lr\",\"-ms-content-zoom-chaining\":\"none | chained\",\"-ms-content-zooming\":\"none | zoom\",\"-ms-content-zoom-limit\":\"<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>\",\"-ms-content-zoom-limit-max\":\"<percentage>\",\"-ms-content-zoom-limit-min\":\"<percentage>\",\"-ms-content-zoom-snap\":\"<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>\",\"-ms-content-zoom-snap-points\":\"snapInterval( <percentage> , <percentage> ) | snapList( <percentage># )\",\"-ms-content-zoom-snap-type\":\"none | proximity | mandatory\",\"-ms-filter\":\"<string>\",\"-ms-flow-from\":\"[ none | <custom-ident> ]#\",\"-ms-flow-into\":\"[ none | <custom-ident> ]#\",\"-ms-high-contrast-adjust\":\"auto | none\",\"-ms-hyphenate-limit-chars\":\"auto | <integer>{1,3}\",\"-ms-hyphenate-limit-lines\":\"no-limit | <integer>\",\"-ms-hyphenate-limit-zone\":\"<percentage> | <length>\",\"-ms-ime-align\":\"auto | after\",\"-ms-overflow-style\":\"auto | none | scrollbar | -ms-autohiding-scrollbar\",\"-ms-scrollbar-3dlight-color\":\"<color>\",\"-ms-scrollbar-arrow-color\":\"<color>\",\"-ms-scrollbar-base-color\":\"<color>\",\"-ms-scrollbar-darkshadow-color\":\"<color>\",\"-ms-scrollbar-face-color\":\"<color>\",\"-ms-scrollbar-highlight-color\":\"<color>\",\"-ms-scrollbar-shadow-color\":\"<color>\",\"-ms-scrollbar-track-color\":\"<color>\",\"-ms-scroll-chaining\":\"chained | none\",\"-ms-scroll-limit\":\"<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>\",\"-ms-scroll-limit-x-max\":\"auto | <length>\",\"-ms-scroll-limit-x-min\":\"<length>\",\"-ms-scroll-limit-y-max\":\"auto | <length>\",\"-ms-scroll-limit-y-min\":\"<length>\",\"-ms-scroll-rails\":\"none | railed\",\"-ms-scroll-snap-points-x\":\"snapInterval( <length-percentage> , <length-percentage> ) | snapList( <length-percentage># )\",\"-ms-scroll-snap-points-y\":\"snapInterval( <length-percentage> , <length-percentage> ) | snapList( <length-percentage># )\",\"-ms-scroll-snap-type\":\"none | proximity | mandatory\",\"-ms-scroll-snap-x\":\"<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>\",\"-ms-scroll-snap-y\":\"<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>\",\"-ms-scroll-translation\":\"none | vertical-to-horizontal\",\"-ms-text-autospace\":\"none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space\",\"-ms-touch-select\":\"grippers | none\",\"-ms-user-select\":\"none | element | text\",\"-ms-wrap-flow\":\"auto | both | start | end | maximum | clear\",\"-ms-wrap-margin\":\"<length>\",\"-ms-wrap-through\":\"wrap | none\",\"-moz-appearance\":\"none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized\",\"-moz-binding\":\"<url> | none\",\"-moz-border-bottom-colors\":\"<color>+ | none\",\"-moz-border-left-colors\":\"<color>+ | none\",\"-moz-border-right-colors\":\"<color>+ | none\",\"-moz-border-top-colors\":\"<color>+ | none\",\"-moz-context-properties\":\"none | [ fill | fill-opacity | stroke | stroke-opacity ]#\",\"-moz-float-edge\":\"border-box | content-box | margin-box | padding-box\",\"-moz-force-broken-image-icon\":\"<integer>\",\"-moz-image-region\":\"<shape> | auto\",\"-moz-orient\":\"inline | block | horizontal | vertical\",\"-moz-outline-radius\":\"<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?\",\"-moz-outline-radius-bottomleft\":\"<outline-radius>\",\"-moz-outline-radius-bottomright\":\"<outline-radius>\",\"-moz-outline-radius-topleft\":\"<outline-radius>\",\"-moz-outline-radius-topright\":\"<outline-radius>\",\"-moz-stack-sizing\":\"ignore | stretch-to-fit\",\"-moz-text-blink\":\"none | blink\",\"-moz-user-focus\":\"ignore | normal | select-after | select-before | select-menu | select-same | select-all | none\",\"-moz-user-input\":\"auto | none | enabled | disabled\",\"-moz-user-modify\":\"read-only | read-write | write-only\",\"-moz-window-dragging\":\"drag | no-drag\",\"-moz-window-shadow\":\"default | menu | tooltip | sheet | none\",\"-webkit-appearance\":\"none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield\",\"-webkit-border-before\":\"<'border-width'> || <'border-style'> || <'color'>\",\"-webkit-border-before-color\":\"<'color'>\",\"-webkit-border-before-style\":\"<'border-style'>\",\"-webkit-border-before-width\":\"<'border-width'>\",\"-webkit-box-reflect\":\"[ above | below | right | left ]? <length>? <image>?\",\"-webkit-mask\":\"[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#\",\"-webkit-mask-attachment\":\"<attachment>#\",\"-webkit-mask-clip\":\"<-webkit-mask-clip-style> [, <-webkit-mask-clip-style> ]*\",\"-webkit-mask-composite\":\"<composite-style>#\",\"-webkit-mask-image\":\"<mask-reference>#\",\"-webkit-mask-origin\":\"[ <box> | border | padding | content ]#\",\"-webkit-mask-position\":\"<position>#\",\"-webkit-mask-position-x\":\"[ <length-percentage> | left | center | right ]#\",\"-webkit-mask-position-y\":\"[ <length-percentage> | top | center | bottom ]#\",\"-webkit-mask-repeat\":\"<repeat-style>#\",\"-webkit-mask-repeat-x\":\"repeat | no-repeat | space | round\",\"-webkit-mask-repeat-y\":\"repeat | no-repeat | space | round\",\"-webkit-mask-size\":\"<bg-size>#\",\"-webkit-overflow-scrolling\":\"auto | touch\",\"-webkit-tap-highlight-color\":\"<color>\",\"-webkit-text-fill-color\":\"<color>\",\"-webkit-text-stroke\":\"<length> || <color>\",\"-webkit-text-stroke-color\":\"<color>\",\"-webkit-text-stroke-width\":\"<length>\",\"-webkit-touch-callout\":\"default | none\",\"-webkit-user-modify\":\"read-only | read-write | read-write-plaintext-only\",\"align-content\":\"normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>\",\"align-items\":\"normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]\",\"align-self\":\"auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>\",\"all\":\"initial | inherit | unset | revert\",\"animation\":\"<single-animation>#\",\"animation-delay\":\"<time>#\",\"animation-direction\":\"<single-animation-direction>#\",\"animation-duration\":\"<time>#\",\"animation-fill-mode\":\"<single-animation-fill-mode>#\",\"animation-iteration-count\":\"<single-animation-iteration-count>#\",\"animation-name\":\"[ none | <keyframes-name> ]#\",\"animation-play-state\":\"<single-animation-play-state>#\",\"animation-timing-function\":\"<single-timing-function>#\",\"appearance\":\"auto | none\",\"azimuth\":\"<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards\",\"backdrop-filter\":\"none | <filter-function-list>\",\"backface-visibility\":\"visible | hidden\",\"background\":\"[ <bg-layer> , ]* <final-bg-layer>\",\"background-attachment\":\"<attachment>#\",\"background-blend-mode\":\"<blend-mode>#\",\"background-clip\":\"<box>#\",\"background-color\":\"<color>\",\"background-image\":\"<bg-image>#\",\"background-origin\":\"<box>#\",\"background-position\":\"<bg-position>#\",\"background-position-x\":\"[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#\",\"background-position-y\":\"[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#\",\"background-repeat\":\"<repeat-style>#\",\"background-size\":\"<bg-size>#\",\"block-overflow\":\"clip | ellipsis | <string>\",\"block-size\":\"<'width'>\",\"border\":\"<br-width> || <br-style> || <color>\",\"border-block-end\":\"<'border-width'> || <'border-style'> || <'color'>\",\"border-block-end-color\":\"<'color'>\",\"border-block-end-style\":\"<'border-style'>\",\"border-block-end-width\":\"<'border-width'>\",\"border-block-start\":\"<'border-width'> || <'border-style'> || <'color'>\",\"border-block-start-color\":\"<'color'>\",\"border-block-start-style\":\"<'border-style'>\",\"border-block-start-width\":\"<'border-width'>\",\"border-bottom\":\"<br-width> || <br-style> || <color>\",\"border-bottom-color\":\"<color>\",\"border-bottom-left-radius\":\"<length-percentage>{1,2}\",\"border-bottom-right-radius\":\"<length-percentage>{1,2}\",\"border-bottom-style\":\"<br-style>\",\"border-bottom-width\":\"<br-width>\",\"border-collapse\":\"collapse | separate\",\"border-color\":\"<color>{1,4}\",\"border-image\":\"<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>\",\"border-image-outset\":\"[ <length> | <number> ]{1,4}\",\"border-image-repeat\":\"[ stretch | repeat | round | space ]{1,2}\",\"border-image-slice\":\"<number-percentage>{1,4} && fill?\",\"border-image-source\":\"none | <image>\",\"border-image-width\":\"[ <length-percentage> | <number> | auto ]{1,4}\",\"border-inline-end\":\"<'border-width'> || <'border-style'> || <'color'>\",\"border-inline-end-color\":\"<'color'>\",\"border-inline-end-style\":\"<'border-style'>\",\"border-inline-end-width\":\"<'border-width'>\",\"border-inline-start\":\"<'border-width'> || <'border-style'> || <'color'>\",\"border-inline-start-color\":\"<'color'>\",\"border-inline-start-style\":\"<'border-style'>\",\"border-inline-start-width\":\"<'border-width'>\",\"border-left\":\"<br-width> || <br-style> || <color>\",\"border-left-color\":\"<color>\",\"border-left-style\":\"<br-style>\",\"border-left-width\":\"<br-width>\",\"border-radius\":\"<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?\",\"border-right\":\"<br-width> || <br-style> || <color>\",\"border-right-color\":\"<color>\",\"border-right-style\":\"<br-style>\",\"border-right-width\":\"<br-width>\",\"border-spacing\":\"<length> <length>?\",\"border-style\":\"<br-style>{1,4}\",\"border-top\":\"<br-width> || <br-style> || <color>\",\"border-top-color\":\"<color>\",\"border-top-left-radius\":\"<length-percentage>{1,2}\",\"border-top-right-radius\":\"<length-percentage>{1,2}\",\"border-top-style\":\"<br-style>\",\"border-top-width\":\"<br-width>\",\"border-width\":\"<br-width>{1,4}\",\"bottom\":\"<length> | <percentage> | auto\",\"box-align\":\"start | center | end | baseline | stretch\",\"box-decoration-break\":\"slice | clone\",\"box-direction\":\"normal | reverse | inherit\",\"box-flex\":\"<number>\",\"box-flex-group\":\"<integer>\",\"box-lines\":\"single | multiple\",\"box-ordinal-group\":\"<integer>\",\"box-orient\":\"horizontal | vertical | inline-axis | block-axis | inherit\",\"box-pack\":\"start | center | end | justify\",\"box-shadow\":\"none | <shadow>#\",\"box-sizing\":\"content-box | border-box\",\"break-after\":\"auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region\",\"break-before\":\"auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region\",\"break-inside\":\"auto | avoid | avoid-page | avoid-column | avoid-region\",\"caption-side\":\"top | bottom | block-start | block-end | inline-start | inline-end\",\"caret-color\":\"auto | <color>\",\"clear\":\"none | left | right | both | inline-start | inline-end\",\"clip\":\"<shape> | auto\",\"clip-path\":\"<clip-source> | [ <basic-shape> || <geometry-box> ] | none\",\"color\":\"<color>\",\"color-adjust\":\"economy | exact\",\"column-count\":\"<integer> | auto\",\"column-fill\":\"auto | balance | balance-all\",\"column-gap\":\"normal | <length-percentage>\",\"column-rule\":\"<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>\",\"column-rule-color\":\"<color>\",\"column-rule-style\":\"<'border-style'>\",\"column-rule-width\":\"<'border-width'>\",\"column-span\":\"none | all\",\"column-width\":\"<length> | auto\",\"columns\":\"<'column-width'> || <'column-count'>\",\"contain\":\"none | strict | content | [ size || layout || style || paint ]\",\"content\":\"normal | none | [ <content-replacement> | <content-list> ] [ / <string> ]?\",\"counter-increment\":\"[ <custom-ident> <integer>? ]+ | none\",\"counter-reset\":\"[ <custom-ident> <integer>? ]+ | none\",\"cursor\":\"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]\",\"direction\":\"ltr | rtl\",\"display\":\"none | inline | block | list-item | inline-list-item | inline-block | inline-table | table | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | flex | inline-flex | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box\",\"empty-cells\":\"show | hide\",\"filter\":\"none | <filter-function-list> | <-ms-filter>\",\"flex\":\"none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\",\"flex-basis\":\"content | <'width'>\",\"flex-direction\":\"row | row-reverse | column | column-reverse\",\"flex-flow\":\"<'flex-direction'> || <'flex-wrap'>\",\"flex-grow\":\"<number>\",\"flex-shrink\":\"<number>\",\"flex-wrap\":\"nowrap | wrap | wrap-reverse\",\"float\":\"left | right | none | inline-start | inline-end\",\"font\":\"[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar | <-non-standard-font>\",\"font-family\":\"[ <family-name> | <generic-family> ]#\",\"font-feature-settings\":\"normal | <feature-tag-value>#\",\"font-kerning\":\"auto | normal | none\",\"font-language-override\":\"normal | <string>\",\"font-optical-sizing\":\"auto | none\",\"font-variation-settings\":\"normal | [ <string> <number> ]#\",\"font-size\":\"<absolute-size> | <relative-size> | <length-percentage>\",\"font-size-adjust\":\"none | <number>\",\"font-stretch\":\"normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded\",\"font-style\":\"normal | italic | oblique\",\"font-synthesis\":\"none | [ weight || style ]\",\"font-variant\":\"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]\",\"font-variant-alternates\":\"normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]\",\"font-variant-caps\":\"normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps\",\"font-variant-east-asian\":\"normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]\",\"font-variant-ligatures\":\"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]\",\"font-variant-numeric\":\"normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]\",\"font-variant-position\":\"normal | sub | super\",\"font-weight\":\"normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900\",\"gap\":\"<'row-gap'> <'column-gap'>?\",\"grid\":\"<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>\",\"grid-area\":\"<grid-line> [ / <grid-line> ]{0,3}\",\"grid-auto-columns\":\"<track-size>+\",\"grid-auto-flow\":\"[ row | column ] || dense\",\"grid-auto-rows\":\"<track-size>+\",\"grid-column\":\"<grid-line> [ / <grid-line> ]?\",\"grid-column-end\":\"<grid-line>\",\"grid-column-gap\":\"<length-percentage>\",\"grid-column-start\":\"<grid-line>\",\"grid-gap\":\"<'grid-row-gap'> <'grid-column-gap'>?\",\"grid-row\":\"<grid-line> [ / <grid-line> ]?\",\"grid-row-end\":\"<grid-line>\",\"grid-row-gap\":\"<length-percentage>\",\"grid-row-start\":\"<grid-line>\",\"grid-template\":\"none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?\",\"grid-template-areas\":\"none | <string>+\",\"grid-template-columns\":\"none | <track-list> | <auto-track-list>\",\"grid-template-rows\":\"none | <track-list> | <auto-track-list>\",\"hanging-punctuation\":\"none | [ first || [ force-end | allow-end ] || last ]\",\"height\":\"[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto\",\"hyphens\":\"none | manual | auto\",\"image-orientation\":\"from-image | <angle> | [ <angle>? flip ]\",\"image-rendering\":\"auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>\",\"image-resolution\":\"[ from-image || <resolution> ] && snap?\",\"ime-mode\":\"auto | normal | active | inactive | disabled\",\"initial-letter\":\"normal | [ <number> <integer>? ]\",\"initial-letter-align\":\"[ auto | alphabetic | hanging | ideographic ]\",\"inline-size\":\"<'width'>\",\"isolation\":\"auto | isolate\",\"justify-content\":\"normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]\",\"justify-items\":\"normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]\",\"justify-self\":\"auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]\",\"left\":\"<length> | <percentage> | auto\",\"letter-spacing\":\"normal | <length-percentage>\",\"line-break\":\"auto | loose | normal | strict\",\"line-clamp\":\"none | <integer>\",\"line-height\":\"normal | <number> | <length> | <percentage>\",\"line-height-step\":\"none | <length>\",\"list-style\":\"<'list-style-type'> || <'list-style-position'> || <'list-style-image'>\",\"list-style-image\":\"<url> | none\",\"list-style-position\":\"inside | outside\",\"list-style-type\":\"<counter-style> | <string> | none\",\"margin\":\"[ <length> | <percentage> | auto ]{1,4}\",\"margin-block-end\":\"<'margin-left'>\",\"margin-block-start\":\"<'margin-left'>\",\"margin-bottom\":\"<length> | <percentage> | auto\",\"margin-inline-end\":\"<'margin-left'>\",\"margin-inline-start\":\"<'margin-left'>\",\"margin-left\":\"<length> | <percentage> | auto\",\"margin-right\":\"<length> | <percentage> | auto\",\"margin-top\":\"<length> | <percentage> | auto\",\"mask\":\"<mask-layer>#\",\"mask-border\":\"<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>\",\"mask-border-mode\":\"luminance | alpha\",\"mask-border-outset\":\"[ <length> | <number> ]{1,4}\",\"mask-border-repeat\":\"[ stretch | repeat | round | space ]{1,2}\",\"mask-border-slice\":\"<number-percentage>{1,4} fill?\",\"mask-border-source\":\"none | <image>\",\"mask-border-width\":\"[ <length-percentage> | <number> | auto ]{1,4}\",\"mask-clip\":\"[ <geometry-box> | no-clip ]#\",\"mask-composite\":\"<compositing-operator>#\",\"mask-image\":\"<mask-reference>#\",\"mask-mode\":\"<masking-mode>#\",\"mask-origin\":\"<geometry-box>#\",\"mask-position\":\"<position>#\",\"mask-repeat\":\"<repeat-style>#\",\"mask-size\":\"<bg-size>#\",\"mask-type\":\"luminance | alpha\",\"max-block-size\":\"<'max-width'>\",\"max-height\":\"<length> | <percentage> | none | max-content | min-content | fit-content | fill-available\",\"max-inline-size\":\"<'max-width'>\",\"max-lines\":\"none | <integer>\",\"max-width\":\"<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>\",\"min-block-size\":\"<'min-width'>\",\"min-height\":\"<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available\",\"min-inline-size\":\"<'min-width'>\",\"min-width\":\"<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>\",\"mix-blend-mode\":\"<blend-mode>\",\"object-fit\":\"fill | contain | cover | none | scale-down\",\"object-position\":\"<position>\",\"offset\":\"[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?\",\"offset-anchor\":\"auto | <position>\",\"offset-block-end\":\"<'left'>\",\"offset-block-start\":\"<'left'>\",\"offset-inline-end\":\"<'left'>\",\"offset-inline-start\":\"<'left'>\",\"offset-distance\":\"<length-percentage>\",\"offset-path\":\"none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]\",\"offset-position\":\"auto | <position>\",\"offset-rotate\":\"[ auto | reverse ] || <angle>\",\"opacity\":\"<number-zero-one>\",\"order\":\"<integer>\",\"orphans\":\"<integer>\",\"outline\":\"[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]\",\"outline-color\":\"<color> | invert\",\"outline-offset\":\"<length>\",\"outline-style\":\"auto | <br-style>\",\"outline-width\":\"<br-width>\",\"overflow\":\"visible | hidden | scroll | auto | <-non-standard-overflow>\",\"overflow-anchor\":\"auto | none\",\"overflow-block\":\"<'overflow'>\",\"overflow-clip-box\":\"padding-box | content-box\",\"overflow-inline\":\"<'overflow'>\",\"overflow-wrap\":\"normal | break-word\",\"overflow-x\":\"visible | hidden | clip | scroll | auto\",\"overflow-y\":\"visible | hidden | clip | scroll | auto\",\"overscroll-behavior\":\"[ contain | none | auto ]{1,2}\",\"overscroll-behavior-x\":\"contain | none | auto\",\"overscroll-behavior-y\":\"contain | none | auto\",\"padding\":\"[ <length> | <percentage> ]{1,4}\",\"padding-block-end\":\"<'padding-left'>\",\"padding-block-start\":\"<'padding-left'>\",\"padding-bottom\":\"<length> | <percentage>\",\"padding-inline-end\":\"<'padding-left'>\",\"padding-inline-start\":\"<'padding-left'>\",\"padding-left\":\"<length> | <percentage>\",\"padding-right\":\"<length> | <percentage>\",\"padding-top\":\"<length> | <percentage>\",\"page-break-after\":\"auto | always | avoid | left | right | recto | verso\",\"page-break-before\":\"auto | always | avoid | left | right | recto | verso\",\"page-break-inside\":\"auto | avoid\",\"paint-order\":\"normal | [ fill || stroke || markers ]\",\"perspective\":\"none | <length>\",\"perspective-origin\":\"<position>\",\"place-content\":\"<'align-content'> <'justify-content'>?\",\"pointer-events\":\"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit\",\"position\":\"static | relative | absolute | sticky | fixed | -webkit-sticky\",\"quotes\":\"none | [ <string> <string> ]+\",\"resize\":\"none | both | horizontal | vertical\",\"right\":\"<length> | <percentage> | auto\",\"rotate\":\"none | [ x | y | z | <number>{3} ]? && <angle>\",\"row-gap\":\"normal | <length-percentage>\",\"ruby-align\":\"start | center | space-between | space-around\",\"ruby-merge\":\"separate | collapse | auto\",\"ruby-position\":\"over | under | inter-character\",\"scale\":\"none | <number>{1,3}\",\"scroll-behavior\":\"auto | smooth\",\"scroll-snap-coordinate\":\"none | <position>#\",\"scroll-snap-destination\":\"<position>\",\"scroll-snap-points-x\":\"none | repeat( <length-percentage> )\",\"scroll-snap-points-y\":\"none | repeat( <length-percentage> )\",\"scroll-snap-type\":\"none | mandatory | proximity\",\"scroll-snap-type-x\":\"none | mandatory | proximity\",\"scroll-snap-type-y\":\"none | mandatory | proximity\",\"shape-image-threshold\":\"<number>\",\"shape-margin\":\"<length-percentage>\",\"shape-outside\":\"none | <shape-box> || <basic-shape> | <image>\",\"tab-size\":\"<integer> | <length>\",\"table-layout\":\"auto | fixed\",\"text-align\":\"start | end | left | right | center | justify | match-parent\",\"text-align-last\":\"auto | start | end | left | right | center | justify\",\"text-combine-upright\":\"none | all | [ digits <integer>? ]\",\"text-decoration\":\"<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'>\",\"text-decoration-color\":\"<color>\",\"text-decoration-line\":\"none | [ underline || overline || line-through || blink ]\",\"text-decoration-skip\":\"none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]\",\"text-decoration-skip-ink\":\"auto | none\",\"text-decoration-style\":\"solid | double | dotted | dashed | wavy\",\"text-emphasis\":\"<'text-emphasis-style'> || <'text-emphasis-color'>\",\"text-emphasis-color\":\"<color>\",\"text-emphasis-position\":\"[ over | under ] && [ right | left ]\",\"text-emphasis-style\":\"none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>\",\"text-indent\":\"<length-percentage> && hanging? && each-line?\",\"text-justify\":\"auto | inter-character | inter-word | none\",\"text-orientation\":\"mixed | upright | sideways\",\"text-overflow\":\"[ clip | ellipsis | <string> ]{1,2}\",\"text-rendering\":\"auto | optimizeSpeed | optimizeLegibility | geometricPrecision\",\"text-shadow\":\"none | <shadow-t>#\",\"text-size-adjust\":\"none | auto | <percentage>\",\"text-transform\":\"none | capitalize | uppercase | lowercase | full-width\",\"text-underline-position\":\"auto | [ under || [ left | right ] ]\",\"top\":\"<length> | <percentage> | auto\",\"touch-action\":\"auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation\",\"transform\":\"none | <transform-list>\",\"transform-box\":\"border-box | fill-box | view-box\",\"transform-origin\":\"[ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>? | [ <length-percentage> | left | center | right | top | bottom ]\",\"transform-style\":\"flat | preserve-3d\",\"transition\":\"<single-transition>#\",\"transition-delay\":\"<time>#\",\"transition-duration\":\"<time>#\",\"transition-property\":\"none | <single-transition-property>#\",\"transition-timing-function\":\"<single-transition-timing-function>#\",\"translate\":\"none | <length-percentage> [ <length-percentage> <length>? ]?\",\"unicode-bidi\":\"normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate\",\"user-select\":\"auto | text | none | contain | all\",\"vertical-align\":\"baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>\",\"visibility\":\"visible | hidden | collapse\",\"white-space\":\"normal | pre | nowrap | pre-wrap | pre-line\",\"widows\":\"<integer>\",\"width\":\"[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto\",\"will-change\":\"auto | <animateable-feature>#\",\"word-break\":\"normal | break-all | keep-all | <-non-standard-word-break>\",\"word-spacing\":\"normal | <length-percentage>\",\"word-wrap\":\"normal | break-word\",\"writing-mode\":\"horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>\",\"z-index\":\"auto | <integer>\",\"zoom\":\"normal | reset | <number> | <percentage>\",\"-moz-background-clip\":\"padding | border\",\"-moz-border-radius-bottomleft\":\"<'border-bottom-left-radius'>\",\"-moz-border-radius-bottomright\":\"<'border-bottom-right-radius'>\",\"-moz-border-radius-topleft\":\"<'border-top-left-radius'>\",\"-moz-border-radius-topright\":\"<'border-bottom-right-radius'>\",\"-moz-osx-font-smoothing\":\"auto | grayscale\",\"-moz-user-select\":\"none | text | all | -moz-none\",\"-ms-flex-align\":\"start | end | center | baseline | stretch\",\"-ms-flex-item-align\":\"auto | start | end | center | baseline | stretch\",\"-ms-flex-line-pack\":\"start | end | center | justify | distribute | stretch\",\"-ms-flex-negative\":\"<'flex-shrink'>\",\"-ms-flex-pack\":\"start | end | center | justify | distribute\",\"-ms-flex-order\":\"<integer>\",\"-ms-flex-positive\":\"<'flex-grow'>\",\"-ms-flex-preferred-size\":\"<'flex-basis'>\",\"-ms-interpolation-mode\":\"nearest-neighbor | bicubic\",\"-ms-grid-column-align\":\"start | end | center | stretch\",\"-ms-grid-row-align\":\"start | end | center | stretch\",\"-webkit-background-clip\":\"[ <box> | border | padding | content | text ]#\",\"-webkit-column-break-after\":\"always | auto | avoid\",\"-webkit-column-break-before\":\"always | auto | avoid\",\"-webkit-column-break-inside\":\"always | auto | avoid\",\"-webkit-font-smoothing\":\"auto | none | antialiased | subpixel-antialiased\",\"-webkit-line-clamp\":\"<positive-integer>\",\"-webkit-mask-box-image\":\"[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?\",\"-webkit-print-color-adjust\":\"economy | exact\",\"-webkit-text-security\":\"none | circle | disc | square\",\"-webkit-user-drag\":\"none | element | auto\",\"-webkit-user-select\":\"auto | none | text | all\",\"alignment-baseline\":\"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical\",\"baseline-shift\":\"baseline | sub | super | <svg-length>\",\"behavior\":\"<url>+\",\"clip-rule\":\"nonzero | evenodd\",\"cue\":\"<'cue-before'> <'cue-after'>?\",\"cue-after\":\"<url> <decibel>? | none\",\"cue-before\":\"<url> <decibel>? | none\",\"dominant-baseline\":\"auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge\",\"fill\":\"<paint>\",\"fill-opacity\":\"<number-zero-one>\",\"fill-rule\":\"nonzero | evenodd\",\"glyph-orientation-horizontal\":\"<angle>\",\"glyph-orientation-vertical\":\"<angle>\",\"kerning\":\"auto | <svg-length>\",\"marker\":\"none | <url>\",\"marker-end\":\"none | <url>\",\"marker-mid\":\"none | <url>\",\"marker-start\":\"none | <url>\",\"pause\":\"<'pause-before'> <'pause-after'>?\",\"pause-after\":\"<time> | none | x-weak | weak | medium | strong | x-strong\",\"pause-before\":\"<time> | none | x-weak | weak | medium | strong | x-strong\",\"rest\":\"<'rest-before'> <'rest-after'>?\",\"rest-after\":\"<time> | none | x-weak | weak | medium | strong | x-strong\",\"rest-before\":\"<time> | none | x-weak | weak | medium | strong | x-strong\",\"shape-rendering\":\"auto | optimizeSpeed | crispEdges | geometricPrecision\",\"src\":\"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#\",\"speak\":\"auto | none | normal\",\"speak-as\":\"normal | spell-out || digits || [ literal-punctuation | no-punctuation ]\",\"stroke\":\"<paint>\",\"stroke-dasharray\":\"none | [ <svg-length>+ ]#\",\"stroke-dashoffset\":\"<svg-length>\",\"stroke-linecap\":\"butt | round | square\",\"stroke-linejoin\":\"miter | round | bevel\",\"stroke-miterlimit\":\"<number-one-or-greater>\",\"stroke-opacity\":\"<number-zero-one>\",\"stroke-width\":\"<svg-length>\",\"text-anchor\":\"start | middle | end\",\"unicode-range\":\"<unicode-range>#\",\"voice-balance\":\"<number> | left | center | right | leftwards | rightwards\",\"voice-duration\":\"auto | <time>\",\"voice-family\":\"[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve\",\"voice-pitch\":\"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]\",\"voice-range\":\"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]\",\"voice-rate\":\"[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>\",\"voice-stress\":\"normal | strong | moderate | none | reduced\",\"voice-volume\":\"silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]\"}}");

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var cmpChar = __webpack_require__(0).cmpChar;
var isNumber = __webpack_require__(0).isNumber;
var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var PLUSSIGN = TYPE.PlusSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var N = 110; // 'n'.charCodeAt(0)
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function checkTokenIsInteger(scanner, disallowSign) {
    var pos = scanner.tokenStart;

    if (scanner.source.charCodeAt(pos) === PLUSSIGN ||
        scanner.source.charCodeAt(pos) === HYPHENMINUS) {
        if (disallowSign) {
            scanner.error();
        }
        pos++;
    }

    for (; pos < scanner.tokenEnd; pos++) {
        if (!isNumber(scanner.source.charCodeAt(pos))) {
            scanner.error('Unexpected input', pos);
        }
    }
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
module.exports = {
    name: 'AnPlusB',
    structure: {
        a: [String, null],
        b: [String, null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var end = start;
        var prefix = '';
        var a = null;
        var b = null;

        if (this.scanner.tokenType === NUMBER ||
            this.scanner.tokenType === PLUSSIGN) {
            checkTokenIsInteger(this.scanner, ALLOW_SIGN);
            prefix = this.scanner.getTokenValue();
            this.scanner.next();
            end = this.scanner.tokenStart;
        }

        if (this.scanner.tokenType === IDENTIFIER) {
            var bStart = this.scanner.tokenStart;

            if (cmpChar(this.scanner.source, bStart, HYPHENMINUS)) {
                if (prefix === '') {
                    prefix = '-';
                    bStart++;
                } else {
                    this.scanner.error('Unexpected hyphen minus');
                }
            }

            if (!cmpChar(this.scanner.source, bStart, N)) {
                this.scanner.error();
            }

            a = prefix === ''  ? '1'  :
                prefix === '+' ? '+1' :
                prefix === '-' ? '-1' :
                prefix;

            var len = this.scanner.tokenEnd - bStart;
            if (len > 1) {
                // ..n-..
                if (this.scanner.source.charCodeAt(bStart + 1) !== HYPHENMINUS) {
                    this.scanner.error('Unexpected input', bStart + 1);
                }

                if (len > 2) {
                    // ..n-{number}..
                    this.scanner.tokenStart = bStart + 2;
                } else {
                    // ..n- {number}
                    this.scanner.next();
                    this.scanner.skipSC();
                }

                checkTokenIsInteger(this.scanner, DISALLOW_SIGN);
                b = '-' + this.scanner.getTokenValue();
                this.scanner.next();
                end = this.scanner.tokenStart;
            } else {
                prefix = '';
                this.scanner.next();
                end = this.scanner.tokenStart;
                this.scanner.skipSC();

                if (this.scanner.tokenType === HYPHENMINUS ||
                    this.scanner.tokenType === PLUSSIGN) {
                    prefix = this.scanner.getTokenValue();
                    this.scanner.next();
                    this.scanner.skipSC();
                }

                if (this.scanner.tokenType === NUMBER) {
                    checkTokenIsInteger(this.scanner, prefix !== '');

                    if (!isNumber(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {
                        prefix = this.scanner.source.charAt(this.scanner.tokenStart);
                        this.scanner.tokenStart++;
                    }

                    if (prefix === '') {
                        // should be an operator before number
                        this.scanner.error();
                    } else if (prefix === '+') {
                        // plus is using by default
                        prefix = '';
                    }

                    b = prefix + this.scanner.getTokenValue();

                    this.scanner.next();
                    end = this.scanner.tokenStart;
                } else {
                    if (prefix) {
                        this.scanner.eat(NUMBER);
                    }
                }
            }
        } else {
            if (prefix === '' || prefix === '+') { // no number
                this.scanner.error(
                    'Number or identifier is expected',
                    this.scanner.tokenStart + (
                        this.scanner.tokenType === PLUSSIGN ||
                        this.scanner.tokenType === HYPHENMINUS
                    )
                );
            }

            b = prefix;
        }

        return {
            type: 'AnPlusB',
            loc: this.getLocation(start, end),
            a: a,
            b: b
        };
    },
    generate: function(node) {
        var a = node.a !== null && node.a !== undefined;
        var b = node.b !== null && node.b !== undefined;

        if (a) {
            this.chunk(
                node.a === '+1' ? '+n' :
                node.a ===  '1' ?  'n' :
                node.a === '-1' ? '-n' :
                node.a + 'n'
            );

            if (b) {
                b = String(node.b);
                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
                    this.chunk(b.charAt(0));
                    this.chunk(b.substr(1));
                } else {
                    this.chunk('+');
                    this.chunk(b);
                }
            }
        } else {
            this.chunk(String(node.b));
        }
    }
};


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var ATKEYWORD = TYPE.AtKeyword;
var SEMICOLON = TYPE.Semicolon;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, SEMICOLON, LEFTCURLYBRACKET, false, true);
}

function isDeclarationBlockAtrule() {
    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
        if (type === RIGHTCURLYBRACKET) {
            return true;
        }

        if (type === LEFTCURLYBRACKET ||
            type === ATKEYWORD) {
            return false;
        }
    }

    return false;
}

module.exports = {
    name: 'Atrule',
    structure: {
        name: String,
        prelude: ['AtrulePrelude', 'Raw', null],
        block: ['Block', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var nameLowerCase;
        var prelude = null;
        var block = null;

        this.scanner.eat(ATKEYWORD);

        name = this.scanner.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.scanner.skipSC();

        // parse prelude
        if (this.scanner.eof === false &&
            this.scanner.tokenType !== LEFTCURLYBRACKET &&
            this.scanner.tokenType !== SEMICOLON) {
            if (this.parseAtrulePrelude) {
                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

                // turn empty AtrulePrelude into null
                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
                    prelude = null;
                }
            } else {
                prelude = consumeRaw.call(this, this.scanner.currentToken);
            }

            this.scanner.skipSC();
        }

        switch (this.scanner.tokenType) {
            case SEMICOLON:
                this.scanner.next();
                break;

            case LEFTCURLYBRACKET:
                if (this.atrule.hasOwnProperty(nameLowerCase) &&
                    typeof this.atrule[nameLowerCase].block === 'function') {
                    block = this.atrule[nameLowerCase].block.call(this);
                } else {
                    // TODO: should consume block content as Raw?
                    block = this.Block(isDeclarationBlockAtrule.call(this));
                }

                break;
        }

        return {
            type: 'Atrule',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.chunk('@');
        this.chunk(node.name);

        if (node.prelude !== null) {
            this.chunk(' ');
            this.node(node.prelude);
        }

        if (node.block) {
            this.node(node.block);
        } else {
            this.chunk(';');
        }
    },
    walkContext: 'atrule'
};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var SEMICOLON = TYPE.Semicolon;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

module.exports = {
    name: 'AtrulePrelude',
    structure: {
        children: [[]]
    },
    parse: function(name) {
        var children = null;

        if (name !== null) {
            name = name.toLowerCase();
        }

        this.scanner.skipSC();

        if (this.atrule.hasOwnProperty(name) &&
            typeof this.atrule[name].prelude === 'function') {
            // custom consumer
            children = this.atrule[name].prelude.call(this);
        } else {
            // default consumer
            children = this.readSequence(this.scope.AtrulePrelude);
        }

        this.scanner.skipSC();

        if (this.scanner.eof !== true &&
            this.scanner.tokenType !== LEFTCURLYBRACKET &&
            this.scanner.tokenType !== SEMICOLON) {
            this.scanner.error('Semicolon or block is expected');
        }

        if (children === null) {
            children = this.createList();
        }

        return {
            type: 'AtrulePrelude',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'atrulePrelude'
};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var STRING = TYPE.String;
var DOLLARSIGN = TYPE.DollarSign;
var ASTERISK = TYPE.Asterisk;
var COLON = TYPE.Colon;
var EQUALSSIGN = TYPE.EqualsSign;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
var CIRCUMFLEXACCENT = TYPE.CircumflexAccent;
var VERTICALLINE = TYPE.VerticalLine;
var TILDE = TYPE.Tilde;

function getAttributeName() {
    if (this.scanner.eof) {
        this.scanner.error('Unexpected end of input');
    }

    var start = this.scanner.tokenStart;
    var expectIdentifier = false;
    var checkColon = true;

    if (this.scanner.tokenType === ASTERISK) {
        expectIdentifier = true;
        checkColon = false;
        this.scanner.next();
    } else if (this.scanner.tokenType !== VERTICALLINE) {
        this.scanner.eat(IDENTIFIER);
    }

    if (this.scanner.tokenType === VERTICALLINE) {
        if (this.scanner.lookupType(1) !== EQUALSSIGN) {
            this.scanner.next();
            this.scanner.eat(IDENTIFIER);
        } else if (expectIdentifier) {
            this.scanner.error('Identifier is expected', this.scanner.tokenEnd);
        }
    } else if (expectIdentifier) {
        this.scanner.error('Vertical line is expected');
    }

    if (checkColon && this.scanner.tokenType === COLON) {
        this.scanner.next();
        this.scanner.eat(IDENTIFIER);
    }

    return {
        type: 'Identifier',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
    };
}

function getOperator() {
    var start = this.scanner.tokenStart;
    var tokenType = this.scanner.tokenType;

    if (tokenType !== EQUALSSIGN &&        // =
        tokenType !== TILDE &&             // ~=
        tokenType !== CIRCUMFLEXACCENT &&  // ^=
        tokenType !== DOLLARSIGN &&        // $=
        tokenType !== ASTERISK &&          // *=
        tokenType !== VERTICALLINE         // |=
    ) {
        this.scanner.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

    if (tokenType === EQUALSSIGN) {
        this.scanner.next();
    } else {
        this.scanner.next();
        this.scanner.eat(EQUALSSIGN);
    }

    return this.scanner.substrToCursor(start);
}

// '[' S* attrib_name ']'
// '[' S* attrib_name S* attrib_matcher S* [ IDENT | STRING ] S* attrib_flags? S* ']'
module.exports = {
    name: 'AttributeSelector',
    structure: {
        name: 'Identifier',
        matcher: [String, null],
        value: ['String', 'Identifier', null],
        flags: [String, null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var matcher = null;
        var value = null;
        var flags = null;

        this.scanner.eat(LEFTSQUAREBRACKET);
        this.scanner.skipSC();

        name = getAttributeName.call(this);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
            // avoid case `[name i]`
            if (this.scanner.tokenType !== IDENTIFIER) {
                matcher = getOperator.call(this);

                this.scanner.skipSC();

                value = this.scanner.tokenType === STRING
                    ? this.String()
                    : this.Identifier();

                this.scanner.skipSC();
            }

            // attribute flags
            if (this.scanner.tokenType === IDENTIFIER) {
                flags = this.scanner.getTokenValue();
                this.scanner.next();

                this.scanner.skipSC();
            }
        }

        this.scanner.eat(RIGHTSQUAREBRACKET);

        return {
            type: 'AttributeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            matcher: matcher,
            value: value,
            flags: flags
        };
    },
    generate: function(node) {
        var flagsPrefix = ' ';

        this.chunk('[');
        this.node(node.name);

        if (node.matcher !== null) {
            this.chunk(node.matcher);

            if (node.value !== null) {
                this.node(node.value);

                // space between string and flags is not required
                if (node.value.type === 'String') {
                    flagsPrefix = '';
                }
            }
        }

        if (node.flags !== null) {
            this.chunk(flagsPrefix);
            this.chunk(node.flags);
        }

        this.chunk(']');
    }
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var SEMICOLON = TYPE.Semicolon;
var ATKEYWORD = TYPE.AtKeyword;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, 0, 0, false, true);
}
function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw);
}
function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, 0, SEMICOLON, true, true);
}
function consumeDeclaration() {
    if (this.scanner.tokenType === SEMICOLON) {
        return consumeRawDeclaration.call(this, this.scanner.currentToken);
    }

    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    if (this.scanner.tokenType === SEMICOLON) {
        this.scanner.next();
    }

    return node;
}

module.exports = {
    name: 'Block',
    structure: {
        children: [[
            'Atrule',
            'Rule',
            'Declaration'
        ]]
    },
    parse: function(isDeclaration) {
        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

        var start = this.scanner.tokenStart;
        var children = this.createList();

        this.scanner.eat(LEFTCURLYBRACKET);

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case RIGHTCURLYBRACKET:
                    break scan;

                case WHITESPACE:
                case COMMENT:
                    this.scanner.next();
                    break;

                case ATKEYWORD:
                    children.push(this.parseWithFallback(this.Atrule, consumeRaw));
                    break;

                default:
                    children.push(consumer.call(this));
            }
        }

        if (!this.scanner.eof) {
            this.scanner.eat(RIGHTCURLYBRACKET);
        }

        return {
            type: 'Block',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('{');
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
        this.chunk('}');
    },
    walkContext: 'block'
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;

module.exports = {
    name: 'Brackets',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.scanner.eat(LEFTSQUAREBRACKET);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.scanner.eat(RIGHTSQUAREBRACKET);
        }

        return {
            type: 'Brackets',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('[');
        this.children(node);
        this.chunk(']');
    }
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var CDC = __webpack_require__(0).TYPE.CDC;

module.exports = {
    name: 'CDC',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.eat(CDC); // -->

        return {
            type: 'CDC',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('-->');
    }
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var CDO = __webpack_require__(0).TYPE.CDO;

module.exports = {
    name: 'CDO',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.eat(CDO); // <!--

        return {
            type: 'CDO',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function() {
        this.chunk('<!--');
    }
};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;
var IDENTIFIER = TYPE.Identifier;
var FULLSTOP = TYPE.FullStop;

// '.' ident
module.exports = {
    name: 'ClassSelector',
    structure: {
        name: String
    },
    parse: function() {
        this.scanner.eat(FULLSTOP);

        return {
            type: 'ClassSelector',
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.scanner.consume(IDENTIFIER)
        };
    },
    generate: function(node) {
        this.chunk('.');
        this.chunk(node.name);
    }
};


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var PLUSSIGN = TYPE.PlusSign;
var SOLIDUS = TYPE.Solidus;
var GREATERTHANSIGN = TYPE.GreaterThanSign;
var TILDE = TYPE.Tilde;

// + | > | ~ | /deep/
module.exports = {
    name: 'Combinator',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        switch (this.scanner.tokenType) {
            case GREATERTHANSIGN:
            case PLUSSIGN:
            case TILDE:
                this.scanner.next();
                break;

            case SOLIDUS:
                this.scanner.next();
                this.scanner.expectIdentifier('deep');
                this.scanner.eat(SOLIDUS);
                break;

            default:
                this.scanner.error('Combinator is expected');
        }

        return {
            type: 'Combinator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var ASTERISK = TYPE.Asterisk;
var SOLIDUS = TYPE.Solidus;

// '/*' .* '*/'
module.exports = {
    name: 'Comment',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var end = this.scanner.tokenEnd;

        if ((end - start + 2) >= 2 &&
            this.scanner.source.charCodeAt(end - 2) === ASTERISK &&
            this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {
            end -= 2;
        }

        this.scanner.next();

        return {
            type: 'Comment',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start + 2, end)
        };
    },
    generate: function(node) {
        this.chunk('/*');
        this.chunk(node.value);
        this.chunk('*/');
    }
};


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var isCustomProperty = __webpack_require__(27).isCustomProperty;
var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var COLON = TYPE.Colon;
var EXCLAMATIONMARK = TYPE.ExclamationMark;
var SOLIDUS = TYPE.Solidus;
var ASTERISK = TYPE.Asterisk;
var DOLLARSIGN = TYPE.DollarSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var SEMICOLON = TYPE.Semicolon;
var PLUSSIGN = TYPE.PlusSign;
var NUMBERSIGN = TYPE.NumberSign;

function consumeValueRaw(startToken) {
    return this.Raw(startToken, EXCLAMATIONMARK, SEMICOLON, false, true);
}

function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, EXCLAMATIONMARK, SEMICOLON, false, false);
}

function consumeValue() {
    var startValueToken = this.scanner.currentToken;
    var value = this.Value();

    if (value.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== SEMICOLON &&
        this.scanner.tokenType !== EXCLAMATIONMARK &&
        this.scanner.isBalanceEdge(startValueToken) === false) {
        this.scanner.error();
    }

    return value;
}

module.exports = {
    name: 'Declaration',
    structure: {
        important: [Boolean, String],
        property: String,
        value: ['Value', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var startToken = this.scanner.currentToken;
        var property = readProperty.call(this);
        var customProperty = isCustomProperty(property);
        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
        var important = false;
        var value;

        this.scanner.skipSC();
        this.scanner.eat(COLON);

        if (!customProperty) {
            this.scanner.skipSC();
        }

        if (parseValue) {
            value = this.parseWithFallback(consumeValue, consumeRaw);
        } else {
            value = consumeRaw.call(this, this.scanner.currentToken);
        }

        if (this.scanner.tokenType === EXCLAMATIONMARK) {
            important = getImportant(this.scanner);
            this.scanner.skipSC();
        }

        // Do not include semicolon to range per spec
        // https://drafts.csswg.org/css-syntax/#declaration-diagram

        if (this.scanner.eof === false &&
            this.scanner.tokenType !== SEMICOLON &&
            this.scanner.isBalanceEdge(startToken) === false) {
            this.scanner.error();
        }

        return {
            type: 'Declaration',
            loc: this.getLocation(start, this.scanner.tokenStart),
            important: important,
            property: property,
            value: value
        };
    },
    generate: function(node) {
        this.chunk(node.property);
        this.chunk(':');
        this.node(node.value);

        if (node.important) {
            this.chunk(node.important === true ? '!important' : '!' + node.important);
        }
    },
    walkContext: 'declaration'
};

function readProperty() {
    var start = this.scanner.tokenStart;
    var prefix = 0;

    // hacks
    switch (this.scanner.tokenType) {
        case ASTERISK:
        case DOLLARSIGN:
        case PLUSSIGN:
        case NUMBERSIGN:
            prefix = 1;
            break;

        // TODO: not sure we should support this hack
        case SOLIDUS:
            prefix = this.scanner.lookupType(1) === SOLIDUS ? 2 : 1;
            break;
    }

    if (this.scanner.lookupType(prefix) === HYPHENMINUS) {
        prefix++;
    }

    if (prefix) {
        this.scanner.skip(prefix);
    }

    this.scanner.eat(IDENTIFIER);

    return this.scanner.substrToCursor(start);
}

// ! ws* important
function getImportant(scanner) {
    scanner.eat(EXCLAMATIONMARK);
    scanner.skipSC();

    var important = scanner.consume(IDENTIFIER);

    // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support
    return important === 'important' ? true : important;
}


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var SEMICOLON = TYPE.Semicolon;

function consumeRaw(startToken) {
    return this.Raw(startToken, 0, SEMICOLON, true, true);
}

module.exports = {
    name: 'DeclarationList',
    structure: {
        children: [[
            'Declaration'
        ]]
    },
    parse: function() {
        var children = this.createList();

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE:
                case COMMENT:
                case SEMICOLON:
                    this.scanner.next();
                    break;

                default:
                    children.push(this.parseWithFallback(this.Declaration, consumeRaw));
            }
        }

        return {
            type: 'DeclarationList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function(prev) {
            if (prev.type === 'Declaration') {
                this.chunk(';');
            }
        });
    }
};


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var NUMBER = __webpack_require__(0).TYPE.Number;

// special reader for units to avoid adjoined IE hacks (i.e. '1px\9')
function readUnit(scanner) {
    var unit = scanner.getTokenValue();
    var backSlashPos = unit.indexOf('\\');

    if (backSlashPos > 0) {
        // patch token offset
        scanner.tokenStart += backSlashPos;

        // return part before backslash
        return unit.substring(0, backSlashPos);
    }

    // no backslash in unit name
    scanner.next();

    return unit;
}

// number ident
module.exports = {
    name: 'Dimension',
    structure: {
        value: String,
        unit: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var value = this.scanner.consume(NUMBER);
        var unit = readUnit(this.scanner);

        return {
            type: 'Dimension',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: value,
            unit: unit
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk(node.unit);
    }
};


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// <function-token> <sequence> ')'
module.exports = {
    name: 'Function',
    structure: {
        name: String,
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var name = this.scanner.consumeFunctionName();
        var nameLowerCase = name.toLowerCase();
        var children;

        children = recognizer.hasOwnProperty(nameLowerCase)
            ? recognizer[nameLowerCase].call(this, recognizer)
            : readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.scanner.eat(RIGHTPARENTHESIS);
        }

        return {
            type: 'Function',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(node.name);
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    },
    walkContext: 'function'
};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var isHex = __webpack_require__(0).isHex;
var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var NUMBERSIGN = TYPE.NumberSign;

function consumeHexSequence(scanner, required) {
    if (!isHex(scanner.source.charCodeAt(scanner.tokenStart))) {
        if (required) {
            scanner.error('Unexpected input', scanner.tokenStart);
        } else {
            return;
        }
    }

    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
        var code = scanner.source.charCodeAt(pos);

        // break on non-hex char
        if (!isHex(code)) {
            // break token, exclude symbol
            scanner.tokenStart = pos;
            return;
        }
    }

    // token is full hex sequence, go to next token
    scanner.next();
}

// # ident
module.exports = {
    name: 'HexColor',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.eat(NUMBERSIGN);

        scan:
        switch (this.scanner.tokenType) {
            case NUMBER:
                consumeHexSequence(this.scanner, true);

                // if token is identifier then number consists of hex only,
                // try to add identifier to result
                if (this.scanner.tokenType === IDENTIFIER) {
                    consumeHexSequence(this.scanner, false);
                }

                break;

            case IDENTIFIER:
                consumeHexSequence(this.scanner, true);
                break;

            default:
                this.scanner.error('Number or identifier is expected');
        }

        return {
            type: 'HexColor',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start + 1) // skip #
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.value);
    }
};


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;
var IDENTIFIER = TYPE.Identifier;

module.exports = {
    name: 'Identifier',
    structure: {
        name: String
    },
    parse: function() {
        return {
            type: 'Identifier',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            name: this.scanner.consume(IDENTIFIER)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;
var IDENTIFIER = TYPE.Identifier;
var NUMBERSIGN = TYPE.NumberSign;

// '#' ident
module.exports = {
    name: 'IdSelector',
    structure: {
        name: String
    },
    parse: function() {
        this.scanner.eat(NUMBERSIGN);

        return {
            type: 'IdSelector',
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.scanner.consume(IDENTIFIER)
        };
    },
    generate: function(node) {
        this.chunk('#');
        this.chunk(node.name);
    }
};


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
var COLON = TYPE.Colon;
var SOLIDUS = TYPE.Solidus;

module.exports = {
    name: 'MediaFeature',
    structure: {
        name: String,
        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var value = null;

        this.scanner.eat(LEFTPARENTHESIS);
        this.scanner.skipSC();

        name = this.scanner.consume(IDENTIFIER);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
            this.scanner.eat(COLON);
            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case NUMBER:
                    if (this.scanner.lookupType(1) === IDENTIFIER) {
                        value = this.Dimension();
                    } else if (this.scanner.lookupNonWSType(1) === SOLIDUS) {
                        value = this.Ratio();
                    } else {
                        value = this.Number();
                    }

                    break;

                case IDENTIFIER:
                    value = this.Identifier();

                    break;

                default:
                    this.scanner.error('Number, dimension, ratio or identifier is expected');
            }

            this.scanner.skipSC();
        }

        this.scanner.eat(RIGHTPARENTHESIS);

        return {
            type: 'MediaFeature',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            value: value
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.chunk(node.name);
        if (node.value !== null) {
            this.chunk(':');
            this.node(node.value);
        }
        this.chunk(')');
    }
};


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENTIFIER = TYPE.Identifier;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

module.exports = {
    name: 'MediaQuery',
    structure: {
        children: [[
            'Identifier',
            'MediaFeature',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        this.scanner.skipSC();

        var children = this.createList();
        var child = null;
        var space = null;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case COMMENT:
                    this.scanner.next();
                    continue;

                case WHITESPACE:
                    space = this.WhiteSpace();
                    continue;

                case IDENTIFIER:
                    child = this.Identifier();
                    break;

                case LEFTPARENTHESIS:
                    child = this.MediaFeature();
                    break;

                default:
                    break scan;
            }

            if (space !== null) {
                children.push(space);
                space = null;
            }

            children.push(child);
        }

        if (child === null) {
            this.scanner.error('Identifier or parenthesis is expected');
        }

        return {
            type: 'MediaQuery',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var COMMA = __webpack_require__(0).TYPE.Comma;

module.exports = {
    name: 'MediaQueryList',
    structure: {
        children: [[
            'MediaQuery'
        ]]
    },
    parse: function(relative) {
        var children = this.createList();

        this.scanner.skipSC();

        while (!this.scanner.eof) {
            children.push(this.MediaQuery(relative));

            if (this.scanner.tokenType !== COMMA) {
                break;
            }

            this.scanner.next();
        }

        return {
            type: 'MediaQueryList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    }
};


/***/ }),
/* 149 */
/***/ (function(module, exports) {

// https://drafts.csswg.org/css-syntax-3/#the-anb-type
module.exports = {
    name: 'Nth',
    structure: {
        nth: ['AnPlusB', 'Identifier'],
        selector: ['SelectorList', null]
    },
    parse: function(allowOfClause) {
        this.scanner.skipSC();

        var start = this.scanner.tokenStart;
        var end = start;
        var selector = null;
        var query;

        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
            query = this.Identifier();
        } else {
            query = this.AnPlusB();
        }

        this.scanner.skipSC();

        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
            this.scanner.next();

            selector = this.SelectorList();

            if (this.needPositions) {
                end = this.getLastListNode(selector.children).loc.end.offset;
            }
        } else {
            if (this.needPositions) {
                end = query.loc.end.offset;
            }
        }

        return {
            type: 'Nth',
            loc: this.getLocation(start, end),
            nth: query,
            selector: selector
        };
    },
    generate: function(node) {
        this.node(node.nth);
        if (node.selector !== null) {
            this.chunk(' of ');
            this.node(node.selector);
        }
    }
};


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var NUMBER = __webpack_require__(0).TYPE.Number;

module.exports = {
    name: 'Number',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'Number',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.scanner.consume(NUMBER)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};


/***/ }),
/* 151 */
/***/ (function(module, exports) {

// '/' | '*' | ',' | ':' | '+' | '-'
module.exports = {
    name: 'Operator',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.next();

        return {
            type: 'Operator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

module.exports = {
    name: 'Parentheses',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.scanner.eat(LEFTPARENTHESIS);

        children = readSequence.call(this, recognizer);

        if (!this.scanner.eof) {
            this.scanner.eat(RIGHTPARENTHESIS);
        }

        return {
            type: 'Parentheses',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.chunk('(');
        this.children(node);
        this.chunk(')');
    }
};


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var NUMBER = TYPE.Number;
var PERCENTSIGN = TYPE.PercentSign;

module.exports = {
    name: 'Percentage',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var number = this.scanner.consume(NUMBER);

        this.scanner.eat(PERCENTSIGN);

        return {
            type: 'Percentage',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: number
        };
    },
    generate: function(node) {
        this.chunk(node.value);
        this.chunk('%');
    }
};


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// : ident [ '(' .. ')' ]?
module.exports = {
    name: 'PseudoClassSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.scanner.eat(COLON);

        if (this.scanner.tokenType === FUNCTION) {
            name = this.scanner.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
                );
            }

            this.scanner.eat(RIGHTPARENTHESIS);
        } else {
            name = this.scanner.consume(IDENTIFIER);
        }

        return {
            type: 'PseudoClassSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk(':');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var FUNCTION = TYPE.Function;
var COLON = TYPE.Colon;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// :: ident [ '(' .. ')' ]?
module.exports = {
    name: 'PseudoElementSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.scanner.eat(COLON);
        this.scanner.eat(COLON);

        if (this.scanner.tokenType === FUNCTION) {
            name = this.scanner.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = this.createList();
                children.push(
                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
                );
            }

            this.scanner.eat(RIGHTPARENTHESIS);
        } else {
            name = this.scanner.consume(IDENTIFIER);
        }

        return {
            type: 'PseudoElementSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        this.chunk('::');
        this.chunk(node.name);

        if (node.children !== null) {
            this.chunk('(');
            this.children(node);
            this.chunk(')');
        }
    },
    walkContext: 'function'
};


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var isNumber = __webpack_require__(0).isNumber;
var TYPE = __webpack_require__(0).TYPE;
var NUMBER = TYPE.Number;
var SOLIDUS = TYPE.Solidus;
var FULLSTOP = TYPE.FullStop;

// Terms of <ratio> should to be a positive number (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without exponent part.
// Additional checks may to be applied on lexer validation.
function consumeNumber(scanner) {
    var value = scanner.consumeNonWS(NUMBER);

    for (var i = 0; i < value.length; i++) {
        var code = value.charCodeAt(i);
        if (!isNumber(code) && code !== FULLSTOP) {
            scanner.error('Unsigned number is expected', scanner.tokenStart - value.length + i);
        }
    }

    if (Number(value) === 0) {
        scanner.error('Zero number is not allowed', scanner.tokenStart - value.length);
    }

    return value;
}

// <positive-integer> S* '/' S* <positive-integer>
module.exports = {
    name: 'Ratio',
    structure: {
        left: String,
        right: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var left = consumeNumber(this.scanner);
        var right;

        this.scanner.eatNonWS(SOLIDUS);
        right = consumeNumber(this.scanner);

        return {
            type: 'Ratio',
            loc: this.getLocation(start, this.scanner.tokenStart),
            left: left,
            right: right
        };
    },
    generate: function(node) {
        this.chunk(node.left);
        this.chunk('/');
        this.chunk(node.right);
    }
};


/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = {
    name: 'Raw',
    structure: {
        value: String
    },
    parse: function(startToken, endTokenType1, endTokenType2, includeTokenType2, excludeWhiteSpace) {
        var startOffset = this.scanner.getTokenStart(startToken);
        var endOffset;

        this.scanner.skip(
            this.scanner.getRawLength(
                startToken,
                endTokenType1,
                endTokenType2,
                includeTokenType2
            )
        );

        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
            endOffset = this.scanner.getOffsetExcludeWS();
        } else {
            endOffset = this.scanner.tokenStart;
        }

        return {
            type: 'Raw',
            loc: this.getLocation(startOffset, endOffset),
            value: this.scanner.source.substring(startOffset, endOffset)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

function consumeRaw(startToken) {
    return this.Raw(startToken, LEFTCURLYBRACKET, 0, false, true);
}

function consumePrelude() {
    var prelude = this.SelectorList();

    if (prelude.type !== 'Raw' &&
        this.scanner.eof === false &&
        this.scanner.tokenType !== LEFTCURLYBRACKET) {
        this.scanner.error();
    }

    return prelude;
}

module.exports = {
    name: 'Rule',
    structure: {
        prelude: ['SelectorList', 'Raw'],
        block: ['Block']
    },
    parse: function() {
        var startToken = this.scanner.currentToken;
        var startOffset = this.scanner.tokenStart;
        var prelude;
        var block;

        if (this.parseRulePrelude) {
            prelude = this.parseWithFallback(consumePrelude, consumeRaw);
        } else {
            prelude = consumeRaw.call(this, startToken);
        }

        block = this.Block(true);

        return {
            type: 'Rule',
            loc: this.getLocation(startOffset, this.scanner.tokenStart),
            prelude: prelude,
            block: block
        };
    },
    generate: function(node) {
        this.node(node.prelude);
        this.node(node.block);
    },
    walkContext: 'rule'
};


/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = {
    name: 'Selector',
    structure: {
        children: [[
            'TypeSelector',
            'IdSelector',
            'ClassSelector',
            'AttributeSelector',
            'PseudoClassSelector',
            'PseudoElementSelector',
            'Combinator',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        var children = this.readSequence(this.scope.Selector);

        // nothing were consumed
        if (this.getFirstListNode(children) === null) {
            this.scanner.error('Selector is expected');
        }

        return {
            type: 'Selector',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var COMMA = TYPE.Comma;

module.exports = {
    name: 'SelectorList',
    structure: {
        children: [[
            'Selector',
            'Raw'
        ]]
    },
    parse: function() {
        var children = this.createList();

        while (!this.scanner.eof) {
            children.push(this.Selector());

            if (this.scanner.tokenType === COMMA) {
                this.scanner.next();
                continue;
            }

            break;
        }

        return {
            type: 'SelectorList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        this.children(node, function() {
            this.chunk(',');
        });
    },
    walkContext: 'selector'
};


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var STRING = __webpack_require__(0).TYPE.String;

module.exports = {
    name: 'String',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'String',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.scanner.consume(STRING)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var EXCLAMATIONMARK = TYPE.ExclamationMark;
var ATKEYWORD = TYPE.AtKeyword;
var CDO = TYPE.CDO;
var CDC = TYPE.CDC;

function consumeRaw(startToken) {
    return this.Raw(startToken, 0, 0, false, false);
}

module.exports = {
    name: 'StyleSheet',
    structure: {
        children: [[
            'Comment',
            'CDO',
            'CDC',
            'Atrule',
            'Rule',
            'Raw'
        ]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.createList();
        var child;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE:
                    this.scanner.next();
                    continue;

                case COMMENT:
                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
                        this.scanner.next();
                        continue;
                    }

                    child = this.Comment();
                    break;

                case CDO: // <!--
                    child = this.CDO();
                    break;

                case CDC: // -->
                    child = this.CDC();
                    break;

                // CSS Syntax Module Level 3
                // §2.2 Error handling
                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
                case ATKEYWORD:
                    child = this.parseWithFallback(this.Atrule, consumeRaw);
                    break;

                // Anything else starts a qualified rule ...
                default:
                    child = this.parseWithFallback(this.Rule, consumeRaw);
            }

            children.push(child);
        }

        return {
            type: 'StyleSheet',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    },
    walkContext: 'stylesheet'
};


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var ASTERISK = TYPE.Asterisk;
var VERTICALLINE = TYPE.VerticalLine;

function eatIdentifierOrAsterisk() {
    if (this.scanner.tokenType !== IDENTIFIER &&
        this.scanner.tokenType !== ASTERISK) {
        this.scanner.error('Identifier or asterisk is expected');
    }

    this.scanner.next();
}

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
module.exports = {
    name: 'TypeSelector',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        if (this.scanner.tokenType === VERTICALLINE) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
        } else {
            eatIdentifierOrAsterisk.call(this);

            if (this.scanner.tokenType === VERTICALLINE) {
                this.scanner.next();
                eatIdentifierOrAsterisk.call(this);
            }
        }

        return {
            type: 'TypeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.name);
    }
};


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var isHex = __webpack_require__(0).isHex;
var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var PLUSSIGN = TYPE.PlusSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var FULLSTOP = TYPE.FullStop;
var QUESTIONMARK = TYPE.QuestionMark;

function scanUnicodeNumber(scanner) {
    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
        var code = scanner.source.charCodeAt(pos);

        // break on fullstop or hyperminus/plussign after exponent
        if (code === FULLSTOP || code === PLUSSIGN) {
            // break token, exclude symbol
            scanner.tokenStart = pos;
            return false;
        }
    }

    return true;
}

// https://drafts.csswg.org/css-syntax-3/#urange
function scanUnicodeRange(scanner) {
    var hexStart = scanner.tokenStart + 1; // skip +
    var hexLength = 0;

    scan: {
        if (scanner.tokenType === NUMBER) {
            if (scanner.source.charCodeAt(scanner.tokenStart) !== FULLSTOP && scanUnicodeNumber(scanner)) {
                scanner.next();
            } else if (scanner.source.charCodeAt(scanner.tokenStart) !== HYPHENMINUS) {
                break scan;
            }
        } else {
            scanner.next(); // PLUSSIGN
        }

        if (scanner.tokenType === HYPHENMINUS) {
            scanner.next();
        }

        if (scanner.tokenType === NUMBER) {
            scanner.next();
        }

        if (scanner.tokenType === IDENTIFIER) {
            scanner.next();
        }

        if (scanner.tokenStart === hexStart) {
            scanner.error('Unexpected input', hexStart);
        }
    }

    // validate for U+x{1,6} or U+x{1,6}-x{1,6}
    // where x is [0-9a-fA-F]
    for (var i = hexStart, wasHyphenMinus = false; i < scanner.tokenStart; i++) {
        var code = scanner.source.charCodeAt(i);

        if (isHex(code) === false && (code !== HYPHENMINUS || wasHyphenMinus)) {
            scanner.error('Unexpected input', i);
        }

        if (code === HYPHENMINUS) {
            // hex sequence shouldn't be an empty
            if (hexLength === 0) {
                scanner.error('Unexpected input', i);
            }

            wasHyphenMinus = true;
            hexLength = 0;
        } else {
            hexLength++;

            // too long hex sequence
            if (hexLength > 6) {
                scanner.error('Too long hex sequence', i);
            }
        }

    }

    // check we have a non-zero sequence
    if (hexLength === 0) {
        scanner.error('Unexpected input', i - 1);
    }

    // U+abc???
    if (!wasHyphenMinus) {
        // consume as many U+003F QUESTION MARK (?) code points as possible
        for (; hexLength < 6 && !scanner.eof; scanner.next()) {
            if (scanner.tokenType !== QUESTIONMARK) {
                break;
            }

            hexLength++;
        }
    }
}

module.exports = {
    name: 'UnicodeRange',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.next(); // U or u
        scanUnicodeRange(this.scanner);

        return {
            type: 'UnicodeRange',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var STRING = TYPE.String;
var URL = TYPE.Url;
var RAW = TYPE.Raw;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

// url '(' S* (string | raw) S* ')'
module.exports = {
    name: 'Url',
    structure: {
        value: ['String', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var value;

        this.scanner.eat(URL);
        this.scanner.skipSC();

        switch (this.scanner.tokenType) {
            case STRING:
                value = this.String();
                break;

            case RAW:
                value = this.Raw(this.scanner.currentToken, 0, RAW, true, false);
                break;

            default:
                this.scanner.error('String or Raw is expected');
        }

        this.scanner.skipSC();
        this.scanner.eat(RIGHTPARENTHESIS);

        return {
            type: 'Url',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: value
        };
    },
    generate: function(node) {
        this.chunk('url');
        this.chunk('(');
        this.node(node.value);
        this.chunk(')');
    }
};


/***/ }),
/* 166 */
/***/ (function(module, exports) {

module.exports = {
    name: 'Value',
    structure: {
        children: [[]]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.readSequence(this.scope.Value);

        return {
            type: 'Value',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        this.children(node);
    }
};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var WHITESPACE = __webpack_require__(0).TYPE.WhiteSpace;
var SPACE = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
});

module.exports = {
    name: 'WhiteSpace',
    structure: {
        value: String
    },
    parse: function() {
        this.scanner.eat(WHITESPACE);
        return SPACE;

        // return {
        //     type: 'WhiteSpace',
        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        //     value: this.scanner.consume(WHITESPACE)
        // };
    },
    generate: function(node) {
        this.chunk(node.value);
    }
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    parseContext: {
        default: 'StyleSheet',
        stylesheet: 'StyleSheet',
        atrule: 'Atrule',
        atrulePrelude: function(options) {
            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: 'MediaQueryList',
        mediaQuery: 'MediaQuery',
        rule: 'Rule',
        selectorList: 'SelectorList',
        selector: 'Selector',
        block: function() {
            return this.Block(true);
        },
        declarationList: 'DeclarationList',
        declaration: 'Declaration',
        value: 'Value'
    },
    scope: __webpack_require__(169),
    atrule: __webpack_require__(175),
    pseudo: __webpack_require__(181),
    node: __webpack_require__(29)
};


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    AtrulePrelude: __webpack_require__(170),
    Selector: __webpack_require__(171),
    Value: __webpack_require__(172)
};


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    getNode: __webpack_require__(53)
};


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var NUMBERSIGN = TYPE.NumberSign;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var PLUSSIGN = TYPE.PlusSign;
var SOLIDUS = TYPE.Solidus;
var ASTERISK = TYPE.Asterisk;
var FULLSTOP = TYPE.FullStop;
var COLON = TYPE.Colon;
var GREATERTHANSIGN = TYPE.GreaterThanSign;
var VERTICALLINE = TYPE.VerticalLine;
var TILDE = TYPE.Tilde;

function getNode(context) {
    switch (this.scanner.tokenType) {
        case PLUSSIGN:
        case GREATERTHANSIGN:
        case TILDE:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Combinator();

        case SOLIDUS:  // /deep/
            return this.Combinator();

        case FULLSTOP:
            return this.ClassSelector();

        case LEFTSQUAREBRACKET:
            return this.AttributeSelector();

        case NUMBERSIGN:
            return this.IdSelector();

        case COLON:
            if (this.scanner.lookupType(1) === COLON) {
                return this.PseudoElementSelector();
            } else {
                return this.PseudoClassSelector();
            }

        case IDENTIFIER:
        case ASTERISK:
        case VERTICALLINE:
            return this.TypeSelector();

        case NUMBER:
            return this.Percentage();
    }
};

module.exports = {
    getNode: getNode
};


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    getNode: __webpack_require__(53),
    '-moz-element': __webpack_require__(54),
    'element': __webpack_require__(54),
    'expression': __webpack_require__(173),
    'var': __webpack_require__(174)
};


/***/ }),
/* 173 */
/***/ (function(module, exports) {

// legacy IE function
// expression '(' raw ')'
module.exports = function() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.currentToken, 0, 0, false, false)
    );
};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var IDENTIFIER = TYPE.Identifier;
var COMMA = TYPE.Comma;
var SEMICOLON = TYPE.Semicolon;
var HYPHENMINUS = TYPE.HyphenMinus;
var EXCLAMATIONMARK = TYPE.ExclamationMark;

// var '(' ident (',' <value>? )? ')'
module.exports = function() {
    var children = this.createList();

    this.scanner.skipSC();

    var identStart = this.scanner.tokenStart;

    this.scanner.eat(HYPHENMINUS);
    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== HYPHENMINUS) {
        this.scanner.error('HyphenMinus is expected');
    }
    this.scanner.eat(IDENTIFIER);

    children.push({
        type: 'Identifier',
        loc: this.getLocation(identStart, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(identStart)
    });

    this.scanner.skipSC();

    if (this.scanner.tokenType === COMMA) {
        children.push(this.Operator());
        children.push(this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(this.scanner.currentToken, EXCLAMATIONMARK, SEMICOLON, false, false)
        );
    }

    return children;
};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    'font-face': __webpack_require__(176),
    'import': __webpack_require__(177),
    'media': __webpack_require__(178),
    'page': __webpack_require__(179),
    'supports': __webpack_require__(180)
};


/***/ }),
/* 176 */
/***/ (function(module, exports) {

module.exports = {
    parse: {
        prelude: null,
        block: function() {
            return this.Block(true);
        }
    }
};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var STRING = TYPE.String;
var IDENTIFIER = TYPE.Identifier;
var URL = TYPE.Url;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

module.exports = {
    parse: {
        prelude: function() {
            var children = this.createList();

            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case STRING:
                    children.push(this.String());
                    break;

                case URL:
                    children.push(this.Url());
                    break;

                default:
                    this.scanner.error('String or url() is expected');
            }

            if (this.scanner.lookupNonWSType(0) === IDENTIFIER ||
                this.scanner.lookupNonWSType(0) === LEFTPARENTHESIS) {
                children.push(this.WhiteSpace());
                children.push(this.MediaQueryList());
            }

            return children;
        },
        block: null
    }
};


/***/ }),
/* 178 */
/***/ (function(module, exports) {

module.exports = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.MediaQueryList()
            );
        },
        block: function() {
            return this.Block(false);
        }
    }
};


/***/ }),
/* 179 */
/***/ (function(module, exports) {

module.exports = {
    parse: {
        prelude: function() {
            return this.createSingleNodeList(
                this.SelectorList()
            );
        },
        block: function() {
            return this.Block(true);
        }
    }
};


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var TYPE = __webpack_require__(0).TYPE;

var WHITESPACE = TYPE.WhiteSpace;
var COMMENT = TYPE.Comment;
var IDENTIFIER = TYPE.Identifier;
var FUNCTION = TYPE.Function;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var HYPHENMINUS = TYPE.HyphenMinus;
var COLON = TYPE.Colon;

function consumeRaw() {
    return this.createSingleNodeList(
        this.Raw(this.scanner.currentToken, 0, 0, false, false)
    );
}

function parentheses() {
    var index = 0;

    this.scanner.skipSC();

    // TODO: make it simplier
    if (this.scanner.tokenType === IDENTIFIER) {
        index = 1;
    } else if (this.scanner.tokenType === HYPHENMINUS &&
               this.scanner.lookupType(1) === IDENTIFIER) {
        index = 2;
    }

    if (index !== 0 && this.scanner.lookupNonWSType(index) === COLON) {
        return this.createSingleNodeList(
            this.Declaration()
        );
    }

    return readSequence.call(this);
}

function readSequence() {
    var children = this.createList();
    var space = null;
    var child;

    this.scanner.skipSC();

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case WHITESPACE:
                space = this.WhiteSpace();
                continue;

            case COMMENT:
                this.scanner.next();
                continue;

            case FUNCTION:
                child = this.Function(consumeRaw, this.scope.AtrulePrelude);
                break;

            case IDENTIFIER:
                child = this.Identifier();
                break;

            case LEFTPARENTHESIS:
                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                break;

            default:
                break scan;
        }

        if (space !== null) {
            children.push(space);
            space = null;
        }

        children.push(child);
    }

    return children;
}

module.exports = {
    parse: {
        prelude: function() {
            var children = readSequence.call(this);

            if (this.getFirstListNode(children) === null) {
                this.scanner.error('Condition is expected');
            }

            return children;
        },
        block: function() {
            return this.Block(false);
        }
    }
};


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    'dir': __webpack_require__(182),
    'has': __webpack_require__(183),
    'lang': __webpack_require__(184),
    'matches': __webpack_require__(185),
    'not': __webpack_require__(186),
    'nth-child': __webpack_require__(187),
    'nth-last-child': __webpack_require__(188),
    'nth-last-of-type': __webpack_require__(189),
    'nth-of-type': __webpack_require__(190),
    'slotted': __webpack_require__(191)
};


/***/ }),
/* 182 */
/***/ (function(module, exports) {

module.exports = {
    parse: function() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};


/***/ }),
/* 183 */
/***/ (function(module, exports) {

module.exports = {
    parse: function() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};


/***/ }),
/* 184 */
/***/ (function(module, exports) {

module.exports = {
    parse: function() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(55);


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(55);


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(56);


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(56);


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(57);


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(57);


/***/ }),
/* 191 */
/***/ (function(module, exports) {

module.exports = {
    parse: function compoundSelector() {
        return this.createSingleNodeList(
            this.Selector()
        );
    }
};


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    node: __webpack_require__(29)
};


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(1).List;
var clone = __webpack_require__(1).clone;
var usageUtils = __webpack_require__(194);
var clean = __webpack_require__(195);
var replace = __webpack_require__(203);
var restructure = __webpack_require__(215);
var walk = __webpack_require__(1).walk;

function readChunk(children, specialComments) {
    var buffer = new List();
    var nonSpaceTokenInBuffer = false;
    var protectedComment;

    children.nextUntil(children.head, function(node, item, list) {
        if (node.type === 'Comment') {
            if (!specialComments || node.value.charAt(0) !== '!') {
                list.remove(item);
                return;
            }

            if (nonSpaceTokenInBuffer || protectedComment) {
                return true;
            }

            list.remove(item);
            protectedComment = node;
            return;
        }

        if (node.type !== 'WhiteSpace') {
            nonSpaceTokenInBuffer = true;
        }

        buffer.insert(list.remove(item));
    });

    return {
        comment: protectedComment,
        stylesheet: {
            type: 'StyleSheet',
            loc: null,
            children: buffer
        }
    };
}

function compressChunk(ast, firstAtrulesAllowed, num, options) {
    options.logger('Compress block #' + num, null, true);

    var seed = 1;

    if (ast.type === 'StyleSheet') {
        ast.firstAtrulesAllowed = firstAtrulesAllowed;
        ast.id = seed++;
    }

    walk(ast, {
        visit: 'Atrule',
        enter: function markScopes(node) {
            if (node.block !== null) {
                node.block.id = seed++;
            }
        }
    });
    options.logger('init', ast);

    // remove redundant
    clean(ast, options);
    options.logger('clean', ast);

    // replace nodes for shortened forms
    replace(ast, options);
    options.logger('replace', ast);

    // structure optimisations
    if (options.restructuring) {
        restructure(ast, options);
    }

    return ast;
}

function getCommentsOption(options) {
    var comments = 'comments' in options ? options.comments : 'exclamation';

    if (typeof comments === 'boolean') {
        comments = comments ? 'exclamation' : false;
    } else if (comments !== 'exclamation' && comments !== 'first-exclamation') {
        comments = false;
    }

    return comments;
}

function getRestructureOption(options) {
    return 'restructure' in options ? options.restructure :
           'restructuring' in options ? options.restructuring :
           true;
}

function wrapBlock(block) {
    return new List().appendData({
        type: 'Rule',
        loc: null,
        prelude: {
            type: 'SelectorList',
            loc: null,
            children: new List().appendData({
                type: 'Selector',
                loc: null,
                children: new List().appendData({
                    type: 'TypeSelector',
                    loc: null,
                    name: 'x'
                })
            })
        },
        block: block
    });
}

module.exports = function compress(ast, options) {
    ast = ast || { type: 'StyleSheet', loc: null, children: new List() };
    options = options || {};

    var compressOptions = {
        logger: typeof options.logger === 'function' ? options.logger : function() {},
        restructuring: getRestructureOption(options),
        forceMediaMerge: Boolean(options.forceMediaMerge),
        usage: options.usage ? usageUtils.buildIndex(options.usage) : false
    };
    var specialComments = getCommentsOption(options);
    var firstAtrulesAllowed = true;
    var input;
    var output = new List();
    var chunk;
    var chunkNum = 1;
    var chunkChildren;

    if (options.clone) {
        ast = clone(ast);
    }

    if (ast.type === 'StyleSheet') {
        input = ast.children;
        ast.children = output;
    } else {
        input = wrapBlock(ast);
    }

    do {
        chunk = readChunk(input, Boolean(specialComments));
        compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
        chunkChildren = chunk.stylesheet.children;

        if (chunk.comment) {
            // add \n before comment if there is another content in output
            if (!output.isEmpty()) {
                output.insert(List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }

            output.insert(List.createItem(chunk.comment));

            // add \n after comment if chunk is not empty
            if (!chunkChildren.isEmpty()) {
                output.insert(List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }
        }

        if (firstAtrulesAllowed && !chunkChildren.isEmpty()) {
            var lastRule = chunkChildren.last();

            if (lastRule.type !== 'Atrule' ||
               (lastRule.name !== 'import' && lastRule.name !== 'charset')) {
                firstAtrulesAllowed = false;
            }
        }

        if (specialComments !== 'exclamation') {
            specialComments = false;
        }

        output.appendList(chunkChildren);
    } while (!input.isEmpty());

    return {
        ast: ast
    };
};


/***/ }),
/* 194 */
/***/ (function(module, exports) {

var hasOwnProperty = Object.prototype.hasOwnProperty;

function buildMap(list, caseInsensitive) {
    var map = Object.create(null);

    if (!Array.isArray(list)) {
        return null;
    }

    for (var i = 0; i < list.length; i++) {
        var name = list[i];

        if (caseInsensitive) {
            name = name.toLowerCase();
        }

        map[name] = true;
    }

    return map;
}

function buildList(data) {
    if (!data) {
        return null;
    }

    var tags = buildMap(data.tags, true);
    var ids = buildMap(data.ids);
    var classes = buildMap(data.classes);

    if (tags === null &&
        ids === null &&
        classes === null) {
        return null;
    }

    return {
        tags: tags,
        ids: ids,
        classes: classes
    };
}

function buildIndex(data) {
    var scopes = false;

    if (data.scopes && Array.isArray(data.scopes)) {
        scopes = Object.create(null);

        for (var i = 0; i < data.scopes.length; i++) {
            var list = data.scopes[i];

            if (!list || !Array.isArray(list)) {
                throw new Error('Wrong usage format');
            }

            for (var j = 0; j < list.length; j++) {
                var name = list[j];

                if (hasOwnProperty.call(scopes, name)) {
                    throw new Error('Class can\'t be used for several scopes: ' + name);
                }

                scopes[name] = i + 1;
            }
        }
    }

    return {
        whitelist: buildList(data),
        blacklist: buildList(data.blacklist),
        scopes: scopes
    };
}

module.exports = {
    buildIndex: buildIndex
};


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var walk = __webpack_require__(1).walk;
var handlers = {
    Atrule: __webpack_require__(196),
    Rule: __webpack_require__(197),
    Declaration: __webpack_require__(198),
    TypeSelector: __webpack_require__(199),
    Comment: __webpack_require__(200),
    Operator: __webpack_require__(201),
    WhiteSpace: __webpack_require__(202)
};

module.exports = function(ast, options) {
    walk(ast, {
        leave: function(node, item, list) {
            if (handlers.hasOwnProperty(node.type)) {
                handlers[node.type].call(this, node, item, list, options);
            }
        }
    });
};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var resolveKeyword = __webpack_require__(1).keyword;

module.exports = function cleanAtrule(node, item, list) {
    if (node.block) {
        // otherwise removed at-rule don't prevent @import for removal
        if (this.stylesheet !== null) {
            this.stylesheet.firstAtrulesAllowed = false;
        }

        if (node.block.children.isEmpty()) {
            list.remove(item);
            return;
        }
    }

    switch (node.name) {
        case 'charset':
            if (!node.prelude || node.prelude.children.isEmpty()) {
                list.remove(item);
                return;
            }

            // if there is any rule before @charset -> remove it
            if (item.prev) {
                list.remove(item);
                return;
            }

            break;

        case 'import':
            if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
                list.remove(item);
                return;
            }

            // if there are some rules that not an @import or @charset before @import
            // remove it
            list.prevUntil(item.prev, function(rule) {
                if (rule.type === 'Atrule') {
                    if (rule.name === 'import' || rule.name === 'charset') {
                        return;
                    }
                }

                this.root.firstAtrulesAllowed = false;
                list.remove(item);
                return true;
            }, this);

            break;

        default:
            var name = resolveKeyword(node.name).basename;
            if (name === 'keyframes' ||
                name === 'media' ||
                name === 'supports') {

                // drop at-rule with no prelude
                if (!node.prelude || node.prelude.children.isEmpty()) {
                    list.remove(item);
                }
            }
    }
};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var hasOwnProperty = Object.prototype.hasOwnProperty;
var walk = __webpack_require__(1).walk;

function cleanUnused(selectorList, usageData) {
    selectorList.children.each(function(selector, item, list) {
        var shouldRemove = false;

        walk(selector, function(node) {
            // ignore nodes in nested selectors
            if (this.selector === null || this.selector === selectorList) {
                switch (node.type) {
                    case 'SelectorList':
                        // TODO: remove toLowerCase when pseudo selectors will be normalized
                        // ignore selectors inside :not()
                        if (this['function'] === null || this['function'].name.toLowerCase() !== 'not') {
                            if (cleanUnused(node, usageData)) {
                                shouldRemove = true;
                            }
                        }
                        break;

                    case 'ClassSelector':
                        if (usageData.whitelist !== null &&
                            usageData.whitelist.classes !== null &&
                            !hasOwnProperty.call(usageData.whitelist.classes, node.name)) {
                            shouldRemove = true;
                        }
                        if (usageData.blacklist !== null &&
                            usageData.blacklist.classes !== null &&
                            hasOwnProperty.call(usageData.blacklist.classes, node.name)) {
                            shouldRemove = true;
                        }
                        break;

                    case 'IdSelector':
                        if (usageData.whitelist !== null &&
                            usageData.whitelist.ids !== null &&
                            !hasOwnProperty.call(usageData.whitelist.ids, node.name)) {
                            shouldRemove = true;
                        }
                        if (usageData.blacklist !== null &&
                            usageData.blacklist.ids !== null &&
                            hasOwnProperty.call(usageData.blacklist.ids, node.name)) {
                            shouldRemove = true;
                        }
                        break;

                    case 'TypeSelector':
                        // TODO: remove toLowerCase when type selectors will be normalized
                        // ignore universal selectors
                        if (node.name.charAt(node.name.length - 1) !== '*') {
                            if (usageData.whitelist !== null &&
                                usageData.whitelist.tags !== null &&
                                !hasOwnProperty.call(usageData.whitelist.tags, node.name.toLowerCase())) {
                                shouldRemove = true;
                            }
                            if (usageData.blacklist !== null &&
                                usageData.blacklist.tags !== null &&
                                hasOwnProperty.call(usageData.blacklist.tags, node.name.toLowerCase())) {
                                shouldRemove = true;
                            }
                        }
                        break;
                }
            }
        });

        if (shouldRemove) {
            list.remove(item);
        }
    });

    return selectorList.children.isEmpty();
}

module.exports = function cleanRuleset(node, item, list, options) {
    var usageData = options.usage;

    if (usageData && (usageData.whitelist !== null || usageData.blacklist !== null)) {
        cleanUnused(node.prelude, usageData);
    }

    if (node.prelude.children.isEmpty() ||
        node.block.children.isEmpty()) {
        list.remove(item);
    }
};


/***/ }),
/* 198 */
/***/ (function(module, exports) {

module.exports = function cleanDeclartion(node, item, list) {
    if (node.value.children && node.value.children.isEmpty()) {
        list.remove(item);
    }
};


/***/ }),
/* 199 */
/***/ (function(module, exports) {

// remove useless universal selector
module.exports = function cleanType(node, item, list) {
    var name = item.data.name;

    // check it's a non-namespaced universal selector
    if (name !== '*') {
        return;
    }

    // remove when universal selector before other selectors
    var nextType = item.next && item.next.data.type;
    if (nextType === 'IdSelector' ||
        nextType === 'ClassSelector' ||
        nextType === 'AttributeSelector' ||
        nextType === 'PseudoClassSelector' ||
        nextType === 'PseudoElementSelector') {
        list.remove(item);
    }
};


/***/ }),
/* 200 */
/***/ (function(module, exports) {

module.exports = function cleanComment(data, item, list) {
    list.remove(item);
};


/***/ }),
/* 201 */
/***/ (function(module, exports) {

// remove white spaces around operators when safe
module.exports = function cleanWhitespace(node, item, list) {
    if (node.value === '+' || node.value === '-') {
        return;
    }

    if (item.prev !== null && item.prev.data.type === 'WhiteSpace') {
        list.remove(item.prev);
    }

    if (item.next !== null && item.next.data.type === 'WhiteSpace') {
        list.remove(item.next);
    }
};


/***/ }),
/* 202 */
/***/ (function(module, exports) {

module.exports = function cleanWhitespace(node, item, list) {
    // remove when first or last item in sequence
    if (item.next === null || item.prev === null) {
        list.remove(item);
        return;
    }

    // remove when previous node is whitespace
    if (item.prev.data.type === 'WhiteSpace') {
        list.remove(item);
        return;
    }

    if ((this.stylesheet !== null && this.stylesheet.children === list) ||
        (this.block !== null && this.block.children === list)) {
        list.remove(item);
        return;
    }
};


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var walk = __webpack_require__(1).walk;
var handlers = {
    Atrule: __webpack_require__(204),
    AttributeSelector: __webpack_require__(206),
    Value: __webpack_require__(207),
    Dimension: __webpack_require__(211),
    Percentage: __webpack_require__(212),
    Number: __webpack_require__(11),
    String: __webpack_require__(213),
    Url: __webpack_require__(214),
    HexColor: __webpack_require__(30).compressHex,
    Identifier: __webpack_require__(30).compressIdent,
    Function: __webpack_require__(30).compressFunction
};

module.exports = function(ast) {
    walk(ast, {
        leave: function(node, item, list) {
            if (handlers.hasOwnProperty(node.type)) {
                handlers[node.type].call(this, node, item, list);
            }
        }
    });
};


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var resolveKeyword = __webpack_require__(1).keyword;
var compressKeyframes = __webpack_require__(205);

module.exports = function(node) {
    // compress @keyframe selectors
    if (resolveKeyword(node.name).basename === 'keyframes') {
        compressKeyframes(node);
    }
};


/***/ }),
/* 205 */
/***/ (function(module, exports) {

module.exports = function(node) {
    node.block.children.each(function(rule) {
        rule.prelude.children.each(function(simpleselector) {
            simpleselector.children.each(function(data, item) {
                if (data.type === 'Percentage' && data.value === '100') {
                    item.data = {
                        type: 'TypeSelector',
                        loc: data.loc,
                        name: 'to'
                    };
                } else if (data.type === 'TypeSelector' && data.name === 'from') {
                    item.data = {
                        type: 'Percentage',
                        loc: data.loc,
                        value: '0'
                    };
                }
            });
        });
    });
};


/***/ }),
/* 206 */
/***/ (function(module, exports) {

// Can unquote attribute detection
// Adopted implementation of Mathias Bynens
// https://github.com/mathiasbynens/mothereff.in/blob/master/unquoted-attributes/eff.js
var escapesRx = /\\([0-9A-Fa-f]{1,6})(\r\n|[ \t\n\f\r])?|\\./g;
var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

function canUnquote(value) {
    if (value === '' || value === '-') {
        return;
    }

    // Escapes are valid, so replace them with a valid non-empty string
    value = value.replace(escapesRx, 'a');

    return !blockUnquoteRx.test(value);
}

module.exports = function(node) {
    var attrValue = node.value;

    if (!attrValue || attrValue.type !== 'String') {
        return;
    }

    var unquotedValue = attrValue.value.replace(/^(.)(.*)\1$/, '$2');
    if (canUnquote(unquotedValue)) {
        node.value = {
            type: 'Identifier',
            loc: attrValue.loc,
            name: unquotedValue
        };
    }
};


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var resolveName = __webpack_require__(1).property;
var handlers = {
    'font': __webpack_require__(208),
    'font-weight': __webpack_require__(209),
    'background': __webpack_require__(210),
    'border': __webpack_require__(58),
    'outline': __webpack_require__(58)
};

module.exports = function compressValue(node) {
    if (!this.declaration) {
        return;
    }

    var property = resolveName(this.declaration.property);

    if (handlers.hasOwnProperty(property.basename)) {
        handlers[property.basename](node);
    }
};


/***/ }),
/* 208 */
/***/ (function(module, exports) {

module.exports = function compressFont(node) {
    var list = node.children;

    list.eachRight(function(node, item) {
        if (node.type === 'Identifier') {
            if (node.name === 'bold') {
                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: '700'
                };
            } else if (node.name === 'normal') {
                var prev = item.prev;

                if (prev && prev.data.type === 'Operator' && prev.data.value === '/') {
                    this.remove(prev);
                }

                this.remove(item);
            } else if (node.name === 'medium') {
                var next = item.next;

                if (!next || next.data.type !== 'Operator') {
                    this.remove(item);
                }
            }
        }
    });

    // remove redundant spaces
    list.each(function(node, item) {
        if (node.type === 'WhiteSpace') {
            if (!item.prev || !item.next || item.next.data.type === 'WhiteSpace') {
                this.remove(item);
            }
        }
    });

    if (list.isEmpty()) {
        list.insert(list.createItem({
            type: 'Identifier',
            name: 'normal'
        }));
    }
};


/***/ }),
/* 209 */
/***/ (function(module, exports) {

module.exports = function compressFontWeight(node) {
    var value = node.children.head.data;

    if (value.type === 'Identifier') {
        switch (value.name) {
            case 'normal':
                node.children.head.data = {
                    type: 'Number',
                    loc: value.loc,
                    value: '400'
                };
                break;
            case 'bold':
                node.children.head.data = {
                    type: 'Number',
                    loc: value.loc,
                    value: '700'
                };
                break;
        }
    }
};


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(1).List;

module.exports = function compressBackground(node) {
    function lastType() {
        if (buffer.length) {
            return buffer[buffer.length - 1].type;
        }
    }

    function flush() {
        if (lastType() === 'WhiteSpace') {
            buffer.pop();
        }

        if (!buffer.length) {
            buffer.unshift(
                {
                    type: 'Number',
                    loc: null,
                    value: '0'
                },
                {
                    type: 'WhiteSpace',
                    value: ' '
                },
                {
                    type: 'Number',
                    loc: null,
                    value: '0'
                }
            );
        }

        newValue.push.apply(newValue, buffer);

        buffer = [];
    }

    var newValue = [];
    var buffer = [];

    node.children.each(function(node) {
        if (node.type === 'Operator' && node.value === ',') {
            flush();
            newValue.push(node);
            return;
        }

        // remove defaults
        if (node.type === 'Identifier') {
            if (node.name === 'transparent' ||
                node.name === 'none' ||
                node.name === 'repeat' ||
                node.name === 'scroll') {
                return;
            }
        }

        // don't add redundant spaces
        if (node.type === 'WhiteSpace' && (!buffer.length || lastType() === 'WhiteSpace')) {
            return;
        }

        buffer.push(node);
    });

    flush();
    node.children = new List().fromArray(newValue);
};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var packNumber = __webpack_require__(11).pack;
var LENGTH_UNIT = {
    // absolute length units
    'px': true,
    'mm': true,
    'cm': true,
    'in': true,
    'pt': true,
    'pc': true,

    // relative length units
    'em': true,
    'ex': true,
    'ch': true,
    'rem': true,

    // viewport-percentage lengths
    'vh': true,
    'vw': true,
    'vmin': true,
    'vmax': true,
    'vm': true
};

module.exports = function compressDimension(node, item) {
    var value = packNumber(node.value, item);

    node.value = value;

    if (value === '0' && this.declaration !== null && this.atrulePrelude === null) {
        var unit = node.unit.toLowerCase();

        // only length values can be compressed
        if (!LENGTH_UNIT.hasOwnProperty(unit)) {
            return;
        }

        // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
        // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
        if (this.declaration.property === '-ms-flex' ||
            this.declaration.property === 'flex') {
            return;
        }

        // issue #222: don't remove units inside calc
        if (this['function'] && this['function'].name === 'calc') {
            return;
        }

        item.data = {
            type: 'Number',
            loc: node.loc,
            value: value
        };
    }
};


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var packNumber = __webpack_require__(11).pack;
var PERCENTAGE_LENGTH_PROPERTY = {
    'margin': true,
    'margin-top': true,
    'margin-left': true,
    'margin-bottom': true,
    'margin-right': true,

    'padding': true,
    'padding-top': true,
    'padding-left': true,
    'padding-bottom': true,
    'padding-right': true,

    'top': true,
    'left': true,
    'bottom': true,
    'right': true,

    'background-position': true,
    'background-position-x': true,
    'background-position-y': true,
    'background-size': true,

    'border': true,
    'border-width': true,
    'border-top-width': true,
    'border-left-width': true,
    'border-bottom-width': true,
    'border-right-width': true,
    'border-image-width': true,

    'border-radius': true,
    'border-bottom-left-radius': true,
    'border-bottom-right-radius': true,
    'border-top-left-radius': true,
    'border-top-right-radius': true
};

module.exports = function compressPercentage(node, item) {
    var value = packNumber(node.value, item);
    var property = this.declaration !== null ? this.declaration.property : null;

    node.value = value;

    if (property !== null && PERCENTAGE_LENGTH_PROPERTY.hasOwnProperty(property)) {
        if (value === '0') {
            item.data = {
                type: 'Number',
                loc: node.loc,
                value: value
            };
        }
    }
};


/***/ }),
/* 213 */
/***/ (function(module, exports) {

module.exports = function(node) {
    var value = node.value;

    // remove escaped newlines, i.e.
    // .a { content: "foo\
    // bar"}
    // ->
    // .a { content: "foobar" }
    value = value.replace(/\\(\r\n|\r|\n|\f)/g, '');

    node.value = value;
};


/***/ }),
/* 214 */
/***/ (function(module, exports) {

var UNICODE = '\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?';
var ESCAPE = '(' + UNICODE + '|\\\\[^\\n\\r\\f0-9a-fA-F])';
var NONPRINTABLE = '\u0000\u0008\u000b\u000e-\u001f\u007f';
var SAFE_URL = new RegExp('^(' + ESCAPE + '|[^\"\'\\(\\)\\\\\\s' + NONPRINTABLE + '])*$', 'i');

module.exports = function(node) {
    var value = node.value;

    if (value.type !== 'String') {
        return;
    }

    var quote = value.value[0];
    var url = value.value.substr(1, value.value.length - 2);

    // convert `\\` to `/`
    url = url.replace(/\\\\/g, '/');

    // remove quotes when safe
    // https://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram
    if (SAFE_URL.test(url)) {
        node.value = {
            type: 'Raw',
            loc: node.value.loc,
            value: url
        };
    } else {
        // use double quotes if string has no double quotes
        // otherwise use original quotes
        // TODO: make better quote type selection
        node.value.value = url.indexOf('"') === -1 ? '"' + url + '"' : quote + url + quote;
    }
};


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var prepare = __webpack_require__(216);
var mergeAtrule = __webpack_require__(220);
var initialMergeRuleset = __webpack_require__(221);
var disjoinRuleset = __webpack_require__(222);
var restructShorthand = __webpack_require__(223);
var restructBlock = __webpack_require__(224);
var mergeRuleset = __webpack_require__(225);
var restructRuleset = __webpack_require__(226);

module.exports = function(ast, options) {
    // prepare ast for restructing
    var indexer = prepare(ast, options);
    options.logger('prepare', ast);

    mergeAtrule(ast, options);
    options.logger('mergeAtrule', ast);

    initialMergeRuleset(ast);
    options.logger('initialMergeRuleset', ast);

    disjoinRuleset(ast);
    options.logger('disjoinRuleset', ast);

    restructShorthand(ast, indexer);
    options.logger('restructShorthand', ast);

    restructBlock(ast);
    options.logger('restructBlock', ast);

    mergeRuleset(ast);
    options.logger('mergeRuleset', ast);

    restructRuleset(ast);
    options.logger('restructRuleset', ast);
};


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var resolveKeyword = __webpack_require__(1).keyword;
var walk = __webpack_require__(1).walk;
var generate = __webpack_require__(1).generate;
var createDeclarationIndexer = __webpack_require__(217);
var processSelector = __webpack_require__(218);

module.exports = function prepare(ast, options) {
    var markDeclaration = createDeclarationIndexer();

    walk(ast, {
        visit: 'Rule',
        enter: function processRule(node) {
            node.block.children.each(markDeclaration);
            processSelector(node, options.usage);
        }
    });

    walk(ast, {
        visit: 'Atrule',
        enter: function(node) {
            if (node.prelude) {
                node.prelude.id = null; // pre-init property to avoid multiple hidden class for generate
                node.prelude.id = generate(node.prelude);
            }

            // compare keyframe selectors by its values
            // NOTE: still no clarification about problems with keyframes selector grouping (issue #197)
            if (resolveKeyword(node.name).basename === 'keyframes') {
                node.block.avoidRulesMerge = true;  /* probably we don't need to prevent those merges for @keyframes
                                                       TODO: need to be checked */
                node.block.children.each(function(rule) {
                    rule.prelude.children.each(function(simpleselector) {
                        simpleselector.compareMarker = simpleselector.id;
                    });
                });
            }
        }
    });

    return {
        declaration: markDeclaration
    };
};


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var generate = __webpack_require__(1).generate;

function Index() {
    this.seed = 0;
    this.map = Object.create(null);
}

Index.prototype.resolve = function(str) {
    var index = this.map[str];

    if (!index) {
        index = ++this.seed;
        this.map[str] = index;
    }

    return index;
};

module.exports = function createDeclarationIndexer() {
    var ids = new Index();

    return function markDeclaration(node) {
        var id = generate(node);

        node.id = ids.resolve(id);
        node.length = id.length;
        node.fingerprint = null;

        return node;
    };
};


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

var generate = __webpack_require__(1).generate;
var specificity = __webpack_require__(219);

var nonFreezePseudoElements = {
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};
var nonFreezePseudoClasses = {
    'link': true,
    'visited': true,
    'hover': true,
    'active': true,
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};

module.exports = function freeze(node, usageData) {
    var pseudos = Object.create(null);
    var hasPseudo = false;

    node.prelude.children.each(function(simpleSelector) {
        var tagName = '*';
        var scope = 0;

        simpleSelector.children.each(function(node) {
            switch (node.type) {
                case 'ClassSelector':
                    if (usageData && usageData.scopes) {
                        var classScope = usageData.scopes[node.name] || 0;

                        if (scope !== 0 && classScope !== scope) {
                            throw new Error('Selector can\'t has classes from different scopes: ' + generate(simpleSelector));
                        }

                        scope = classScope;
                    }
                    break;

                case 'PseudoClassSelector':
                    var name = node.name.toLowerCase();

                    if (!nonFreezePseudoClasses.hasOwnProperty(name)) {
                        pseudos[name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'PseudoElementSelector':
                    var name = node.name.toLowerCase();

                    if (!nonFreezePseudoElements.hasOwnProperty(name)) {
                        pseudos[name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'TypeSelector':
                    tagName = node.name.toLowerCase();
                    break;

                case 'AttributeSelector':
                    if (node.flags) {
                        pseudos['[' + node.flags.toLowerCase() + ']'] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'WhiteSpace':
                case 'Combinator':
                    tagName = '*';
                    break;
            }
        });

        simpleSelector.compareMarker = specificity(simpleSelector).toString();
        simpleSelector.id = null; // pre-init property to avoid multiple hidden class
        simpleSelector.id = generate(simpleSelector);

        if (scope) {
            simpleSelector.compareMarker += ':' + scope;
        }

        if (tagName !== '*') {
            simpleSelector.compareMarker += ',' + tagName;
        }
    });

    // add property to all rule nodes to avoid multiple hidden class
    node.pseudoSignature = hasPseudo && Object.keys(pseudos).sort().join(',');
};


/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = function specificity(simpleSelector) {
    var A = 0;
    var B = 0;
    var C = 0;

    simpleSelector.children.each(function walk(node) {
        switch (node.type) {
            case 'SelectorList':
            case 'Selector':
                node.children.each(walk);
                break;

            case 'IdSelector':
                A++;
                break;

            case 'ClassSelector':
            case 'AttributeSelector':
                B++;
                break;

            case 'PseudoClassSelector':
                switch (node.name.toLowerCase()) {
                    case 'not':
                        node.children.each(walk);
                        break;

                    case 'before':
                    case 'after':
                    case 'first-line':
                    case 'first-letter':
                        C++;
                        break;

                    // TODO: support for :nth-*(.. of <SelectorList>), :matches(), :has()

                    default:
                        B++;
                }
                break;

            case 'PseudoElementSelector':
                C++;
                break;

            case 'TypeSelector':
                // ignore universal selector
                if (node.name.charAt(node.name.length - 1) !== '*') {
                    C++;
                }
                break;

        }
    });

    return [A, B, C];
};


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(1).List;
var resolveKeyword = __webpack_require__(1).keyword;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var walk = __webpack_require__(1).walk;

function addRuleToMap(map, item, list, single) {
    var node = item.data;
    var name = resolveKeyword(node.name).basename;
    var id = node.name.toLowerCase() + '/' + (node.prelude ? node.prelude.id : null);

    if (!hasOwnProperty.call(map, name)) {
        map[name] = Object.create(null);
    }

    if (single) {
        delete map[name][id];
    }

    if (!hasOwnProperty.call(map[name], id)) {
        map[name][id] = new List();
    }

    map[name][id].append(list.remove(item));
}

function relocateAtrules(ast, options) {
    var collected = Object.create(null);
    var topInjectPoint = null;

    ast.children.each(function(node, item, list) {
        if (node.type === 'Atrule') {
            var name = resolveKeyword(node.name).basename;

            switch (name) {
                case 'keyframes':
                    addRuleToMap(collected, item, list, true);
                    return;

                case 'media':
                    if (options.forceMediaMerge) {
                        addRuleToMap(collected, item, list, false);
                        return;
                    }
                    break;
            }

            if (topInjectPoint === null &&
                name !== 'charset' &&
                name !== 'import') {
                topInjectPoint = item;
            }
        } else {
            if (topInjectPoint === null) {
                topInjectPoint = item;
            }
        }
    });

    for (var atrule in collected) {
        for (var id in collected[atrule]) {
            ast.children.insertList(
                collected[atrule][id],
                atrule === 'media' ? null : topInjectPoint
            );
        }
    }
};

function isMediaRule(node) {
    return node.type === 'Atrule' && node.name === 'media';
}

function processAtrule(node, item, list) {
    if (!isMediaRule(node)) {
        return;
    }

    var prev = item.prev && item.prev.data;

    if (!prev || !isMediaRule(prev)) {
        return;
    }

    // merge @media with same query
    if (node.prelude &&
        prev.prelude &&
        node.prelude.id === prev.prelude.id) {
        prev.block.children.appendList(node.block.children);
        list.remove(item);

        // TODO: use it when we can refer to several points in source
        // prev.loc = {
        //     primary: prev.loc,
        //     merged: node.loc
        // };
    }
}

module.exports = function rejoinAtrule(ast, options) {
    relocateAtrules(ast, options);

    walk(ast, {
        visit: 'Atrule',
        reverse: true,
        enter: processAtrule
    });
};


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var walk = __webpack_require__(1).walk;
var utils = __webpack_require__(31);

function processRule(node, item, list) {
    var selectors = node.prelude.children;
    var declarations = node.block.children;

    list.prevUntil(item.prev, function(prev) {
        // skip non-ruleset node if safe
        if (prev.type !== 'Rule') {
            return utils.unsafeToSkipNode.call(selectors, prev);
        }

        var prevSelectors = prev.prelude.children;
        var prevDeclarations = prev.block.children;

        // try to join rulesets with equal pseudo signature
        if (node.pseudoSignature === prev.pseudoSignature) {
            // try to join by selectors
            if (utils.isEqualSelectors(prevSelectors, selectors)) {
                prevDeclarations.appendList(declarations);
                list.remove(item);
                return true;
            }

            // try to join by declarations
            if (utils.isEqualDeclarations(declarations, prevDeclarations)) {
                utils.addSelectors(prevSelectors, selectors);
                list.remove(item);
                return true;
            }
        }

        // go to prev ruleset if has no selector similarities
        return utils.hasSimilarSelectors(selectors, prevSelectors);
    });
}

// NOTE: direction should be left to right, since rulesets merge to left
// ruleset. When direction right to left unmerged rulesets may prevent lookup
// TODO: remove initial merge
module.exports = function initialMergeRule(ast) {
    walk(ast, {
        visit: 'Rule',
        enter: processRule
    });
};


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(1).List;
var walk = __webpack_require__(1).walk;

function processRule(node, item, list) {
    var selectors = node.prelude.children;

    // generate new rule sets:
    // .a, .b { color: red; }
    // ->
    // .a { color: red; }
    // .b { color: red; }

    // while there are more than 1 simple selector split for rulesets
    while (selectors.head !== selectors.tail) {
        var newSelectors = new List();
        newSelectors.insert(selectors.remove(selectors.head));

        list.insert(list.createItem({
            type: 'Rule',
            loc: node.loc,
            prelude: {
                type: 'SelectorList',
                loc: node.prelude.loc,
                children: newSelectors
            },
            block: {
                type: 'Block',
                loc: node.block.loc,
                children: node.block.children.copy()
            },
            pseudoSignature: node.pseudoSignature
        }), item);
    }
}

module.exports = function disjoinRule(ast) {
    walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter: processRule
    });
};


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(1).List;
var generate = __webpack_require__(1).generate;
var walk = __webpack_require__(1).walk;

var REPLACE = 1;
var REMOVE = 2;
var TOP = 0;
var RIGHT = 1;
var BOTTOM = 2;
var LEFT = 3;
var SIDES = ['top', 'right', 'bottom', 'left'];
var SIDE = {
    'margin-top': 'top',
    'margin-right': 'right',
    'margin-bottom': 'bottom',
    'margin-left': 'left',

    'padding-top': 'top',
    'padding-right': 'right',
    'padding-bottom': 'bottom',
    'padding-left': 'left',

    'border-top-color': 'top',
    'border-right-color': 'right',
    'border-bottom-color': 'bottom',
    'border-left-color': 'left',
    'border-top-width': 'top',
    'border-right-width': 'right',
    'border-bottom-width': 'bottom',
    'border-left-width': 'left',
    'border-top-style': 'top',
    'border-right-style': 'right',
    'border-bottom-style': 'bottom',
    'border-left-style': 'left'
};
var MAIN_PROPERTY = {
    'margin': 'margin',
    'margin-top': 'margin',
    'margin-right': 'margin',
    'margin-bottom': 'margin',
    'margin-left': 'margin',

    'padding': 'padding',
    'padding-top': 'padding',
    'padding-right': 'padding',
    'padding-bottom': 'padding',
    'padding-left': 'padding',

    'border-color': 'border-color',
    'border-top-color': 'border-color',
    'border-right-color': 'border-color',
    'border-bottom-color': 'border-color',
    'border-left-color': 'border-color',
    'border-width': 'border-width',
    'border-top-width': 'border-width',
    'border-right-width': 'border-width',
    'border-bottom-width': 'border-width',
    'border-left-width': 'border-width',
    'border-style': 'border-style',
    'border-top-style': 'border-style',
    'border-right-style': 'border-style',
    'border-bottom-style': 'border-style',
    'border-left-style': 'border-style'
};

function TRBL(name) {
    this.name = name;
    this.loc = null;
    this.iehack = undefined;
    this.sides = {
        'top': null,
        'right': null,
        'bottom': null,
        'left': null
    };
}

TRBL.prototype.getValueSequence = function(declaration, count) {
    var values = [];
    var iehack = '';
    var hasBadValues = declaration.value.children.some(function(child) {
        var special = false;

        switch (child.type) {
            case 'Identifier':
                switch (child.name) {
                    case '\\0':
                    case '\\9':
                        iehack = child.name;
                        return;

                    case 'inherit':
                    case 'initial':
                    case 'unset':
                    case 'revert':
                        special = child.name;
                        break;
                }
                break;

            case 'Dimension':
                switch (child.unit) {
                    // is not supported until IE11
                    case 'rem':

                    // v* units is too buggy across browsers and better
                    // don't merge values with those units
                    case 'vw':
                    case 'vh':
                    case 'vmin':
                    case 'vmax':
                    case 'vm': // IE9 supporting "vm" instead of "vmin".
                        special = child.unit;
                        break;
                }
                break;

            case 'HexColor': // color
            case 'Number':
            case 'Percentage':
                break;

            case 'Function':
                special = child.name;
                break;

            case 'WhiteSpace':
                return false; // ignore space

            default:
                return true;  // bad value
        }

        values.push({
            node: child,
            special: special,
            important: declaration.important
        });
    });

    if (hasBadValues || values.length > count) {
        return false;
    }

    if (typeof this.iehack === 'string' && this.iehack !== iehack) {
        return false;
    }

    this.iehack = iehack; // move outside

    return values;
};

TRBL.prototype.canOverride = function(side, value) {
    var currentValue = this.sides[side];

    return !currentValue || (value.important && !currentValue.important);
};

TRBL.prototype.add = function(name, declaration) {
    function attemptToAdd() {
        var sides = this.sides;
        var side = SIDE[name];

        if (side) {
            if (side in sides === false) {
                return false;
            }

            var values = this.getValueSequence(declaration, 1);

            if (!values || !values.length) {
                return false;
            }

            // can mix only if specials are equal
            for (var key in sides) {
                if (sides[key] !== null && sides[key].special !== values[0].special) {
                    return false;
                }
            }

            if (!this.canOverride(side, values[0])) {
                return true;
            }

            sides[side] = values[0];
            return true;
        } else if (name === this.name) {
            var values = this.getValueSequence(declaration, 4);

            if (!values || !values.length) {
                return false;
            }

            switch (values.length) {
                case 1:
                    values[RIGHT] = values[TOP];
                    values[BOTTOM] = values[TOP];
                    values[LEFT] = values[TOP];
                    break;

                case 2:
                    values[BOTTOM] = values[TOP];
                    values[LEFT] = values[RIGHT];
                    break;

                case 3:
                    values[LEFT] = values[RIGHT];
                    break;
            }

            // can mix only if specials are equal
            for (var i = 0; i < 4; i++) {
                for (var key in sides) {
                    if (sides[key] !== null && sides[key].special !== values[i].special) {
                        return false;
                    }
                }
            }

            for (var i = 0; i < 4; i++) {
                if (this.canOverride(SIDES[i], values[i])) {
                    sides[SIDES[i]] = values[i];
                }
            }

            return true;
        }
    }

    if (!attemptToAdd.call(this)) {
        return false;
    }

    // TODO: use it when we can refer to several points in source
    // if (this.loc) {
    //     this.loc = {
    //         primary: this.loc,
    //         merged: declaration.loc
    //     };
    // } else {
    //     this.loc = declaration.loc;
    // }
    if (!this.loc) {
        this.loc = declaration.loc;
    }

    return true;
};

TRBL.prototype.isOkToMinimize = function() {
    var top = this.sides.top;
    var right = this.sides.right;
    var bottom = this.sides.bottom;
    var left = this.sides.left;

    if (top && right && bottom && left) {
        var important =
            top.important +
            right.important +
            bottom.important +
            left.important;

        return important === 0 || important === 4;
    }

    return false;
};

TRBL.prototype.getValue = function() {
    var result = new List();
    var sides = this.sides;
    var values = [
        sides.top,
        sides.right,
        sides.bottom,
        sides.left
    ];
    var stringValues = [
        generate(sides.top.node),
        generate(sides.right.node),
        generate(sides.bottom.node),
        generate(sides.left.node)
    ];

    if (stringValues[LEFT] === stringValues[RIGHT]) {
        values.pop();
        if (stringValues[BOTTOM] === stringValues[TOP]) {
            values.pop();
            if (stringValues[RIGHT] === stringValues[TOP]) {
                values.pop();
            }
        }
    }

    for (var i = 0; i < values.length; i++) {
        if (i) {
            result.appendData({ type: 'WhiteSpace', value: ' ' });
        }

        result.appendData(values[i].node);
    }

    if (this.iehack) {
        result.appendData({ type: 'WhiteSpace', value: ' ' });
        result.appendData({
            type: 'Identifier',
            loc: null,
            name: this.iehack
        });
    }

    return {
        type: 'Value',
        loc: null,
        children: result
    };
};

TRBL.prototype.getDeclaration = function() {
    return {
        type: 'Declaration',
        loc: this.loc,
        important: this.sides.top.important,
        property: this.name,
        value: this.getValue()
    };
};

function processRule(rule, shorts, shortDeclarations, lastShortSelector) {
    var declarations = rule.block.children;
    var selector = rule.prelude.children.first().id;

    rule.block.children.eachRight(function(declaration, item) {
        var property = declaration.property;

        if (!MAIN_PROPERTY.hasOwnProperty(property)) {
            return;
        }

        var key = MAIN_PROPERTY[property];
        var shorthand;
        var operation;

        if (!lastShortSelector || selector === lastShortSelector) {
            if (key in shorts) {
                operation = REMOVE;
                shorthand = shorts[key];
            }
        }

        if (!shorthand || !shorthand.add(property, declaration)) {
            operation = REPLACE;
            shorthand = new TRBL(key);

            // if can't parse value ignore it and break shorthand children
            if (!shorthand.add(property, declaration)) {
                lastShortSelector = null;
                return;
            }
        }

        shorts[key] = shorthand;
        shortDeclarations.push({
            operation: operation,
            block: declarations,
            item: item,
            shorthand: shorthand
        });

        lastShortSelector = selector;
    });

    return lastShortSelector;
}

function processShorthands(shortDeclarations, markDeclaration) {
    shortDeclarations.forEach(function(item) {
        var shorthand = item.shorthand;

        if (!shorthand.isOkToMinimize()) {
            return;
        }

        if (item.operation === REPLACE) {
            item.item.data = markDeclaration(shorthand.getDeclaration());
        } else {
            item.block.remove(item.item);
        }
    });
}

module.exports = function restructBlock(ast, indexer) {
    var stylesheetMap = {};
    var shortDeclarations = [];

    walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter: function(node) {
            var stylesheet = this.block || this.stylesheet;
            var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
            var ruleMap;
            var shorts;

            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
                ruleMap = {
                    lastShortSelector: null
                };
                stylesheetMap[stylesheet.id] = ruleMap;
            } else {
                ruleMap = stylesheetMap[stylesheet.id];
            }

            if (ruleMap.hasOwnProperty(ruleId)) {
                shorts = ruleMap[ruleId];
            } else {
                shorts = {};
                ruleMap[ruleId] = shorts;
            }

            ruleMap.lastShortSelector = processRule.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
        }
    });

    processShorthands(shortDeclarations, indexer.declaration);
};


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var resolveProperty = __webpack_require__(1).property;
var resolveKeyword = __webpack_require__(1).keyword;
var walk = __webpack_require__(1).walk;
var generate = __webpack_require__(1).generate;
var fingerprintId = 1;
var dontRestructure = {
    'src': 1 // https://github.com/afelix/csso/issues/50
};

var DONT_MIX_VALUE = {
    // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
    'display': /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
    // https://developer.mozilla.org/en/docs/Web/CSS/text-align
    'text-align': /^(start|end|match-parent|justify-all)$/i
};

var CURSOR_SAFE_VALUE = [
    'auto', 'crosshair', 'default', 'move', 'text', 'wait', 'help',
    'n-resize', 'e-resize', 's-resize', 'w-resize',
    'ne-resize', 'nw-resize', 'se-resize', 'sw-resize',
    'pointer', 'progress', 'not-allowed', 'no-drop', 'vertical-text', 'all-scroll',
    'col-resize', 'row-resize'
];

var POSITION_SAFE_VALUE = [
    'static', 'relative', 'absolute', 'fixed'
];

var NEEDLESS_TABLE = {
    'border-width': ['border'],
    'border-style': ['border'],
    'border-color': ['border'],
    'border-top': ['border'],
    'border-right': ['border'],
    'border-bottom': ['border'],
    'border-left': ['border'],
    'border-top-width': ['border-top', 'border-width', 'border'],
    'border-right-width': ['border-right', 'border-width', 'border'],
    'border-bottom-width': ['border-bottom', 'border-width', 'border'],
    'border-left-width': ['border-left', 'border-width', 'border'],
    'border-top-style': ['border-top', 'border-style', 'border'],
    'border-right-style': ['border-right', 'border-style', 'border'],
    'border-bottom-style': ['border-bottom', 'border-style', 'border'],
    'border-left-style': ['border-left', 'border-style', 'border'],
    'border-top-color': ['border-top', 'border-color', 'border'],
    'border-right-color': ['border-right', 'border-color', 'border'],
    'border-bottom-color': ['border-bottom', 'border-color', 'border'],
    'border-left-color': ['border-left', 'border-color', 'border'],
    'margin-top': ['margin'],
    'margin-right': ['margin'],
    'margin-bottom': ['margin'],
    'margin-left': ['margin'],
    'padding-top': ['padding'],
    'padding-right': ['padding'],
    'padding-bottom': ['padding'],
    'padding-left': ['padding'],
    'font-style': ['font'],
    'font-variant': ['font'],
    'font-weight': ['font'],
    'font-size': ['font'],
    'font-family': ['font'],
    'list-style-type': ['list-style'],
    'list-style-position': ['list-style'],
    'list-style-image': ['list-style']
};

function getPropertyFingerprint(propertyName, declaration, fingerprints) {
    var realName = resolveProperty(propertyName).basename;

    if (realName === 'background') {
        return propertyName + ':' + generate(declaration.value);
    }

    var declarationId = declaration.id;
    var fingerprint = fingerprints[declarationId];

    if (!fingerprint) {
        switch (declaration.value.type) {
            case 'Value':
                var vendorId = '';
                var iehack = '';
                var special = {};
                var raw = false;

                declaration.value.children.each(function walk(node) {
                    switch (node.type) {
                        case 'Value':
                        case 'Brackets':
                        case 'Parentheses':
                            node.children.each(walk);
                            break;

                        case 'Raw':
                            raw = true;
                            break;

                        case 'Identifier':
                            var name = node.name;

                            if (!vendorId) {
                                vendorId = resolveKeyword(name).vendor;
                            }

                            if (/\\[09]/.test(name)) {
                                iehack = RegExp.lastMatch;
                            }

                            if (realName === 'cursor') {
                                if (CURSOR_SAFE_VALUE.indexOf(name) === -1) {
                                    special[name] = true;
                                }
                            } else if (realName === 'position') {
                                if (POSITION_SAFE_VALUE.indexOf(name) === -1) {
                                    special[name] = true;
                                }
                            } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                                if (DONT_MIX_VALUE[realName].test(name)) {
                                    special[name] = true;
                                }
                            }

                            break;

                        case 'Function':
                            var name = node.name;

                            if (!vendorId) {
                                vendorId = resolveKeyword(name).vendor;
                            }

                            if (name === 'rect') {
                                // there are 2 forms of rect:
                                //   rect(<top>, <right>, <bottom>, <left>) - standart
                                //   rect(<top> <right> <bottom> <left>) – backwards compatible syntax
                                // only the same form values can be merged
                                var hasComma = node.children.some(function(node) {
                                    return node.type === 'Operator' && node.value === ',';
                                });
                                if (!hasComma) {
                                    name = 'rect-backward';
                                }
                            }

                            special[name + '()'] = true;

                            // check nested tokens too
                            node.children.each(walk);

                            break;

                        case 'Dimension':
                            var unit = node.unit;

                            switch (unit) {
                                // is not supported until IE11
                                case 'rem':

                                // v* units is too buggy across browsers and better
                                // don't merge values with those units
                                case 'vw':
                                case 'vh':
                                case 'vmin':
                                case 'vmax':
                                case 'vm': // IE9 supporting "vm" instead of "vmin".
                                    special[unit] = true;
                                    break;
                            }
                            break;
                    }
                });

                fingerprint = raw
                    ? '!' + fingerprintId++
                    : '!' + Object.keys(special).sort() + '|' + iehack + vendorId;
                break;

            case 'Raw':
                fingerprint = '!' + declaration.value.value;
                break;

            default:
                fingerprint = generate(declaration.value);
        }

        fingerprints[declarationId] = fingerprint;
    }

    return propertyName + fingerprint;
}

function needless(props, declaration, fingerprints) {
    var property = resolveProperty(declaration.property);

    if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
        var table = NEEDLESS_TABLE[property.basename];

        for (var i = 0; i < table.length; i++) {
            var ppre = getPropertyFingerprint(property.prefix + table[i], declaration, fingerprints);
            var prev = props.hasOwnProperty(ppre) ? props[ppre] : null;

            if (prev && (!declaration.important || prev.item.data.important)) {
                return prev;
            }
        }
    }
}

function processRule(rule, item, list, props, fingerprints) {
    var declarations = rule.block.children;

    declarations.eachRight(function(declaration, declarationItem) {
        var property = declaration.property;
        var fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
        var prev = props[fingerprint];

        if (prev && !dontRestructure.hasOwnProperty(property)) {
            if (declaration.important && !prev.item.data.important) {
                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };

                prev.block.remove(prev.item);

                // TODO: use it when we can refer to several points in source
                // declaration.loc = {
                //     primary: declaration.loc,
                //     merged: prev.item.data.loc
                // };
            } else {
                declarations.remove(declarationItem);

                // TODO: use it when we can refer to several points in source
                // prev.item.data.loc = {
                //     primary: prev.item.data.loc,
                //     merged: declaration.loc
                // };
            }
        } else {
            var prev = needless(props, declaration, fingerprints);

            if (prev) {
                declarations.remove(declarationItem);

                // TODO: use it when we can refer to several points in source
                // prev.item.data.loc = {
                //     primary: prev.item.data.loc,
                //     merged: declaration.loc
                // };
            } else {
                declaration.fingerprint = fingerprint;

                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };
            }
        }
    });

    if (declarations.isEmpty()) {
        list.remove(item);
    }
}

module.exports = function restructBlock(ast) {
    var stylesheetMap = {};
    var fingerprints = Object.create(null);

    walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter: function(node, item, list) {
            var stylesheet = this.block || this.stylesheet;
            var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
            var ruleMap;
            var props;

            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
                ruleMap = {};
                stylesheetMap[stylesheet.id] = ruleMap;
            } else {
                ruleMap = stylesheetMap[stylesheet.id];
            }

            if (ruleMap.hasOwnProperty(ruleId)) {
                props = ruleMap[ruleId];
            } else {
                props = {};
                ruleMap[ruleId] = props;
            }

            processRule.call(this, node, item, list, props, fingerprints);
        }
    });
};


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

var walk = __webpack_require__(1).walk;
var utils = __webpack_require__(31);

/*
    At this step all rules has single simple selector. We try to join by equal
    declaration blocks to first rule, e.g.

    .a { color: red }
    b { ... }
    .b { color: red }
    ->
    .a, .b { color: red }
    b { ... }
*/

function processRule(node, item, list) {
    var selectors = node.prelude.children;
    var declarations = node.block.children;
    var nodeCompareMarker = selectors.first().compareMarker;
    var skippedCompareMarkers = {};

    list.nextUntil(item.next, function(next, nextItem) {
        // skip non-ruleset node if safe
        if (next.type !== 'Rule') {
            return utils.unsafeToSkipNode.call(selectors, next);
        }

        if (node.pseudoSignature !== next.pseudoSignature) {
            return true;
        }

        var nextFirstSelector = next.prelude.children.head;
        var nextDeclarations = next.block.children;
        var nextCompareMarker = nextFirstSelector.data.compareMarker;

        // if next ruleset has same marked as one of skipped then stop joining
        if (nextCompareMarker in skippedCompareMarkers) {
            return true;
        }

        // try to join by selectors
        if (selectors.head === selectors.tail) {
            if (selectors.first().id === nextFirstSelector.data.id) {
                declarations.appendList(nextDeclarations);
                list.remove(nextItem);
                return;
            }
        }

        // try to join by properties
        if (utils.isEqualDeclarations(declarations, nextDeclarations)) {
            var nextStr = nextFirstSelector.data.id;

            selectors.some(function(data, item) {
                var curStr = data.id;

                if (nextStr < curStr) {
                    selectors.insert(nextFirstSelector, item);
                    return true;
                }

                if (!item.next) {
                    selectors.insert(nextFirstSelector);
                    return true;
                }
            });

            list.remove(nextItem);
            return;
        }

        // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)
        if (nextCompareMarker === nodeCompareMarker) {
            return true;
        }

        skippedCompareMarkers[nextCompareMarker] = true;
    });
}

module.exports = function mergeRule(ast) {
    walk(ast, {
        visit: 'Rule',
        enter: processRule
    });
};


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var List = __webpack_require__(1).List;
var walk = __webpack_require__(1).walk;
var utils = __webpack_require__(31);

function calcSelectorLength(list) {
    var length = 0;

    list.each(function(data) {
        length += data.id.length + 1;
    });

    return length - 1;
}

function calcDeclarationsLength(tokens) {
    var length = 0;

    for (var i = 0; i < tokens.length; i++) {
        length += tokens[i].length;
    }

    return (
        length +          // declarations
        tokens.length - 1 // delimeters
    );
}

function processRule(node, item, list) {
    var avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
    var selectors = node.prelude.children;
    var block = node.block;
    var disallowDownMarkers = Object.create(null);
    var allowMergeUp = true;
    var allowMergeDown = true;

    list.prevUntil(item.prev, function(prev, prevItem) {
        // skip non-ruleset node if safe
        if (prev.type !== 'Rule') {
            return utils.unsafeToSkipNode.call(selectors, prev);
        }

        var prevSelectors = prev.prelude.children;
        var prevBlock = prev.block;

        if (node.pseudoSignature !== prev.pseudoSignature) {
            return true;
        }

        allowMergeDown = !prevSelectors.some(function(selector) {
            return selector.compareMarker in disallowDownMarkers;
        });

        // try prev ruleset if simpleselectors has no equal specifity and element selector
        if (!allowMergeDown && !allowMergeUp) {
            return true;
        }

        // try to join by selectors
        if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {
            prevBlock.children.appendList(block.children);
            list.remove(item);
            return true;
        }

        // try to join by properties
        var diff = utils.compareDeclarations(block.children, prevBlock.children);

        // console.log(diff.eq, diff.ne1, diff.ne2);

        if (diff.eq.length) {
            if (!diff.ne1.length && !diff.ne2.length) {
                // equal blocks
                if (allowMergeDown) {
                    utils.addSelectors(selectors, prevSelectors);
                    list.remove(prevItem);
                }

                return true;
            } else if (!avoidRulesMerge) { /* probably we don't need to prevent those merges for @keyframes
                                              TODO: need to be checked */

                if (diff.ne1.length && !diff.ne2.length) {
                    // prevBlock is subset block
                    var selectorLength = calcSelectorLength(selectors);
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeUp && selectorLength < blockLength) {
                        utils.addSelectors(prevSelectors, selectors);
                        block.children = new List().fromArray(diff.ne1);
                    }
                } else if (!diff.ne1.length && diff.ne2.length) {
                    // node is subset of prevBlock
                    var selectorLength = calcSelectorLength(prevSelectors);
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeDown && selectorLength < blockLength) {
                        utils.addSelectors(selectors, prevSelectors);
                        prevBlock.children = new List().fromArray(diff.ne2);
                    }
                } else {
                    // diff.ne1.length && diff.ne2.length
                    // extract equal block
                    var newSelector = {
                        type: 'SelectorList',
                        loc: null,
                        children: utils.addSelectors(prevSelectors.copy(), selectors)
                    };
                    var newBlockLength = calcSelectorLength(newSelector.children) + 2; // selectors length + curly braces length
                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    // create new ruleset if declarations length greater than
                    // ruleset description overhead
                    if (allowMergeDown && blockLength >= newBlockLength) {
                        var newRule = {
                            type: 'Rule',
                            loc: null,
                            prelude: newSelector,
                            block: {
                                type: 'Block',
                                loc: null,
                                children: new List().fromArray(diff.eq)
                            },
                            pseudoSignature: node.pseudoSignature
                        };

                        block.children = new List().fromArray(diff.ne1);
                        prevBlock.children = new List().fromArray(diff.ne2.concat(diff.ne2overrided));
                        list.insert(list.createItem(newRule), prevItem);
                        return true;
                    }
                }
            }
        }

        if (allowMergeUp) {
            // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);
            // await property families to find property interception correctly
            allowMergeUp = !prevSelectors.some(function(prevSelector) {
                return selectors.some(function(selector) {
                    return selector.compareMarker === prevSelector.compareMarker;
                });
            });
        }

        prevSelectors.each(function(data) {
            disallowDownMarkers[data.compareMarker] = true;
        });
    });
}

module.exports = function restructRule(ast) {
    walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter: processRule
    });
};


/***/ }),
/* 227 */
/***/ (function(module) {

module.exports = JSON.parse("{\"_from\":\"csso@^3.5.1\",\"_id\":\"csso@3.5.1\",\"_inBundle\":false,\"_integrity\":\"sha1-e564vmFiiXPBsmHhadLwJACOdYs=\",\"_location\":\"/csso\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"range\",\"registry\":true,\"raw\":\"csso@^3.5.1\",\"name\":\"csso\",\"escapedName\":\"csso\",\"rawSpec\":\"^3.5.1\",\"saveSpec\":null,\"fetchSpec\":\"^3.5.1\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"http://r.tnpm.oa.com/csso/download/csso-3.5.1.tgz\",\"_shasum\":\"7b9eb8be61628973c1b261e169d2f024008e758b\",\"_spec\":\"csso@^3.5.1\",\"_where\":\"/Users/june/workspace/wechat-miniprogram/miniprogram-simulate\",\"author\":{\"name\":\"Sergey Kryzhanovsky\",\"email\":\"skryzhanovsky@ya.ru\",\"url\":\"https://github.com/afelix\"},\"bugs\":{\"url\":\"https://github.com/css/csso/issues\"},\"bundleDependencies\":false,\"dependencies\":{\"css-tree\":\"1.0.0-alpha.29\"},\"deprecated\":false,\"description\":\"CSS minifier with structural optimisations\",\"devDependencies\":{\"browserify\":\"^13.0.0\",\"coveralls\":\"^2.11.6\",\"eslint\":\"^2.2.0\",\"istanbul\":\"^0.4.2\",\"jscs\":\"~3.0.7\",\"mocha\":\"^3.5.3\",\"package-json-versionify\":\"^1.0.4\",\"source-map\":\"^0.5.6\",\"uglify-js\":\"^2.6.1\"},\"engines\":{\"node\":\">=0.10.0\"},\"eslintConfig\":{\"env\":{\"node\":true,\"mocha\":true,\"es6\":true},\"rules\":{\"no-duplicate-case\":2,\"no-undef\":2,\"no-unused-vars\":[2,{\"vars\":\"all\",\"args\":\"after-used\"}]}},\"files\":[\"dist/csso-browser.js\",\"lib\",\"HISTORY.md\",\"LICENSE\",\"README.md\"],\"homepage\":\"https://github.com/css/csso\",\"keywords\":[\"css\",\"compress\",\"minifier\",\"minify\",\"optimise\",\"optimisation\",\"csstree\"],\"license\":\"MIT\",\"main\":\"./lib/index\",\"maintainers\":[{\"name\":\"Roman Dvornov\",\"email\":\"rdvornov@gmail.com\"}],\"name\":\"csso\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/css/csso.git\"},\"scripts\":{\"browserify\":\"browserify -t package-json-versionify --standalone csso lib/index.js | uglifyjs --compress --mangle -o dist/csso-browser.js\",\"codestyle\":\"jscs lib test && eslint lib test\",\"codestyle-and-test\":\"npm run codestyle && npm test\",\"coverage\":\"istanbul cover _mocha -- -R dot\",\"coveralls\":\"istanbul cover _mocha --report lcovonly -- -R dot && cat ./coverage/lcov.info | coveralls\",\"gh-pages\":\"git clone --depth=1 -b gh-pages https://github.com/css/csso.git .gh-pages && npm run browserify && cp dist/csso-browser.js .gh-pages/ && cd .gh-pages && git commit -am \\\"update\\\" && git push && cd .. && rm -rf .gh-pages\",\"hydrogen\":\"node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/csso --stat -o /dev/null\",\"postpublish\":\"npm run gh-pages\",\"prepublish\":\"npm run browserify\",\"test\":\"mocha --reporter dot\",\"travis\":\"npm run codestyle-and-test && npm run coveralls\"},\"version\":\"3.5.1\"}");

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

const path = __webpack_require__(3)
const _ = __webpack_require__(10)

const compiler = _.getCompiler()
const wxmlCache = {}
const compilerResCache = {}

module.exports = {
    /**
     * 获取 wxml
     */
    getWxml(componentPath, config) {
        let wxml = wxmlCache[componentPath]

        if (wxml) return wxml
        if (config.compiler === 'official') {
            // 使用官方编译器
            if (!compiler) {
                wxml = _.readFile(`${componentPath}.wxml`)
                if (typeof wxml !== 'function') {
                    // 可能是用官方编译器编译好的函数，所以需要加此判断（如在 karma 测试）
                    throw new Error('not support official compiler, please use simulate compiler')
                }
            } else {
                let gwx
                if (compilerResCache[config.rootPath]) {
                    gwx = compilerResCache[config.rootPath]
                } else {
                    const compileString = compiler.wxmlToJs(config.rootPath)
                    // eslint-disable-next-line no-new-func
                    const compileFunc = new Function(compileString)

                    gwx = compileFunc()
                    compilerResCache[config.rootPath] = gwx
                }

                let relativeWxmlPath = `${path.relative(config.rootPath, componentPath)}.wxml`
                relativeWxmlPath = relativeWxmlPath.replace(/\\/g, '/')

                // 构建编译结果为函数
                wxml = gwx(relativeWxmlPath)
            }
        } else {
            // 使用纯 js 实现的编译器
            wxml = _.readFile(`${componentPath}.wxml`)
        }

        // 缓存 wxml 内容
        wxmlCache[componentPath] = wxml

        return wxml
    }
}


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const _ = __webpack_require__(10)

/**
 * Touch polyfill
 */
class Touch {
    constructor(options = {}) {
        this.clientX = 0
        this.clientY = 0
        this.identifier = 0
        this.pageX = 0
        this.pageY = 0
        this.screenX = 0
        this.screenY = 0
        this.target = null

        Object.keys(options).forEach(key => {
            this[key] = options[key]
        })
    }
}

module.exports = function() {
    if (_.getEnv() === 'nodejs') {
        try {
            global.Touch = window.Touch = Touch
        } catch (err) {
            // ignore
        }
    }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const jComponent = __webpack_require__(32)

const api = __webpack_require__(231)

const officialTagList = [
    'view', 'scroll-view', 'swiper', 'movable-view', 'cover-view', 'cover-view',
    'icon', 'text', 'rich-text', 'progress',
    'button', 'checkbox', 'form', 'input', 'label', 'picker', 'picker', 'picker-view', 'radio', 'slider', 'switch', 'textarea',
    'navigator', 'function-page-navigator',
    'audio', 'image', 'video', 'camera', 'live-player', 'live-pusher',
    'map',
    'canvas',
    'open-data', 'web-view', 'ad'
]

module.exports = function() {
    // 注册内置组件
    officialTagList.forEach(name => {
        jComponent.register({
            id: name,
            tagName: `wx-${name}`,
            template: '<slot/>',
        })
    })

    // 注入 api
    global.wx = api
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

const Animation = __webpack_require__(232)
const MapContext = __webpack_require__(233)
const UpdateManager = __webpack_require__(234)
const dataApi = __webpack_require__(235)
const openApi = __webpack_require__(236)
const _ = __webpack_require__(12)

module.exports = {
    request: _.mockAsync('request'),

    uploadFile: _.mockAsync('uploadFile'),
    downloadFile: _.mockAsync('downloadFile'),

    connectSocket: _.mockAsync('connectSocket'),
    onSocketOpen: _.mockAsync('onSocketOpen'),
    onSocketError: _.mockAsync('onSocketError'),
    sendSocketMessage: _.mockAsync('sendSocketMessage'),
    onSocketMessage: _.mockAsync('onSocketMessage'),
    closeSocket: _.mockAsync('closeSocket'),
    onSocketClose: _.mockAsync('onSocketClose'),

    chooseImage: _.mockAsync('chooseImage'),
    previewImage: _.mockAsync('previewImage'),
    getImageInfo: _.mockAsync('getImageInfo'),
    saveImageToPhotosAlbum: _.mockAsync('saveImageToPhotosAlbum'),

    startRecord: _.mockAsync('startRecord'),
    stopRecord: _.mockAsync('stopRecord'),

    getRecorderManager: _.mockAsync('getRecorderManager'),

    playVoice: _.mockAsync('playVoice'),
    pauseVoice: _.mockAsync('pauseVoice'),
    stopVoice: _.mockAsync('stopVoice'),

    getBackgroundAudioPlayerState: _.mockAsync('getBackgroundAudioPlayerState'),
    playBackgroundAudio: _.mockAsync('playBackgroundAudio'),
    pauseBackgroundAudio: _.mockAsync('pauseBackgroundAudio'),
    seekBackgroundAudio: _.mockAsync('seekBackgroundAudio'),
    stopBackgroundAudio: _.mockAsync('stopBackgroundAudio'),
    onBackgroundAudioPlay: _.mockAsync('onBackgroundAudioPlay'),
    onBackgroundAudioPause: _.mockAsync('onBackgroundAudioPause'),
    onBackgroundAudioStop: _.mockAsync('onBackgroundAudioStop'),

    getBackgroundAudioManager: _.mockAsync('getBackgroundAudioManager'),

    createAudioContext: _.mockAsync('createAudioContext'),
    createInnerAudioContext: _.mockAsync('createInnerAudioContext'),
    getAvailableAudioSources: _.mockAsync('getAvailableAudioSources'),

    chooseVideo: _.mockAsync('chooseVideo'),
    saveVideoToPhotosAlbum: _.mockAsync('saveVideoToPhotosAlbum'),

    createVideoContext: _.mockAsync('createVideoContext'),

    createCameraContext: _.mockAsync('createCameraContext'),

    createLivePlayerContext: _.mockAsync('createLivePlayerContext'),
    createLivePusherContext: _.mockAsync('createLivePusherContext'),

    loadFontFace: _.mockAsync('loadFontFace'),

    saveFile: _.mockAsync('saveFile'),
    getFileInfo: _.mockAsync('getFileInfo'),
    getSavedFileList: _.mockAsync('getSavedFileList'),
    getSavedFileInfo: _.mockAsync('getSavedFileInfo'),
    removeSavedFile: _.mockAsync('removeSavedFile'),
    openDocument: _.mockAsync('openDocument'),

    onMemoryWarning: _.mockAsync('onMemoryWarning'),

    getNetworkType: _.mockAsync('getNetworkType'),
    onNetworkStatusChange: _.mockAsync('onNetworkStatusChange'),

    onAccelerometerChange: _.mockAsync('onAccelerometerChange'),
    startAccelerometer: _.mockAsync('startAccelerometer'),
    stopAccelerometer: _.mockAsync('stopAccelerometer'),

    onCompassChange: _.mockAsync('onCompassChange'),
    startCompass: _.mockAsync('startCompass'),
    stopCompass: _.mockAsync('stopCompass'),

    makePhoneCall: _.mockAsync('makePhoneCall'),

    scanCode: _.mockAsync('scanCode'),

    setClipboardData: _.mockAsync('setClipboardData'),
    getClipboardData: _.mockAsync('getClipboardData'),

    openBluetoothAdapter: _.mockAsync('openBluetoothAdapter'),
    closeBluetoothAdapter: _.mockAsync('closeBluetoothAdapter'),
    getBluetoothAdapterState: _.mockAsync('getBluetoothAdapterState'),
    onBluetoothAdapterStateChange: _.mockAsync('onBluetoothAdapterStateChange'),
    startBluetoothDevicesDiscovery: _.mockAsync('startBluetoothDevicesDiscovery'),
    stopBluetoothDevicesDiscovery: _.mockAsync('stopBluetoothDevicesDiscovery'),
    getBluetoothDevices: _.mockAsync('getBluetoothDevices'),
    getConnectedBluetoothDevices: _.mockAsync('getConnectedBluetoothDevices'),
    onBluetoothDeviceFound: _.mockAsync('onBluetoothDeviceFound'),
    createBLEConnection: _.mockAsync('createBLEConnection'),
    closeBLEConnection: _.mockAsync('closeBLEConnection'),
    getBLEDeviceServices: _.mockAsync('getBLEDeviceServices'),
    getBLEDeviceCharacteristics: _.mockAsync('getBLEDeviceCharacteristics'),
    readBLECharacteristicValue: _.mockAsync('readBLECharacteristicValue'),
    writeBLECharacteristicValue: _.mockAsync('writeBLECharacteristicValue'),
    notifyBLECharacteristicValueChange: _.mockAsync('notifyBLECharacteristicValueChange'),
    onBLEConnectionStateChange: _.mockAsync('onBLEConnectionStateChange'),
    onBLECharacteristicValueChange: _.mockAsync('onBLECharacteristicValueChange'),

    startBeaconDiscovery: _.mockAsync('startBeaconDiscovery'),
    stopBeaconDiscovery: _.mockAsync('stopBeaconDiscovery'),
    getBeacons: _.mockAsync('getBeacons'),
    onBeaconUpdate: _.mockAsync('onBeaconUpdate'),
    onBeaconServiceChange: _.mockAsync('onBeaconServiceChange'),

    setScreenBrightness: _.mockAsync('setScreenBrightness'),
    getScreenBrightness: _.mockAsync('getScreenBrightness'),
    setKeepScreenOn: _.mockAsync('setKeepScreenOn'),

    onUserCaptureScreen: _.mockAsync('onUserCaptureScreen'),

    vibrateLong: _.mockAsync('vibrateLong'),
    vibrateShort: _.mockAsync('vibrateShort'),

    addPhoneContact: _.mockAsync('addPhoneContact'),

    getHCEState: _.mockAsync('getHCEState'),
    startHCE: _.mockAsync('startHCE'),
    stopHCE: _.mockAsync('stopHCE'),
    onHCEMessage: _.mockAsync('onHCEMessage'),
    sendHCEMessage: _.mockAsync('sendHCEMessage'),

    startWifi: _.mockAsync('startWifi'),
    stopWifi: _.mockAsync('stopWifi'),
    connectWifi: _.mockAsync('connectWifi'),
    getWifiList: _.mockAsync('getWifiList'),
    onGetWifiList: _.mockAsync('onGetWifiList'),
    setWifiList: _.mockAsync('setWifiList'),
    onWifiConnected: _.mockAsync('onWifiConnected'),
    getConnectedWifi: _.mockAsync('getConnectedWifi'),

    showToast: _.mockAsync('showToast'),
    showLoading: _.mockAsync('showLoading'),
    hideToast: _.mockAsync('hideToast'),
    hideLoading: _.mockAsync('hideLoading'),
    showModal: _.mockAsync('showModal'),
    showActionSheet: _.mockAsync('showActionSheet'),

    setNavigationBarTitle: _.mockAsync('setNavigationBarTitle'),
    showNavigationBarLoading: _.mockAsync('showNavigationBarLoading'),
    hideNavigationBarLoading: _.mockAsync('hideNavigationBarLoading'),
    setNavigationBarColor: _.mockAsync('setNavigationBarColor'),

    setTabBarBadge: _.mockAsync('setTabBarBadge'),
    removeTabBarBadge: _.mockAsync('removeTabBarBadge'),
    showTabBarRedDot: _.mockAsync('showTabBarRedDot'),
    hideTabBarRedDot: _.mockAsync('hideTabBarRedDot'),
    setTabBarStyle: _.mockAsync('setTabBarStyle'),
    setTabBarItem: _.mockAsync('setTabBarItem'),
    showTabBar: _.mockAsync('showTabBar'),
    hideTabBar: _.mockAsync('hideTabBar'),

    setBackgroundColor: _.mockAsync('setBackgroundColor'),
    setBackgroundTextStyle: _.mockAsync('setBackgroundTextStyle'),

    setTopBarText: _.mockAsync('setTopBarText'),

    createAnimation(transition = {}) {
        return new Animation(transition)
    },

    pageScrollTo: _.mockAsync('pageScrollTo'),

    createCanvasContext: _.mockAsync('createCanvasContext'),
    createContext: _.mockAsync('createContext'),
    drawCanvas: _.mockAsync('drawCanvas'),
    canvasToTempFilePath: _.mockAsync('canvasToTempFilePath'),
    canvasGetImageData: _.mockAsync('canvasGetImageData'),
    canvasPutImageData: _.mockAsync('canvasPutImageData'),

    startPullDownRefresh: _.mockAsync('startPullDownRefresh'),
    stopPullDownRefresh: _.mockAsync('stopPullDownRefresh'),

    createWorker: _.mockAsync('createWorker'),

    // network
    // TODO

    // media
    // TOOD

    // file
    // TODO

    // data
    ...dataApi,

    // location
    chooseLocation(options = {}) {
        _.runInAsync(options, {
            errMsg: 'chooseLocation:ok',
            address: '广东省广州市海珠区tit创意园品牌街',
            name: '腾讯微信总部',
            latitude: 23.1001,
            longitude: 113.32456,
        })
    },
    getLocation(options = {}) {
        _.runInAsync(options, {
            errMsg: 'getLocation:ok',
            accuracy: 65,
            altitude: 0,
            latitude: 23.12908,
            longitude: 113.26436,
            speed: -1,
            verticalAccuracy: 65,
            horizontalAccuracy: 65,
        })
    },
    openLocation: _.mockAsync('openLocation'),

    // device
    // TODO

    // open
    ...openApi,

    // update
    getUpdateManager() {
        return new UpdateManager()
    },

    // worker
    // TODO

    // report
    reportMonitor: _.mockSync(null),

    // miniprogram
    // TODO

    // base
    canIUse: _.mockSync(true),

    // canvas
    // TODO

    // debug
    getLogManager: _.mockSync(console),
    setEnableDebug: _.mockSync(null),

    // thirdparty
    getExtConfig(options = {}) {
        _.runInAsync(options, {
            errMsg: 'getExtConfig:ok',
            extConfig: wx.getExtConfigSync(),
        })
    },
    getExtConfigSync() {
        return {}
    },

    // map
    createMapContext(...args) {
        return new MapContext(...args)
    },

    // route
    navigateTo: _.mockAsync('navigateTo'),
    redirectTo: _.mockAsync('redirectTo'),
    switchTab: _.mockAsync('switchTab'),
    navigateBack: _.mockAsync('navigateBack'),
    reLaunch: _.mockAsync('reLaunch'),

    // share
    getShareInfo(options = {}) {
        _.runInAsync(options, {
            errMsg: 'getShareInfo:ok',
            encryptedData: 'CiyLU1Aw2KjvrjMdj8YKliAjtP4gsMZMQmRzooG2xrDcvSnxIMXFufNstNGTyaGS9uT5geRa0W4oTOb1WT7fJlAC+oNPdbB+3hVbJSRgv+4lGOETKUQz6OYStslQ142dNCuabNPGBzlooOmB231qMM85d2/fV6ChevvXvQP8Hkue1poOFtnEtpyxVLW1zAo6/1Xx1COxFvrc2d7UL/lmHInNlxuacJXwu0fjpXfz/YqYzBIBzD6WUfTIF9GRHpOn/Hz7saL8xz+W//FRAUid1OksQaQx4CMs8LOddcQhULW4ucetDf96JcR3g0gfRK4PC7E/r7Z6xNrXd2UIeorGj5Ef7b1pJAYB6Y5anaHqZ9J6nKEBvB4DnNLIVWSgARns/8wR2SiRS7MNACwTyrGvt9ts8p12PKFdlqYTopNHR1Vf7XjfhQlVsAJdNiKdYmYVoKlaRv85IfVunYzO0IKXsyl7JCUjCpoG20f0a04COwfneQAGGwd5oa+T8yO5hzuyDb/XcxxmK01EpqOyuxINew==',
            iv: 'r7BXXKkLb8qrSNn05n0qiA==',
        })
    },
    hideShareMenu: _.mockAsync('hideShareMenu'),
    showShareMenu: _.mockAsync('showShareMenu'),
    updateShareMenu: _.mockAsync('updateShareMenu'),

    // system
    getSystemInfo(options = {}) {
        _.runInAsync(options, {
            errMsg: 'getSystemInfo:ok',
            ...wx.getSystemInfoSync(),
        })
    },
    getSystemInfoSync() {
        return {
            SDKVersion: '2.3.0',
            batteryLevel: 100,
            benchmarkLevel: 1,
            brand: 'devtools',
            fontSizeSetting: 16,
            language: 'zh_CN',
            model: 'iPhone 7 Plus',
            pixelRatio: 3,
            platform: 'devtools',
            screenHeight: 736,
            screenWidth: 414,
            statusBarHeight: 20,
            system: 'iOS 10.0.1',
            version: '6.6.3',
            windowHeight: 672,
            windowWidth: 414,
        }
    },

    // wxml
    createSelectorQuery() {
        return {
            in(compInst) {
                return compInst.createSelectorQuery()
            },
        }
    },
    createIntersectionObserver(compInst, options) {
        return compInst.createIntersectionObserver(options)
    },
}


/***/ }),
/* 232 */
/***/ (function(module, exports) {

class Animation {
    constructor(option = {}) {
        this.actions = []
        this.currentTransform = []
        this.currentStepAnimates = []

        this.option = {
            transition: {
                duration: option.duration !== undefined ? option.duration : 400,
                timingFunction: option.timingFunction !== undefined ? option.timingFunction : 'linear',
                delay: option.delay !== undefined ? option.delay : 0,
            },
            transformOrigin: option.transformOrigin || '50% 50% 0',
        }
    }

    export() {
        const actions = this.actions
        this.actions = []
        return {actions}
    }

    step(option = {}) {
        this.currentStepAnimates.forEach((animate) => {
            if (animate.type !== 'style') {
                this.currentTransform[animate.type] = animate
            } else {
                this.currentTransform[`${animate.type}.${animate.args[0]}`] = animate
            }
        })

        this.actions.push({
            animates: Object.keys(this.currentTransform).reduce((prev, key) => [...prev, this.currentTransform[key]], []),
            option: {
                transformOrigin: option.transformOrigin !== undefined ? option.transformOrigin : this.option.transformOrigin,
                transition: {
                    duration: option.duration !== undefined ? option.duration : this.option.transition.duration,
                    timingFunction: option.timingFunction !== undefined ? option.timingFunction : this.option.transition.timingFunction,
                    delay: option.delay !== undefined ? option.delay : this.option.transition.delay,
                },
            },
        })

        this.currentStepAnimates = []
        return this
    }

    matrix(a = 1, b = 0, c = 0, d = 1, tx = 1, ty = 1) {
        this.currentStepAnimates.push({type: 'matrix', args: [a, b, c, d, tx, ty]})
        return this
    }

    matrix3d(a1 = 1, b1 = 0, c1 = 0, d1 = 0, a2 = 0, b2 = 1, c2 = 0, d2 = 0, a3 = 0, b3 = 0, c3 = 1, d3 = 0, a4 = 0, b4 = 0, c4 = 0, d4 = 1) {
        this.currentStepAnimates.push({type: 'matrix3d', args: [a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4]})
        this.stepping = false
        return this
    }

    rotate(angle = 0) {
        this.currentStepAnimates.push({type: 'rotate', args: [angle]})
        return this
    }

    rotate3d(x = 0, y = 0, z = 0, a = 0) {
        this.currentStepAnimates.push({type: 'rotate3d', args: [x, y, z, a]})
        this.stepping = false
        return this
    }

    rotateX(a = 0) {
        this.currentStepAnimates.push({type: 'rotateX', args: [a]})
        this.stepping = false
        return this
    }

    rotateY(a = 0) {
        this.currentStepAnimates.push({type: 'rotateY', args: [a]})
        this.stepping = false
        return this
    }

    rotateZ(a = 0) {
        this.currentStepAnimates.push({type: 'rotateZ', args: [a]})
        this.stepping = false
        return this
    }

    scale(sx = 1, sy) {
        this.currentStepAnimates.push({type: 'scale', args: [sx, sy !== undefined ? sy : sx]})
        return this
    }

    scale3d(sx = 1, sy = 1, sz = 1) {
        this.currentStepAnimates.push({type: 'scale3d', args: [sx, sy, sz]})
        return this
    }

    scaleX(s = 1) {
        this.currentStepAnimates.push({type: 'scaleX', args: [s]})
        return this
    }

    scaleY(s = 1) {
        this.currentStepAnimates.push({type: 'scaleY', args: [s]})
        return this
    }

    scaleZ(s = 1) {
        this.currentStepAnimates.push({type: 'scaleZ', args: [s]})
        return this
    }

    skew(ax = 0, ay = 0) {
        this.currentStepAnimates.push({type: 'skew', args: [ax, ay]})
        return this
    }

    skewX(a = 0) {
        this.currentStepAnimates.push({type: 'skewX', args: [a]})
        return this
    }

    skewY(a = 0) {
        this.currentStepAnimates.push({type: 'skewY', args: [a]})
        return this
    }

    translate(tx = 0, ty = 0) {
        this.currentStepAnimates.push({type: 'translate', args: [tx, ty]})
        return this
    }

    translate3d(tx = 0, ty = 0, tz = 0) {
        this.currentStepAnimates.push({type: 'translate3d', args: [tx, ty, tz]})
        return this
    }

    translateX(t = 0) {
        this.currentStepAnimates.push({type: 'translateX', args: [t]})
        return this
    }

    translateY(t = 0) {
        this.currentStepAnimates.push({type: 'translateY', args: [t]})
        return this
    }

    translateZ(t = 0) {
        this.currentStepAnimates.push({type: 'translateZ', args: [t]})
        return this
    }

    opacity(value) {
        this.currentStepAnimates.push({type: 'style', args: ['opacity', value]})
        return this
    }

    backgroundColor(value) {
        this.currentStepAnimates.push({type: 'style', args: ['background-color', value]})
        return this
    }

    width(value) {
        this.currentStepAnimates.push({type: 'style', args: ['width', typeof value === 'number' ? value + 'px' : value]})
        return this
    }

    height(value) {
        this.currentStepAnimates.push({type: 'style', args: ['height', typeof value === 'number' ? value + 'px' : value]})
        return this
    }

    left(value) {
        this.currentStepAnimates.push({type: 'style', args: ['left', typeof value === 'number' ? value + 'px' : value]})
        return this
    }

    right(value) {
        this.currentStepAnimates.push({type: 'style', args: ['right', typeof value === 'number' ? value + 'px' : value]})
        return this
    }

    top(value) {
        this.currentStepAnimates.push({type: 'style', args: ['top', typeof value === 'number' ? value + 'px' : value]})
        return this
    }

    bottom(value) {
        this.currentStepAnimates.push({type: 'style', args: ['bottom', typeof value === 'number' ? value + 'px' : value]})
        return this
    }
}

module.exports = Animation


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable class-methods-use-this */
const _ = __webpack_require__(12)

class MapContext {
    constructor(id, parent) {
        this._exparserNode = parent.selectComponent(`#${id}`)
    }

    getCenterLocation(options = {}) {
        _.runInAsync(options, {
            errMsg: 'getMapCenterLocation:ok',
            latitude: 39.92,
            longitude: 116.46,
        })
    }

    getRegion(options = {}) {
        _.runInAsync(options, {
            errMsg: 'getMapRegion:ok',
            northeast: {
                latitude: 39.92493685384383,
                longitude: 116.47287460327148,
            },
            southwest: {
                latitude: 39.91506279020459,
                longitude: 116.44712539672851,
            },
        })
    }

    getScale(options = {}) {
        _.runInAsync(options, {
            errMsg: 'getMapScale:ok',
            scale: 14,
        })
    }

    get includePoints() {
        return _.mockAsync('includePoints')
    }

    get moveToLocation() {
        return _.mockSync(null)
    }

    get translateMarker() {
        return _.mockAsync('translateMarker')
    }
}

module.exports = MapContext


/***/ }),
/* 234 */
/***/ (function(module, exports) {

/* eslint-disable class-methods-use-this */
class UpdateManager {
    constructor() {
        this.updateCallback = null
    }

    applyUpdate() {
        setTimeout(() => {
            if (this.updateCallback && typeof this.updateCallback === 'function') {
                this.updateCallback()
            }
        }, 0)
    }

    onCheckForUpdate(callback) {
        setTimeout(() => {
            if (callback && typeof callback === 'function') {
                callback({hasUpdate: true})
            }
        }, 0)
    }

    onUpdateFailed() {}

    onUpdateReady(callback) {
        this.updateCallback = callback
    }
}

module.exports = UpdateManager


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

/* global localStorage */
const _ = __webpack_require__(12)

module.exports = {
    clearStorage(options) {
        const res = {errMsg: 'clearStorage:ok'}
        try {
            wx.clearStorageSync()
        } catch (err) {
            res.errMsg = `clearStorage:fail ${err.message}`
        }

        _.runInAsync(options, res)
    },
    clearStorageSync() {
        localStorage.clear()
    },
    getStorage(options) {
        const res = {errMsg: 'getStorage:ok'}
        try {
            res.data = wx.getStorageSync(options.key)
        } catch (err) {
            res.errMsg = `getStorage:fail ${err.message}`
        }

        _.runInAsync(options, res)
    },
    getStorageSync(key) {
        return JSON.parse(localStorage.getItem(key))
    },
    getStorageInfo(options) {
        let res = {errMsg: 'getStorageInfo:ok'}
        try {
            const data = wx.getStorageInfoSync()
            res = Object.assign(res, data)
        } catch (err) {
            res.errMsg = `getStorageInfo:fail ${err.message}`
        }

        _.runInAsync(options, res)
    },
    getStorageInfoSync() {
        const length = localStorage.length
        const keys = []
        let currentSize = 0

        for (let i = 0; i < length; i++) {
            const key = localStorage.key(i)
            keys.push(key)
            currentSize += _.getSize(localStorage.getItem(key))
        }

        return {
            keys,
            currentSize,
            limitSize: 1024 * 10,
        }
    },
    removeStorage(options) {
        const res = {errMsg: 'removeStorage:ok'}
        try {
            wx.removeStorageSync(options.key)
        } catch (err) {
            res.errMsg = `removeStorage:fail ${err.message}`
        }

        _.runInAsync(options, res)
    },
    removeStorageSync(key) {
        localStorage.removeItem(key)
    },
    setStorage(options) {
        const res = {errMsg: 'setStorage:ok'}
        try {
            wx.setStorageSync(options.key, options.data)
        } catch (err) {
            res.errMsg = `setStorage:fail ${err.message}`
        }

        _.runInAsync(options, res)
    },
    setStorageSync(key, data) {
        localStorage.setItem(key, JSON.stringify(data))
    },
}


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

const _ = __webpack_require__(12)

module.exports = {
    getAccountInfoSync: _.mockSync({
        miniprogram: {appId: 'wx4f4bc4dec97d474b'},
    }),
    chooseAddress(options = {}) {
        _.runInAsync(options, {
            errMsg: 'chooseAddress:ok',
            cityName: '广州市',
            countyName: '海珠区',
            detailInfo: '新港中路397号',
            nationalCode: '510000',
            postalCode: '510000',
            provinceName: '广东省',
            telNumber: '020-81167888',
            userName: '张三',
        })
    },
    authorize: _.mockAsync('authorize'),
    addCard(options = {}) {
        const cardList = (options.cardList || []).map(item => ({
            code: 'this is a mock code',
            isSuccess: true,
            ...item,
        }))

        _.runInAsync(options, {
            errMsg: 'addCard:ok',
            cardList
        })
    },
    openCard: _.mockAsync('openCard'),
    reportAnalytics: _.mockSync(null),
    chooseInvoice(options = {}) {
        _.runInAsync(options, {
            errMsg: 'chooseInvoice:ok',
            invoiceInfo: {
                cardId: 'pjZ8Yt5crPbAouhFqFf6JFgZv4Lc',
                encryptCode: 'fbdt/fWy1VitQwhbKtSjNeR3BJyfpeJXfZjjGsdCXiM=',
                publisherAppId: 'wx00000000000000',
            },
        })
    },
    chooseInvoiceTitle(options = {}) {
        _.runInAsync(options, {
            errMsg: 'chooseInvoiceTitle:ok',
            bankAccount: '1209 0928 2210 301',
            bankName: '招商银行股份有限公司广州市体育东路支行',
            companyAddress: '广州市海珠区新港中路397号自编72号(商业街F5-1)',
            taxNumber: '91440101327598294H',
            telephone: '020-81167888',
            title: '广州腾讯科技有限公司',
            type: 0,
        })
    },
    checkSession: _.mockAsync('checkSession'),
    login(options = {}) {
        _.runInAsync(options, {
            errMsg: 'login:ok',
            code: '033UAswz1j8Fjb0lT4yz1Wmrwz1UAsw9',
        })
    },
    navigateBackMiniProgram: _.mockAsync('navigateBackMiniProgram'),
    navigateToMiniProgram: _.mockAsync('navigateToMiniProgram'),
    requestPayment: _.mockAsync('requestPayment'),
    getSetting(options = {}) {
        _.runInAsync(options, {
            errMsg: 'getSetting:ok',
            authSetting: {
                'scope.address': true,
                'scope.invoice': true,
                'scope.invoiceTitle': true,
                'scope.subscribemsg': true,
            },
        })
    },
    openSetting(options = {}) {
        _.runInAsync(options, {
            errMsg: 'openSetting:ok',
            authSetting: {
                'scope.address': true,
                'scope.invoice': true,
                'scope.invoiceTitle': true,
                'scope.subscribemsg': true,
            },
        })
    },
    checkIsSoterEnrolledInDevice(options = {}) {
        _.runInAsync(options, {
            errMsg: 'checkIsSoterEnrolledInDevice:ok',
            isEnrolled: true,
        })
    },
    checkIsSupportSoterAuthentication(options = {}) {
        _.runInAsync(options, {
            errMsg: 'checkIsSupportSoterAuthentication:ok',
            supportMode: ['fingerPrint'],
        })
    },
    startSoterAuthentication: _.mockAsync('startSoterAuthentication'),
    getUserInfo(options) {
        _.runInAsync(options, {
            errMsg: 'getUserInfo:ok',
            userInfo: {
                nickName: 'Band',
                gender: 1,
                language: 'zh_CN',
                city: 'Guangzhou',
                province: 'Guangdong',
                country: 'CN',
                avatarUrl: 'http://wx.qlogo.cn/mmopen/vi_32/aSKcBBPpibyKNicHNTMM0qJVh8Kjgiak2AHWr8MHM4WgMEm7GFhsf8OYrySdbvAMvTsw3mo8ibKicsnfN5pRjl1p8HQ/0',
            },
            rawData: '{"nickName":"Band","gender":1,"language":"zh_CN","city":"Guangzhou","province":"Guangdong","country":"CN","avatarUrl":"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"}HyVFkGl5F5OQWJZZaNzBBg==',
            signature: '75e81ceda165f4ffa64f4068af58c64b8f54b88c',
            encryptedData: 'CiyLU1Aw2KjvrjMdj8YKliAjtP4gsMZMQmRzooG2xrDcvSnxIMXFufNstNGTyaGS9uT5geRa0W4oTOb1WT7fJlAC+oNPdbB+3hVbJSRgv+4lGOETKUQz6OYStslQ142dNCuabNPGBzlooOmB231qMM85d2/fV6ChevvXvQP8Hkue1poOFtnEtpyxVLW1zAo6/1Xx1COxFvrc2d7UL/lmHInNlxuacJXwu0fjpXfz/YqYzBIBzD6WUfTIF9GRHpOn/Hz7saL8xz+W//FRAUid1OksQaQx4CMs8LOddcQhULW4ucetDf96JcR3g0gfRK4PC7E/r7Z6xNrXd2UIeorGj5Ef7b1pJAYB6Y5anaHqZ9J6nKEBvB4DnNLIVWSgARns/8wR2SiRS7MNACwTyrGvt9ts8p12PKFdlqYTopNHR1Vf7XjfhQlVsAJdNiKdYmYVoKlaRv85IfVunYzO0IKXsyl7JCUjCpoG20f0a04COwfneQAGGwd5oa+T8yO5hzuyDb/XcxxmK01EpqOyuxINew==',
            iv: 'r7BXXKkLb8qrSNn05n0qiA==',
        })
    },
    getWeRunData(options) {
        _.runInAsync(options, {
            errMsg: 'getUserInfo:ok',
            encryptedData: 'XoLUxF76jN/OsfTGUqF/ZqRn+2PtO66lAMg/g0D3bg1L2/Nds8gTQrH7fGmbTgGtUC2R9lbJh7fLEaO9boeCqru1Em2BD/IbfN6lI/nu55himuBvypESz+H9uV7izLP/',
            iv: 'r7BXXKkLb8qrSNn05n0qiA==',
        })
    },
}


/***/ })
/******/ ]);
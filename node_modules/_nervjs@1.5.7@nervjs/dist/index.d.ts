// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../../packages/nerv/nerv-utils
//   ../../../../packages/nerv/nerv-shared

declare module 'nervjs' {
    import Component from 'nervjs/component';
    import PureComponent from 'nervjs/pure-component';
    import { render } from 'nervjs/render';
    import createElement from 'nervjs/create-element';
    import cloneElement from 'nervjs/clone-element';
    import { nextTick } from 'nerv-utils';
    import { Children } from 'nervjs/children';
    import { hydrate } from 'nervjs/hydrate';
    import options from 'nervjs/options';
    import { createPortal } from 'nervjs/vdom/create-portal';
    import { version } from 'nervjs/version';
    import { unmountComponentAtNode, findDOMNode, unstable_renderSubtreeIntoContainer, createFactory, unstable_batchedUpdates, isValidElement } from 'nervjs/dom';
    import { PropTypes } from 'nervjs/prop-types';
    import { getHooks, useEffect, useLayoutEffect, useReducer, useState, useRef, useCallback, useMemo, useImperativeHandle, useContext } from 'nervjs/hooks';
    import { createRef, forwardRef } from 'nervjs/create-ref';
    import { memo } from 'nervjs/memo';
    import { createContext } from 'nervjs/create-context';
    import { renderComponent } from 'nervjs/lifecycle';
    import Current from 'nervjs/current-owner';
    import { Fragment } from 'nervjs/fragment';
    export { Children, Component, PureComponent, createElement, cloneElement, render, nextTick, options, findDOMNode, isValidElement, unmountComponentAtNode, createPortal, unstable_renderSubtreeIntoContainer, hydrate, createFactory, unstable_batchedUpdates, version, PropTypes, createRef, forwardRef, memo, createContext, renderComponent, getHooks, Current, Fragment, useEffect, useLayoutEffect, useReducer, useState, useRef, useCallback, useMemo, useImperativeHandle, useContext };
    const _default: {
        Children: {
            map(children: any[], fn: import("./children").IterateFn, ctx: any): any[];
            forEach(children: any[], fn: import("./children").IterateFn, ctx: any): void;
            count(children: any[]): number;
            only(children: any[]): any;
            toArray(children: any[]): any[];
        };
        Component: typeof Component;
        PureComponent: typeof PureComponent;
        createElement: typeof createElement;
        cloneElement: typeof cloneElement;
        render: typeof render;
        nextTick: (fn: any, ...args: any[]) => void;
        options: {
            afterMount: import("./options").optionsHook;
            afterUpdate: import("./options").optionsHook;
            beforeUpdate: import("./options").optionsHook;
            beforeUnmount: import("./options").optionsHook;
            beforeMount: import("./options").optionsHook;
            afterCreate: import("./options").optionsHook;
            beforeRender: (component: import("../../nerv-shared/src").Component<any, any>) => void;
            roots: import("../../nerv-shared/src").VirtualNode[];
            debug: boolean;
        };
        findDOMNode: typeof findDOMNode;
        isValidElement: typeof isValidElement;
        unmountComponentAtNode: typeof unmountComponentAtNode;
        createPortal: typeof createPortal;
        unstable_renderSubtreeIntoContainer: typeof unstable_renderSubtreeIntoContainer;
        hydrate: typeof hydrate;
        createFactory: typeof createFactory;
        unstable_batchedUpdates: (fn: any, ...args: any[]) => void;
        version: string;
        PropTypes: {
            array: any;
            bool: any;
            func: any;
            number: any;
            object: any;
            string: any;
            any: any;
            arrayOf: () => any;
            element: any;
            instanceOf: () => any;
            node: any;
            objectOf: () => any;
            oneOf: () => any;
            oneOfType: () => any;
            shape: () => any;
            exact: () => any;
            PropTypes: {};
            checkPropTypes: typeof import("../../nerv-shared/src").noop;
        };
        createRef: typeof createRef;
        forwardRef: typeof forwardRef;
        memo: typeof memo;
        createContext: typeof createContext;
        renderComponent: typeof renderComponent;
        getHooks: typeof getHooks;
        Current: {
            current: Component<any, any> | null;
            index: number;
        };
        useEffect: typeof useEffect;
        useLayoutEffect: typeof useLayoutEffect;
        useReducer: typeof useReducer;
        useState: typeof useState;
        useRef: typeof useRef;
        useCallback: typeof useCallback;
        useMemo: typeof useMemo;
        useImperativeHandle: typeof useImperativeHandle;
        useContext: typeof useContext;
        Fragment: typeof Fragment;
    };
    export default _default;
}

declare module 'nervjs/component' {
    import { Props, ComponentLifecycle, Refs, Component as ComponentInst, CompositeComponent } from 'nerv-shared';
    import { Hook, HookEffect } from 'nervjs/hooks';
    interface Component<P = {}, S = {}> extends ComponentLifecycle<P, S> {
        _rendered: any;
        dom: any;
    }
    class Component<P, S> implements ComponentInst<P, S> {
        static defaultProps: {};
        static getDerivedStateFromError?(error?: any): object | null;
        state: Readonly<S>;
        props: Readonly<P> & Readonly<Props>;
        prevProps: P;
        prevState: S;
        prevContext: object;
        _parentComponent: Component<any, any>;
        vnode: CompositeComponent;
        context: any;
        _dirty: boolean;
        _disable: boolean;
        _pendingStates: any[];
        _pendingCallbacks: Function[];
        refs: Refs;
        isReactComponent: Object;
        _afterScheduleEffect: boolean;
        hooks: Hook[];
        effects: HookEffect[];
        layoutEffects: HookEffect[];
        constructor(props?: P, context?: any);
        setState<K extends keyof S>(state: ((prevState: Readonly<S>, props: P) => Pick<S, K> | S) | (Pick<S, K> | S), callback?: () => void): void;
        getState(): S;
        clearCallBacks(): void;
        forceUpdate(callback?: Function): void;
        render(nextProps?: P, nextState?: any, nextContext?: any): any;
    }
    export default Component;
}

declare module 'nervjs/pure-component' {
    import Component from 'nervjs/component';
    class PureComponent<P, S> extends Component<P, S> {
        isPureComponent: boolean;
        shouldComponentUpdate(nextProps: P, nextState: S): boolean;
    }
    export default PureComponent;
}

declare module 'nervjs/render' {
    import { VirtualNode } from 'nerv-shared';
    export function render(vnode: VirtualNode, container: Element, callback?: Function): any;
}

declare module 'nervjs/create-element' {
    import FullComponent from 'nervjs/full-component';
    import { Props, VNode, VirtualChildren } from 'nerv-shared';
    import Component from 'nervjs/component';
    function createElement<T>(type: string | Function | Component<any, any>, properties?: T & Props | null, ..._children: Array<VirtualChildren | null>): VNode | Component<any, any> | FullComponent;
    export default createElement;
}

declare module 'nervjs/clone-element' {
    export default function cloneElement(vnode: any, props?: object, ...children: any[]): any;
}

declare module 'nervjs/children' {
    import { VirtualChildren } from 'nerv-shared';
    export type IterateFn = (value: VirtualChildren | any, index: number, array: Array<VirtualChildren | any>) => any;
    export const Children: {
        map(children: any[], fn: IterateFn, ctx: any): any[];
        forEach(children: any[], fn: IterateFn, ctx: any): void;
        count(children: any[]): number;
        only(children: any[]): any;
        toArray(children: any[]): any[];
    };
}

declare module 'nervjs/hydrate' {
    export function hydrate(vnode: any, container: Element, callback?: Function): any;
}

declare module 'nervjs/options' {
    import { CompositeComponent, StatelessComponent, VirtualNode, Component } from 'nerv-shared';
    export type optionsHook = (vnode: CompositeComponent | StatelessComponent) => void;
    const options: {
        afterMount: optionsHook;
        afterUpdate: optionsHook;
        beforeUpdate: optionsHook;
        beforeUnmount: optionsHook;
        beforeMount: optionsHook;
        afterCreate: optionsHook;
        beforeRender: (component: Component<any, any>) => void;
        roots: VirtualNode[];
        debug: boolean;
    };
    export default options;
}

declare module 'nervjs/vdom/create-portal' {
    import { VirtualNode, Portal } from 'nerv-shared';
    export function createPortal(children: VirtualNode, container: Element): Portal;
}

declare module 'nervjs/version' {
    export const version = "15.4.2";
}

declare module 'nervjs/dom' {
    export function unmountComponentAtNode(dom: any): boolean;
    export function findDOMNode(component: any): any;
    export function createFactory(type: any): any;
    export function unstable_renderSubtreeIntoContainer(parentComponent: any, vnode: any, container: any, callback: any): any;
    export function isValidElement(element: any): boolean;
    export const unstable_batchedUpdates: (fn: any, ...args: any[]) => void;
}

declare module 'nervjs/prop-types' {
    import { noop } from 'nerv-shared';
    function getShim(): any;
    const PropTypes: {
        array: any;
        bool: any;
        func: any;
        number: any;
        object: any;
        string: any;
        any: any;
        arrayOf: typeof getShim;
        element: any;
        instanceOf: typeof getShim;
        node: any;
        objectOf: typeof getShim;
        oneOf: typeof getShim;
        oneOfType: typeof getShim;
        shape: typeof getShim;
        exact: typeof getShim;
        PropTypes: {};
        checkPropTypes: typeof noop;
    };
    export { PropTypes };
}

declare module 'nervjs/hooks' {
    import Component from 'nervjs/component';
    import { RefObject } from 'nervjs/create-ref';
    import { Context } from 'nervjs/create-context';
    export function getHooks(index: number): Hook;
    type SetStateAction<S> = S | ((prevState: S) => S);
    type Dispatch<A> = (value: A) => void;
    type EffectCallback = () => (void | (() => void));
    type DependencyList = ReadonlyArray<any>;
    type Reducer<S, A> = (prevState: S, action: A) => S;
    type ReducerState<R extends Reducer<any, any>> = R extends Reducer<infer S, any> ? S : never;
    type ReducerAction<R extends Reducer<any, any>> = R extends Reducer<any, infer A> ? A : never;
    export interface HookEffect {
        deps?: DependencyList;
        effect: EffectCallback;
        cleanup?: Function;
    }
    export interface HookState<S> {
        component: Component<any, any>;
        state: [S, Dispatch<SetStateAction<S>>];
    }
    export interface HookRef<T> {
        ref?: RefObject<T>;
    }
    export interface HookReducer<R extends Reducer<any, any>, I> {
        component: Component<any, any>;
        state: [ReducerState<R>, Dispatch<ReducerAction<R>>];
    }
    export interface HookCallback<T> {
        deps?: DependencyList;
        callback: Function;
        value: T;
    }
    export interface HookContext {
        context?: true;
    }
    export type Hook = HookEffect & HookState<unknown> & HookReducer<any, unknown> & HookRef<unknown> & HookCallback<any> & HookContext;
    export function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];
    export function useReducer<R extends Reducer<any, any>, I>(reducer: R, initialState: I & ReducerState<R>, initializer?: (arg: I & ReducerState<R>) => ReducerState<R>): [ReducerState<R>, Dispatch<ReducerAction<R>>];
    export function invokeEffects(component: Component<any, any>, delay?: boolean): void;
    export function useEffect(effect: EffectCallback, deps?: DependencyList): void;
    export function useLayoutEffect(effect: EffectCallback, deps?: DependencyList): void;
    export function useRef<T>(initialValue?: T): RefObject<T>;
    export function useMemo<T>(factory: () => T, deps?: DependencyList): T;
    export function useCallback<T extends (...args: never[]) => unknown>(callback: T, deps: DependencyList): T;
    export function useContext<T>(context: Context<T>): T;
    export function useImperativeHandle<T, R extends T>(ref: RefObject<T> | undefined, init: () => R, deps?: DependencyList): void;
    export {};
}

declare module 'nervjs/create-ref' {
    export interface RefObject<T> {
        current?: T;
    }
    export function createRef<T>(): RefObject<T>;
    export function forwardRef(cb: Function): Function;
}

declare module 'nervjs/memo' {
    import Component from 'nervjs/component';
    export function memo(component: Function, propsAreEqual?: Function): {
        (this: Component<{}, {}>, props: any): import("../../nerv-shared/src").VNode | Component<any, any> | import("./full-component").default;
        _forwarded: boolean;
        isMemo: boolean;
    };
}

declare module 'nervjs/create-context' {
    import Component from 'nervjs/component';
    export let uid: number;
    export interface ProviderProps<T> {
        value: T;
    }
    export interface ConsumerProps {
        children: Function;
    }
    export interface ConsumerState<T> {
        value: T;
    }
    export interface Context<T> {
        Provider: Component<ProviderProps<T>>;
        Consumer: Component<ConsumerProps, ConsumerState<T>>;
        _id: string;
        _defaultValue: T;
    }
    export function createContext<T>(defaultValue: T): Context<T>;
}

declare module 'nervjs/lifecycle' {
    import { CompositeComponent, VText, VVoid, VNode } from 'nerv-shared';
    import FullComponent from 'nervjs/full-component';
    import Component from 'nervjs/component';
    import { Emiter } from 'nervjs/emiter';
    export type ParentContext = Record<string, Emiter<any>>;
    export function errorCatcher(fn: Function, component: Component<any, any>): any;
    export function ensureVirtualNode(rendered: any): VText | VVoid | VNode;
    export function mountVNode(vnode: any, parentContext: any, parentComponent?: any): Element | Text | Comment | (Element | Text | Comment)[];
    export function getContextByContextType(vnode: FullComponent, parentContext: ParentContext): any;
    export function mountComponent(vnode: FullComponent, parentContext: ParentContext, parentComponent: any): Element;
    export function getChildContext(component: any, context?: {}): any;
    export function renderComponent(component: Component<any, any>): any;
    export function flushMount(): void;
    export function reRenderComponent(prev: CompositeComponent, current: CompositeComponent): any;
    export function updateComponent(component: any, isForce?: boolean): any;
    export function unmountComponent(vnode: FullComponent): void;
}

declare module 'nervjs/current-owner' {
    import Component from 'nervjs/component';
    const Current: {
        current: null | Component<any, any>;
        index: number;
    };
    export default Current;
}

declare module 'nervjs/fragment' {
    export function Fragment(props: any): any;
}

declare module 'nervjs/full-component' {
    import { VType, CompositeComponent, Ref } from 'nerv-shared';
    import Component from 'nervjs/component';
    class ComponentWrapper implements CompositeComponent {
        vtype: VType;
        type: any;
        name: string;
        _owner: any;
        props: any;
        component: Component<any, any>;
        context: any;
        key: any;
        dom: Element | null;
        _rendered: any;
        ref: Ref;
        constructor(type: any, props: any);
        init(parentContext: any, parentComponent: any): Element;
        update(previous: any, current: any, parentContext: any, domNode?: any): any;
        destroy(): void;
    }
    export default ComponentWrapper;
}

declare module 'nervjs/emiter' {
    class Emiter<T> {
        value: T;
        constructor(value: T);
        on(handler: Function): void;
        off(handler: Function): void;
        set(value: T): void;
    }
    export { Emiter };
}

